<!DOCTYPE HTML>
<html lang="zh-CN">


<head><meta name="generator" content="Hexo 3.9.0">
    <meta charset="utf-8">
    <meta name="keywords" content="&lt;原&gt;#  数论各种小定理, tabris的博客">
    <meta name="description" content="数论各种小定理置顶  2016年05月24日 10:54:37   Tabris_ 阅读数：1603

 博客爬取于2019-04-18 17:15:15以下为正文
版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。https">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>&lt;原&gt;#  数论各种小定理 | tabris的博客</title>
    <link rel="icon" type="image/png" href="/favicon.png">

    <link rel="stylesheet" type="text/css" href="/libs/awesome/css/font-awesome.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="/css/matery.css">
    <link rel="stylesheet" type="text/css" href="/css/my.css">
    <style type="text/css">
        
    </style>

    <script src="/libs/jquery/jquery-2.2.0.min.js"></script>
<link rel="stylesheet" href="/css/prism-duotone-space.css" type="text/css"></head>


<body>

<header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/medias/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">tabris的博客</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fa fa-navicon"></i></a>
<ul class="right">
    
    <li class="hide-on-med-and-down">
        <a href="/" class="waves-effect waves-light">
            
            <i class="fa fa-home"></i>
            
            <span>首页</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/tags" class="waves-effect waves-light">
            
            <i class="fa fa-tags"></i>
            
            <span>标签</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/categories" class="waves-effect waves-light">
            
            <i class="fa fa-bookmark"></i>
            
            <span>分类</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/archives" class="waves-effect waves-light">
            
            <i class="fa fa-archive"></i>
            
            <span>归档</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/about" class="waves-effect waves-light">
            
            <i class="fa fa-user-circle-o"></i>
            
            <span>关于</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/friends" class="waves-effect waves-light">
            
            <i class="fa fa-address-book"></i>
            
            <span>友情链接</span>
        </a>
    </li>
    
    <li>
        <a href="#searchModal" class="modal-trigger waves-effect waves-light">
            <i id="searchIcon" class="fa fa-search" title="搜索"></i>
        </a>
    </li>
</ul>

<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">tabris的博客</div>
        <div class="logo-desc">
            
            With the low level of hard work of most people, there is no chance to fight for talent.
            
        </div>
    </div>

    

    <ul class="menu-list mobile-menu-list">
        
        <li>
            <a href="/" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-home"></i>
                
                首页
            </a>
        </li>
        
        <li>
            <a href="/tags" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-tags"></i>
                
                标签
            </a>
        </li>
        
        <li>
            <a href="/categories" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-bookmark"></i>
                
                分类
            </a>
        </li>
        
        <li>
            <a href="/archives" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-archive"></i>
                
                归档
            </a>
        </li>
        
        <li>
            <a href="/about" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-user-circle-o"></i>
                
                关于
            </a>
        </li>
        
        <li>
            <a href="/friends" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-address-book"></i>
                
                友情链接
            </a>
        </li>
        
        
    </ul>
</div>

        </div>

        
    </nav>

</header>


<script src="/libs/cryptojs/crypto-js.min.js"></script>
<script>
    (function() {
        let pwd = '';
        if (pwd && pwd.length > 0) {
            if (pwd !== CryptoJS.SHA256(prompt('请输入访问本文章的密码')).toString(CryptoJS.enc.Hex)) {
                alert('密码错误，将返回主页！');
                location.href = '/';
            }
        }
    })();
</script>




<div class="bg-cover pd-header post-cover" style="background-image: url('/medias/featureimages/8.jpg')">
    <div class="container">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <div class="description center-align post-title">
                        &lt;原&gt;#  数论各种小定理
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>



<main class="post-container content">

    
    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
<style>
    #articleContent h1::before,
    #articleContent h2::before,
    #articleContent h3::before,
    #articleContent h4::before,
    #articleContent h5::before,
    #articleContent h6::before {
        display: block;
        content: " ";
        height: 100px;
        margin-top: -100px;
        visibility: hidden;
    }

    #articleContent :focus {
        outline: none;
    }

    .toc-fixed {
        position: fixed;
        top: 64px;
    }

    .toc-widget {
        padding-left: 20px;
    }

    .toc-widget .toc-title {
        margin: 35px 0 15px 0;
        padding-left: 17px;
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    .toc-widget ol {
        padding: 0;
        list-style: none;
    }

    #toc-content ol {
        padding-left: 10px;
    }

    #toc-content ol li {
        padding-left: 10px;
    }

    #toc-content .toc-link:hover {
        color: #42b983;
        font-weight: 700;
        text-decoration: underline;
    }

    #toc-content .toc-link::before {
        background-color: transparent;
        max-height: 25px;
    }

    #toc-content .is-active-link {
        color: #42b983;
    }

    #toc-content .is-active-link::before {
        background-color: #42b983;
    }

    #floating-toc-btn {
        position: fixed;
        right: 20px;
        bottom: 76px;
        padding-top: 15px;
        margin-bottom: 0;
        z-index: 998;
    }

    #floating-toc-btn .btn-floating {
        width: 48px;
        height: 48px;
    }

    #floating-toc-btn .btn-floating i {
        line-height: 48px;
        font-size: 1.4rem;
    }
</style>
<div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                          <div class="article-tag">
                            <span class="chip bg-color">无标签</span>
                          </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                    <div class="post-cate">
                        <i class="fa fa-bookmark fa-fw icon-category"></i>
                        
                            <a href="/categories/OJ算法题/" class="post-category" target="_blank">
                                OJ算法题
                            </a>
                        
                    </div>
                    
                </div>
            </div>

            <div class="post-info">
                <div class="post-date info-break-policy">
                    <i class="fa fa-calendar-minus-o fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2016-05-24
                </div>

                
                    
                    <div class="info-break-policy">
                        <i class="fa fa-file-word-o fa-fw"></i>文章字数:&nbsp;&nbsp;
                        7.2k
                    </div>
                    

                    
                    <div class="info-break-policy">
                        <i class="fa fa-clock-o fa-fw"></i>阅读时长:&nbsp;&nbsp;
                        37 分
                    </div>
                    
                
				
				
                    <div id="busuanzi_container_page_pv" class="info-break-policy">
                        <i class="fa fa-eye fa-fw"></i>阅读次数:&nbsp;&nbsp;
                        <span id="busuanzi_value_page_pv"></span>
                    </div>
				
            </div>
        </div>
        <hr class="clearfix">
        <div class="card-content article-card-content">
            <div id="articleContent">
                <h1 id="数论各种小定理"><a href="#数论各种小定理" class="headerlink" title="数论各种小定理"></a>数论各种小定理</h1><p>置顶  2016年05月24日 10:54:37  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a><br>阅读数：1603</p>
<hr>
<p> 博客爬取于<code>2019-04-18 17:15:15</code><br><strong><em>以下为正文</em></strong></p>
<p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/51488462" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/51488462</a></p>
<h1 id="这里是数论入门题目了-很全面"><a href="#这里是数论入门题目了-很全面" class="headerlink" title="[ 这里是数论入门题目了 很全面"></a>[ 这里是数论入门题目了 很全面</h1><p>](<a href="http://acm.hust.edu.cn/vjudge/contest/view.action?cid=120197#problem/D" target="_blank" rel="noopener">http://acm.hust.edu.cn/vjudge/contest/view.action?cid=120197#problem/D</a>) &lt;&lt;–<br>戳这里</p>
<p><strong> 欧拉降幂 </strong><br><img src="https://img-blog.csdn.net/20160507152606333?watermark/2/text/aHR0cDovL2Jsb
2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravi
ty/Center" alt></p>
<p>A  x  %  C  =  A  x  %  ϕ  (  C  )  +  ϕ  (  C  )  %  C  ,  (  x  ≥  ϕ  (  C<br>)  )</p>
<p>O(1)解决快速乘取膜</p>
<pre><code>LLu qmodx(LLu a,LLu b,LLu c)
{
    a%=c,b%=c;
    if(c&lt;=1000000000) return a*b%c;
    return (a*b-(LLu)(a/(long double)c*b+1e-8)*c+c)%c;
}
</code></pre><p>n = p1^a1<em>p2^a2</em>p3^a3<em>…</em>pk^ak 约束和s =<br>(p1^0+p1^1+p1^2+…p1^a1)(p2^0+p2^1+p2^2+…p2^a2)…(pk^0+pk^1+pk^2+…pk^ak）</p>
<p>lucas 定理 快速求大组合数 (省内存&amp;省时间)<br><a href="http://blog.csdn.net/skywalkert/article/details/52553048" target="_blank" rel="noopener"> 组合数求模 </a><br><a href="http://picks.logdown.com/posts/245545-binomial-coefficient-modulo-
prime" target="_blank" rel="noopener"> 组合数求模 </a></p>
<pre><code>#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;algorithm&gt;
#include &lt;cmath&gt;
#include &lt;cstring&gt;
using namespace std;

#define lld  __int64

lld  n, m, p;

lld Ext_gcd(lld a,lld b,lld &amp;x,lld &amp;y)
{
   if(b==0) { x=1, y=0; return a; }
   lld ret= Ext_gcd(b,a%b,y,x);
   y-= a/b*x;
   return ret;
}

lld Inv(lld a,int m)   ///求逆元
{
   lld d,x,y,t= (lld)m;
   d= Ext_gcd(a,t,x,y);
   if(d==1) return (x%t+t)%t;
   return -1;
}

lld Cm(lld n, lld m, lld p)  ///组合数学
{
    lld a=1, b=1;
    if(m&gt;n) return 0;
    while(m)
    {
        a=(a*n)%p;
        b=(b*m)%p;
        m--;
        n--;
    }
    return (lld)a*Inv(b,p)%p;  ///（a/b）%p 等价于 a*（b，p）的逆元
}

int Lucas(lld n, lld m, lld p)  ///把n分段递归求解相乘
{
    if(m==0) return 1;
    return (lld)Cm(n%p,m%p,p)*(lld)Lucas(n/p,m/p,p)%p;
}

int main()
{
    int  T;
    while(~scanf(&quot;%I64d%I64d&quot;,&amp;n,&amp;m))
    {
        n--,m--;
        m--;
        __int64 p=1000000007;

        printf(&quot;%d\n&quot;,Lucas(n+m-1,m,p));
    }
    return 0;
}
/****************************************/
LL qmul(LL a,LL b,LL c)
{
    LL res=0;
    while(b)
    {
        if(b&amp;1) res=(res+a)%c;
        a=(a+a)%c;
        b&gt;&gt;=1;
    }
    return res;
}
LL qmod(LL a,LL b,LL c)
{
    LL res=1;
    while(b)
    {
        if(b&amp;1) res=qmul(res,a,c)%c;
        b&gt;&gt;=1;
        a=qmul(a,a,c)%c;
    }
    return res;
}
LL exgcd(LL a,LL b,LL &amp;x,LL &amp;y) //ax+by=d
{

    if(!b)
    {
        x=1;
        y=0;
        return a;
    }
    else
    {
        LL r=exgcd(b,a%b,x,y);
        LL t = x;
        x = y;
        y=t-a/b*x;
        return r;
    }
}

LL CRT(LL a[],LL m[],LL len) //x%m[i]=a[i]
{
    LL i,x,y,M,n=1,ret=0;
    for(i=0; i&lt;len; ++i) n*=m[i];
    for(i=0; i&lt;len; ++i)
    {
        M=n/m[i];
        exgcd(M,m[i],x,y);
        ret=(ret+qmul(qmul(x,M,n),a[i],n))%n;
    }
    return (ret+n)%n;
}



LL C(LL n,LL m,LL p)//组合数模素数P
{
    if(m&gt;n||m&lt;0) return 0;
    if(n-m&lt;m) m=n-m;
    LL a=1,b=1;
    for(int i=0; i&lt;m; ++i)
    {
        a=a*(n-i)%p;
        b=b*(m-i)%p;
    }
    return a*qmod(b,p-2,p)%p;
}

LL Lucas(LL n,LL m,LL p)
{
    LL ans=1;
    while(n&amp;&amp;m&amp;&amp;ans)
    {
        ans=ans*C(n%p,m%p,p)%p;
        n/=p,m/=p;
    }
    return ans;
}
</code></pre><h1 id="余数问题"><a href="#余数问题" class="headerlink" title="余数问题"></a>余数问题</h1><p><a href="http://vjudge.net/contest/132006#overview" target="_blank" rel="noopener"> 这里是余数问题的练习题目 </a></p>
<h3 id="余数定理"><a href="#余数定理" class="headerlink" title="余数定理"></a>余数定理</h3><blockquote>
<p>计算  (  a  b  )  mod  c  其中b能整除a<br>如果b与c互素，则  (  a  /  b  )  %  c  =  a  ∗  b  p  h  i  (  c  )  −  1<br>如果b与c不互素，则  (  a  /  b  )  %  c  =  (  a  %  b  c  )  /  b<br>对于b与c互素和不互素都有  (  a  /  b  )  %  c  =  (  a  %  b  c  )  /  b  成立</p>
</blockquote>
<h3 id="扩展欧几里得"><a href="#扩展欧几里得" class="headerlink" title="扩展欧几里得"></a>扩展欧几里得</h3><p>这里是扩展欧几里德入门的题目了 做完这些我觉得才明白了扩展欧几里德的应用 <a href="http://acm.hust.edu.cn/vjudge/contest/117544#overview" target="_blank" rel="noopener"> 传送阵&lt;&lt;—
</a></p>
<pre><code>#include &lt;iostream&gt;
#include &lt;stdio.h&gt;
#include &lt;algorithm&gt;
#include &lt;string.h&gt;
using namespace std;

#define LL long long int
#define _LL __int64

LL exgcd_euclid(LL a,LL b,LL &amp;x,LL &amp;y)
{
    if(b==0)
    {
        x=1;
        y=0;
        return a;
    }
    LL r=exgcd_euclid(b,a%b,x,y);
    LL t=x;
    x=y;
    y=t-a/b*y;
    return r;
}


LL exgcd(LL m,LL &amp;x,LL n,LL &amp;y)
{
    LL x1,x0,y1,y0;
    x0=1,y0=0;
    x1=0,y1=1;
    LL r=(m%n+n)%n;
    LL q=(m-r)/n;
    x=0,y=1;
    while(r)
    {
        x=x0-q*x1,y=y0-q*y1,x0=x1,y0=y1;
        x1=x,y1=y;
        m=n,n=r,r=m%n;
        q=(m-r)/n;
    }
    return n;
}

int main()
{
    LL ar,br,cr;
    LL x,y,m,n,l;
    while(~scanf(&quot;%lld%lld%lld%lld%lld&quot;,&amp;x,&amp;y,&amp;m,&amp;n,&amp;l))
    {
        LL M=exgcd(n-m,ar,l,br);
        if((x-y)%M||m==n)
            printf(&quot;Impossible\n&quot;);
        else
        {
            LL s=l/M;
            ar=ar*((x-y)/M);
            ar=(ar%s+s)%s;
            printf(&quot;%lld\n&quot;,ar);
        }
    }
    return 0;
}
</code></pre><h3 id="逆元"><a href="#逆元" class="headerlink" title="逆元"></a>逆元</h3><p>定义:  a  ×  x  ≡  1  (  mod  m  )  ,称x为a关于m的逆元<br>对于方程  (  a  x  )  mod  c  我们可以转化为求  (  a  ×  x  −  1  )  mod  c<br>由于  x  ×  x  −  1  ≡  1  (  mod  m  )  恒成立,所以除法取模就可以将被除数转化为乘上被除数的逆元即可.</p>
<h5 id="求逆元的两种方法"><a href="#求逆元的两种方法" class="headerlink" title="求逆元的两种方法"></a>求逆元的两种方法</h5><ol>
<li>扩展欧几里德<br>(  a  x  )  ≡  ?  (  mod  c  )  =  &gt; a  ≡  ?  ×  x  (  mod  c  )  =  &gt; a  =  ?<br>×  x  +  k  ×  c<br>通过公式的推到，最后得到一个明显的同余式<br>而?的最小正整数解就是x的逆元</li>
</ol>
<pre><code>void exgcd(int a,int b,int &amp;d,int &amp;x,int &amp;y){
    if(b==0) {
        x = 1,y = 0,d=a;
        return ;
    }
    exgcd(b,a%b,d,x,y);
    int t = x;
    x = y;
    y = t - ( a / b ) * y;
    return ;
}
int inv(int a){
    int x,y,d;
    exgcd(a,MOD,d,x,y);
    if(d==1)  return (x%MOD+MOD)%MOD;   //返回最小正整数解
    return -1;  //不存在逆元
}
/**
注意只有当a与mod互质即 gcd(a,mod) 时才有逆元,否则不存在逆元
*/
</code></pre><ol>
<li>费马小定理   </li>
</ol>
<blockquote>
<p>费马小定理 :  a  p  −  1  ≡  1  (  mod  p  )  .<br>可以转化为  a  ×  a  p  −  2  ≡  1  (  mod  p  )  .所以  a  p  −  2<br>就是a关于p的逆元(!!!!!p必须为素数)</p>
</blockquote>
<pre><code>int qmod(int a,int b){
    int res = 1;
    while(b){
        if(b&amp;1) res=res*a%MOD;
        b&gt;&gt;=1;
        a=a*a%MOD;
    }
    return res;
}
int inv(int a){
    return qmod(a,MOD-2);
}
</code></pre><h3 id="求解高次同余方程"><a href="#求解高次同余方程" class="headerlink" title="求解高次同余方程"></a>求解高次同余方程</h3><p>还是用 babystep_gaintstep算法求解。但是这题并不能用POJ_2417的算法，直接套该<br>算法，下面简要说明一下不能用的原因。首先我们有必要归纳一下用babystep算法解题<br>的步骤：<br>(1) 求M = ceil( sqrt(C) ) ；<br>(2) for(i=0;i&lt; M;i++) hash( i , A^i ) ；<br>(3) 求D = A^M%C；<br>(4) r = 1 ; for( i = 0 ; i &lt; M ; i++ ) ex_gcd(r , C , x , y ) ; res = x <em> B %<br>C ; jj = find( res)<br>如果找到了这时候的jj，则答案就是i</em>M+jj，如果没有找到，则res = res <em> D % C，继续循<br>环查找，如果最终都没有找到，则输出无解。 在上述的步骤中，如果题目中没有告诉我们<br>gcd(A , C) = 1，则我们上述的方法是错误的，原因就在于第4步，求res的时候。因为如果<br>我们无法保证gcd(A , C) = 1 ，也就不能保证gcd(r ,C) = 1（因为D=A^M, r = D^i），所有在<br>用 扩展欧几里得求出r</em>x + C<em>y = gcd(r,C ) 的一个解x0之后，原方程:r</em>x+C<em>y = B的解<br>x = x0 </em> B / gcd(r,C) + i<em>C / gcd(r,C) ，但是我们这个时候并不能计算出gcd(r,C)，因为此时<br>的r本来就是经过取余之后得出的，并不能直接用来求gcd，因此我们上述的普通babystep<br>算法就会出错了。<br>这样我们就要换一种处理的方法了，这里介绍一种AC大牛博客上的一种“消因子”的方法，<br>具体内容请看这里：AC大牛。经过上面的分析我们很清楚接下去的处理应该从哪方面着<br>手，就是应该从不能求出gcd(r , C)入手。一种思想就是既然无法求， 那我每次只要保证<br>gcd(r, C) = 1那样就可以想普通babystep一样求解了，既然要保证gcd(r,C) =1 ，而<br>r = (A^M)^i,因此归根到底还是要求gcd( A , C ) = 1。下面就是从AC大牛博客上参考的“消因子”<br>法了，每次我们 都消去A,C的一个因子，然后对B,C, D进行如下的处理：B/=tmp;C/=tmp ;<br>D = D</em> A/tmp%C ，这样经过b轮的消因子之后，gcd(A,C) = 1， 接下去我们就可以用普通<br>的babystep求解出方程：A^x = B’( mod C’ ) 的解 res1， 原方程的解就是 res = res1 + b。<br>下面给出这种方法正确的简要证明；一开始我们要求的方程是：A^x = B( mod C )，也就是<br>求一个最小的x，使得A^x + C<em>y = B，通过消因子， 我们不断在方程两遍消去gcd(A,C)，这<br>样方程就可以变成 D</em>A^x1 + C’<em>y1 = B’，很简单就可以证明上式中 x = x1 + b ; y = y1 的（只要<br>在方程的两边分别将消去的因子乘回去等式还是保持不变的）。这样我们的问题就转化为了<br>求x1和y1，即D</em>A^x1 = B’( mod C’ )，此时gcd( A , C’) = 1，这样我们就可以用普通的babystep<br>求出上述式子的解x1，同时也就求出了x，这样本题就解决了。<br>但是上述的方法还是有一个bug的，也就是说，我们用babystep求出的x1&gt;=0，所以上述的<br>方法只能求出x &gt;= b的解，这样我们自然就会想到如果有一个解x &lt; b怎么办，上述方法就会出<br>先错误了，因此我们这里还需要改进。考虑b的最大值是多少，考虑每次我们消去的因子数都<br>最小也就是2，这样我们就可以得到b的最大值就是log(C)，这样我们只要保证每次log(C)之内的<br>解都特判一下， 就不会出现我们刚才的问题了， 所以我们要在进行上述处理之前进行一次for<br>循环 ，特判0 - log(C)直接的x是否能成为解，接下去再用上述的“消因子”算法。<br>最后不得不佩服发明这种算法的人的神奇，将O(C)复杂度的判断，分两级判断将复杂度降低<br>到O( sqrt(C) )，所以就是为什么叫” babystep_gaintstep “了， 哈哈。</p>
<h4 id="babystep算法模板"><a href="#babystep算法模板" class="headerlink" title="babystep算法模板"></a>babystep算法模板</h4><pre><code>#define CC(m ,what) memset(m , what , sizeof(m))
LL A, B ,C ;
const int NN = 99991 ;
bool has[NN] ;
int idx[NN] , val[NN] ;

void insert_(int id , LL vv)
{
    LL v = vv % NN ;
    while( has[v] &amp;&amp; val[v]!=vv)
    {
        v++ ;
        if(v == NN) v-=NN ;
    }
    if( !has[v] )
    {
        has[v] = 1;
        val[v] = vv ;
        idx[v] = id ;
    }
}
int findi(LL vv)
{
    LL v = vv % NN ;
    while( has[v] &amp;&amp; val[v]!=vv)
    {
        v++ ;
        if(v == NN) v-=NN ;
    }
    if( !has[v] )  return -1;
    return idx[v] ;
}
void ex_gcd(LL a , LL b , LL&amp; x , LL&amp; y)
{
    if(b == 0)
    {
        x = 1 ;
        y = 0 ;
        return ;
    }
    ex_gcd(b , a%b , x, y) ;
    LL t = x ;
    x = y;
    y = t - a/b*y ;
}
LL gcd(LL a,LL b)
{
    while( a%b != 0)
    {
        LL c = a ;
        a = b ;
        b = c % b ;
    }
    return b ;
}
LL baby_step(LL A, LL B , LL C)
{
    LL ans = 1 ;
    for(LL i=0; i&lt;=50; i++)
    {
        if(ans == B)    return i ;
        ans = ans * A % C ;
    }
    LL tmp , d = 0 ;
    LL D = 1 % C ;
    while( (tmp=gcd(A,C)) != 1 )
    {
        if(B % tmp) return -1 ;
        d++ ;
        B/=tmp ;
        C/=tmp ;
        D = D*A/tmp%C ;
    }
    CC( has , 0) ;
    CC( idx, -1) ;
    CC(val , -1) ;
    LL M = ceil( sqrt(C*1.0) ) ;
    LL rr = 1 ;
    for(int i=0; i&lt;M; i++)
    {
        insert_(i, rr) ;
        rr = rr * A % C ;
    }
    LL x, y ;
    for(int i=0; i&lt;M; i++)
    {
        ex_gcd(D, C , x, y) ;
        LL r = x * B % C;
        r = (r % C + C) % C ;
        int jj = findi( r ) ;
        if(jj != -1)
        {
            return  LL(i)*M + LL(jj) + d ;
        }
        D = D * rr % C ;
    }
    return -1 ;
}
</code></pre><h1 id="素数测试"><a href="#素数测试" class="headerlink" title="素数测试"></a>素数测试</h1><h3 id="线性筛法打素数表"><a href="#线性筛法打素数表" class="headerlink" title="线性筛法打素数表"></a>线性筛法打素数表</h3><pre><code>int prime[20000],kp=0;
int Is_or[65536];
void Prime()
{
    int n =65536; //2~n之间的素数
    kp=0;
    memset(Is_or,1,sizeof(Is_or));
    Is_or[0]=Is_or[1]=0;
    for(int i=2;i&lt;n;i++)
    {
        if(Is_or[i])    prime[kp++]=i;

        for(int j=0;j&lt;kp&amp;&amp;i*prime[j]&lt;n;j++)
        {
            Is_or[i*prime[j]]=0;
            if(i%prime[j]==0) break;
        }
    }
    return ;
}
</code></pre><h3 id="随机性素数测试-miller-rabbin"><a href="#随机性素数测试-miller-rabbin" class="headerlink" title="随机性素数测试 miller-rabbin"></a>随机性素数测试 miller-rabbin</h3><p>普通的素数测试我们有O(√ n)的试除算法。事实上，我们有O(slog³n)的算法。</p>
<p>定理一：假如p是质数，且(a,p)=1，那么a^(p-1)≡1(mod<br>p)。即假如p是质数，且a,p互质，那么a的(p-1)次方除以p的余数恒等于1。（费马小定理）</p>
<p>该定理的逆命题是不一定成立的，但是令人可喜的是大多数情况是成立的。</p>
<p>于是我们就得到了一个定理的直接应用，对于待验证的数p，我们不断取a∈［1，p-1]且a∈Z，验证a^(p-1) mod<br>p是否等于1，不是则p果断不是素数，共取s次。其中a^(p-1) mod p可以通过把p-1写成二进制，由(a<em>b)mod c=(a mod c)</em>b<br>mod c，可以在t=log(p-1)的时间内计算出解，如考虑整数相乘的复杂度，则一次计算的总复杂度为log³(p-1)。这个方法叫快速幂取模。</p>
<p>为了提高算法的准确性，我们又有一个可以利用的定理。<br>定理二：对于0 &lt; x &lt; p，x^2 mod p =1 =&gt; x=1或p-1。</p>
<p>我们令p-1=(2^t)*u，即p-1为u二进制表示后面跟t个0。我们先计算出x[0]=a^u mod p<br>，再平方t次并在每一次模p，每一次的结果记为x[i]，最后也可以计算出a^(p-1) mod<br>p。若发现x[i]=1而x[i-1]不等于1也不等于p-1，则发现p果断不是素数。</p>
<p>可以证明，使用以上两个定理以后，检验s次出错的概率至多为2^(-s)，所以这个算法是很可靠的。</p>
<p>需要注意的是，为了防止溢出（特别大的数据），a*b mod c 也应用类似快速幂取模的方法计算。当然，数据不是很大就可以免了。</p>
<p>下面是我的程序。</p>
<pre><code>//****************************************************************
// Miller_Rabin 算法进行素数测试
//速度快，而且可以判断 &lt;2^63的数
//****************************************************************
const int S=20;//随机算法判定次数，S越大，判错概率越小
//计算 (a*b)%c.   a,b都是long long的数，直接相乘可能溢出的
//  a,b,c &lt;2^63
long long mult_mod(long long a,long long b,long long c)
{
    a%=c;
    b%=c;
    long long ret=0;
    while(b)
    {
        if(b&amp;1){ret+=a;ret%=c;}
        a&lt;&lt;=1;
        if(a&gt;=c)a%=c;
        b&gt;&gt;=1;
    }
    return ret;
}
//计算  x^n %c
long long pow_mod(long long x,long long n,long long mod)//x^n%c
{
    if(n==1)return x%mod;
    x%=mod;
    long long tmp=x;
    long long ret=1;
    while(n)
    {
        if(n&amp;1) ret=mult_mod(ret,tmp,mod);
        tmp=mult_mod(tmp,tmp,mod);
        n&gt;&gt;=1;
    }
    return ret;
}

//以a为基,n-1=x*2^t      a^(n-1)=1(mod n)  验证n是不是合数
//一定是合数返回true,不一定返回false
bool check(long long a,long long n,long long x,long long t)
{
    long long ret=pow_mod(a,x,n);
    long long last=ret;
    for(int i=1;i&lt;=t;i++)
    {
        ret=mult_mod(ret,ret,n);
        if(ret==1&amp;&amp;last!=1&amp;&amp;last!=n-1) return true;//合数
        last=ret;
    }
    if(ret!=1) return true;
    return false;
}

// Miller_Rabin()算法素数判定
//是素数返回true.(可能是伪素数，但概率极小)
//合数返回false;

bool Miller_Rabin(long long n)
{
    if(n&lt;2)return false;
    if(n==2)return true;
    if((n&amp;1)==0) return false;//偶数
    long long x=n-1;
    long long t=0;
    while((x&amp;1)==0){x&gt;&gt;=1;t++;}
    for(int i=0;i&lt;S;i++)
    {
        long long a=rand()%(n-1)+1;//rand()需要stdlib.h头文件
        if(check(a,n,x,t))
            return false;//合数
    }
    return true;
}
</code></pre><h3 id="pollard-rho-longlong质因子分解"><a href="#pollard-rho-longlong质因子分解" class="headerlink" title="pollard_rho(longlong质因子分解)"></a>pollard_rho(longlong质因子分解)</h3><pre><code>//************************************************
//pollard_rho 算法进行质因数分解
//************************************************
long long factor[100];//质因数分解结果（刚返回时是无序的）
int tol;//质因数的个数。数组小标从0开始

long long gcd(long long a,long long b)
{
    if(a==0)return 1;//???????
    if(a&lt;0) return gcd(-a,b);
    while(b)
    {
        long long t=a%b;
        a=b;
        b=t;
    }
    return a;
}

long long Pollard_rho(long long x,long long c)
{
    long long i=1,k=2;
    long long x0=rand()%x;
    long long y=x0;
    while(1)
    {
        i++;
        x0=(mult_mod(x0,x0,x)+c)%x;
        long long d=gcd(y-x0,x);
        if(d!=1&amp;&amp;d!=x) return d;
        if(y==x0) return x;
        if(i==k){y=x0;k+=k;}
    }
}
//对n进行素因子分解
void findfac(long long n)
{
    if(Miller_Rabin(n))//素数
    {
        factor[tol++]=n; //值得注意的是 这里的factor并不是有序的!!!!!
        return;
    }
    long long p=n;
    while(p&gt;=n)p=Pollard_rho(p,rand()%(n-1)+1);
    findfac(p);
    findfac(n/p);
}
</code></pre><h3 id="算数基本定理展开"><a href="#算数基本定理展开" class="headerlink" title="算数基本定理展开"></a>算数基本定理展开</h3><p>对于任意一个  N  我们可以写成  N  =  P  a  1  1  ∗  P  a  2  2  ∗  P  a  3  3  ∗  .  .  .<br>∗  P  a  n  n<br>我们求解的时候只要先讲素数筛出来,然后直接一个个的除就行了,这样的理想复杂度是  O  (  m  i  n  {  (  小  于  l  o  g  n<br>2  )  ,  k  p  }  )  ,  k  p  为  筛  出  的  素  数  个  数<br>但是注意一种情况,可能展开的数N就是一个很大的素数,比如  99997  ,这样的数如果有  1  e  6<br>个的话就不能简单快速的展开了.于是我们可以在判定数是否为素数的数组中在开一维记录其为第几个素数.这样一来复杂度就会降低很多  小  于  O  (  l<br>o  g  n  2  )</p>
<pre><code>int prime[N],kp;
int Is_or[N][2];
void Prime(){
    kp = 0;
    memset(Is_or,true,sizeof(Is_or));
    Is_or[0][0]=Is_or[1][0]=0;
    for(int i=2;i&lt;=100000;i++){
        if(Is_or[i][0]) Is_or[i][1]=kp,prime[kp++]=i;//记录其为第几个素数
        for(int j=0;j&lt;kp&amp;&amp;prime[j]*i&lt;=100000;j++){
            Is_or[prime[j]*i][0]=0;
            if(0==i%prime[j]) break;
        }
    }
    return ;
}
int main(){
    int tem;
    cin&gt;&gt;tem;
    for(int j=0;j&lt;kp&amp;&amp;tem&gt;=prime[j];j++){
        if(Is_or[tem][0]) {a[Is_or[tem][1]]++;break;}
        //if(0==tem%prime[j]) ;  
        while(0==tem%prime[j]) a[j]++,tem/=prime[j];
    }
}
</code></pre><h1 id="乘性函数"><a href="#乘性函数" class="headerlink" title="乘性函数"></a>乘性函数</h1><h3 id="欧拉函数表"><a href="#欧拉函数表" class="headerlink" title="欧拉函数表"></a>欧拉函数表</h3><p>————————–.</p>
<pre><code>void phi_table()  //欧拉函数。。。
{
    int i,j;
    for(i=2; i&lt;=5e6; i++)
        phi[i]=0;
    phi[1]=1;
    for(i=2; i&lt;=5e6; i++)
        if(!phi[i])
            for(j=i; j&lt;=5e6; j+=i)
            {
                if(!phi[j])phi[j]=j;
                phi[j]=phi[j]/i*(i-1);
            }
    phi[0]=0;
    return 0;
}

void phi_table(int maxn)
{
    for(int i=1;i&lt;=maxn;i++)
    phi[i]=i;

    for(int i=2;i&lt;=maxn;i+=2)
    phi[i]/=2;

    for(int i=3;i&lt;=maxn;i+=2)
    if(phi[i]==i)
        for(int j=i;j&lt;=maxn;j+=i)
            phi[j]=phi[j]/i*(i-1);

    return ;
}
//  以上是打表的形式  这是求单个的 
void Prime()
{
    int n=200;
    int k=0;
    memset(Is_or,1,sizeof(Is_or));
    Is_or[0]=Is_or[1]=0;
    for(int i=2; i&lt;n; i++)
    {
        if(Is_or[i])
        {
        prime[k++]=i;
            for(int j=i+i; j&lt;n; j+=i)
            {
                Is_or[j]=0;
            }
        }
    }
    return ;
}

LL Phi(LL n)
{
    LL rea=n;
    for(int i=0; prime[i]*prime[i]&lt;=n&amp;&amp;i&lt;kp; i++)
    {
        if(n%prime[i]==0)
        {
            rea=rea-rea/prime[i];
            while(n%prime[i]==0)
                n/=prime[i];
        }
    }
    if(n&gt;1)    rea=rea-rea/n;
    return rea;
}
/************************/
O(n)求素数+欧拉函数
用最小的素因子筛掉每个数
int prime[N],phi[N],cnt;// prime:记录质数，phi记录欧拉函数
int Min_factor[N];// i的最小素因子
bool vis[N];
void Init()
{
    cnt=0;
    phi[1]=1;
    int x;
    for(int i=2;i&lt;N;i++)
    {
        if(!vis[i])
        {
            prime[++cnt]=i;
            phi[i]=i-1;
            Min_factor[i]=i;
        }
        for(int k=1;k&lt;=cnt&amp;&amp;prime[k]*i&lt;N;k++)
        {
            x=prime[k]*i;
            vis[x]=true;
            Min_factor[x]=prime[k];
            if(i%prime[k]==0)
            {
                phi[x]=phi[i]*prime[k];
                break;
            }
            else phi[x]=phi[i]*(prime[k]-1);
        }
    }
}
</code></pre><h1 id="计算方法"><a href="#计算方法" class="headerlink" title="计算方法"></a>计算方法</h1><h3 id="矩阵快速幂"><a href="#矩阵快速幂" class="headerlink" title="矩阵快速幂"></a>矩阵快速幂</h3><pre><code>struct Matrix
{
    LL m[M][M];
    void clearO()
    {
        for(int i=0; i&lt;M; i++) //初始化矩阵
            for(int j=0; j&lt;M; j++)
                m[i][j]= 0;
    }
    void clearE()
    {
        for(int i=0; i&lt;M; i++) //初始化矩阵
            for(int j=0; j&lt;M; j++)
                m[i][j]= (i==j);
    }
    void display()
    {
        for(int i=0; i&lt;M; i++)
            {
                for(int j=0; j&lt;M; j++)
                printf(&quot;%d &quot;,m[i][j]);
                puts(&quot;&quot;);
            }
    }
};

Matrix operator * (Matrix a,Matrix b)
{
    Matrix c;
    c.clearO();

    for(int k=0; k&lt;M; k++)
        for(int i=0; i&lt;M; i++) //实现矩阵乘法
        {
            if(a.m[i][k] &lt;= 0)  continue;
            for(int j=0; j&lt;M; j++)
            {
                if(b.m[k][j] &lt;= 0)    continue;
                c.m[i][j]=(c.m[i][j]+a.m[i][k]*b.m[k][j]+MOD)%MOD;
            }
        }
    return c;
}

Matrix operator ^ (Matrix a,LL b)
{
    Matrix c;
    c.clearE();
    while(b)
    {
        if(b&amp;1) c= c * a ;
        b &gt;&gt;= 1;
        a = a * a ;
    }
    return c;
}



//#include &lt;bits/stdc++.h&gt;
#include &lt;stdio.h&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;string.h&gt;

using namespace std;

#define INF 0x3f3f3f3f
#define pb push_back
#define abs(a) (a)&gt;0?(a):-(a)
#define min(a,b) (a)&gt;(b)?(a):(b)
#define lalal puts(&quot;*******&quot;);
typedef long long int LL ;
/*******************************/

const int N = 100+5;
int MOD ;

struct Matrix
{
    LL m[N][N];
    int row,culumn;
    void clearE()
    {
        for(int i=0; i&lt;row; i++)
            for(int j=0; j&lt;culumn; j++)
                m[i][j]=(i==j);
    }
    void clearO()
    {
        for(int i=0; i&lt;row; i++)
            for(int j=0; j&lt;culumn; j++)
                m[i][j]=0;
    }
    void display()
    {
        for(int i=0; i&lt;row; i++)
        {
            for(int j=0; j&lt;culumn; j++)
                printf(&quot;%d &quot;,m[i][j]);
            puts(&quot;&quot;);
        }
    }
};
//循环矩阵 * 的写法。。对于循环矩阵来说 行和列是一样都循环的 并不用特意区分  
Matrix operator *(Matrix &amp;a,Matrix &amp;b)
{
    Matrix c;
    c.row=a.row,c.culumn=b.culumn,c.clearO();

    for (int k = 0; k &lt; a.culumn; k++)
        if (a.m[0][k])
        {
            for (int j = 0; j &lt; b.culumn; j++)
                if (b.m[k][j])
                    c.m[0][j] = (c.m[0][j] + a.m[0][k] * b.m[k][j]) % MOD;
        }
    for (int i = 1; i &lt; c.culumn; i++)
    {
        c.m[i][0] = c.m[i - 1][c.culumn - 1];
        for (int j = 1; j &lt; c.culumn; j++)
            c.m[i][j] = c.m[i - 1][j - 1];
    }
    return c;
}

Matrix operator ^(Matrix &amp;a,int b)
{
    Matrix c;
    c.row=a.row,c.culumn=a.culumn,c.clearE();

    while(b)
    {
        if(b&amp;1) c=c*a;
        b&gt;&gt;=1;
        a=a*a;
    }

    return c;
}

int main()
{
    int t;
    scanf(&quot;%d&quot;,&amp;t);
    while(t--)
    {
        LL n,m,L,R,M;
        scanf(&quot;%I64d%I64d%I64d%I64d%I64d&quot;,&amp;n,&amp;m,&amp;L,&amp;R,&amp;M);

        MOD=M;
        Matrix a,b;
        a.row=1,b.row=a.culumn=b.culumn=n,a.clearO(),b.clearO();

        for(int i=0; i&lt;n; i++)
        {
            scanf(&quot;%I64d&quot;,&amp;a.m[0][i]);
            a.m[0][i]%=MOD;
            b.m[(i-1+n)%n][i]=R%MOD;
            b.m[(i+1)%n][i]=L%MOD;
            b.m[i][i]=1;
        }

        b=b^(m);
        a=a*b;

        for(int i=0; i&lt;n; i++)
        {
            if(i)printf(&quot; &quot;);
            printf(&quot;%I64d&quot;,a.m[0][i]);
        }
        puts(&quot;&quot;);
    }
    return 0;
}
</code></pre><h3 id="FFT-NTT"><a href="#FFT-NTT" class="headerlink" title="FFT/NTT"></a>FFT/NTT</h3><p>用于快速求卷积  c  =  a  ⊗  b<br>卷积可以类比两个多项式相乘<br>正常暴力求卷积的复杂度是  O  (  n  2  )  ,但是通过FFT加速 求卷积的复杂度能降到  O  (  n  l  o  g  2  n  )<br><a href="http://www.gatevin.moe/acm/fft%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%
E7%AC%94%E8%AE%B0/" target="_blank" rel="noopener"> 算法学习笔记 </a><br>FFT模板</p>
<pre><code>struct Complex{
    double real, image;
    Complex(double _real, double _image){
        real = _real;
        image = _image;
    }
    Complex(){}

    Complex operator + (const Complex &amp;tmp){
        return Complex(real + tmp.real, image + tmp.image);
    }
    Complex operator - (const Complex &amp;tmp){
        return Complex(real - tmp.real, image - tmp.image);
    }
    Complex operator * (const Complex &amp;tmp){
        return Complex(real*tmp.real - image*tmp.image, real*tmp.image + image*tmp.real);
    }
};
int rev(int id, int len){
    int ret = 0;
    for(int i = 0; (1 &lt;&lt; i) &lt; len; i++){
        ret &lt;&lt;= 1;
        if(id &amp; (1 &lt;&lt; i)) ret |= 1;
    }
    return ret;
}
Complex A[N];
void FFT(Complex *a, int len, int DFT){
    for(int i = 0; i &lt; len; i++)
        A[rev(i, len)] = a[i];
    for(int s = 1; (1 &lt;&lt; s) &lt;= len; s++){
        int m = (1 &lt;&lt; s);
        Complex wm = Complex(cos(DFT*2*PI/m), sin(DFT*2*PI/m));
        for(int k = 0; k &lt; len; k += m){
            Complex w = Complex(1, 0);
            for(int j = 0; j &lt; (m &gt;&gt; 1); j++){
                Complex t = w*A[k + j + (m &gt;&gt; 1)];
                Complex u = A[k + j];
                A[k + j] = u + t;
                A[k + j + (m &gt;&gt; 1)] = u - t;
                w = w*wm;
            }
        }
    }
    if(DFT == -1) for(int i = 0; i &lt; len; i++) A[i].real /= len, A[i].image /= len;
    for(int i = 0; i &lt; len; i++) a[i] = A[i];
    return;
}
int main()
{
    /**
    求卷积c=a⊗b
    la为a的长度
    lb为b的长度
    len为最后结果的长度.
    **/
    int sa,sb;
    sa=sb=0;
    while((1&lt;&lt;sa)&lt;la) sa++;
    while((1&lt;&lt;sb)&lt;lb) sb++;
    int len = (1&lt;&lt;(max(sa,sb)+1));
    A = FFT(A,len,1);
    B = FFT(B,len,1);
    for(int i=0;i&lt;len;i++)  A[i]=A[i]*B[i],ans[i]=0;
    A = FFT(A,len,-1);
    /**
    这是最后的卷积的结果.
    **/
}
</code></pre><p>NTT</p>
<pre><code>const int Maxn=50000;

LL A[Maxn&lt;&lt;2],B[Maxn&lt;&lt;2];
int ans[Maxn&lt;&lt;2];

inline LL qmod(LL a, LL b,LL P) {
    LL ans=1;
    for(; b; b&gt;&gt;=1, a=a*a%P)
        if(b&amp;1) ans=ans*a%P;
    return ans;
}
struct NTT {
    int pos[Maxn&lt;&lt;2],k,G,Mod;
    inline void init(int len) {
        Mod = 998244353,G = 3;
        for(k=1; k&lt;=len; k&lt;&lt;=1);
        for(int i=1; i&lt;k; i++)
            pos[i]=(i&amp;1)?((pos[i&gt;&gt;1]&gt;&gt;1)^(k&gt;&gt;1)):(pos[i&gt;&gt;1]&gt;&gt;1);
    }
    inline void dft(LL *a) {
        for(int i=1; i&lt;k; i++)if(pos[i]&gt;i)swap(a[pos[i]],a[i]);
        for(int m1=1; m1&lt;k; m1&lt;&lt;=1) {
            int m2=m1&lt;&lt;1;
            LL wn=qmod(G,(Mod-1)/m2,Mod)%Mod;
            for(int i=0; i&lt;k; i+=m2) {
                LL w=1;
                for(int j=0; j&lt;m1; j++) {
                    LL &amp;A=a[i+j],&amp;B=a[i+j+m1],t=B*w%Mod;
                    B=(A-t+Mod)%Mod;
                    A=(A+t)%Mod;
                    w=w*wn%Mod;
                }
            }
        }
    }
    inline void mui(LL *A,LL *B,int m) {
        init(m);
        dft(A);dft(B);
        for(int i=0; i&lt;k; i++)A[i]=A[i]*B[i]%Mod;
        dft(A);
        reverse(A+1,A+k);
        int inv=qmod(k,Mod-2,Mod)%Mod;
        for(int i=0; i&lt;k; i++)A[i]=inv*A[i]%Mod;
    }
} ntt;
</code></pre><h3 id="牛顿迭代法-线性开根"><a href="#牛顿迭代法-线性开根" class="headerlink" title="牛顿迭代法 线性开根"></a>牛顿迭代法 线性开根</h3><blockquote>
<p>下面这种方法可以很有效地求出根号a的近似值：首先随便猜一个近似值x，然后不断令x等于x和a/x的平均数，迭代个六七次后x的值就已经相当精确了。<br>( 4 + 2/ 4 ) / 2 = 2.25<br>( 2.25 + 2/ 2.25 ) / 2 = 1.56944..<br>( 1.56944..+ 2/1.56944..) / 2 = 1.42189..<br>( 1.42189..+ 2/1.42189..) / 2 = 1.41423..<br>这种算法的原理很简单，我们仅仅是不断用(x,f(x))的切线来逼近方程x^2-a=0的根。根号a实际上就是x^2-a=0的一个正实根，这个函数的导数是2x。<br>也就是说，函数上任一点(x,f(x))处的切线斜率是2x。那么，x-f(x)/(2x)就是一个比x更接近的近似值。代入f(x)=x^2-a得到x-(x^2-<br>a)/(2x)，也就是(x+a/x)/2。</p>
</blockquote>
<pre><code>const float EPS = 1e-5;   
int sqrt(double x) {   
    if(x == 0) return 0;   
    double result = x; /*Use double to avoid possible overflow*/   
    double lastValue;   
    do{   
        lastValue = result;   
        result = result / 2.0f + x / 2.0f / result;   
    }while(abs(result - lastValue) &gt; EPS);  
 return (double)result;  
 }  
</code></pre><h4 id="更牛逼的一种开跟方式-快的一笔"><a href="#更牛逼的一种开跟方式-快的一笔" class="headerlink" title="更牛逼的一种开跟方式 快的一笔"></a>更牛逼的一种开跟方式 快的一笔</h4><pre><code>/**
来自雷神之锤III的源代码中q_math.c的文件中。
*/
float Q_rsqrt( float number ) {   
    long i; float x2, y; const float threehalfs = 1.5F;  
    x2 = number * 0.5F;   
    y = number;   
    i = * ( long * ) &amp;y; // evil floating point bit level hacking   
    i = 0x5f3759df - ( i &gt;&gt; 1 ); // what the fuck?   
    y = * ( float * ) &amp;i;   
    y = y * ( threehalfs - ( x2 * y * y ) ); // 1st iteration   
    // y = y * ( threehalfs - ( x2 * y * y ) ); // 2nd iteration, this can be removed  
    #ifndef Q3_VM #  
    ifdef __linux__ assert( !isnan(y) ); // bk010122 - FPE?  
    #endif  
    #endif return y;   
}  
//整理得到
int sqrt(float x) {   
    if(x == 0) return 0;   
    float result = x;   
    float xhalf = 0.5f*result;   
    int i = *(int*)&amp;result;   
    i = 0x5f375a86- (i&gt;&gt;1); // what the fuck?   
    result = *(float*)&amp;i;   
    result = result*(1.5f-xhalf*result*result); // Newton step, repeating increases accuracy   
    result = result*(1.5f-xhalf*result*result);   
    return 1.0f/result;   
}  
</code></pre><p>O  (  n  )  预处理逆元</p>
<pre><code>方法一  i的逆元
inv[1] = 1;   
for (int i = 2; i&lt;MAXN; i++)  
    inv[i] = inv[MOD%i]*(MOD-MOD/i)%MOD;  
方法二  inv{(n-i)!} = inv(n!)*n    //阶乘逆元
Fac[0] = 1;
for (int i = 1; i &lt; N; i++) Fac[i] = (Fac[i-1] * i) % MOD;
Inv[N-1] = pow_mod(Fac[N-1], MOD-2);//Fac[N]^{MOD-2}
for (int i = N - 2; i &gt;= 0; i--) Inv[i] = Inv[i+1] * (i + 1) % MOD;
方法三  费马小定理
fac[0]=1;
for(int i=1;i&lt;N;i++)fac[i]=fac[i-1]*i%MOD;
for(int i=1;i&lt;N;i++)inv[i]=qmod(fac[i],MOD-2);
</code></pre><h1 id="数学概念"><a href="#数学概念" class="headerlink" title="数学概念"></a>数学概念</h1><h2 id="素数"><a href="#素数" class="headerlink" title="素数"></a>素数</h2><pre><code>不赘述
</code></pre><h2 id="反素数"><a href="#反素数" class="headerlink" title="反素数"></a>反素数</h2><h2 id="原根"><a href="#原根" class="headerlink" title="原根"></a>原根</h2><p><strong> 定义 </strong> ：设  m  &gt; 1  ，  gcd  (  a  ,  m  )  =  1  ，使得  a  r  ≡  (  mod  m  )  成立的最小的  r  ，称为  a  对模  m  的阶，记为。  δ  m  (  a  ) </p>
<p><strong> 定理 </strong> ：如果模  m  有原根，那么它一共有个  φ  (  φ  (  m  )  )  原根。 </p>
<p><strong> 定理 </strong> ：若  m  &gt; 1  ，  gcd  (  a  ,  m  )  =  1  ，  a  n  ≡  (  mod  m  )  则  δ  m  (  a  )  |  n  。 </p>
<p><strong> 定理 </strong> ：如果  p  为素数，那么素数  p  一定存在原根，并且模  p  的原根的个数为  φ  (  p  −  1  )  。 </p>
<p><strong> 定理 </strong> ：设  m  是正整数，  a  是整数，若  a  模  m  的阶等于  φ  (  m  )  ，则称  a  为模  m  的一个原根。 </p>
<p>假设一个数  g  对于模  m  来说是原根，那么  g  i  mod  p  的结果两两不同,且有  1  &lt; g  &lt; p  ，  0  ≤  i<br>&lt; p  那么  g  可以称为是模  p  的一个原根，归根到底就是  g  p  −  1  ≡  (  mod  p  )  当且仅当指数为  p<br>−  1  的时候成立。（这里是素数）</p>
<p>模  m  有原根的充要条件：  m  =  2  ,  4  ,  p  a  ,  2  p  a  ，其中  p  是奇素数。</p>
<p>求模素数  P  原根的方法：对  p  −  1  素因子分解，即  p  −  1  =  p  a  1  1  p  a  2  2  .  .<br>.  p  a  k  k  是的标准分解式，若恒有<br>g  p  −  1  p  i  ≠  1  (  mod  p  )</p>
<p>成立，则  g  就是  p  的原根。（对于合数求原根，只需把  p  −  1  换成  φ  (  p  )  即可）</p>
<p><a href="http://blog.csdn.net/zhang20072844/article/details/11541133" target="_blank" rel="noopener"> 求解原根的优化方法 </a></p>
<p>求解原根的完整代码</p>
<pre><code>如果mod 为素数
int get(int mod) {
    for(int i = 2; ; i++) {
        set&lt;int&gt; s;
        for(int j = 1, x = 1; j &lt; mod; j++) {
            x = (x*i)%mod;
            s.insert(x);
        }
        if(s.size() == mod-1) return i;
    }
}

----------------------------------------------------------------
//注意爆int，所以用LL
LL qmod(LL a,LL b,LL c){
    LL res = 1;a%=c;
    while(b){
        if(b&amp;1) res=res*a%c;
        b&gt;&gt;=1,a=a*a%c;
    }
    return res;
}

int prime[N];
int Is_or[N][2];

void Prime(){
    int n = 100000;
    prime[0]=0;
    memset(Is_or,1,sizeof(Is_or));
    for(int i=2;i&lt;=n;i++){
        if(Is_or[i][0]) prime[++prime[0]]=i,Is_or[i][1]=prime[0];
        for(int j=1;j&lt;=prime[0]&amp;&amp;i*prime[j]&lt;=n;j++){
            Is_or[i*prime[j]][0]=0;
            if(0==i%prime[j]) break;
        }
    }
    return ;
}

int Phi(int x){
    //因为本题中数据都是质数，所以欧拉函数值就都是x-1了。
    return x-1;
}

int a[10000],cnt;
void divide(int n){
    cnt = 0;
    for(int i=1;prime[i]*prime[i]&lt;=n;i++){
        if(n&lt;=prime[prime[0]]&amp;&amp;Is_or[n][0]){a[++cnt]=n;n=1;break;}
        if(n%prime[i]==0){a[++cnt]=prime[i];n/=prime[i];}
        while(n%prime[i]==0){n/=prime[i];}
    }
    if(n&gt;1)a[++cnt]=n;
    return;
}

void work(int n){
    int phi = Phi(n);
    bool flag ;
    for(int i=2;i&lt;n;i++){ //一个数的原根是很小的 所以暴力枚举就行,但其实是有优化方法的,
        flag = true;
        for(int j=1;j&lt;=cnt;j++){
            int tmp = phi/a[j];
            if(qmod(i,tmp,n)==1){
                flag = false;
                break;
            }
        }
        if(flag){
            printf(&quot;%d\n&quot;,i);
            return ;
        }
    }
    puts(&quot;没有原根&quot;);
}

int main(){
    Prime();
    int n;
    while(~scanf(&quot;%d&quot;,&amp;n)){
        divide(Phi(n));
        work(n);
    }
    return 0;
}
</code></pre>
            </div>
            <hr/>

            
            <style>
    #reward {
        margin: 40px 0;
        text-align: center;
    }

    #reward .reward-link {
        font-size: 1.88rem;
    }

    #reward .btn-floating:hover {
        box-shadow: 0 6px 12px rgba(0, 0, 0, 0.2), 0 5px 15px rgba(0, 0, 0, 0.2);
    }

    #rewardModal {
        width: 320px;
        height: 350px;
    }

    #rewardModal .reward-title {
        margin: 15px auto;
        padding-bottom: 5px;
    }

    #rewardModal .modal-content {
        padding: 10px;
    }

    #rewardModal .close {
        position: absolute;
        right: 15px;
        top: 15px;
        color: rgba(0, 0, 0, 0.5);
        font-size: 1.3rem;
        line-height: 20px;
        cursor: pointer;
    }

    #rewardModal .close:hover {
        color: #ef5350;
        transform: scale(1.3);
        -moz-transform:scale(1.3);
        -webkit-transform:scale(1.3);
        -o-transform:scale(1.3);
    }

    #rewardModal .reward-tabs {
        margin: 0 auto;
        width: 210px;
    }

    .reward-tabs .tabs {
        height: 38px;
        margin: 10px auto;
        padding-left: 0;
    }

    .reward-content ul {
        padding-left: 0 !important;
    }

    .reward-tabs .tabs .tab {
        height: 38px;
        line-height: 38px;
    }

    .reward-tabs .tab a {
        color: #fff;
        background-color: #ccc;
    }

    .reward-tabs .tab a:hover {
        background-color: #ccc;
        color: #fff;
    }

    .reward-tabs .wechat-tab .active {
        color: #fff !important;
        background-color: #22AB38 !important;
    }

    .reward-tabs .alipay-tab .active {
        color: #fff !important;
        background-color: #019FE8 !important;
    }

    .reward-tabs .reward-img {
        width: 210px;
        height: 210px;
    }
</style>

<div id="reward">
    <a href="#rewardModal" class="reward-link modal-trigger btn-floating btn-large waves-effect waves-light red">赏</a>

    <!-- Modal Structure -->
    <div id="rewardModal" class="modal">
        <div class="modal-content">
            <a class="close modal-close"><i class="fa fa-close"></i></a>
            <h4 class="reward-title">你的赏识是我前进的动力</h4>
            <div class="reward-content">
                <div class="reward-tabs">
                    <ul class="tabs row">
                        <li class="tab col s6 alipay-tab waves-effect waves-light"><a href="#alipay">支付宝</a></li>
                        <li class="tab col s6 wechat-tab waves-effect waves-light"><a href="#wechat">微 信</a></li>
                    </ul>
                    <div id="alipay">
                        <img src="/medias/reward/alipay.jpg" class="reward-img" alt="支付宝打赏二维码">
                    </div>
                    <div id="wechat">
                        <img src="/medias/reward/wechat.jpg" class="reward-img" alt="微信打赏二维码">
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
    $(function () {
        $('.tabs').tabs();
    });
</script>
            

            <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">

<div id="article-share">
    
    <div class="social-share" data-disabled="qzone" data-wechat-qrcode-helper="<p>微信里点“发现”->“扫一扫”二维码便可查看分享。</p>"></div>
    
</div>

<script src="/libs/share/js/social-share.min.js"></script>

            

    <div class="reprint" id="reprint-statement">
        <p class="reprint-tip">
            <i class="fa fa-exclamation-triangle"></i>&nbsp;&nbsp;
            <span>转载规则</span>
        </p>
        
            <div class="center-align">
                <a rel="license" href="https://creativecommons.org/licenses/by/4.0/deed.zh">
                    <img alt=""
                         style="border-width:0"
                         src="https://i.creativecommons.org/l/by/4.0/88x31.png"/>
                </a>
            </div>
            <br/>
            <span xmlns:dct="http://purl.org/dc/terms/" href="http://purl.org/dc/dcmitype/Text"
                  property="dct:title" rel="dct:type">
                    《&lt;原&gt;#  数论各种小定理》
                </span> 由
            <a xmlns:cc="http://creativecommons.org/ns#" href="/2016/05/24/51488462/" property="cc:attributionName"
               rel="cc:attributionURL">
                tabris
            </a> 采用
            <a rel="license" href="https://creativecommons.org/licenses/by/4.0/deed.zh">
                知识共享署名 4.0 国际许可协议
            </a>进行许可。
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>


        </div>
    </div>

    

    

    

    

    
        <style>
    .valine-card {
        margin: 1.5rem auto;
    }

    .valine-card .card-content {
        padding: 20px 20px 5px 20px;
    }

    #vcomments input[type=text],
    #vcomments input[type=email],
    #vcomments input[type=url],
    #vcomments textarea {
        box-sizing: border-box;
    }

    #vcomments p {
        margin: 2px 2px 10px;
        font-size: 1.05rem;
        line-height: 1.78rem;
    }

    #vcomments blockquote p {
        text-indent: 0.2rem;
    }

    #vcomments a {
        padding: 0 2px;
        color: #42b983;
        font-weight: 500;
        text-decoration: underline;
    }

    #vcomments img {
        max-width: 100%;
        height: auto;
        cursor: pointer;
    }

    #vcomments ol li {
        list-style-type: decimal;
    }

    #vcomments ol,
    ul {
        display: block;
        padding-left: 2em;
        word-spacing: 0.05rem;
    }

    #vcomments ul li,
    ol li {
        display: list-item;
        line-height: 1.8rem;
        font-size: 1rem;
    }

    #vcomments ul li {
        list-style-type: disc;
    }

    #vcomments ul ul li {
        list-style-type: circle;
    }

    #vcomments table, th, td {
        padding: 12px 13px;
        border: 1px solid #dfe2e5;
    }

    #vcomments table, th, td {
        border: 0;
    }

    table tr:nth-child(2n), thead {
        background-color: #fafafa;
    }

    #vcomments table th {
        background-color: #f2f2f2;
        min-width: 80px;
    }

    #vcomments table td {
        min-width: 80px;
    }

    #vcomments h1 {
        font-size: 1.85rem;
        font-weight: bold;
        line-height: 2.2rem;
    }

    #vcomments h2 {
        font-size: 1.65rem;
        font-weight: bold;
        line-height: 1.9rem;
    }

    #vcomments h3 {
        font-size: 1.45rem;
        font-weight: bold;
        line-height: 1.7rem;
    }

    #vcomments h4 {
        font-size: 1.25rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    #vcomments h5 {
        font-size: 1.1rem;
        font-weight: bold;
        line-height: 1.4rem;
    }

    #vcomments h6 {
        font-size: 1rem;
        line-height: 1.3rem;
    }

    #vcomments p {
        font-size: 1rem;
        line-height: 1.5rem;
    }

    #vcomments hr {
        margin: 12px 0;
        border: 0;
        border-top: 1px solid #ccc;
    }

    #vcomments blockquote {
        margin: 15px 0;
        border-left: 5px solid #42b983;
        padding: 1rem 0.8rem 0.3rem 0.8rem;
        color: #666;
        background-color: rgba(66, 185, 131, .1);
    }

    #vcomments pre {
        font-family: monospace, monospace;
        padding: 1.2em;
        margin: .5em 0;
        background: #272822;
        overflow: auto;
        border-radius: 0.3em;
        tab-size: 4;
    }

    #vcomments code {
        font-family: monospace, monospace;
        padding: 1px 3px;
        font-size: 0.92rem;
        color: #e96900;
        background-color: #f8f8f8;
        border-radius: 2px;
    }

    #vcomments pre code {
        font-family: monospace, monospace;
        padding: 0;
        color: #e8eaf6;
        background-color: #272822;
    }

    #vcomments pre[class*="language-"] {
        padding: 1.2em;
        margin: .5em 0;
    }

    #vcomments code[class*="language-"],
    pre[class*="language-"] {
        color: #e8eaf6;
    }

    #vcomments [type="checkbox"]:not(:checked), [type="checkbox"]:checked {
        position: inherit;
        margin-left: -1.3rem;
        margin-right: 0.4rem;
        margin-top: -1px;
        vertical-align: middle;
        left: unset;
        visibility: visible;
    }

    #vcomments b,
    strong {
        font-weight: bold;
    }

    #vcomments dfn {
        font-style: italic;
    }

    #vcomments small {
        font-size: 85%;
    }

    #vcomments cite {
        font-style: normal;
    }

    #vcomments mark {
        background-color: #fcf8e3;
        padding: .2em;
    }

    #vcomments table, th, td {
        padding: 12px 13px;
        border: 1px solid #dfe2e5;
    }

    table tr:nth-child(2n), thead {
        background-color: #fafafa;
    }

    #vcomments table th {
        background-color: #f2f2f2;
        min-width: 80px;
    }

    #vcomments table td {
        min-width: 80px;
    }

    #vcomments [type="checkbox"]:not(:checked), [type="checkbox"]:checked {
        position: inherit;
        margin-left: -1.3rem;
        margin-right: 0.4rem;
        margin-top: -1px;
        vertical-align: middle;
        left: unset;
        visibility: visible;
    }
</style>

<div class="card valine-card" data-aos="fade-up">
    <div id="vcomments" class="card-content"></div>
</div>

<script src="/libs/valine/av-min.js"></script>
<script src="/libs/valine/Valine.min.js"></script>
<script>
    new Valine({
        el: '#vcomments',
        appId: 'XkeYrd6r1FrJXgASPvPJa9Hp-gzGzoHsz',
        appKey: 'de9Yfw8ns8xwf6S9eHOj82Wi',
        notify: 'false' === 'true',
        verify: 'false' === 'true',
        visitor: 'true' === 'true',
        avatar: 'mm',
        pageSize: '10',
        lang: 'zh-cn',
        placeholder: 'just go go'
    });
</script>
    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fa fa-chevron-left"></i>&nbsp;上一篇</div>
            <div class="card">
                <a href="/2016/05/31/51544872/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/3.jpg" class="responsive-img" alt="<原>#  codeforces">
                        
                        <span class="card-title"><原>#  codeforces</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            这是你自定义的文章摘要内容，如果这个属性有值，文章卡片摘要就显示这段文字，否则程序会自动截取文章的部分内容作为摘要
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="fa fa-clock-o fa-fw icon-date"></i>2016-05-31
                        </span>
                        <span class="publish-author">
                            
                            <i class="fa fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/OJ算法题/" class="post-category" target="_blank">
                                    OJ算法题
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fa fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/2016/05/22/51476199/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/16.jpg" class="responsive-img" alt="<原>#  组合数学各种小定理">
                        
                        <span class="card-title"><原>#  组合数学各种小定理</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            这是你自定义的文章摘要内容，如果这个属性有值，文章卡片摘要就显示这段文字，否则程序会自动截取文章的部分内容作为摘要
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="fa fa-clock-o fa-fw icon-date"></i>2016-05-22
                            </span>
                        <span class="publish-author">
                            
                            <i class="fa fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/OJ算法题/" class="post-category" target="_blank">
                                    OJ算法题
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
            </div>
        </div>
        
    </div>
</article>
</div>


<script>
    $('#articleContent').on('copy', function (e) {
        // IE8 or earlier browser is 'undefined'
        if (typeof window.getSelection === 'undefined') return;

        var selection = window.getSelection();
        // if the selection is short let's not annoy our users.
        if (('' + selection).length < Number.parseInt('120')) {
            return;
        }

        // create a div outside of the visible area and fill it with the selected text.
        var bodyElement = document.getElementsByTagName('body')[0];
        var newdiv = document.createElement('div');
        newdiv.style.position = 'absolute';
        newdiv.style.left = '-99999px';
        bodyElement.appendChild(newdiv);
        newdiv.appendChild(selection.getRangeAt(0).cloneContents());

        // we need a <pre> tag workaround.
        // otherwise the text inside "pre" loses all the line breaks!
        if (selection.getRangeAt(0).commonAncestorContainer.nodeName === 'PRE') {
            newdiv.innerHTML = "<pre>" + newdiv.innerHTML + "</pre>";
        }

        var url = document.location.href;
        newdiv.innerHTML += '<br />'
            + '来源: tabris的博客<br />'
            + '作者: tabris<br />'
            + '链接: <a href="' + url + '">' + url + '</a><br />'
            + '本文章著作权归作者(tabris)所有，任何形式的转载都请注明出处。';

        selection.selectAllChildren(newdiv);
        window.setTimeout(function () {bodyElement.removeChild(newdiv);}, 200);
    });
</script>


    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget">
            <div class="toc-title"><i class="fa fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fa fa-list"></i>
    </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            // headingsOffset: -205,
            headingSelector: 'h1, h2, h3, h4, h5, h6'
        });

        // modify the toc link href to support Chinese.
        let i = 0;
        let tocHeading = 'toc-heading-';
        $('#toc-content a').each(function () {
            $(this).attr('href', '#' + tocHeading + (++i));
        });

        // modify the heading title id to support Chinese.
        i = 0;
        $('#articleContent').children('h1, h2, h3, h4, h5, h6').each(function () {
            $(this).attr('id', tocHeading + (++i));
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).slideUp(500);
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).slideDown(500);
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>
    

</main>


<footer class="page-footer bg-color">
    <div class="container row center-align">
        <div class="col s12 m8 l8 copy-right">
            本站由&copy;<a href="https://blinkfox.github.io/" target="_blank">Blinkfox</a>基于
            <a href="https://hexo.io/" target="_blank">Hexo</a> 的
            <a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">hexo-theme-matery</a>主题搭建.

            
                &nbsp;<i class="fa fa-area-chart"></i>&nbsp;站点总字数:&nbsp;
                <span class="white-color">414.6k</span>
            

            
			
                <br>
                
                <span id="busuanzi_container_site_pv">
                    <i class="fa fa-heart-o"></i>
                    本站总访问量 <span id="busuanzi_value_site_pv" class="white-color"></span>
                </span>
                
                
                <span id="busuanzi_container_site_uv">
                    <i class="fa fa-users"></i>
                    次,&nbsp;访客数 <span id="busuanzi_value_site_uv" class="white-color"></span> 人.
                </span>
                
            
        </div>
        <div class="col s12 m4 l4 social-link social-statis">
    <a href="https://github.com/tabris233" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fa fa-github"></i>
    </a>



    <a href="mailto:604925267@qq.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fa fa-envelope-open"></i>
    </a>



    <a href="tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=604925267" class="tooltipped" data-tooltip="QQ联系我: 604925267" data-position="top" data-delay="50">
        <i class="fa fa-qq"></i>
    </a>



    <a href="/atom.xml" class="tooltipped" target="_blank" data-tooltip="RSS 订阅" data-position="top" data-delay="50">
        <i class="fa fa-rss"></i>
    </a>
</div>
    </div>
</footer>

<div class="progress-bar"></div>


<!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fa fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script src="/js/search.js"></script>
<script type="text/javascript">
$(function () {
    searchFunc("/" + "search.xml", 'searchInput', 'searchResult');
});
</script>
<!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fa fa-angle-up"></i>
    </a>
</div>


<script src="/libs/materialize/materialize.min.js"></script>
<script src="/libs/masonry/masonry.pkgd.min.js"></script>
<script src="/libs/aos/aos.js"></script>
<script src="/libs/scrollprogress/scrollProgress.min.js"></script>
<script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
<script src="/js/matery.js"></script>

<!-- Global site tag (gtag.js) - Google Analytics -->




    <script async src="/libs/others/busuanzi.pure.mini.js"></script>


</body>
</html>