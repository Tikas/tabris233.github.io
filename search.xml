<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>csdn博文迁移至hexo心路历程</title>
      <link href="/2019/04/18/csdn2hexo/"/>
      <url>/2019/04/18/csdn2hexo/</url>
      
        <content type="html"><![CDATA[<blockquote><p>  某天我之前的<code>hexo</code>主题被自己玩坏了, 决定换一个主题,</p><p>  同时突然想把之前<code>CSDN</code>博文迁移进来,CSDN这个网站是越来越傻逼了.</p><p>  最终选择了<a href="https://codeload.github.com/blinkfox/hexo-theme-matery" target="_blank" rel="noopener">hexo-theme-matery</a>主题,</p><p>  但最艰难的博文迁移过程算是完成了,但仍然有很大瑕疵..</p></blockquote><h1 id="HEXO更换主题-并配置"><a href="#HEXO更换主题-并配置" class="headerlink" title="HEXO更换主题,并配置"></a>HEXO更换主题,并配置</h1><p>有了<a href="https://easyhexo.com/" target="_blank" rel="noopener">easyHexo</a>这个项目做起来还是很容易的,里面很详细的介绍了<code>hexo</code>博客的构建部署及主题使用以及配置.</p><p>我这里就不在赘述了,只说几个坑吧.</p><h2 id="代码高亮问题"><a href="#代码高亮问题" class="headerlink" title="代码高亮问题"></a>代码高亮问题</h2><ol><li><p>我采用的 <a href="https://github.com/ele828/hexo-prism-plugin" target="_blank" rel="noopener">hexo-prism-plugin</a> 是一个代码高亮的插件,但是对<code>c++</code>代码的编写是必须为</p><pre class=" language-md"><code class="language-md">​```cpp​</code></pre><pre><code>不能为```md​```c++​</code></pre><p><code>`</code></p></li></ol><h2 id="渲染问题"><a href="#渲染问题" class="headerlink" title="渲染问题"></a>渲染问题</h2><p>之前的文件中存在<code>}}</code>这样的字符,<code>hexo</code>渲染的时候就会出现报错</p><pre class=" language-javascript"><code class="language-javascript">FATAL Something's wrong<span class="token punctuation">.</span> Maybe you can find the solution here<span class="token punctuation">:</span> http<span class="token punctuation">:</span><span class="token operator">/</span><span class="token operator">/</span>hexo<span class="token punctuation">.</span>io<span class="token operator">/</span>docs<span class="token operator">/</span>troubleshooting<span class="token punctuation">.</span>htmlTemplate render error<span class="token punctuation">:</span> <span class="token punctuation">(</span>unknown path<span class="token punctuation">)</span> <span class="token punctuation">[</span>Line <span class="token number">31</span><span class="token punctuation">,</span> Column <span class="token number">21</span><span class="token punctuation">]</span>expected variable end</code></pre><p>参考了<a href="https://blog.csdn.net/chwshuang/article/details/52350559" target="_blank" rel="noopener">文章一</a>,<a href="https://www.jianshu.com/p/738ebe02029b" target="_blank" rel="noopener">文章二</a> 找到问题并解决</p><h1 id="CSDN博文迁移"><a href="#CSDN博文迁移" class="headerlink" title="CSDN博文迁移"></a>CSDN博文迁移</h1><p>我这里有<code>300+</code>篇博文在<code>csdn</code>上,所以很难人工迁移,所以选择<code>python</code>爬虫的方式爬取迁移,</p><p>百度一通找了好多爬虫,不是太老了,就是效果不行,</p><p>最终我找到了一个能凑合用的脚本,<a href="https://github.com/gaocegege/csdn-blog-export" target="_blank" rel="noopener">csdn-blog-export</a></p><p>它能够自动爬取博文,并输出<code>markdown</code>文本或者<code>html</code>的代码,</p><p>但是年代还是过于老了, <code>CSDN</code>的网站<code>html</code>结构已经大变,于是进行了魔改,终于可以爬取到信息了,</p><p>期间主要是有几个问题</p><ol><li><p>不适应新的网站<code>html</code>机构, </p><blockquote><p>  魔改后可用</p></blockquote></li><li><p>缺少<code>hexo</code>需要的<code>yaml front matter</code>, </p><blockquote><p>  添加此函数 获得<code>yaml front matter</code></p><pre class=" language-python"><code class="language-python">  <span class="token keyword">def</span> <span class="token function">getHexoTitleMarkdown</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> detail<span class="token punctuation">)</span><span class="token punctuation">:</span>      title <span class="token operator">=</span> <span class="token string">'&lt;'</span> <span class="token operator">+</span> \              html2text<span class="token punctuation">.</span>html2text<span class="token punctuation">(</span>detail<span class="token punctuation">.</span>find<span class="token punctuation">(</span>class_<span class="token operator">=</span><span class="token string">'article-title-box'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>span<span class="token punctuation">.</span>prettify<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span>rstrip<span class="token punctuation">(</span><span class="token string">'\n'</span><span class="token punctuation">)</span> <span class="token operator">+</span> \              <span class="token string">'>'</span> <span class="token operator">+</span> \              html2text<span class="token punctuation">.</span>html2text<span class="token punctuation">(</span>detail<span class="token punctuation">.</span>find<span class="token punctuation">(</span>class_<span class="token operator">=</span><span class="token string">'title-article'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>prettify<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span>rstrip<span class="token punctuation">(</span><span class="token string">'\n'</span><span class="token punctuation">)</span>      date <span class="token operator">=</span> html2text<span class="token punctuation">.</span>html2text<span class="token punctuation">(</span>detail<span class="token punctuation">.</span>find<span class="token punctuation">(</span>class_<span class="token operator">=</span><span class="token string">'time'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>prettify<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span>replace<span class="token punctuation">(</span><span class="token string">'\n'</span><span class="token punctuation">,</span> <span class="token string">''</span><span class="token punctuation">)</span>      date <span class="token operator">=</span> date<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token number">4</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token string">'-'</span> <span class="token operator">+</span> date<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">:</span><span class="token number">7</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token string">'-'</span> <span class="token operator">+</span> date<span class="token punctuation">[</span><span class="token number">8</span><span class="token punctuation">:</span><span class="token number">10</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token string">' '</span> <span class="token operator">+</span> date<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">8</span><span class="token punctuation">:</span><span class="token punctuation">]</span>      tags <span class="token operator">=</span> detail<span class="token punctuation">.</span>find_all<span class="token punctuation">(</span>class_<span class="token operator">=</span><span class="token string">'tag-link'</span><span class="token punctuation">)</span>      tags <span class="token operator">=</span> map<span class="token punctuation">(</span>deleteURL<span class="token punctuation">,</span> map<span class="token punctuation">(</span><span class="token keyword">lambda</span> x<span class="token punctuation">:</span> x<span class="token punctuation">.</span>replace<span class="token punctuation">(</span><span class="token string">'\n'</span><span class="token punctuation">,</span> <span class="token string">''</span><span class="token punctuation">)</span><span class="token punctuation">,</span> map<span class="token punctuation">(</span>html2text<span class="token punctuation">.</span>html2text<span class="token punctuation">,</span> map<span class="token punctuation">(</span><span class="token keyword">lambda</span> x<span class="token punctuation">:</span> x<span class="token punctuation">.</span>prettify<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> tags<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>      <span class="token comment" spellcheck="true"># print(tags)</span>      tags <span class="token operator">=</span> <span class="token string">''</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span>map<span class="token punctuation">(</span><span class="token keyword">lambda</span> x<span class="token punctuation">:</span> <span class="token string">'  - '</span> <span class="token operator">+</span> x <span class="token operator">+</span> <span class="token string">'\n'</span><span class="token punctuation">,</span> map<span class="token punctuation">(</span><span class="token keyword">lambda</span> x<span class="token punctuation">:</span> x<span class="token punctuation">.</span>replace<span class="token punctuation">(</span><span class="token string">'='</span><span class="token punctuation">,</span> <span class="token string">''</span><span class="token punctuation">)</span><span class="token punctuation">.</span>strip<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> tags<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>      str <span class="token operator">=</span> u<span class="token triple-quoted-string string">'''---  title: %s  date: %s  description:  toc: true  author: tabris  # 图片推荐使用图床(腾讯云、七牛云、又拍云等)来做图片的路径.如:http://xxx.com/xxx.jpg  img:   # 如果top值为true，则会是首页推荐文章  top: false  # 如果要对文章设置阅读验证密码的话，就可以在设置password的值，该值必须是用SHA256加密后的密码，防止被他人识破  password:   # 本文章是否开启mathjax，且需要在主题的_config.yml文件中也需要开启才行  mathjax: false  summary: 这是你自定义的文章摘要内容，如果这个属性有值，文章卡片摘要就显示这段文字，否则程序会自动截取文章的部分内容作为摘要  categories: OJ算法题  tags:  %s  ---  '''</span> <span class="token operator">%</span> <span class="token punctuation">(</span>title<span class="token punctuation">.</span>replace<span class="token punctuation">(</span><span class="token string">'\n'</span><span class="token punctuation">,</span> <span class="token string">''</span><span class="token punctuation">)</span><span class="token punctuation">.</span>replace<span class="token punctuation">(</span><span class="token string">':'</span><span class="token punctuation">,</span> <span class="token string">' '</span><span class="token punctuation">)</span><span class="token punctuation">,</span> date<span class="token punctuation">.</span>replace<span class="token punctuation">(</span><span class="token string">':'</span><span class="token punctuation">,</span> <span class="token string">' '</span><span class="token punctuation">)</span><span class="token punctuation">,</span> tags<span class="token punctuation">.</span>replace<span class="token punctuation">(</span><span class="token string">':'</span><span class="token punctuation">,</span> <span class="token string">' '</span><span class="token punctuation">)</span><span class="token punctuation">)</span>      <span class="token comment" spellcheck="true"># print(str)</span>      <span class="token comment" spellcheck="true"># exit(0)</span>      <span class="token keyword">return</span> str</code></pre></blockquote></li><li><p>爬取得到的<code>markdown</code>文本格式不是很理想</p><blockquote><p>  <strong>这个问题并没有解决</strong></p><p>  最开始查看了这个脚本使用的<code>html</code>转<code>markdown</code>模块(<a href="https://github.com/aaronsw/html2text" target="_blank" rel="noopener">html2text</a>)最后一次维护是<code>2012</code>年,</p><p>  于是就换了一个新模块<a href>html2markdown</a>,可最后发现这个模块的效果还不如<a href="https://github.com/aaronsw/html2text" target="_blank" rel="noopener">html2text</a>, 于是放弃.</p></blockquote></li></ol><hr><p>最终迁移到了<a href="https://tabris.top/categories/OJ算法题/">https://tabris.top/categories/OJ算法题/</a>,</p><p>迁移脚本在这里<a href="https://github.com/tabris233/Spider/tree/master/csdn2hexo" target="_blank" rel="noopener">csdn2hexo</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>主流应用换源or镜像加速</title>
      <link href="/2019/04/14/changesource/"/>
      <url>/2019/04/14/changesource/</url>
      
        <content type="html"><![CDATA[<h1 id="Arch-or-manjaro-pacman"><a href="#Arch-or-manjaro-pacman" class="headerlink" title="Arch or manjaro : pacman"></a>Arch or manjaro : pacman</h1><h2 id="启用中国源"><a href="#启用中国源" class="headerlink" title="启用中国源"></a>启用中国源</h2><pre class=" language-shell"><code class="language-shell">sudo pacman-mirrors -c China</code></pre><h2 id="添加archlinuxcn源"><a href="#添加archlinuxcn源" class="headerlink" title="添加archlinuxcn源"></a>添加archlinuxcn源</h2><p>archlinuxcn源至您的 /etc/pacman.conf</p><pre class=" language-toml"><code class="language-toml">[archlinuxcn]#The Chinese Arch Linux communities packages.SigLevel = Optional TrustAllServer = https://mirrors.ustc.edu.cn/archlinuxcn/$arch</code></pre><h1 id="ubuntu"><a href="#ubuntu" class="headerlink" title="ubuntu"></a>ubuntu</h1><h2 id="1-备份原来的源"><a href="#1-备份原来的源" class="headerlink" title="1.备份原来的源"></a>1.备份原来的源</h2><pre class=" language-shell"><code class="language-shell">sudo cp /etc/apt/sources.list /etc/apt/sources_init.list</code></pre><p>将以前的源备份一下，以防以后可以用的。</p><h2 id="2-更换源"><a href="#2-更换源" class="headerlink" title="2.更换源"></a>2.更换源</h2><pre class=" language-shell"><code class="language-shell">sudo gedit /etc/apt/sources.list</code></pre><p>使用gedit打开文档，将下边的阿里源复制进去，然后点击保存关闭。</p><h3 id="阿里源"><a href="#阿里源" class="headerlink" title="阿里源"></a>阿里源</h3><pre class=" language-typescript"><code class="language-typescript">deb http<span class="token punctuation">:</span><span class="token operator">/</span><span class="token operator">/</span>mirrors<span class="token punctuation">.</span>aliyun<span class="token punctuation">.</span>com<span class="token operator">/</span>ubuntu<span class="token operator">/</span> xenial maindeb<span class="token operator">-</span>src http<span class="token punctuation">:</span><span class="token operator">/</span><span class="token operator">/</span>mirrors<span class="token punctuation">.</span>aliyun<span class="token punctuation">.</span>com<span class="token operator">/</span>ubuntu<span class="token operator">/</span> xenial maindeb http<span class="token punctuation">:</span><span class="token operator">/</span><span class="token operator">/</span>mirrors<span class="token punctuation">.</span>aliyun<span class="token punctuation">.</span>com<span class="token operator">/</span>ubuntu<span class="token operator">/</span> xenial<span class="token operator">-</span>updates maindeb<span class="token operator">-</span>src http<span class="token punctuation">:</span><span class="token operator">/</span><span class="token operator">/</span>mirrors<span class="token punctuation">.</span>aliyun<span class="token punctuation">.</span>com<span class="token operator">/</span>ubuntu<span class="token operator">/</span> xenial<span class="token operator">-</span>updates maindeb http<span class="token punctuation">:</span><span class="token operator">/</span><span class="token operator">/</span>mirrors<span class="token punctuation">.</span>aliyun<span class="token punctuation">.</span>com<span class="token operator">/</span>ubuntu<span class="token operator">/</span> xenial universedeb<span class="token operator">-</span>src http<span class="token punctuation">:</span><span class="token operator">/</span><span class="token operator">/</span>mirrors<span class="token punctuation">.</span>aliyun<span class="token punctuation">.</span>com<span class="token operator">/</span>ubuntu<span class="token operator">/</span> xenial universedeb http<span class="token punctuation">:</span><span class="token operator">/</span><span class="token operator">/</span>mirrors<span class="token punctuation">.</span>aliyun<span class="token punctuation">.</span>com<span class="token operator">/</span>ubuntu<span class="token operator">/</span> xenial<span class="token operator">-</span>updates universedeb<span class="token operator">-</span>src http<span class="token punctuation">:</span><span class="token operator">/</span><span class="token operator">/</span>mirrors<span class="token punctuation">.</span>aliyun<span class="token punctuation">.</span>com<span class="token operator">/</span>ubuntu<span class="token operator">/</span> xenial<span class="token operator">-</span>updates universedeb http<span class="token punctuation">:</span><span class="token operator">/</span><span class="token operator">/</span>mirrors<span class="token punctuation">.</span>aliyun<span class="token punctuation">.</span>com<span class="token operator">/</span>ubuntu<span class="token operator">/</span> xenial<span class="token operator">-</span>security maindeb<span class="token operator">-</span>src http<span class="token punctuation">:</span><span class="token operator">/</span><span class="token operator">/</span>mirrors<span class="token punctuation">.</span>aliyun<span class="token punctuation">.</span>com<span class="token operator">/</span>ubuntu<span class="token operator">/</span> xenial<span class="token operator">-</span>security maindeb http<span class="token punctuation">:</span><span class="token operator">/</span><span class="token operator">/</span>mirrors<span class="token punctuation">.</span>aliyun<span class="token punctuation">.</span>com<span class="token operator">/</span>ubuntu<span class="token operator">/</span> xenial<span class="token operator">-</span>security universedeb<span class="token operator">-</span>src http<span class="token punctuation">:</span><span class="token operator">/</span><span class="token operator">/</span>mirrors<span class="token punctuation">.</span>aliyun<span class="token punctuation">.</span>com<span class="token operator">/</span>ubuntu<span class="token operator">/</span> xenial<span class="token operator">-</span>security universe</code></pre><h2 id="3-更新"><a href="#3-更新" class="headerlink" title="3.更新"></a>3.更新</h2><h3 id="更新源"><a href="#更新源" class="headerlink" title="更新源"></a>更新源</h3><pre class=" language-shell"><code class="language-shell">sudo apt-get update</code></pre><p>复损坏的软件包，尝试卸载出错的包，重新安装正确版本的。</p><pre class=" language-shell"><code class="language-shell">sudo apt-get -f install</code></pre><h3 id="更新软件"><a href="#更新软件" class="headerlink" title="更新软件"></a>更新软件</h3><pre class=" language-shell"><code class="language-shell"> sudo apt-get upgrade</code></pre><h2 id="4-其他常用源"><a href="#4-其他常用源" class="headerlink" title="4.其他常用源"></a>4.其他常用源</h2><h3 id="西电源（只有校内网网线使用，但是不限制流量，还是十分靠谱的）"><a href="#西电源（只有校内网网线使用，但是不限制流量，还是十分靠谱的）" class="headerlink" title="西电源（只有校内网网线使用，但是不限制流量，还是十分靠谱的）"></a>西电源（只有校内网网线使用，但是不限制流量，还是十分靠谱的）</h3><pre><code>deb http://linux.xidian.edu.cn/mirrors/ubuntu/ xenial main restricted universe multiverse#deb-src http://linux.xidian.edu.cn/mirrors/ubuntu/ xenial main restricted universe multiversedeb http://linux.xidian.edu.cn/mirrors/ubuntu/ xenial-security main restricted universe multiverse#deb-src http://linux.xidian.edu.cn/mirrors/ubuntu/ xenial-security main restricted universe multiversedeb http://linux.xidian.edu.cn/mirrors/ubuntu/ xenial-updates main restricted universe multiverse#deb-src http://linux.xidian.edu.cn/mirrors/ubuntu/ xenial-updates main restricted universe multiverse#deb http://linux.xidian.edu.cn/mirrors/ubuntu/ xenial-backports main restricted universe multiverse#deb-src http://linux.xidian.edu.cn/mirrors/ubuntu/ xenial-backports main restricted universe multiverse#deb http://linux.xidian.edu.cn/mirrors/ubuntu/ xenial-proposed main restricted universe multiverse#deb-src http://linux.xidian.edu.cn/mirrors/ubuntu/ xenial-proposed main restricted universe multiverse</code></pre><h3 id="清华源"><a href="#清华源" class="headerlink" title="清华源"></a>清华源</h3><pre><code>deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial main restricted universe multiverse# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial main restricted universe multiversedeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-updates main restricted universe multiverse# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-updates main restricted universe multiversedeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-backports main restricted universe multiverse# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-backports main restricted universe multiversedeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-security main restricted universe multiverse# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-security main restricted universe multiverse</code></pre><h3 id="网易源"><a href="#网易源" class="headerlink" title="网易源"></a>网易源</h3><pre><code>deb http://mirrors.163.com/ubuntu/ wily main restricted universe multiversedeb http://mirrors.163.com/ubuntu/ wily-security main restricted universe multiversedeb http://mirrors.163.com/ubuntu/ wily-updates main restricted universe multiversedeb http://mirrors.163.com/ubuntu/ wily-proposed main restricted universe multiversedeb http://mirrors.163.com/ubuntu/ wily-backports main restricted universe multiversedeb-src http://mirrors.163.com/ubuntu/ wily main restricted universe multiversedeb-src http://mirrors.163.com/ubuntu/ wily-security main restricted universe multiversedeb-src http://mirrors.163.com/ubuntu/ wily-updates main restricted universe multiversedeb-src http://mirrors.163.com/ubuntu/ wily-proposed main restricted universe multiversedeb-src http://mirrors.163.com/ubuntu/ wily-backports main restricted universe multiverse</code></pre><h1 id="git"><a href="#git" class="headerlink" title="git"></a>git</h1><pre class=" language-shell"><code class="language-shell">git config --global http.proxy 'socks5://127.0.0.1:1080'</code></pre><h3 id="git-设置不用每次输入帐号密码"><a href="#git-设置不用每次输入帐号密码" class="headerlink" title="git 设置不用每次输入帐号密码"></a>git 设置不用每次输入帐号密码</h3><p>执行一下 这个命令：</p><p><code>git config --global credential.helper store</code></p><p>然后，下次再输入一次 账号密码 就可以了。</p><h1 id="pip"><a href="#pip" class="headerlink" title="pip"></a>pip</h1><p><strong>pip国内的一些镜像</strong></p><ul><li>阿里云 <a href="http://mirrors.aliyun.com/pypi/simple/" target="_blank" rel="noopener">http://mirrors.aliyun.com/pypi/simple/</a> </li><li>中国科技大学 <a href="https://pypi.mirrors.ustc.edu.cn/simple/" target="_blank" rel="noopener">https://pypi.mirrors.ustc.edu.cn/simple/</a> </li><li>豆瓣(douban) <a href="http://pypi.douban.com/simple/" target="_blank" rel="noopener">http://pypi.douban.com/simple/</a> </li><li>清华大学 <a href="https://pypi.tuna.tsinghua.edu.cn/simple/" target="_blank" rel="noopener">https://pypi.tuna.tsinghua.edu.cn/simple/</a> </li><li>中国科学技术大学 <a href="http://pypi.mirrors.ustc.edu.cn/simple/" target="_blank" rel="noopener">http://pypi.mirrors.ustc.edu.cn/simple/</a></li></ul><p><strong>修改源方法：</strong></p><p><strong>临时使用：</strong><br>可以在使用pip的时候在后面加上-i参数，指定pip源<br>eg: <code>pip install scrapy -i https://pypi.tuna.tsinghua.edu.cn/simple</code></p><p><strong>永久修改：</strong><br><strong>linux:</strong><br>修改 ~/.pip/pip.conf (没有就创建一个)， 内容如下：</p><pre class=" language-toml"><code class="language-toml">[global]index-url = https://pypi.tuna.tsinghua.edu.cn/simple</code></pre><h1 id="ruby"><a href="#ruby" class="headerlink" title="ruby"></a>ruby</h1><blockquote><p><a href="https://gems.ruby-china.com/" target="_blank" rel="noopener">https://gems.ruby-china.com/</a></p></blockquote><pre class=" language-shell"><code class="language-shell">$ gem update --system # 这里请翻墙一下$ gem -v2.6.3$ gem sources --add https://gems.ruby-china.com/ --remove https://rubygems.org/$ gem sources -l*** CURRENT SOURCES ***https://gems.ruby-china.org# 请确保只有 gems.ruby-china.org$ gem install rails</code></pre><h1 id="docker"><a href="#docker" class="headerlink" title="docker"></a>docker</h1><h2 id="镜像加速"><a href="#镜像加速" class="headerlink" title="镜像加速"></a>镜像加速</h2><p>鉴于国内网络问题，后续拉取 Docker 镜像十分缓慢，我们可以需要配置加速器来解决，我使用的是阿里云的镜像加速器: <a href="https://oj7znbfj.mirror.aliyuncs.com" target="_blank" rel="noopener">https://oj7znbfj.mirror.aliyuncs.com</a></p><p>新版的 <code>Docker</code> 使用 <code>/etc/docker/daemon.json（Linux）</code> 或者 <code>%programdata%\docker\config\daemon.json（Windows）</code> 来配置 <code>Daemon</code>。</p><p>请在该配置文件中加入（没有该文件的话，请先建一个）：</p><pre class=" language-json"><code class="language-json"><span class="token punctuation">{</span>    <span class="token property">"registry-mirrors"</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">"https://oj7znbfj.mirror.aliyuncs.com"</span><span class="token punctuation">]</span><span class="token punctuation">}</span></code></pre><h1 id="npm"><a href="#npm" class="headerlink" title="npm"></a>npm</h1><p>安装node.js后，现在的node.js已经自带了npm工具了，但是国外的源很慢，为了解决这个问题，同时使用cnpm替换npm，我们通过切换源，切换到国内淘宝的源中。下面是我的操作过程。简单记录便于以后自己查看。</p><ol><li><p>查看npm版本</p><pre class=" language-shell"><code class="language-shell">npm -v</code></pre></li><li><p>升级npm版本</p><pre class=" language-shell"><code class="language-shell">npm update</code></pre></li><li><p>查看npm配置</p><pre class=" language-shell"><code class="language-shell">npm config list</code></pre></li><li><p>更换源配置</p><pre class=" language-shell"><code class="language-shell">npm config set registry https://registry.npm.taobao.orgnpm config list / npm config get registery #检查是否替换成功</code></pre></li><li><p>安装cnpm插件</p><pre class=" language-shell"><code class="language-shell">npm install -g cnpm --registry=https://registry.npm.taobao.orgcnpm -v</code></pre></li><li><p>安装包测试</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 实用技能 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> git </tag>
            
            <tag> ruby </tag>
            
            <tag> docker </tag>
            
            <tag> npm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vim使用心得</title>
      <link href="/2019/03/11/vim/"/>
      <url>/2019/03/11/vim/</url>
      
        <content type="html"><![CDATA[<h1 id="vim简介"><a href="#vim简介" class="headerlink" title="vim简介"></a>vim简介</h1><p>Vim是从 vi 发展出来的一个文本编辑器。代码补完、编译及错误跳转等方便编程的功能特别丰富，在程序员中被广泛使用。</p><p>所有的 Unix Like 系统都会内建 vi 文本编辑器，其他的文本编辑器则不一定会存在。</p><p>但是目前我们使用比较多的是 vim 编辑器。</p><p>vim 具有程序编辑的能力，可以主动的以字体颜色辨别语法的正确性，方便程序设计。</p><p>vim主要有以下几个优点.</p><ul><li>可以不使用鼠标，完全用键盘操作。</li><li>系统资源占用小，打开大文件毫无压力。</li><li>键盘命令变成肌肉记忆以后，操作速度极快。</li></ul><p>同时现今很多开源软件(ranger,lazygit)采用的快捷键都与vim类似.学习vim变得很有必要.</p><p>但我这里采用的是<code>neovim</code></p><p><a href="https://neovim.io/" target="_blank" rel="noopener">NeoVim</a> 旨在成为Vim的升级版，有不少对它的介绍，我就不赘述了。NeoVim官网强调了它的四大特点:</p><ul><li>Powerful plugins（强大的插件）</li><li>Better out-of-the-box（更好的开箱即用）</li><li>First-class embedding（高度支持嵌入模式）</li><li>Drop-in replacement for Vim（直接替换Vim）。</li></ul><h2 id="vim基本配置"><a href="#vim基本配置" class="headerlink" title="vim基本配置"></a>vim基本配置</h2><blockquote><p>了解的还不是很详细, 暂时以我自己的配置介绍</p></blockquote><pre class=" language-vim"><code class="language-vim"><span class="token string">""</span><span class="token string">""</span><span class="token string">""</span><span class="token string">""</span><span class="token string">""</span><span class="token string">""</span><span class="token string">""</span><span class="token string">""</span><span class="token string">""</span><span class="token string">""</span><span class="token string">""</span><span class="token string">""</span><span class="token string">""</span><span class="token string">""</span><span class="token string">""</span><span class="token string">""</span><span class="token string">""</span><span class="token string">""</span><span class="token string">""</span><span class="token string">""</span><span class="token string">""</span><span class="token string">""</span><span class="token string">""</span><span class="token string">""</span><span class="token string">""</span><span class="token string">""</span><span class="token string">""</span><span class="token string">""</span><span class="token string">""</span><span class="token string">""</span><span class="token string">""</span><span class="token string">""</span><span class="token string">""</span><span class="token string">""</span><span class="token string">""</span><span class="token string">""</span><span class="token string">""</span><span class="token string">""</span><span class="token string">""</span><span class="token string">""</span><span class="token comment" spellcheck="true">" base config</span><span class="token string">""</span><span class="token string">""</span><span class="token string">""</span><span class="token string">""</span><span class="token string">""</span><span class="token string">""</span><span class="token string">""</span><span class="token string">""</span><span class="token string">""</span><span class="token string">""</span><span class="token string">""</span><span class="token string">""</span><span class="token string">""</span><span class="token string">""</span><span class="token string">""</span><span class="token string">""</span><span class="token string">""</span><span class="token string">""</span><span class="token string">""</span><span class="token string">""</span><span class="token string">""</span><span class="token string">""</span><span class="token string">""</span><span class="token string">""</span><span class="token string">""</span><span class="token string">""</span><span class="token string">""</span><span class="token string">""</span><span class="token string">""</span><span class="token string">""</span><span class="token string">""</span><span class="token string">""</span><span class="token string">""</span><span class="token string">""</span><span class="token string">""</span><span class="token string">""</span><span class="token string">""</span><span class="token string">""</span><span class="token string">""</span><span class="token string">""</span><span class="token keyword">set</span> <span class="token keyword">number</span><span class="token keyword">set</span> termguicolors                                  <span class="token comment" spellcheck="true">" true color</span><span class="token keyword">colorscheme</span> NeoSolarized                           <span class="token comment" spellcheck="true">" scheme</span><span class="token keyword">set</span> <span class="token builtin">background</span><span class="token operator">=</span>dark<span class="token keyword">set</span> <span class="token builtin">encoding</span><span class="token operator">=</span>utf<span class="token operator">-</span><span class="token number">8</span><span class="token comment" spellcheck="true">" 自动折行</span><span class="token keyword">set</span> <span class="token builtin">linebreak</span><span class="token keyword">set</span> <span class="token builtin">nowrap</span><span class="token comment" spellcheck="true">"垂直滚动时，光标距离顶部/底部的位置（单位：行）。</span><span class="token keyword">set</span> <span class="token builtin">scrolloff</span><span class="token operator">=</span><span class="token number">5</span><span class="token comment" spellcheck="true">"set textwidth=80</span><span class="token comment" spellcheck="true">" tabs and spaces handling</span><span class="token keyword">set</span> <span class="token builtin">expandtab</span><span class="token keyword">set</span> <span class="token builtin">tabstop</span><span class="token operator">=</span><span class="token number">4</span><span class="token keyword">set</span> <span class="token builtin">softtabstop</span><span class="token operator">=</span><span class="token number">4</span><span class="token keyword">set</span> <span class="token builtin">shiftwidth</span><span class="token operator">=</span><span class="token number">4</span><span class="token comment" spellcheck="true">" 侦测文件类型</span><span class="token keyword">filetype</span> <span class="token keyword">on</span><span class="token comment" spellcheck="true">" 载入文件类型插件</span><span class="token keyword">filetype</span> plugin <span class="token keyword">on</span><span class="token comment" spellcheck="true">" 为特定文件类型载入相关缩进文件</span><span class="token keyword">filetype</span> indent <span class="token keyword">on</span><span class="token comment" spellcheck="true">" 设置空白字符的视觉提示</span><span class="token keyword">set</span> <span class="token keyword">list</span> <span class="token builtin">listchars</span><span class="token operator">=</span>extends<span class="token punctuation">:</span>❯<span class="token punctuation">,</span>precedes<span class="token punctuation">:</span>❮<span class="token punctuation">,</span><span class="token keyword">tab</span><span class="token punctuation">:</span>▸\ <span class="token punctuation">,</span>trail<span class="token punctuation">:</span>˽<span class="token punctuation">,</span>space<span class="token punctuation">:</span>·<span class="token comment" spellcheck="true">" 高亮当前行列</span><span class="token keyword">set</span> <span class="token builtin">cursorcolumn</span><span class="token keyword">set</span> <span class="token builtin">cursorline</span><span class="token comment" spellcheck="true">" 搜索时忽略大小写。</span><span class="token keyword">set</span> <span class="token builtin">ignorecase</span><span class="token comment" spellcheck="true">" 如果同时打开了ignorecase，那么对于只有一个大写字母的搜索词，将大小写敏感；其他情况都是大小写不敏感。比如，搜索Test时，将不匹配test；搜索test时，将匹配Test。</span><span class="token keyword">set</span> <span class="token builtin">smartcase</span><span class="token comment" spellcheck="true">" 打开英语单词的拼写检查。</span><span class="token keyword">set</span> <span class="token builtin">spell</span> <span class="token builtin">spelllang</span><span class="token operator">=</span>en_us<span class="token comment" spellcheck="true">" 自动切换工作目录。这主要用在一个 Vim 会话之中打开多个文件的情况，默认的工作目录是打开的第一个文件的目录。该配置可以将工作目录自动切换到，正在编辑的文件的目录。</span><span class="token keyword">set</span> <span class="token builtin">autochdir</span><span class="token string">""</span><span class="token string">""</span><span class="token string">""</span><span class="token string">""</span><span class="token string">""</span><span class="token string">""</span><span class="token string">""</span><span class="token string">""</span><span class="token string">""</span><span class="token string">""</span><span class="token string">""</span><span class="token string">""</span><span class="token string">""</span><span class="token string">""</span><span class="token string">""</span><span class="token string">""</span><span class="token string">""</span><span class="token string">""</span><span class="token string">""</span><span class="token string">""</span><span class="token string">""</span><span class="token string">""</span><span class="token string">""</span><span class="token string">""</span><span class="token string">""</span><span class="token string">""</span><span class="token string">""</span><span class="token string">""</span><span class="token string">""</span><span class="token string">""</span><span class="token string">""</span><span class="token string">""</span><span class="token string">""</span><span class="token string">""</span><span class="token string">""</span><span class="token string">""</span><span class="token string">""</span><span class="token string">""</span><span class="token string">""</span><span class="token string">""</span><span class="token comment" spellcheck="true">" keyboard map</span><span class="token string">""</span><span class="token string">""</span><span class="token string">""</span><span class="token string">""</span><span class="token string">""</span><span class="token string">""</span><span class="token string">""</span><span class="token string">""</span><span class="token string">""</span><span class="token string">""</span><span class="token string">""</span><span class="token string">""</span><span class="token string">""</span><span class="token string">""</span><span class="token string">""</span><span class="token string">""</span><span class="token string">""</span><span class="token string">""</span><span class="token string">""</span><span class="token string">""</span><span class="token string">""</span><span class="token string">""</span><span class="token string">""</span><span class="token string">""</span><span class="token string">""</span><span class="token string">""</span><span class="token string">""</span><span class="token string">""</span><span class="token string">""</span><span class="token string">""</span><span class="token string">""</span><span class="token string">""</span><span class="token string">""</span><span class="token string">""</span><span class="token string">""</span><span class="token string">""</span><span class="token string">""</span><span class="token string">""</span><span class="token string">""</span><span class="token string">""</span><span class="token comment" spellcheck="true">" sudo保存</span><span class="token keyword">ca</span> <span class="token keyword">w</span><span class="token operator">!</span><span class="token operator">!</span> <span class="token keyword">w</span> <span class="token operator">!</span>sudo tee <span class="token string">"%"</span> tnoremap <span class="token operator">&lt;</span>ESC<span class="token operator">></span>    <span class="token operator">&lt;</span>C<span class="token operator">-</span>\<span class="token operator">></span><span class="token operator">&lt;</span>C<span class="token operator">-</span><span class="token keyword">n</span><span class="token operator">></span><span class="token comment" spellcheck="true">"去行首空格</span><span class="token comment" spellcheck="true">":%s/^\s\+</span><span class="token comment" spellcheck="true">"去行末空格</span><span class="token comment" spellcheck="true">":%s/\s\+$</span></code></pre><h2 id="vim插件管理器"><a href="#vim插件管理器" class="headerlink" title="vim插件管理器"></a>vim插件管理器</h2><blockquote><p>参考 <a href="https://www.jianshu.com/p/0c83e6aed270" target="_blank" rel="noopener">https://www.jianshu.com/p/0c83e6aed270</a></p><p><strong>每安装一个插件最好都要去github官网看下,顺便看看文档, 会让你安装的插件用起来更顺手.</strong></p></blockquote><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>现在流行的有这几种插件管理器,<code>VBunle</code>,<code>NeoBunle</code>,<code>vim-plug</code>, 我这里采用的是<code>vim-plug</code>.</p><p>neovim下安装命令</p><pre class=" language-shell"><code class="language-shell">curl -fLo ~/.config/nvim/autoload/plug.vim --create-dirs \ https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim</code></pre><p>vim下安装命令</p><pre class=" language-shell"><code class="language-shell">curl -fLo ~/.vim/autoload/plug.vim --create-dirs \ https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim</code></pre><h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><h4 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h4><p>要安装插件，你必须如下所示首先在 Vim 配置文件中声明它们。一般 Vim 的配置文件是 <code>~/.vimrc</code>，Neovim 的配置文件是 <code>~/.config/nvim/init.vim</code>。请记住，当你在配置文件中声明插件时，列表应该以 <code>call plug#begin(PLUGIN_DIRECTORY)</code> 开始，并以 <code>plug#end()</code> 结束。</p><p>例如，我们安装 “lightline.vim” 插件。为此，请在 <code>~/.vimrc</code> 的顶部添加以下行。</p><pre class=" language-typescript"><code class="language-typescript">call plug#<span class="token function">begin</span><span class="token punctuation">(</span><span class="token string">'~/.vim/plugged'</span><span class="token punctuation">)</span>Plug <span class="token string">'itchyny/lightline.vim'</span>call plug#<span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><p>在 vim 配置文件中添加上面的行后，通过输入以下命令重新加载：<br> <code>:source ~/.vimrc</code><br> 或者，只需重新加载 Vim 编辑器。</p><p> 现在，打开 vim 编辑器：<br> <code>$ vim</code><br> 使用以下命令检查状态：<br> <code>:PlugStatus</code><br> 然后输入下面的命令，然后按回车键安装之前在配置文件中声明的插件。<br> <code>:PlugInstall</code></p><h4 id="更新插件"><a href="#更新插件" class="headerlink" title="更新插件"></a>更新插件</h4><p>要更新插件，请运行：</p><pre class=" language-vim"><code class="language-vim"><span class="token punctuation">:</span>PlugUpdate</code></pre><p>更新插件后，按下 <code>d</code> 查看更改。或者，你可以之后输入 <code>:PlugDiff</code>。</p><h4 id="审查插件"><a href="#审查插件" class="headerlink" title="审查插件"></a>审查插件</h4><p>有时，更新的插件可能有新的 bug 或无法正常工作。要解决这个问题，你可以简单地回滚有问题的插件。输入 <code>:PlugDiff</code> 命令，然后按回车键查看上次 <code>:PlugUpdate</code>的更改，并在每个段落上按 <code>X</code> 将每个插件回滚到更新前的前一个状态。</p><h4 id="删除插件"><a href="#删除插件" class="headerlink" title="删除插件"></a>删除插件</h4><p>删除一个插件删除或注释掉你以前在你的 vim 配置文件中添加的 <code>plug</code> 命令。然后，运行 <code>:source ~/.vimrc</code> 或重启 Vim 编辑器。最后，运行以下命令卸载插件：<br> <code>:PlugClean</code></p><p>该命令将删除 vim 配置文件中所有未声明的插件。</p><h4 id="升级-Vim-plug"><a href="#升级-Vim-plug" class="headerlink" title="升级 Vim-plug"></a>升级 Vim-plug</h4><p>要升级vim-plug本身，请输入：<br> <code>:PlugUpgrade</code></p><p>如你所见，使用 Vim-plug 管理插件并不难。它简化了插件管理。现在去找出你最喜欢的插件并使用 Vim-plug 来安装它们。</p><h1 id="安装插件-1"><a href="#安装插件-1" class="headerlink" title="安装插件"></a>安装插件</h1><blockquote><p>插件这个东西,少即是多,运行速度会更快</p></blockquote><h2 id="工具篇"><a href="#工具篇" class="headerlink" title="工具篇"></a>工具篇</h2><h3 id="安装vim中文手册"><a href="#安装vim中文手册" class="headerlink" title="安装vim中文手册"></a>安装<a href="https://github.com/yianwillis/vimcdoc" target="_blank" rel="noopener">vim中文手册</a></h3><p><a href="https://github.com/yianwillis/vimcdoc" target="_blank" rel="noopener">yianwillis/vimcdoc</a></p><p><code>Plug &#39;yianwillis/vimcdoc&#39;</code></p><h3 id="编码优化插件"><a href="#编码优化插件" class="headerlink" title="编码优化插件"></a>编码优化插件</h3><h4 id="代码补全"><a href="#代码补全" class="headerlink" title="代码补全"></a>代码补全</h4><p>vim要有python支持,如果没有需要输入<code>pip install neovim</code>命令安装neovim的python支持模块.</p><p><code>Plug &#39;Valloric/YouCompleteMe&#39;</code></p><p><strong>上面的插件对C++的支持是很强大的但是在麻烦.后来改用<code>deoplete</code>了</strong></p><pre class=" language-typescript"><code class="language-typescript">Plug <span class="token string">'shougo/unite.vim'</span>                            " deoplete依赖Plug <span class="token string">'Shougo/deoplete.nvim'</span>                        " 代码补全Plug <span class="token string">'jiangmiao/auto-pairs'</span>                        " 括号自动补全Plug <span class="token string">'tpope/vim-surround'</span>Plug <span class="token string">'scrooloose/syntastic'</span>                        " 静态代码分析Plug <span class="token string">'neomake/neomake'</span>                             " 语法检查Plug <span class="token string">'mg979/vim-visual-multi'</span>                      " 多光标 </code></pre><h3 id="GitHelp"><a href="#GitHelp" class="headerlink" title="GitHelp"></a>GitHelp</h3><pre class=" language-typescript"><code class="language-typescript">Plug <span class="token string">'tpope/vim-fugitive'</span>                          " git pluginPlug <span class="token string">'airblade/vim-gitgutter'</span>                      "</code></pre><h3 id="文件树"><a href="#文件树" class="headerlink" title="文件树"></a>文件树</h3><blockquote><pre class=" language-typescript"><code class="language-typescript">Plug <span class="token string">'shougo/vimfiler.vim'</span>                         " file explorer 这个项目已经不维护了</code></pre></blockquote><p>现在采用<code>shougo/defx.nvim</code>这个插件</p><pre class=" language-typescript"><code class="language-typescript"><span class="token keyword">if</span> <span class="token function">has</span><span class="token punctuation">(</span><span class="token string">'nvim'</span><span class="token punctuation">)</span>  Plug <span class="token string">'Shougo/defx.nvim'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> <span class="token string">'do'</span><span class="token punctuation">:</span> <span class="token string">':UpdateRemotePlugins'</span> <span class="token punctuation">}</span><span class="token keyword">else</span>  Plug <span class="token string">'Shougo/defx.nvim'</span>  Plug <span class="token string">'roxma/nvim-yarp'</span>  Plug <span class="token string">'roxma/vim-hug-neovim-rpc'</span>endif" 这是defx的两个支持插件Plug <span class="token string">'kristijanhusak/defx-git'</span>Plug <span class="token string">'kristijanhusak/defx-icons'</span></code></pre><p>defx 没有提供默认的键盘映射,所以需要自己进行设置</p><pre class=" language-typescript"><code class="language-typescript">" 这是我的配置<span class="token punctuation">.</span> 参考文档种的配置做的修改<span class="token punctuation">.</span>  还需完善autocmd FileType defx call s<span class="token punctuation">:</span><span class="token function">defx_my_settings</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">function</span><span class="token operator">!</span> s<span class="token punctuation">:</span><span class="token function">defx_my_settings</span><span class="token punctuation">(</span><span class="token punctuation">)</span> abort  setl nonumber  setl norelativenumber  setl listchars<span class="token operator">=</span>  " Define mappings  nnoremap <span class="token operator">&lt;</span>silent<span class="token operator">></span><span class="token operator">&lt;</span>buffer<span class="token operator">></span><span class="token operator">&lt;</span>expr<span class="token operator">></span> <span class="token operator">&lt;</span>CR<span class="token operator">></span>  \ defx#<span class="token function">do_action</span><span class="token punctuation">(</span><span class="token string">'open'</span><span class="token punctuation">)</span>  nnoremap <span class="token operator">&lt;</span>silent<span class="token operator">></span><span class="token operator">&lt;</span>buffer<span class="token operator">></span><span class="token operator">&lt;</span>expr<span class="token operator">></span> c  \ defx#<span class="token function">do_action</span><span class="token punctuation">(</span><span class="token string">'copy'</span><span class="token punctuation">)</span>  nnoremap <span class="token operator">&lt;</span>silent<span class="token operator">></span><span class="token operator">&lt;</span>buffer<span class="token operator">></span><span class="token operator">&lt;</span>expr<span class="token operator">></span> m  \ defx#<span class="token function">do_action</span><span class="token punctuation">(</span><span class="token string">'move'</span><span class="token punctuation">)</span>  nnoremap <span class="token operator">&lt;</span>silent<span class="token operator">></span><span class="token operator">&lt;</span>buffer<span class="token operator">></span><span class="token operator">&lt;</span>expr<span class="token operator">></span> p  \ defx#<span class="token function">do_action</span><span class="token punctuation">(</span><span class="token string">'paste'</span><span class="token punctuation">)</span>  nnoremap <span class="token operator">&lt;</span>silent<span class="token operator">></span><span class="token operator">&lt;</span>buffer<span class="token operator">></span><span class="token operator">&lt;</span>expr<span class="token operator">></span> l  \ defx#<span class="token function">do_action</span><span class="token punctuation">(</span><span class="token string">'open'</span><span class="token punctuation">)</span>  nnoremap <span class="token operator">&lt;</span>silent<span class="token operator">></span><span class="token operator">&lt;</span>buffer<span class="token operator">></span><span class="token operator">&lt;</span>expr<span class="token operator">></span> E  \ defx#<span class="token function">do_action</span><span class="token punctuation">(</span><span class="token string">'open'</span><span class="token punctuation">,</span> <span class="token string">'vsplit'</span><span class="token punctuation">)</span>  nnoremap <span class="token operator">&lt;</span>silent<span class="token operator">></span><span class="token operator">&lt;</span>buffer<span class="token operator">></span><span class="token operator">&lt;</span>expr<span class="token operator">></span> P  \ defx#<span class="token function">do_action</span><span class="token punctuation">(</span><span class="token string">'open'</span><span class="token punctuation">,</span> <span class="token string">'pedit'</span><span class="token punctuation">)</span>"  nnoremap <span class="token operator">&lt;</span>silent<span class="token operator">></span><span class="token operator">&lt;</span>buffer<span class="token operator">></span><span class="token operator">&lt;</span>expr<span class="token operator">></span> l  \ defx#<span class="token function">do_action</span><span class="token punctuation">(</span><span class="token string">'open_or_close_tree'</span><span class="token punctuation">)</span>  nnoremap <span class="token operator">&lt;</span>silent<span class="token operator">></span><span class="token operator">&lt;</span>buffer<span class="token operator">></span><span class="token operator">&lt;</span>expr<span class="token operator">></span> K  \ defx#<span class="token function">do_action</span><span class="token punctuation">(</span><span class="token string">'new_directory'</span><span class="token punctuation">)</span>  nnoremap <span class="token operator">&lt;</span>silent<span class="token operator">></span><span class="token operator">&lt;</span>buffer<span class="token operator">></span><span class="token operator">&lt;</span>expr<span class="token operator">></span> N  \ defx#<span class="token function">do_action</span><span class="token punctuation">(</span><span class="token string">'new_file'</span><span class="token punctuation">)</span>  nnoremap <span class="token operator">&lt;</span>silent<span class="token operator">></span><span class="token operator">&lt;</span>buffer<span class="token operator">></span><span class="token operator">&lt;</span>expr<span class="token operator">></span> M  \ defx#<span class="token function">do_action</span><span class="token punctuation">(</span><span class="token string">'new_multiple_files'</span><span class="token punctuation">)</span>  nnoremap <span class="token operator">&lt;</span>silent<span class="token operator">></span><span class="token operator">&lt;</span>buffer<span class="token operator">></span><span class="token operator">&lt;</span>expr<span class="token operator">></span> C  \ defx#<span class="token function">do_action</span><span class="token punctuation">(</span><span class="token string">'toggle_columns'</span><span class="token punctuation">,</span>  \                <span class="token string">'mark:filename:type:size:time'</span><span class="token punctuation">)</span>  nnoremap <span class="token operator">&lt;</span>silent<span class="token operator">></span><span class="token operator">&lt;</span>buffer<span class="token operator">></span><span class="token operator">&lt;</span>expr<span class="token operator">></span> S  \ defx#<span class="token function">do_action</span><span class="token punctuation">(</span><span class="token string">'toggle_sort'</span><span class="token punctuation">,</span> <span class="token string">'time'</span><span class="token punctuation">)</span>  nnoremap <span class="token operator">&lt;</span>silent<span class="token operator">></span><span class="token operator">&lt;</span>buffer<span class="token operator">></span><span class="token operator">&lt;</span>expr<span class="token operator">></span> d  \ defx#<span class="token function">do_action</span><span class="token punctuation">(</span><span class="token string">'remove'</span><span class="token punctuation">)</span>  nnoremap <span class="token operator">&lt;</span>silent<span class="token operator">></span><span class="token operator">&lt;</span>buffer<span class="token operator">></span><span class="token operator">&lt;</span>expr<span class="token operator">></span> r  \ defx#<span class="token function">do_action</span><span class="token punctuation">(</span><span class="token string">'rename'</span><span class="token punctuation">)</span>  nnoremap <span class="token operator">&lt;</span>silent<span class="token operator">></span><span class="token operator">&lt;</span>buffer<span class="token operator">></span><span class="token operator">&lt;</span>expr<span class="token operator">></span> <span class="token operator">!</span>  \ defx#<span class="token function">do_action</span><span class="token punctuation">(</span><span class="token string">'execute_command'</span><span class="token punctuation">)</span>  nnoremap <span class="token operator">&lt;</span>silent<span class="token operator">></span><span class="token operator">&lt;</span>buffer<span class="token operator">></span><span class="token operator">&lt;</span>expr<span class="token operator">></span> x  \ defx#<span class="token function">do_action</span><span class="token punctuation">(</span><span class="token string">'execute_system'</span><span class="token punctuation">)</span>  nnoremap <span class="token operator">&lt;</span>silent<span class="token operator">></span><span class="token operator">&lt;</span>buffer<span class="token operator">></span><span class="token operator">&lt;</span>expr<span class="token operator">></span> yy  \ defx#<span class="token function">do_action</span><span class="token punctuation">(</span><span class="token string">'yank_path'</span><span class="token punctuation">)</span>  nnoremap <span class="token operator">&lt;</span>silent<span class="token operator">></span><span class="token operator">&lt;</span>buffer<span class="token operator">></span><span class="token operator">&lt;</span>expr<span class="token operator">></span> <span class="token punctuation">.</span>  \ defx#<span class="token function">do_action</span><span class="token punctuation">(</span><span class="token string">'toggle_ignored_files'</span><span class="token punctuation">)</span>  nnoremap <span class="token operator">&lt;</span>silent<span class="token operator">></span><span class="token operator">&lt;</span>buffer<span class="token operator">></span><span class="token operator">&lt;</span>expr<span class="token operator">></span> <span class="token punctuation">;</span>  \ defx#<span class="token function">do_action</span><span class="token punctuation">(</span><span class="token string">'repeat'</span><span class="token punctuation">)</span>  nnoremap <span class="token operator">&lt;</span>silent<span class="token operator">></span><span class="token operator">&lt;</span>buffer<span class="token operator">></span><span class="token operator">&lt;</span>expr<span class="token operator">></span> h  \ defx#<span class="token function">is_opened_tree</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">?</span> defx#<span class="token function">do_action</span><span class="token punctuation">(</span><span class="token string">'close_tree'</span><span class="token punctuation">)</span> <span class="token punctuation">:</span>defx#<span class="token function">do_action</span><span class="token punctuation">(</span><span class="token string">'cd'</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token string">'..'</span><span class="token punctuation">]</span><span class="token punctuation">)</span>  nnoremap <span class="token operator">&lt;</span>silent<span class="token operator">></span><span class="token operator">&lt;</span>buffer<span class="token operator">></span><span class="token operator">&lt;</span>expr<span class="token operator">></span> <span class="token operator">~</span>  \ defx#<span class="token function">do_action</span><span class="token punctuation">(</span><span class="token string">'cd'</span><span class="token punctuation">)</span>  nnoremap <span class="token operator">&lt;</span>silent<span class="token operator">></span><span class="token operator">&lt;</span>buffer<span class="token operator">></span><span class="token operator">&lt;</span>expr<span class="token operator">></span> q  \ defx#<span class="token function">do_action</span><span class="token punctuation">(</span><span class="token string">'quit'</span><span class="token punctuation">)</span>  nnoremap <span class="token operator">&lt;</span>silent<span class="token operator">></span><span class="token operator">&lt;</span>buffer<span class="token operator">></span><span class="token operator">&lt;</span>expr<span class="token operator">></span> <span class="token operator">&lt;</span>Space<span class="token operator">></span>  \ defx#<span class="token function">do_action</span><span class="token punctuation">(</span><span class="token string">'toggle_select'</span><span class="token punctuation">)</span> <span class="token punctuation">.</span> <span class="token string">'j'</span>  nnoremap <span class="token operator">&lt;</span>silent<span class="token operator">></span><span class="token operator">&lt;</span>buffer<span class="token operator">></span><span class="token operator">&lt;</span>expr<span class="token operator">></span> <span class="token operator">*</span>  \ defx#<span class="token function">do_action</span><span class="token punctuation">(</span><span class="token string">'toggle_select_all'</span><span class="token punctuation">)</span>  nnoremap <span class="token operator">&lt;</span>silent<span class="token operator">></span><span class="token operator">&lt;</span>buffer<span class="token operator">></span><span class="token operator">&lt;</span>expr<span class="token operator">></span> j  \ <span class="token function">line</span><span class="token punctuation">(</span><span class="token string">'.'</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token function">line</span><span class="token punctuation">(</span><span class="token string">'$'</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token string">'gg'</span> <span class="token punctuation">:</span> <span class="token string">'j'</span>  nnoremap <span class="token operator">&lt;</span>silent<span class="token operator">></span><span class="token operator">&lt;</span>buffer<span class="token operator">></span><span class="token operator">&lt;</span>expr<span class="token operator">></span> k  \ <span class="token function">line</span><span class="token punctuation">(</span><span class="token string">'.'</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">1</span> <span class="token operator">?</span> <span class="token string">'G'</span> <span class="token punctuation">:</span> <span class="token string">'k'</span>  nnoremap <span class="token operator">&lt;</span>silent<span class="token operator">></span><span class="token operator">&lt;</span>buffer<span class="token operator">></span><span class="token operator">&lt;</span>expr<span class="token operator">></span> <span class="token operator">&lt;</span>C<span class="token operator">-</span>l<span class="token operator">></span>  \ defx#<span class="token function">do_action</span><span class="token punctuation">(</span><span class="token string">'redraw'</span><span class="token punctuation">)</span>  nnoremap <span class="token operator">&lt;</span>silent<span class="token operator">></span><span class="token operator">&lt;</span>buffer<span class="token operator">></span><span class="token operator">&lt;</span>expr<span class="token operator">></span> <span class="token operator">&lt;</span>C<span class="token operator">-</span>g<span class="token operator">></span>  \ defx#<span class="token function">do_action</span><span class="token punctuation">(</span><span class="token string">'print'</span><span class="token punctuation">)</span>  nnoremap <span class="token operator">&lt;</span>silent<span class="token operator">></span><span class="token operator">&lt;</span>buffer<span class="token operator">></span><span class="token operator">&lt;</span>expr<span class="token operator">></span> cd  \ defx#<span class="token function">do_action</span><span class="token punctuation">(</span><span class="token string">'change_vim_cwd'</span><span class="token punctuation">)</span>endfunction</code></pre><h3 id="语法树"><a href="#语法树" class="headerlink" title="语法树"></a>语法树</h3><pre class=" language-typescript"><code class="language-typescript">Plug <span class="token string">'majutsushi/tagbar'</span>                           "浏览tag    </code></pre><h2 id="美化篇"><a href="#美化篇" class="headerlink" title="美化篇"></a><strong>美化篇</strong></h2><h3 id="安装开始界面插件"><a href="#安装开始界面插件" class="headerlink" title="安装开始界面插件"></a>安装开始界面插件</h3><pre class=" language-typescript"><code class="language-typescript">Plug <span class="token string">'mhinz/vim-startify'</span>                              "start page</code></pre><h3 id="安装主题"><a href="#安装主题" class="headerlink" title="安装主题"></a>安装主题</h3><p><code>Plug &#39;icymind/NeoSolarized&#39;                 &quot;主题</code></p><h3 id="安装状态栏插件"><a href="#安装状态栏插件" class="headerlink" title="安装状态栏插件"></a>安装状态栏插件</h3><p>状态栏能显示当前的状态，还是有不少用处的，好看的状态栏就是为了美观，毕竟谁也不喜欢对着个难看的东西吧。<br> 　　这里使用的是 <a href="https://link.jianshu.com?t=https%3A%2F%2Fgithub.com%2Fvim-airline%2Fvim-airline" target="_blank" rel="noopener">airline </a>：</p><pre class=" language-typescript"><code class="language-typescript">Plug <span class="token string">'vim-airline/vim-airline'</span>                     "状态栏工具    Plug <span class="token string">'vim-airline/vim-airline-themes'</span>              "状态栏主题    </code></pre><pre class=" language-typescript"><code class="language-typescript"><span class="token string">""</span><span class="token string">""</span><span class="token string">""</span><span class="token string">""</span><span class="token string">""</span><span class="token string">""</span><span class="token string">""</span><span class="token string">""</span><span class="token string">""</span><span class="token string">""</span><span class="token string">""</span><span class="token string">""</span><span class="token string">""</span><span class="token string">""</span><span class="token string">""</span><span class="token string">""</span><span class="token string">""</span><span class="token string">""</span><span class="token string">""</span><span class="token string">""</span><span class="token string">""</span><span class="token string">""</span><span class="token string">""</span><span class="token string">""</span><span class="token string">""</span><span class="token string">""</span><span class="token string">""</span><span class="token string">""</span><span class="token string">""</span><span class="token string">""</span><span class="token string">""</span><span class="token string">""</span><span class="token string">""</span><span class="token string">""</span><span class="token string">""</span><span class="token string">""</span><span class="token string">""</span><span class="token string">""</span><span class="token string">""</span><span class="token string">""</span>" Airline config<span class="token string">""</span><span class="token string">""</span><span class="token string">""</span><span class="token string">""</span><span class="token string">""</span><span class="token string">""</span><span class="token string">""</span><span class="token string">""</span><span class="token string">""</span><span class="token string">""</span><span class="token string">""</span><span class="token string">""</span><span class="token string">""</span><span class="token string">""</span><span class="token string">""</span><span class="token string">""</span><span class="token string">""</span><span class="token string">""</span><span class="token string">""</span><span class="token string">""</span><span class="token string">""</span><span class="token string">""</span><span class="token string">""</span><span class="token string">""</span><span class="token string">""</span><span class="token string">""</span><span class="token string">""</span><span class="token string">""</span><span class="token string">""</span><span class="token string">""</span><span class="token string">""</span><span class="token string">""</span><span class="token string">""</span><span class="token string">""</span><span class="token string">""</span><span class="token string">""</span><span class="token string">""</span><span class="token string">""</span><span class="token string">""</span><span class="token string">""</span><span class="token keyword">let</span> g<span class="token punctuation">:</span>airline_powerline_fonts <span class="token operator">=</span> <span class="token number">0</span><span class="token keyword">let</span> g<span class="token punctuation">:</span>airline_theme <span class="token operator">=</span> <span class="token string">'bubblegum'</span><span class="token keyword">let</span> g<span class="token punctuation">:</span>airline#extensions#whitespace#enabled <span class="token operator">=</span> <span class="token number">0</span>" to use fancy symbols <span class="token keyword">for</span> airline<span class="token punctuation">,</span> uncomment the following lines and use a" patched font <span class="token punctuation">(</span>more info on the README<span class="token punctuation">.</span>rst<span class="token punctuation">)</span><span class="token keyword">if</span> <span class="token operator">!</span><span class="token function">exists</span><span class="token punctuation">(</span><span class="token string">'g:airline_symbols'</span><span class="token punctuation">)</span>   <span class="token keyword">let</span> g<span class="token punctuation">:</span>airline_symbols <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>endif<span class="token keyword">let</span> g<span class="token punctuation">:</span>airline_left_sep <span class="token operator">=</span> <span class="token string">'⮀'</span><span class="token keyword">let</span> g<span class="token punctuation">:</span>airline_left_alt_sep <span class="token operator">=</span> <span class="token string">'⮁'</span><span class="token keyword">let</span> g<span class="token punctuation">:</span>airline_right_sep <span class="token operator">=</span> <span class="token string">'⮂'</span><span class="token keyword">let</span> g<span class="token punctuation">:</span>airline_right_alt_sep <span class="token operator">=</span> <span class="token string">'⮃'</span><span class="token keyword">let</span> g<span class="token punctuation">:</span>airline_symbols<span class="token punctuation">.</span>branch <span class="token operator">=</span> <span class="token string">'⭠'</span><span class="token keyword">let</span> g<span class="token punctuation">:</span>airline_symbols<span class="token punctuation">.</span>readonly <span class="token operator">=</span> <span class="token string">'⭤'</span><span class="token keyword">let</span> g<span class="token punctuation">:</span>airline_symbols<span class="token punctuation">.</span>linenr <span class="token operator">=</span> <span class="token string">'⭡'</span><span class="token keyword">let</span> g<span class="token punctuation">:</span>airline#extensions#tabline#enabled <span class="token operator">=</span> <span class="token number">1</span><span class="token keyword">let</span> g<span class="token punctuation">:</span>airline#extensions#tabline#show_tabs <span class="token operator">=</span> <span class="token number">1</span><span class="token keyword">let</span> g<span class="token punctuation">:</span>airline#extensions#tabline#left_sep <span class="token operator">=</span> <span class="token string">'⮀'</span><span class="token keyword">let</span> g<span class="token punctuation">:</span>airline#extensions#tabline#left_alt_sep <span class="token operator">=</span> <span class="token string">'⮁'</span><span class="token keyword">let</span> g<span class="token punctuation">:</span>airline#extensions#tabline#right_sep <span class="token operator">=</span> <span class="token string">'⮂'</span><span class="token keyword">let</span> g<span class="token punctuation">:</span>airline#extensions#tabline#right_alt_sep <span class="token operator">=</span> <span class="token string">'⮃'</span></code></pre><hr><p>这是我自己的neovim配置</p><p><a href="https://github.com/tabris233/config/blob/master/neovim/init.vim" target="_blank" rel="noopener">https://github.com/tabris233/config/blob/master/neovim/init.vim</a></p>]]></content>
      
      
      <categories>
          
          <category> 实用技能 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> editor </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>StudyDocker</title>
      <link href="/2019/01/10/studydocker/"/>
      <url>/2019/01/10/studydocker/</url>
      
        <content type="html"><![CDATA[<p>操作环境: Arch &amp; manjaro </p><p>docker命令行管理工具使用的<code>dockly</code> 但仍然有缺陷,以后再找找 有没有其他更好用的命令行工具.</p><p>教程先看了一遍 <a href="https://www.bilibili.com/video/av27122140" target="_blank" rel="noopener">B站的尚硅谷教程</a> 有些av号的顺序不对.  看这个就行了.</p><p>tabris’s 阿里云镜像加速器: <a href="https://oj7znbfj.mirror.aliyuncs.com" target="_blank" rel="noopener">https://oj7znbfj.mirror.aliyuncs.com</a></p><h1 id="安装篇"><a href="#安装篇" class="headerlink" title="安装篇"></a>安装篇</h1><p>命令安装<code>docker</code>本体</p><pre class=" language-shell"><code class="language-shell">sudo pacman -S docker</code></pre><blockquote><p>同时建议安装<code>dockly</code>作为docker的命令行管理软件.</p><p><a href="https://www.npmjs.com/package/dockly" target="_blank" rel="noopener">https://www.npmjs.com/package/dockly</a></p></blockquote><p>非root用户运行docker是执行如下命令</p><pre class=" language-shell"><code class="language-shell">sudo usermod -aG docker $USER #your usrname</code></pre><p>执行如下命令启动docker服务</p><pre class=" language-shell"><code class="language-shell">systemctl enable docker  systemctl start docker</code></pre><h2 id="镜像加速"><a href="#镜像加速" class="headerlink" title="镜像加速"></a>镜像加速</h2><p>鉴于国内网络问题，后续拉取 Docker 镜像十分缓慢，我们可以需要配置加速器来解决，我使用的是阿里云的镜像加速器: <a href="https://oj7znbfj.mirror.aliyuncs.com" target="_blank" rel="noopener">https://oj7znbfj.mirror.aliyuncs.com</a></p><p>新版的 <code>Docker</code> 使用 <code>/etc/docker/daemon.json（Linux）</code> 或者 <code>%programdata%\docker\config\daemon.json（Windows）</code> 来配置 <code>Daemon</code>。</p><p>请在该配置文件中加入（没有该文件的话，请先建一个）：</p><pre class=" language-json"><code class="language-json"><span class="token punctuation">{</span>    <span class="token property">"registry-mirrors"</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">"https://oj7znbfj.mirror.aliyuncs.com"</span><span class="token punctuation">]</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 实用技能 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
            <tag> Linux </tag>
            
            <tag> 虚拟化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>InternshipSummary</title>
      <link href="/2018/12/01/internshipsummary/"/>
      <url>/2018/12/01/internshipsummary/</url>
      
        <content type="html"><![CDATA[<h2 id="Internship-Summary"><a href="#Internship-Summary" class="headerlink" title="Internship Summary"></a>Internship Summary</h2><blockquote><p>this is the summary for my six month internship. </p><p>2018-05-24~</p></blockquote><h3 id="干了什么"><a href="#干了什么" class="headerlink" title="干了什么"></a>干了什么</h3><p><code>5月24日</code>入职.</p><p>半个月后开始参与<strong>商户联调</strong>.</p><p><code>6月22号</code>接到<strong>手机号同步脚本</strong>的需求,<code>7月11号</code>上线</p><ul><li>开发用时其实只有两天. 后面进行的是漫长的发布流程,公司内开发工具不熟悉.同时测试也是一个实习生,卡住了几天.</li></ul><p>同时接到<strong>自动化用例server</strong>需求</p><p><code>8月5号</code>正式方案评审结束</p><p><code>8月10号</code>正式开发完,后一直等待测试侧的开发</p><p><code>8月17号</code>左右接到<strong>商户迁移对账脚本</strong>的需求 <code>8月24号</code>开发完毕,但后期有优化</p><ul><li>这个做的就太慢了, 6张表整不明白了 当然也和python语言有些关系,语言基础不够</li></ul><p><code>8月底</code>开始部署自动化测试用例,陆续到9月中旬正式运行.</p><p><code>8月底</code>接到QA的<strong>商户监控报表</strong>需求,开始采取<code>监控平台报表定制</code>,但不能查到商户名称,无奈改成python脚本.</p><ul><li>开发上线还是有问题.  分布式调度平台无法调用.</li></ul><p><code>9月10号</code>左右接到<strong>深铁预测提取脚本</strong>需求, <code>9月18号</code>会议结束,<code>9月25号</code>脚本开发完毕,等征信侧部署ditto.</p><blockquote><p>这时候基本没有商户联调的工作了</p></blockquote><p><code>9月14号</code>接到<strong>客服系统优化</strong>需求,<code>9月底</code>前端功能点部分优化结束.然后开始挂起.</p><ul><li>前端都不会,现学现卖,做的很慢,</li></ul><blockquote><p><del><code>9月底</code>接到薪资offer,心态崩.此事不谈</del></p></blockquote><p><code>10月中旬</code>开始在做后台部分的修改方案</p><blockquote><p>当时考虑的是2.0的兼容,但是沟通问题,导致没有理解到位</p></blockquote><p><code>10月中旬</code>接到<strong>自动化用例的优化</strong>小需求,工时较短,但由于依赖服务还在测试阶段 没有提发.</p><blockquote><p>测试结束后突然又加了个优化点..</p></blockquote><p><code>10月中旬</code>接到<strong>行业数据预拉取</strong>需求 ,于<code>10月17日</code>方案评审 ,<code>10月25日正式开始编码</code>,<code>10月26日</code>提code review,<code>10月27日</code>提测, <code>11月5日</code>评审了代码,同日排上测试,<code>11月9日</code>测完,<code>11月12日</code>发布.</p><blockquote><p>接到需求时 客服系统需求挂起 快结束时继续开发</p><p>并发程序开发经验匮乏.</p><p>同时出现shell脚本 ‘\r\n’和’\n’ 的问题</p><p>bug超多,</p></blockquote><p><code>10月中旬后期</code>征信侧部署结束,开始联调,后发布</p><p><code>10月底,11月初</code>接到<strong>自动化用例改造</strong>需求,<code>11月13日</code>完成开发,次日联调</p><blockquote><p>cgi,server 改造,基本是从其他模块复用代码,难度不大,但cgi首次开发,进度较慢,</p><p><strong>但是写在方案上的点竟然有遗漏,用户白名单没有配置????</strong></p><p>同事周5前端换人,进度延期</p><p>之前代码仓库申请的是我的git目录下 发布的时候发现不行</p><p><code>11月15日</code>申请正式代码库,被要求用新框架开发cgi,尝试改造,<strong>半天工</strong>后,发现框架改动较大,依赖非常不好改,遂放弃,依旧沿用老框架.</p></blockquote><p><code>11月15,16日</code>完成<strong>客服系统</strong>的前后端开发</p><blockquote><p>前端的分支目录未知, 还没有把代码提交到分支上.</p><p>后面验证下就可以发布了</p></blockquote><p><code>11月17,20~24日</code>,<strong>自动化用例</strong>与前端联调,同时接到<strong>广告/活动/红点查询链路优化需求</strong></p><blockquote><p>前端临时换人, 导致了很多坑,本预计17号收尾的,延误一个多星期.</p><p>联调过程,虽然是开发环境缺少数据等因素耽搁了时间.同时前端工作交接出现问题,前端代码中的一处修改/一处打桩,导致两个调了很久的问题.但主要还是我的经验不足,一来导致不管是前端还是导师/leader都觉得是我的问题…….</p><p>没有对前后端参数进行仔细的对比,,,对基础工具(apache)的使用不熟练.造成时间上的严重浪费.</p></blockquote><h3 id="学习了什么"><a href="#学习了什么" class="headerlink" title="学习了什么"></a>学习了什么</h3><p>很多,</p><blockquote><p>点比较杂,一些零散经验性的东西,很难列出.</p></blockquote><ul><li>linux的使用</li><li>开发工具的使用</li><li>应该注意的问题</li><li>对架构有了点了解</li></ul><h3 id="现在的问题"><a href="#现在的问题" class="headerlink" title="现在的问题"></a>现在的问题</h3><blockquote><p> 能力问题还是经验问题?</p></blockquote><p>经验问题是一定存在的. </p><ul><li>内部工具掌握的不够</li><li>开发经验的不足</li><li>项目系统不够了解,</li></ul><p>能力问题</p><ul><li>问题定位的速度慢</li><li>头铁,</li><li>基础<strong>不</strong>扎实</li></ul>]]></content>
      
      
      <categories>
          
          <category> 工作 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 实习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式</title>
      <link href="/2018/11/18/designpattern/"/>
      <url>/2018/11/18/designpattern/</url>
      
        <content type="html"><![CDATA[<blockquote><p>学习下设计模式</p><p>参考<a href="http://www.runoob.com/" target="_blank" rel="noopener">菜鸟教程</a></p><p>但其实菜鸟教程介绍的比较简略,还是要参考下其他</p></blockquote><h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><h2 id="设计模式的六大原则"><a href="#设计模式的六大原则" class="headerlink" title="设计模式的六大原则"></a>设计模式的六大原则</h2><p><strong>1、开闭原则（Open Close Principle）</strong></p><p>开闭原则的意思是：<strong>对扩展开放，对修改关闭</strong>。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。简言之，是为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类，后面的具体设计中我们会提到这点。</p><p><strong>2、里氏代换原则（Liskov Substitution Principle）</strong></p><p>里氏代换原则是面向对象设计的基本原则之一。 里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。LSP 是继承复用的基石，只有当派生类可以替换掉基类，且软件单位的功能不受到影响时，基类才能真正被复用，而派生类也能够在基类的基础上增加新的行为。里氏代换原则是对开闭原则的补充。实现开闭原则的关键步骤就是抽象化，而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。</p><p><strong>3、依赖倒转原则（Dependence Inversion Principle）</strong></p><p>这个原则是开闭原则的基础，具体内容：针对接口编程，依赖于抽象而不依赖于具体。</p><p><strong>4、接口隔离原则（Interface Segregation Principle）</strong></p><p>这个原则的意思是：使用多个隔离的接口，比使用单个接口要好。它还有另外一个意思是：降低类之间的耦合度。由此可见，其实设计模式就是从大型软件架构出发、便于升级和维护的软件设计思想，它强调降低依赖，降低耦合。</p><p><strong>5、迪米特法则，又称最少知道原则（Demeter Principle）</strong></p><p>最少知道原则是指：一个实体应当尽量少地与其他实体之间发生相互作用，使得系统功能模块相对独立。</p><p><strong>6、合成复用原则（Composite Reuse Principle）</strong></p><p>合成复用原则是指：尽量使用合成/聚合的方式，而不是使用继承。</p><h2 id="创建型模式"><a href="#创建型模式" class="headerlink" title="创建型模式"></a>创建型模式</h2><blockquote><p>这些设计模式提供了一种在创建对象的同时隐藏创建逻辑的方式，而不是使用 new 运算符直接实例化对象。这使得程序在判断针对某个给定实例需要创建哪些对象时更加灵活。</p></blockquote><h3 id="工厂模式（Factory-Pattern）"><a href="#工厂模式（Factory-Pattern）" class="headerlink" title="工厂模式（Factory Pattern）"></a>工厂模式（Factory Pattern）</h3><p><a href="https://blog.csdn.net/silangquan/article/details/20492293" target="_blank" rel="noopener">C++实现参考 &lt;- 特别赞</a></p><h3 id="抽象工厂模式（Abstract-Factory-Pattern）"><a href="#抽象工厂模式（Abstract-Factory-Pattern）" class="headerlink" title="抽象工厂模式（Abstract Factory Pattern）"></a>抽象工厂模式（Abstract Factory Pattern）</h3><h3 id="单例模式（Singleton-Pattern）"><a href="#单例模式（Singleton-Pattern）" class="headerlink" title="单例模式（Singleton Pattern）"></a>单例模式（Singleton Pattern）</h3><h3 id="建造者模式（Builder-Pattern）"><a href="#建造者模式（Builder-Pattern）" class="headerlink" title="建造者模式（Builder Pattern）"></a>建造者模式（Builder Pattern）</h3><h3 id="原型模式（Prototype-Pattern）"><a href="#原型模式（Prototype-Pattern）" class="headerlink" title="原型模式（Prototype Pattern）"></a>原型模式（Prototype Pattern）</h3><h2 id="结构型模式"><a href="#结构型模式" class="headerlink" title="结构型模式"></a><strong>结构型模式</strong></h2><blockquote><p>这些设计模式关注类和对象的组合。继承的概念被用来组合接口和定义组合对象获得新功能的方式。</p></blockquote><h3 id="适配器模式（Adapter-Pattern）"><a href="#适配器模式（Adapter-Pattern）" class="headerlink" title="适配器模式（Adapter Pattern）"></a>适配器模式（Adapter Pattern）</h3><h3 id="桥接模式（Bridge-Pattern）"><a href="#桥接模式（Bridge-Pattern）" class="headerlink" title="桥接模式（Bridge Pattern）"></a>桥接模式（Bridge Pattern）</h3><h3 id="过滤器模式（Filter、Criteria-Pattern）"><a href="#过滤器模式（Filter、Criteria-Pattern）" class="headerlink" title="过滤器模式（Filter、Criteria Pattern）"></a>过滤器模式（Filter、Criteria Pattern）</h3><h3 id="组合模式（Composite-Pattern）"><a href="#组合模式（Composite-Pattern）" class="headerlink" title="组合模式（Composite Pattern）"></a>组合模式（Composite Pattern）</h3><h3 id="装饰器模式（Decorator-Pattern）"><a href="#装饰器模式（Decorator-Pattern）" class="headerlink" title="装饰器模式（Decorator Pattern）"></a>装饰器模式（Decorator Pattern）</h3><h3 id="外观模式（Facade-Pattern）"><a href="#外观模式（Facade-Pattern）" class="headerlink" title="外观模式（Facade Pattern）"></a>外观模式（Facade Pattern）</h3><h3 id="享元模式（Flyweight-Pattern）"><a href="#享元模式（Flyweight-Pattern）" class="headerlink" title="享元模式（Flyweight Pattern）"></a>享元模式（Flyweight Pattern）</h3><h3 id="代理模式（Proxy-Pattern）"><a href="#代理模式（Proxy-Pattern）" class="headerlink" title="代理模式（Proxy Pattern）"></a>代理模式（Proxy Pattern）</h3><h2 id="行为型模式"><a href="#行为型模式" class="headerlink" title="行为型模式"></a><strong>行为型模式</strong></h2><h3 id="责任链模式（Chain-of-Responsibility-Pattern）"><a href="#责任链模式（Chain-of-Responsibility-Pattern）" class="headerlink" title="责任链模式（Chain of Responsibility Pattern）"></a>责任链模式（Chain of Responsibility Pattern）</h3><h3 id="命令模式（Command-Pattern）"><a href="#命令模式（Command-Pattern）" class="headerlink" title="命令模式（Command Pattern）"></a>命令模式（Command Pattern）</h3><h3 id="解释器模式（Interpreter-Pattern）"><a href="#解释器模式（Interpreter-Pattern）" class="headerlink" title="解释器模式（Interpreter Pattern）"></a>解释器模式（Interpreter Pattern）</h3><h3 id="迭代器模式（Iterator-Pattern）"><a href="#迭代器模式（Iterator-Pattern）" class="headerlink" title="迭代器模式（Iterator Pattern）"></a>迭代器模式（Iterator Pattern）</h3><h3 id="中介者模式（Mediator-Pattern）"><a href="#中介者模式（Mediator-Pattern）" class="headerlink" title="中介者模式（Mediator Pattern）"></a>中介者模式（Mediator Pattern）</h3><h3 id="备忘录模式（Memento-Pattern）"><a href="#备忘录模式（Memento-Pattern）" class="headerlink" title="备忘录模式（Memento Pattern）"></a>备忘录模式（Memento Pattern）</h3><h3 id="观察者模式（Observer-Pattern）"><a href="#观察者模式（Observer-Pattern）" class="headerlink" title="观察者模式（Observer Pattern）"></a>观察者模式（Observer Pattern）</h3><h3 id="状态模式（State-Pattern）"><a href="#状态模式（State-Pattern）" class="headerlink" title="状态模式（State Pattern）"></a>状态模式（State Pattern）</h3><h3 id="空对象模式（Null-Object-Pattern）"><a href="#空对象模式（Null-Object-Pattern）" class="headerlink" title="空对象模式（Null Object Pattern）"></a>空对象模式（Null Object Pattern）</h3><h3 id="策略模式（Strategy-Pattern）"><a href="#策略模式（Strategy-Pattern）" class="headerlink" title="策略模式（Strategy Pattern）"></a>策略模式（Strategy Pattern）</h3><h3 id="模板模式（Template-Pattern）"><a href="#模板模式（Template-Pattern）" class="headerlink" title="模板模式（Template Pattern）"></a>模板模式（Template Pattern）</h3><h3 id="访问者模式（Visitor-Pattern）"><a href="#访问者模式（Visitor-Pattern）" class="headerlink" title="访问者模式（Visitor Pattern）"></a>访问者模式（Visitor Pattern）</h3>]]></content>
      
      
      <categories>
          
          <category> 软工 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>工厂模式.</title>
      <link href="/2018/11/18/productpattern/"/>
      <url>/2018/11/18/productpattern/</url>
      
        <content type="html"><![CDATA[<p><a href="http://www.runoob.com/design-pattern/abstract-factory-pattern.html" target="_blank" rel="noopener">http://www.runoob.com/design-pattern/abstract-factory-pattern.html</a></p><p>下面例子中鼠标，键盘，耳麦为产品，惠普，戴尔为工厂。</p><h3 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h3><p>简单工厂模式不是 23 种里的一种，简而言之，就是有一个专门生产某个产品的类。</p><p>比如下图中的鼠标工厂，专业生产鼠标，给参数 0，生产戴尔鼠标，给参数 1，生产惠普鼠标。</p><h3 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h3><p>工厂模式也就是鼠标工厂是个父类，有生产鼠标这个接口。</p><p>戴尔鼠标工厂，惠普鼠标工厂继承它，可以分别生产戴尔鼠标，惠普鼠标。</p><p>生产哪种鼠标不再由参数决定，而是创建鼠标工厂时，由戴尔鼠标工厂创建。</p><p>后续直接调用鼠标工厂.生产鼠标()即可</p><h3 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h3><p>抽象工厂模式也就是不仅生产鼠标，同时生产键盘。</p><p>也就是 PC 厂商是个父类，有生产鼠标，生产键盘两个接口。</p><p>戴尔工厂，惠普工厂继承它，可以分别生产戴尔鼠标+戴尔键盘，和惠普鼠标+惠普键盘。</p><p>创建工厂时，由戴尔工厂创建。</p><p>后续工厂.生产鼠标()则生产戴尔鼠标，工厂.生产键盘()则生产戴尔键盘。</p><blockquote><p>在抽象工厂模式中，假设我们需要增加一个工厂</p></blockquote><p>假设我们增加华硕工厂，则我们需要增加华硕工厂，和戴尔工厂一样，继承 PC 厂商。</p><p>之后创建华硕鼠标，继承鼠标类。创建华硕键盘，继承键盘类即可。</p><blockquote><p>在抽象工厂模式中，假设我们需要增加一个产品</p></blockquote><p>假设我们增加耳麦这个产品，则首先我们需要增加耳麦这个父类，再加上戴尔耳麦，惠普耳麦这两个子类。</p><p>之后在PC厂商这个父类中，增加生产耳麦的接口。最后在戴尔工厂，惠普工厂这两个类中，分别实现生产戴尔耳麦，惠普耳麦的功能。 以上。</p>]]></content>
      
      
      <categories>
          
          <category> 软工 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>StudyLinux----arch</title>
      <link href="/2018/09/23/studylinux-arch/"/>
      <url>/2018/09/23/studylinux-arch/</url>
      
        <content type="html"><![CDATA[<blockquote><p>manjaro 真好用 arch 再见!</p><p>推荐manjaro-deepin 对中文的支持比较好</p><p>桌面环境真的是个大坑啊   </p><p>现在觉得折腾确实挺有趣的, 但以后有机会还是配一个mbp吧, linux的桌面环境是真的烦人..aur和完善的桌面环境感觉还是后者比较重要.</p><p>争取能做出来一个安装+部署配置的脚本</p></blockquote><h1 id="Arch-踩坑笔记"><a href="#Arch-踩坑笔记" class="headerlink" title="Arch 踩坑笔记"></a>Arch 踩坑笔记</h1><blockquote><p>记录一下从0开始玩linux的经历</p><p>其实之前已经有了一点ubuntu的使用经验 但是很浅</p><p>Arch 作为’最难’安装的linux系统  通过它可以更好的了解linux</p><p>这里是VMware安装的Arch虚拟机<br><a href="https://blog.csdn.net/u011054333/article/details/50631599" target="_blank" rel="noopener">配置和美化Arch Linux</a></p></blockquote><h2 id="安装"><a href="#安装" class="headerlink" title="安装:"></a>安装:</h2><p>这里参考</p><blockquote><p> <strong>注意引导方式建议使用rEFInd 代替教程里采用的grub</strong></p><p><a href="https://www.viseator.com/2017/05/17/arch_install/" target="_blank" rel="noopener">这是最全面的安装指南</a></p></blockquote><p>如果进入不了<code>[root@archiso ]</code> 是物理机安装时 u盘的卷标不是`ARCH_20XXYY</p><h3 id="基础设置"><a href="#基础设置" class="headerlink" title="基础设置:"></a>基础设置:</h3><h4 id="创建新用户"><a href="#创建新用户" class="headerlink" title="创建新用户"></a>创建新用户</h4><pre><code># useradd -m -G wheel &lt;username&gt; （请自行替换username为你的用户名）# passwd &lt;username&gt; （请自行替换username为你的用户名）</code></pre><h4 id="开机自动联网"><a href="#开机自动联网" class="headerlink" title="开机自动联网"></a>开机自动联网</h4><pre class=" language-shell"><code class="language-shell"># systemctl enable dhcpcd</code></pre><h4 id="网络工具"><a href="#网络工具" class="headerlink" title="网络工具"></a>网络工具</h4><pre class=" language-shell"><code class="language-shell"># pacman -Syy net-tools</code></pre><h4 id="时间"><a href="#时间" class="headerlink" title="时间"></a>时间</h4><p>装完archlinux，因为时区的问题，时间总是比实际快了8个小时，找了各种办法，最终使用了openNTPD的方法</p><p>设置时区：<code>sudo ln sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime</code></p><p>安装openNTPD：<code>sudo pacman -S openntpd</code></p><p>重启openNTPD：<code>systemctl restart openntpd</code></p><p>设置开机启动：<code>systemctl enable openntpd</code></p><h4 id="ssh"><a href="#ssh" class="headerlink" title="ssh"></a>ssh</h4><p>安装ssh</p><pre><code># pacman -Syy openssh</code></pre><p>启动服务</p><pre><code># systemctl start sshd</code></pre><p>开机启动</p><pre><code># systemctl enable sshd.service</code></pre><h4 id="启用中国源"><a href="#启用中国源" class="headerlink" title="启用中国源"></a>启用中国源</h4><pre class=" language-shell"><code class="language-shell">sudo pacman-mirrors -c China</code></pre><h4 id="添加archlinuxcn源"><a href="#添加archlinuxcn源" class="headerlink" title="添加archlinuxcn源"></a>添加archlinuxcn源</h4><p>archlinuxcn源至您的 /etc/pacman.conf</p><pre class=" language-toml"><code class="language-toml">[archlinuxcn]#The Chinese Arch Linux communities packages.SigLevel = Optional TrustAllServer = https://mirrors.ustc.edu.cn/archlinuxcn/$arch</code></pre><h4 id="aur助手"><a href="#aur助手" class="headerlink" title="aur助手"></a>aur助手</h4><p><a href="https://github.com/Jguer/yay" target="_blank" rel="noopener">yay</a> 是下一个最好的 AUR 助手。它使用 Go 语言写成，宗旨是提供最少化用户输入的 <code>pacman</code> 界面、yaourt 式的搜索，而几乎没有任何依赖软件。</p><p>yay 的特性：</p><ul><li><code>yay</code> 提供 AUR 表格补全，并且从 ABS 或 AUR 下载 PKGBUILD</li><li>支持收窄搜索，并且不需要引用 PKGBUILD 源</li><li><code>yay</code> 的二进制文件除了 <code>pacman</code> 以外别无依赖</li><li>提供先进的包依赖解决方案，以及在编译安装之后移除编译时的依赖</li><li>当在 <code>/etc/pacman.conf</code> 文件配置中启用了色彩时支持色彩输出</li><li><code>yay</code> 可被配置成只支持 AUR 或者 repo 里的软件包</li></ul><p>安装 yay：</p><blockquote><p><strong>现在yay已经添加到官方源中</strong></p><p><strong><code>sudo pacman -S yay</code>即可安装</strong></p></blockquote><p>当然你还可以从 <code>git</code> 克隆并编译安装。</p><pre><code>git clone https://aur.archlinux.org/yay.gitcd yaymakepkg -si</code></pre><p>使用 yay：</p><p>搜索：</p><pre><code>yay -Ss &lt;package-name&gt;</code></pre><p>安装：</p><pre><code>yay -S &lt;package-name&gt;</code></pre><h4 id="powerline"><a href="#powerline" class="headerlink" title="powerline"></a>powerline</h4><p>Powerline 是 vim、zsh、bash、tmux、IPython、Awesome、bar、fish、lemonbar、pdb、rc、shell、tcsh、wm、i3 和 Qtil 中的一个状态栏插件。它给程序提供了状态栏，并使程序更好看。它用 Python 写成。</p><h4 id="VPN"><a href="#VPN" class="headerlink" title="VPN"></a>VPN</h4><p>electron-ssr : GUI的界面的ssr.很好用</p><h4 id="中文字体"><a href="#中文字体" class="headerlink" title="中文字体"></a>中文字体</h4><p>[参考ArchWiki]</p><p><a href="https://wiki.archlinux.org/index.php/Font_Configuration/Chinese_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)" target="_blank" rel="noopener">https://wiki.archlinux.org/index.php/Font_Configuration/Chinese_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)</a></p><pre><code>yay -S ttf-ms-fonts ttf-roboto noto-fonts noto-fonts-cjk adobe-source-han-sans-cn-fonts adobe-source-han-serif-cn-fonts ttf-dejavu</code></pre><p>添加配置文件,<code>~/.config/fontconfig/fonts.conf</code> or <code>/etc/fonts/local.conf</code></p><h3 id="命令行"><a href="#命令行" class="headerlink" title="命令行"></a>命令行</h3><blockquote><p>linux 强大的命令行操作,使效率倍增,所以配置好命令行,并安装实用命令行软件是必要的</p></blockquote><h4 id="zsh-1"><a href="#zsh-1" class="headerlink" title="zsh^1"></a>zsh<a href="[终端环境之Zsh＆oh-my-zsh](https://mtaoist.xyz/2018/03/14/oh-my-zsh/)">^1</a></h4><pre class=" language-shell"><code class="language-shell">sudo pacman -S zsh zsh-completions# 将zsh设为默认shellchsh -s /bin/zsh#其他发行版可先用chsh -l 查看zsh安装位置</code></pre><h5 id="oh-my-zsh"><a href="#oh-my-zsh" class="headerlink" title="oh-my-zsh"></a>oh-my-zsh</h5><ul><li><p>curl 和 git 应该已被安装(若没有Arch 用sudo pacman -S curl git 安装，其他发行版类似。)</p></li><li><p><a href="http://ohmyz.sh/" target="_blank" rel="noopener">Oh-my-zsh</a>是一个傻瓜化的zsh配置管理框架，提供了大量实用的功能，主题等。做到开箱即用，现在基本成为了Zsh的标配。</p></li><li><p>安装</p><pre><code>sh -c &quot;$(curl -fsSL https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh)&quot;</code></pre></li><li><p>配置文件位置： ~/.zshrc</p></li><li><p>主题<br><code>oh-my-zsh</code>自带大量<a href="https://github.com/robbyrussell/oh-my-zsh/wiki/Themes" target="_blank" rel="noopener">Themes</a>，默认为<code>robbyrussell</code>。你也可以选择<code>random</code>，即每次打开终端随机选一个主题。</p><blockquote><p>ZSH_THEME=”你喜欢的主题名”<br><img src="https://mtaoist.xyz/img/zsh_theme.png" alt="themes"></p></blockquote></li><li><p>常用插件</p><ul><li><p>git: 提供大量git的Aliases，<a href="https://github.com/robbyrussell/oh-my-zsh/wiki/Plugin:git" target="_blank" rel="noopener">详情</a></p></li><li><p>archlinux： 提供一些pacman包管理器的Aliases，<a href="https://github.com/robbyrussell/oh-my-zsh/wiki/Plugins#archlinux" target="_blank" rel="noopener">详情</a></p></li><li><p>z：经常使用cd 切换路径，积累一定数据后可用z快速跳转到指定位置</p></li><li><p>sudo：按两次[Esc]自动在前面加sudo</p></li><li><p>pip： 补全pip 命令</p></li><li><p>zsh-autosuggestions: 根据历史记录进行智能提示(按 ctrl+E 是正确姿势)。非oh-my-zsh自带，用git下载安装</p><pre><code>git clone https://github.com/zsh-users/zsh-autosuggestions $ZSH_CUSTOM/plugins/zsh-autosuggestions</code></pre></li><li><p>zsh-syntax-highlighting：命令高亮，正确显示绿色，错误为红色。非oh-my-zsh自带，用git下载安装</p><pre><code>git clone https://github.com/zsh-users/zsh-syntax-highlighting.git ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-syntax-highlighting</code></pre><blockquote><p>plugins=( 你想启用的插件，空格分隔 )<br><img src="https://mtaoist.xyz/img/zsh_plugins.png" alt="plugins"></p></blockquote></li><li><p>重新加载配置文件，立刻生效。</p><blockquote><p>source ~/.zshrc</p></blockquote></li></ul></li><li><p>其他插件请参见官方<a href="https://github.com/robbyrussell/oh-my-zsh/wiki/Plugins-Overview" target="_blank" rel="noopener">wiki</a></p></li><li><p>少即是多，启用大量插件会严重拖慢zsh启动速度</p></li></ul><hr><p>我这里采用的是<code>agnoster</code>主题<br>为在使用tmux时不重复显示<code>whoami@whereami</code>做两处修改</p><ul><li>在<code>/etc/profile</code>中添加环境变量<pre><code>DEFAULT_USER=$USER</code></pre></li><li>在<code>agnoster</code>主题文件91行中做如下修改<pre class=" language-git"><code class="language-git"><span class="token deleted">- if [[ "$USER" != "$DEFAULT_USER" || -n "$SSH_CLIENT"]]; then</span><span class="token inserted">+ if [[ "$USER" != "$DEFAULT_USER" || (( -n "$SSH_CLIENT" &amp;&amp; -z "$TMUX" )) ]]; then</span></code></pre>这样在本地初始打开一个terminal时不会显示,ssh远程连接是时显示<br>进入tmux时不会显示</li></ul><p>原因是<br><a href="https://blog.csdn.net/kingolie/article/details/53066679" target="_blank" rel="noopener">Archlinux下安装和配置zsh</a></p><h4 id="tmux"><a href="#tmux" class="headerlink" title="tmux"></a>tmux</h4><p>安装tmux</p><pre class=" language-shell"><code class="language-shell">sudo pacman -S tmux</code></pre><p>在这里配置tmux<br><a href="https://github.com/gpakosz/.tmux" target="_blank" rel="noopener">https://github.com/gpakosz/.tmux</a> 这个简单好看,且对true color支持很好,但对<br><a href="https://github.com/samoshkin/tmux-config" target="_blank" rel="noopener">https://github.com/samoshkin/tmux-config</a>  &lt;–推荐这个配置,这个配置针对键位的优化很好,</p><p><a href="http://lotabout.me/2018/true-color-for-tmux-and-vim/" target="_blank" rel="noopener">为 vim + tmux 开启真彩色(true color)</a></p><p><a href="https://blog.csdn.net/u014717036/article/details/60139776" target="_blank" rel="noopener">tmux进阶之tmuxinator</a></p><blockquote><p>  FAQ:</p><ol><li><p>tmux 嵌套使用的话，如何将 tmux 命令发送到嵌套内的会话窗口？<a href="https://blog.csdn.net/henryhu712/article/details/83824487" target="_blank" rel="noopener">转载自</a></p><p>  很常见的例子是，在本地用 tmux 登陆远程服务器，服务器上又使用了 tmux。问题是，在这种情况下，tmux 指令被外层会话窗口捕获（本地 tmux），根本无法控制服务器上运行的 tmux。例如，想退出服务器上的会话，ctrl + b, d, 结果退出的是本地 tmux 连接, sh*t。</p><p>  介绍一个简单方法：按着 ctrl，点击两次 b 键，这样发出的 tmux 指令就是发送到内层窗口会话！如此简单！</p></li></ol><hr></blockquote><h4 id="neovim"><a href="#neovim" class="headerlink" title="neovim"></a>neovim</h4><blockquote><p>neovim属于vim的加强版  功能更加强大</p></blockquote><p>注意的是启动neovim的命令式<code>nvim</code>而不是<code>neovim</code></p><p>同时安装 <a href="https://gitee.com/hustlion-dev/nerd-fonts#option-3-install-script" target="_blank" rel="noopener">nerd-fonts</a> </p><blockquote><p>如果安装spacevim 则不需要手动安装nerd-fonts</p></blockquote><h5 id="spacevim"><a href="#spacevim" class="headerlink" title="spacevim"></a>spacevim</h5><p>一个定制化的vim配置,支持<code>vim,neovim</code> </p><p><a href="https://spacevim.org/" target="_blank" rel="noopener">官网</a></p><blockquote><p>初学的时候可以使用这个省事儿些,但是后面学习使用vim最好采用自己的配置,按需添加插件配置.</p></blockquote><h4 id="Xshell下256-真色支持"><a href="#Xshell下256-真色支持" class="headerlink" title="*Xshell下256/真色支持"></a>*Xshell下256/真色支持</h4><p>检查当前是否为256/真色<a href="https://gaomf.cn/2017/01/16/Terminal_Color/" target="_blank" rel="noopener">参考本篇文章</a></p><p>我这里的xshell只能支持256色</p><p>这时xshell中只有在tmux下spacevim才能显示256色,不支持真色</p><p>在.zshrc文件头添加</p><pre class=" language-shell"><code class="language-shell">sh /${.zshrc的目录}/.change_term.sh</code></pre><p>.change_term.sh文件内容如下</p><pre class=" language-shell"><code class="language-shell">echo "before: $TERM"if [ "$TERM" = "linux" ]then  echo "export TERM=xterm-256color"  export TERM=xterm-256colorelif [ "$TERM" = "xterm" ]then  echo "export TERM=tmux-direct"  export TERM=tmux-directelif [ "$TERM" = "xterm-256color" ]then  echo "export TERM=xterm-direct"  export TERM=xterm-directelse  echo "export TERM=tmux-256color"  export TERM=tmux-256colorfiecho "now: $TERM"# 如果是ssh自动启用tmuxif [ -n "$SSH_CLIENT" ]then  tmuxficlear </code></pre><p>glances: 代替htop的资源监控工具</p><p>ranger: ranger是一个以<a href="https://baike.baidu.com/item/GPL" target="_blank" rel="noopener">GPL</a>许可证发放源码，默认使用VIM风格键盘绑定、<a href="https://baike.baidu.com/item/curses/1630775" target="_blank" rel="noopener">curses</a>图形库，基于字符终端的<a href="https://baike.baidu.com/item/%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86%E5%99%A8/8716754" target="_blank" rel="noopener">文件管理器</a>，是自由免费软件。</p><p>tig: git的命令行管理软件</p><p>dockly: docker的命令行管理软件</p><p>wtfutil: 基于 Terminal 的个人 dashboard 实用程序，专为显示不常用的但非常重要的日常数据而设计</p><h3 id="常用软件"><a href="#常用软件" class="headerlink" title="常用软件"></a>常用软件</h3><h4 id="编辑器-amp-IDE"><a href="#编辑器-amp-IDE" class="headerlink" title="编辑器&amp;IDE"></a>编辑器&amp;IDE</h4><p>JetBrains ToolBox: JB全家桶,管理Clion,IDEA,PyCharm项目</p><p>code::blocks</p><p>vscode: </p><p>Typora: markdown编辑器</p><h4 id="终端"><a href="#终端" class="headerlink" title="终端"></a>终端</h4><p>Yakuake: 悬挂式命令行,很方便</p><h4 id="开发工具"><a href="#开发工具" class="headerlink" title="开发工具"></a>开发工具</h4><p>GitKraken: git的图形化管理软件</p><p>: (文件对比工具)</p><h4 id="影音"><a href="#影音" class="headerlink" title="影音"></a>影音</h4><p>网易云音乐</p><h4 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h4><p>google-chrome</p><h4 id="通讯工具"><a href="#通讯工具" class="headerlink" title="通讯工具"></a>通讯工具</h4><p>deepin.com.qq.office： tim</p><p>deepin-wechat： 微信</p><blockquote><p>wine程序字体dpi太小导致视觉观感很难受</p><p>调整DPI字体</p><p>1，先退出deepin-tim或deepin-qq，否则会提示错误。</p><p>2，运行<strong>env WINEPREFIX=”$HOME/.deepinwine/Deepin-TIM” winecfg</strong>（如果是修改QQ界面字体大小，就把Deepin-TIM改成Deepin-QQ），然后将屏幕分辨率拖放到合适的大小（一般120就可以了）。</p></blockquote><p>gitter:</p><p>telegram:</p><h4 id="虚拟机"><a href="#虚拟机" class="headerlink" title="虚拟机"></a>虚拟机</h4><p>docker</p><p>virtualbox</p><h4 id="helper"><a href="#helper" class="headerlink" title="helper"></a>helper</h4><p>albert: linux下的启动器 </p><h3 id="桌面环境"><a href="#桌面环境" class="headerlink" title="桌面环境"></a>桌面环境</h3><blockquote><p><a href="https://blog.csdn.net/kingolie/article/details/76723448" target="_blank" rel="noopener">参考</a></p><p>如果安装manjaro 就不需要手动安装这些了</p></blockquote><h4 id="1、安装显卡驱动"><a href="#1、安装显卡驱动" class="headerlink" title="1、安装显卡驱动"></a><strong>1、安装显卡驱动</strong></h4><pre class=" language-zsh"><code class="language-zsh"># lspci | grep VGA    # 确定显卡型号# pacman -S <驱动包>## # 官方仓库提供的驱动包：# # +----------------------+--------------------+--------------+# # |                      |        开源        |     私有     |# # +----------------------+--------------------+--------------+# # |         通用         |   xf86-video-vesa  |              |# # +----------------------+--------------------+--------------+# # |         Intel        |  xf86-video-intel  |              |# # +--------+-------------+--------------------+--------------+# # |        | GeForce 9+  |                    |    nvidia    |# # +        +-------------+                    +--------------+# # | nVidia | GeForce 8/9 | xf86-video-nouveau | nvidia-340xx |# # +        +-------------+                    +--------------+# # |        | GeForce 6/7 |                    | nvidia-304xx |# # +--------+-------------+--------------------+--------------+# # |        AMD/ATI       |   xf86-video-ati   |              |# # +----------------------+--------------------+--------------+12345678910111213141516171819</code></pre><h4 id="2、安装桌面环境"><a href="#2、安装桌面环境" class="headerlink" title="2、安装桌面环境"></a><strong>2、安装桌面环境</strong></h4><p>所有桌面环境都需要依赖xorg。所以先要安装xorg组。</p><pre class=" language-shell"><code class="language-shell">pacman -S xorg</code></pre><p>输入命令之后首先会询问要安装xorg组下的哪些包，选择全部。然后对于libgl包有个四个不同的实现，选择mesa-libgl。<br>然后再安装xorg-xinit和xterm：</p><pre class=" language-shell"><code class="language-shell">pacman -S xorg-xinit xterm</code></pre><p>安装完成之后就可以使用startx命令启动xorg的简易界面了。进入成功的话会显示出几个简陋的窗口。然后按Ctrl+D就可以退出了。</p><h4 id="3、安装xfce4桌面"><a href="#3、安装xfce4桌面" class="headerlink" title="3、安装xfce4桌面"></a><strong>3、安装xfce4桌面</strong></h4><p>安装xfce4桌面和附带的软件包：</p><pre class=" language-shell"><code class="language-shell">pacman -S xfce4 xfce4-goodies</code></pre><h4 id="4、安装LightDM登录管理器-显示管理器"><a href="#4、安装LightDM登录管理器-显示管理器" class="headerlink" title="4、安装LightDM登录管理器(显示管理器)"></a><strong>4、安装LightDM登录管理器(显示管理器)</strong></h4><p>详细安装和配置看arch-wiki-lighdm<br>我没有通过startx的方式启动桌面环境，而是使用了登录管理器lightdm<br>安装：</p><pre class=" language-zsh"><code class="language-zsh">pacman -S lightdm lightdm-gtk-greeter</code></pre><p>其配置文件为：<br>/etc/lightdm/lightdm.conf<br>安装好之后测试启动：</p><pre class=" language-shell"><code class="language-shell">systemctl start lightdm.service1</code></pre><p>如果正常就会看到熟悉的登录界面了，不过不要登录，现在只是测试lightdm是否可以正常启动<br>点击画面上的关机小图标，弹出关机对话，选择注销!<br>注销之后就回到之前的tty命令行模式了，可以看到相关的启动信息<br>一切正常，所以设置lightdm为开机自动启动，这样以后开机就不会出现tty命令行界面了，而是直接进入登录界面：</p><pre class=" language-shell"><code class="language-shell">systemctl enable lightdm.service</code></pre><p>之后你可以重启进入xfce4图形界面，然后在图形界面中使用终端来继续以下配置步骤，也可以不重启，直接继续</p><p>进入xfce4图形界面的命令为<code>startxfce4</code></p><h4 id="桌面美化"><a href="#桌面美化" class="headerlink" title="桌面美化"></a>桌面美化</h4><p>好好干活,美化个屁.</p>]]></content>
      
      
      <categories>
          
          <category> 实用技能 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GraduationProject</title>
      <link href="/2018/09/23/graduationproject/"/>
      <url>/2018/09/23/graduationproject/</url>
      
        <content type="html"><![CDATA[<blockquote><p>在这里记录一下我的毕业设计<br>链接在<a href="https://github.com/tabris233/GraduationProject" target="_blank" rel="noopener">GitHub</a>上</p></blockquote><p>md 写个p 面向cv编程就完了</p>]]></content>
      
      
      <categories>
          
          <category> 项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 毕业设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>正则表达式手册</title>
      <link href="/2018/03/17/manualofregex/"/>
      <url>/2018/03/17/manualofregex/</url>
      
        <content type="html"><![CDATA[<h1 id="表达式全集"><a href="#表达式全集" class="headerlink" title="表达式全集"></a>表达式全集</h1><p>由于hexo的markdown的引擎太烂了  这里的格式会乱点<br>有时间在换一个好一点的引擎   太乱了!!<br>移步这里<a href="http://tool.oschina.net/uploads/apidocs/jquery/regexp.html" target="_blank" rel="noopener">格式好看的正则表达式手册</a></p><table><thead><tr><th style="text-align:center">字符</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:center">\</td><td style="text-align:left">将下一个字符标记为一个特殊字符、或一个原义字符、或一个向后引用、或一个八进制转义符。例如，“<code>n</code>”匹配字符“<code>n</code>”。“<code>\n</code>”匹配一个换行符。串行“<code>\</code>”匹配“<code>\</code>”而“<code>(</code>”则匹配“<code>(</code>”。</td></tr><tr><td style="text-align:center">^</td><td style="text-align:left">匹配输入字符串的开始位置。如果设置了RegExp对象的Multiline属性，^也匹配“<code>\n</code>”或“<code>\r</code>”之后的位置。</td></tr><tr><td style="text-align:center">$</td><td style="text-align:left">匹配输入字符串的结束位置。如果设置了RegExp对象的Multiline属性，$也匹配“<code>\n</code>”或“<code>\r</code>”之前的位置。</td></tr><tr><td style="text-align:center"></td><td style="text-align:left">匹配前面的子表达式零次或多次。例如，zo能匹配“<code>z</code>”以及“<code>zoo</code>”。<em>等价于{0,}。</em></td></tr><tr><td style="text-align:center">+</td><td style="text-align:left">匹配前面的子表达式一次或多次。例如，“<code>zo+</code>”能匹配“<code>zo</code>”以及“<code>zoo</code>”，但不能匹配“<code>z</code>”。+等价于{1,}。</td></tr><tr><td style="text-align:center">?</td><td style="text-align:left">匹配前面的子表达式零次或一次。例如，“<code>do(es)?</code>”可以匹配“<code>does</code>”或“<code>does</code>”中的“<code>do</code>”。?等价于{0,1}。</td></tr><tr><td style="text-align:center">{n}</td><td style="text-align:left">n是一个非负整数。匹配确定的n次。例如，“<code>o{2}</code>”不能匹配“<code>Bob</code>”中的“<code>o</code>”，但是能匹配“<code>food</code>”中的两个o。</td></tr><tr><td style="text-align:center">{n,}</td><td style="text-align:left">n是一个非负整数。至少匹配n次。例如，“<code>o{2,}</code>”不能匹配“<code>Bob</code>”中的“<code>o</code>”，但能匹配“<code>foooood</code>”中的所有o。“<code>o{1,}</code>”等价于“<code>o+</code>”。“<code>o{0,}</code>”则等价于“<code>o</code>”。</td></tr><tr><td style="text-align:center">{n,m}</td><td style="text-align:left">m和n均为非负整数，其中n&lt;=m。最少匹配n次且最多匹配m次。例如，“<code>o{1,3}</code>”将匹配“<code>fooooood</code>”中的前三个o。“<code>o{0,1}</code>”等价于“<code>o?</code>”。请注意在逗号和两个数之间不能有空格。</td></tr><tr><td style="text-align:center">?</td><td style="text-align:left">当该字符紧跟在任何一个其他限制符（*,+,?，{n}，{n,}，{n,m}）后面时，匹配模式是非贪婪的。非贪婪模式尽可能少的匹配所搜索的字符串，而默认的贪婪模式则尽可能多的匹配所搜索的字符串。例如，对于字符串“<code>oooo</code>”，“<code>o+?</code>”将匹配单个“<code>o</code>”，而“<code>o+</code>”将匹配所有“<code>o</code>”。</td></tr><tr><td style="text-align:center">.</td><td style="text-align:left">匹配除“<code>\`</code>n<code>”之外的任何单个字符。要匹配包括“</code>`<code>n</code>”在内的任何字符，请使用像“`(.</td><td>\n)`”的模式。</td></tr><tr><td style="text-align:center">(pattern)</td><td style="text-align:left">匹配pattern并获取这一匹配。所获取的匹配可以从产生的Matches集合得到，在VBScript中使用SubMatches集合，在JScript中则使用$0…$9属性。要匹配圆括号字符，请使用“<code>(</code>”或“<code>)</code>”。</td></tr><tr><td style="text-align:center">(?:pattern)</td><td style="text-align:left">匹配pattern但不获取匹配结果，也就是说这是一个非获取匹配，不进行存储供以后使用。这在使用或字符“`(</td><td>)<code>”来组合一个模式的各个部分是很有用。例如“</code>industr(?:y</td><td>ies)<code>”就是一个比“</code>industry</td><td>industries`”更简略的表达式。</td></tr><tr><td style="text-align:center">(?=pattern)</td><td style="text-align:left">正向肯定预查，在任何匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如，“`Windows(?=95</td><td>98</td><td>NT</td><td>2000)<code>”能匹配“</code>Windows2000<code>”中的“</code>Windows<code>”，但不能匹配“</code>Windows3.1<code>”中的“</code>Windows`”。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。</td></tr><tr><td style="text-align:center">(?!pattern)</td><td style="text-align:left">正向否定预查，在任何不匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如“`Windows(?!95</td><td>98</td><td>NT</td><td>2000)<code>”能匹配“</code>Windows3.1<code>”中的“</code>Windows<code>”，但不能匹配“</code>Windows2000<code>”中的“</code>Windows`”。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始</td></tr><tr><td style="text-align:center">(?&lt;=pattern)</td><td style="text-align:left">反向肯定预查，与正向肯定预查类拟，只是方向相反。例如，“`(?&lt;=95</td><td>98</td><td>NT</td><td>2000)Windows<code>”能匹配“</code>2000Windows<code>”中的“</code>Windows<code>”，但不能匹配“</code>3.1Windows<code>”中的“</code>Windows`”。</td></tr><tr><td style="text-align:center">(?&lt;!pattern)</td><td style="text-align:left">反向否定预查，与正向否定预查类拟，只是方向相反。例如“`(?&lt;!95</td><td>98</td><td>NT</td><td>2000)Windows<code>”能匹配“</code>3.1Windows<code>”中的“</code>Windows<code>”，但不能匹配“</code>2000Windows<code>”中的“</code>Windows`”。</td></tr><tr><td style="text-align:center">x\</td><td style="text-align:left">y</td><td>匹配x或y。例如，“`z</td><td>food<code>”能匹配“</code>z<code>”或“</code>food<code>”。“</code>(z</td><td>f)ood<code>”则匹配“</code>zood<code>”或“</code>food`”。</td></tr><tr><td style="text-align:center">[xyz]</td><td style="text-align:left">字符集合。匹配所包含的任意一个字符。例如，“<code>[abc]</code>”可以匹配“<code>plain</code>”中的“<code>a</code>”。</td></tr><tr><td style="text-align:center">[^xyz]</td><td style="text-align:left">负值字符集合。匹配未包含的任意字符。例如，“<code>[^abc]</code>”可以匹配“<code>plain</code>”中的“<code>p</code>”。</td></tr><tr><td style="text-align:center">[a-z]</td><td style="text-align:left">字符范围。匹配指定范围内的任意字符。例如，“<code>[a-z]</code>”可以匹配“<code>a</code>”到“<code>z</code>”范围内的任意小写字母字符。</td></tr><tr><td style="text-align:center">[^a-z]</td><td style="text-align:left">负值字符范围。匹配任何不在指定范围内的任意字符。例如，“<code>[^a-z]</code>”可以匹配任何不在“<code>a</code>”到“<code>z</code>”范围内的任意字符。</td></tr><tr><td style="text-align:center">\b</td><td style="text-align:left">匹配一个单词边界，也就是指单词和空格间的位置。例如，“<code>er\b</code>”可以匹配“<code>never</code>”中的“<code>er</code>”，但不能匹配“<code>verb</code>”中的“<code>er</code>”。</td></tr><tr><td style="text-align:center">\B</td><td style="text-align:left">匹配非单词边界。“<code>er\B</code>”能匹配“<code>verb</code>”中的“<code>er</code>”，但不能匹配“<code>never</code>”中的“<code>er</code>”。</td></tr><tr><td style="text-align:center">\cx</td><td style="text-align:left">匹配由x指明的控制字符。例如，\cM匹配一个Control-M或回车符。x的值必须为A-Z或a-z之一。否则，将c视为一个原义的“<code>c</code>”字符。</td></tr><tr><td style="text-align:center">\d</td><td style="text-align:left">匹配一个数字字符。等价于[0-9]。</td></tr><tr><td style="text-align:center">\D</td><td style="text-align:left">匹配一个非数字字符。等价于[^0-9]。</td></tr><tr><td style="text-align:center">\f</td><td style="text-align:left">匹配一个换页符。等价于\x0c和\cL。</td></tr><tr><td style="text-align:center">\n</td><td style="text-align:left">匹配一个换行符。等价于\x0a和\cJ。</td></tr><tr><td style="text-align:center">\r</td><td style="text-align:left">匹配一个回车符。等价于\x0d和\cM。</td></tr><tr><td style="text-align:center">\s</td><td style="text-align:left">匹配任何空白字符，包括空格、制表符、换页符等等。等价于[ \f\n\r\t\v]。</td></tr><tr><td style="text-align:center">\S</td><td style="text-align:left">匹配任何非空白字符。等价于[^ \f\n\r\t\v]。</td></tr><tr><td style="text-align:center">\t</td><td style="text-align:left">匹配一个制表符。等价于\x09和\cI。</td></tr><tr><td style="text-align:center">\v</td><td style="text-align:left">匹配一个垂直制表符。等价于\x0b和\cK。</td></tr><tr><td style="text-align:center">\w</td><td style="text-align:left">匹配包括下划线的任何单词字符。等价于“<code>[A-Za-z0-9*]*</code>”。</td></tr><tr><td style="text-align:center">\W</td><td style="text-align:left">匹配任何非单词字符。等价于“<code>[^A-Za-z0-9]</code>”。</td></tr><tr><td style="text-align:center">\xn</td><td style="text-align:left">匹配n，其中n为十六进制转义值。十六进制转义值必须为确定的两个数字长。例如，“<code>\x41</code>”匹配“<code>A</code>”。“<code>\x041</code>”则等价于“<code>\x04&amp;1</code>”。正则表达式中可以使用ASCII编码。.</td></tr><tr><td style="text-align:center">\num</td><td style="text-align:left">匹配num，其中num是一个正整数。对所获取的匹配的引用。例如，“<code>(.)\1</code>”匹配两个连续的相同字符。</td></tr><tr><td style="text-align:center">\n</td><td style="text-align:left">标识一个八进制转义值或一个向后引用。如果\n之前至少n个获取的子表达式，则n为向后引用。否则，如果n为八进制数字（0-7），则n为一个八进制转义值。</td></tr><tr><td style="text-align:center">\nm</td><td style="text-align:left">标识一个八进制转义值或一个向后引用。如果\nm之前至少有nm个获得子表达式，则nm为向后引用。如果\nm之前至少有n个获取，则n为一个后跟文字m的向后引用。如果前面的条件都不满足，若n和m均为八进制数字（0-7），则\nm将匹配八进制转义值nm。</td></tr><tr><td style="text-align:center">\nml</td><td style="text-align:left">如果n为八进制数字（0-3），且m和l均为八进制数字（0-7），则匹配八进制转义值nml。</td></tr><tr><td style="text-align:center">\un</td><td style="text-align:left">匹配n，其中n是一个用四个十六进制数字表示的Unicode字符。例如，\u00A9匹配版权符号（©）。</td></tr></tbody></table><h1 id="常用正则表达式"><a href="#常用正则表达式" class="headerlink" title="常用正则表达式"></a>常用正则表达式</h1><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>用户名</td><td><code>/^[a-z0-9*-]{3,16}$/</code></td></tr><tr><td>密码</td><td><code>/^[a-z0-9-]{6,18}$/</code></td></tr><tr><td>十六进制值</td><td><code>/^#?([a-f0-9]{6}\&amp;#124;[a-f0-9]{3})$/</code></td></tr><tr><td>电子邮箱</td><td><code>/^([a-z0-9*.-]+)@([\da-z.-]+).([a-z.]{2,6})$/</code> <code>/^[a-z\d]+(.[a-z\d]+)@(\da-z?)+(.{1,2}[a-z]+)+$/</code>*`</td></tr><tr><td>URL</td><td><code>/^(https?:\/\/)?([\da-z.-]+).([a-z.]{2,6})([\/\w .-])*\/?$/</code>*`</td></tr><tr><td>IP 地址</td><td>`/((2[0-4]\d\</td><td>25[0-5]\</td><td>[01]?\d\d?).){3}(2[0-4]\d\</td><td>25[0-5]\</td><td>[01]?\d\d?)/<code></code>/^(?:(?:25[0-5]\</td><td>2[0-4][0-9]\</td><td>[01]?[0-9][0-9]?).){3}(?:25[0-5]\</td><td>2[0-4][0-9]\</td><td>[01]?[0-9][0-9]?)$/`</td></tr><tr><td>HTML 标签</td><td>`/^&lt;([a-z]+)([^&lt;]+)(?:&gt;(.*)&lt;\/\1&gt;\</td><td>\s+\/&gt;)$/`</td></tr><tr><td>删除代码\注释</td><td>`(?&lt;!http:\</td><td>\S)//.$`</td></tr><tr><td>Unicode编码中的汉字范围</td><td><code>/^[\u2E80-\u9FFF]+$/</code></td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 实用技能 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 正则表达式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python学习笔记</title>
      <link href="/2018/03/07/notesofpython/"/>
      <url>/2018/03/07/notesofpython/</url>
      
        <content type="html"><![CDATA[<p>抄写了两个Spider,发现对于Python基础的掌握实在是差劲的可以.</p><p>于是乎 过来补补基础</p><p>一直在<a href="https://www.hackerrank.com/" target="_blank" rel="noopener">Hackerrank</a>上面做Python的题目.知识点覆盖挺全面的,推荐一波.</p><h1 id="Basic"><a href="#Basic" class="headerlink" title="Basic"></a>Basic</h1><h2 id="乱七八糟小技巧"><a href="#乱七八糟小技巧" class="headerlink" title="乱七八糟小技巧"></a>乱七八糟小技巧</h2><pre class=" language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> n<span class="token punctuation">,</span>m<span class="token punctuation">,</span><span class="token operator">*</span>l <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'1'</span><span class="token punctuation">,</span><span class="token string">'2'</span><span class="token punctuation">]</span><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span>m<span class="token punctuation">,</span>l<span class="token punctuation">)</span><span class="token number">1</span> <span class="token number">2</span> <span class="token punctuation">[</span><span class="token punctuation">]</span></code></pre><h2 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h2><h3 id><a href="#" class="headerlink" title="."></a>.</h3><h4 id="set"><a href="#set" class="headerlink" title="set"></a>set</h4><p>集合是一个无序的，不重复的数据组合，它的主要作用如下：<br>去重，把一个列表变成集合，就自动去重了<br>关系测试，测试两组数据之前的交集、差集、并集等关系</p><pre class=" language-python"><code class="language-python">list_1 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">]</span><span class="token comment" spellcheck="true">#去重</span>list_1 <span class="token operator">=</span> set<span class="token punctuation">(</span>list_1<span class="token punctuation">)</span>list_2 <span class="token operator">=</span> set<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">66</span><span class="token punctuation">,</span><span class="token number">22</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">)</span>list_3 <span class="token operator">=</span> set<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>list_1<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>list_2<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>list_3<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"---------------------------"</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#关系测试</span><span class="token comment" spellcheck="true">#交集(两个列表里面都有的值，这里是4、6)：</span><span class="token keyword">print</span><span class="token punctuation">(</span>list_1<span class="token punctuation">.</span>intersection<span class="token punctuation">(</span>list_2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#并集（把两个列别合并起来，然后去重）：</span><span class="token keyword">print</span><span class="token punctuation">(</span>list_1<span class="token punctuation">.</span>union<span class="token punctuation">(</span>list_2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#差集（把list_1里面有的而list_2里面没有的取出来）：</span><span class="token keyword">print</span><span class="token punctuation">(</span>list_1<span class="token punctuation">.</span>difference<span class="token punctuation">(</span>list_2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#对称差集（两个列表里面，互相没有的取出来，也就是只去掉那些互相都有的值）</span><span class="token keyword">print</span><span class="token punctuation">(</span>list_1<span class="token punctuation">.</span>symmetric_difference<span class="token punctuation">(</span>list_2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#子集（判断list_1是否包含了list_3里面的所有值）</span><span class="token keyword">print</span><span class="token punctuation">(</span>list_3<span class="token punctuation">.</span>issubset<span class="token punctuation">(</span>list_1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#父集（判断list_1是否为list_3的父集）</span><span class="token keyword">print</span><span class="token punctuation">(</span>list_1<span class="token punctuation">.</span>issuperset<span class="token punctuation">(</span>list_3<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#无交集（判断list_3和list_4是否完全没有任何交集）</span>list_4 <span class="token operator">=</span> set<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>list_3<span class="token punctuation">.</span>isdisjoint<span class="token punctuation">(</span>list_4<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#-----------------------关系测试的另一种写法：</span><span class="token string">''</span>'s <span class="token operator">=</span> set<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">)</span>      <span class="token comment" spellcheck="true">#创建一个数值集合</span>t <span class="token operator">=</span> set<span class="token punctuation">(</span><span class="token string">"Hello"</span><span class="token punctuation">)</span>         <span class="token comment" spellcheck="true">#创建一个唯一字符的集合</span>a <span class="token operator">=</span> t <span class="token operator">|</span> s          <span class="token comment" spellcheck="true"># t 和 s的并集</span>b <span class="token operator">=</span> t <span class="token operator">&amp;</span> s          <span class="token comment" spellcheck="true"># t 和 s的交集</span>c <span class="token operator">=</span> t – s          <span class="token comment" spellcheck="true"># 求差集（项在t中，但不在s中）</span>d <span class="token operator">=</span> t <span class="token operator">^</span> s          <span class="token comment" spellcheck="true"># 对称差集（项在t或s中，但不会同时出现在二者中）</span>基本操作：t<span class="token punctuation">.</span>add<span class="token punctuation">(</span><span class="token string">'x'</span><span class="token punctuation">)</span>            <span class="token comment" spellcheck="true"># 添加一项</span>s<span class="token punctuation">.</span>update<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">37</span><span class="token punctuation">,</span><span class="token number">42</span><span class="token punctuation">]</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># 在s中添加多项</span>使用remove<span class="token punctuation">(</span><span class="token punctuation">)</span>可以删除一项：t<span class="token punctuation">.</span>remove<span class="token punctuation">(</span><span class="token string">'H'</span><span class="token punctuation">)</span>   <span class="token comment" spellcheck="true">#有就删除，没有就报错</span>t<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">#随机弹出一个</span>t<span class="token punctuation">.</span>discard<span class="token punctuation">(</span><span class="token string">'H'</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">#有就删除，没有也不会报错</span>len<span class="token punctuation">(</span>s<span class="token punctuation">)</span>set 的长度x <span class="token keyword">in</span> s测试 x 是否是 s 的成员x <span class="token operator">not</span> <span class="token keyword">in</span> s测试 x 是否不是 s 的成员s<span class="token punctuation">.</span>issubset<span class="token punctuation">(</span>t<span class="token punctuation">)</span>s <span class="token operator">&lt;=</span> t测试是否 s 中的每一个元素都在 t 中s<span class="token punctuation">.</span>issuperset<span class="token punctuation">(</span>t<span class="token punctuation">)</span>s <span class="token operator">>=</span> t测试是否 t 中的每一个元素都在 s 中s<span class="token punctuation">.</span>union<span class="token punctuation">(</span>t<span class="token punctuation">)</span>s <span class="token operator">|</span> t返回一个新的 set 包含 s 和 t 中的每一个元素s<span class="token punctuation">.</span>intersection<span class="token punctuation">(</span>t<span class="token punctuation">)</span>s <span class="token operator">&amp;</span> t返回一个新的 set 包含 s 和 t 中的公共元素s<span class="token punctuation">.</span>difference<span class="token punctuation">(</span>t<span class="token punctuation">)</span>s <span class="token operator">-</span> t返回一个新的 set 包含 s 中有但是 t 中没有的元素s<span class="token punctuation">.</span>symmetric_difference<span class="token punctuation">(</span>t<span class="token punctuation">)</span>s <span class="token operator">^</span> t返回一个新的 set 包含 s 和 t 中不重复的元素s<span class="token punctuation">.</span>copy<span class="token punctuation">(</span><span class="token punctuation">)</span>返回 set “s”的一个浅复制</code></pre><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><h3 id="-1"><a href="#-1" class="headerlink" title="."></a>.</h3><h4 id="对字符定义优先级"><a href="#对字符定义优先级" class="headerlink" title="对字符定义优先级"></a>对字符定义优先级</h4><p>将需要排序的字符集放到一个字符串中<br>在这个字符串中越靠前的字符排序后越靠前</p><pre class=" language-python"><code class="language-python">order <span class="token operator">=</span> <span class="token string">'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1357902468'</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token operator">*</span>sorted<span class="token punctuation">(</span>input<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> key<span class="token operator">=</span>order<span class="token punctuation">.</span>index<span class="token punctuation">)</span><span class="token punctuation">,</span> sep<span class="token operator">=</span><span class="token string">''</span><span class="token punctuation">)</span></code></pre><h4 id="关键字排序"><a href="#关键字排序" class="headerlink" title="关键字排序"></a>关键字排序</h4><pre class=" language-python"><code class="language-python">N<span class="token punctuation">,</span> M <span class="token operator">=</span> map<span class="token punctuation">(</span>int<span class="token punctuation">,</span> input<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># Ｎ行 Ｍ列</span>rows <span class="token operator">=</span> <span class="token punctuation">[</span>input<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>N<span class="token punctuation">)</span><span class="token punctuation">]</span>  <span class="token comment" spellcheck="true"># 一行 为一组数据</span>K <span class="token operator">=</span> int<span class="token punctuation">(</span>input<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 以第几为关键字</span><span class="token keyword">for</span> row <span class="token keyword">in</span> sorted<span class="token punctuation">(</span>rows<span class="token punctuation">,</span> key<span class="token operator">=</span><span class="token keyword">lambda</span> x<span class="token punctuation">:</span> int<span class="token punctuation">(</span>x<span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">[</span>K<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true"># lambda 匿名函数</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>row<span class="token punctuation">)</span></code></pre><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><h3 id="-2"><a href="#-2" class="headerlink" title="."></a>.</h3><h4 id="26字母"><a href="#26字母" class="headerlink" title="26字母"></a>26字母</h4><pre class=" language-Python"><code class="language-Python">import stringalpha = string.ascii_lowercase</code></pre><h4 id="字符串反转"><a href="#字符串反转" class="headerlink" title="字符串反转"></a>字符串反转</h4><pre class=" language-Python"><code class="language-Python">>>>　s = 'abcde'>>>　print(s[::-1])edcba</code></pre><h4 id="字符串格式化输出"><a href="#字符串格式化输出" class="headerlink" title="字符串格式化输出"></a>字符串格式化输出</h4><p>个人喜欢最新的<code>&#39;{}&#39;.format()</code>的形式,不仅写起来更方便一些,还有旧方法不能实现的操作.感觉以后可能完全取缔旧的方法.</p><p><a href="https://pyformat.info/" target="_blank" rel="noopener">.format的介绍(与旧方法的对比)</a></p><p>输出一行 ‘-‘</p><pre class=" language-Python"><code class="language-Python">'{:-{align}{width}}'.format( '',align='>', width = 5)</code></pre><p>输出</p><pre><code>-----</code></pre><h2 id="函数-function"><a href="#函数-function" class="headerlink" title="函数(function)"></a>函数(function)</h2><p>可更改(mutable)与不可更改(immutable)对象<br>在 python 中，strings, tuples, 和 numbers 是不可更改的对象，而 list,dict 等则是可以修改的对象。</p><ul><li>不可变类型：变量赋值 a=5 后再赋值 a=10，这里实际是新生成一个 int 值对象 10，再让 a 指向它，而 5 被丢弃，不是改变a的值，相当于新生成了a。</li><li>可变类型：变量赋值 la=[1,2,3,4] 后再赋值 la[2]=5 则是将 list la 的第三个元素值更改，本身la没有动，只是其内部的一部分值被修改了。</li></ul><p>python 函数的参数传递：</p><ul><li>不可变类型：类似 c++ 的值传递，如 整数、字符串、元组。如fun（a），传递的只是a的值，没有影响a对象本身。比如在 fun（a）内部修改 a 的值，只是修改另一个复制的对象，不会影响 a 本身。</li><li>可变类型：类似 c++ 的引用传递，如 列表，字典。如 fun（la），则是将 la 真正的传过去，修改后fun外部的la也会受影响</li></ul><p>python 中一切都是对象，严格意义我们不能说值传递还是引用传递，我们应该说传不可变对象和传可变对象。</p><h3 id="-3"><a href="#-3" class="headerlink" title="."></a>.</h3><h4 id="eval"><a href="#eval" class="headerlink" title="eval()"></a>eval()</h4><p>eval(string) 对于一个字符串，相当与<strong>运行</strong>这个字符串所代表的python代码</p><pre class=" language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> x <span class="token operator">=</span> <span class="token number">1</span><span class="token operator">>></span><span class="token operator">></span> eval<span class="token punctuation">(</span><span class="token string">'x+1'</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span>eval<span class="token punctuation">(</span><span class="token string">'x+1'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">2</span></code></pre><h1 id="各种库"><a href="#各种库" class="headerlink" title="各种库"></a>各种库</h1><p>导入库</p><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> 库 <span class="token comment" spellcheck="true">#使用时需要 `库.函数()`</span><span class="token keyword">from</span> 库 <span class="token keyword">import</span> 函数 <span class="token comment" spellcheck="true"># 使用时直接 `函数()` 即可</span></code></pre><h2 id="collections"><a href="#collections" class="headerlink" title="collections"></a>collections</h2><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> collections</code></pre><h3 id="Counter"><a href="#Counter" class="headerlink" title="Counter"></a>Counter</h3><p>计数用的函数</p><h3 id="defaultdict"><a href="#defaultdict" class="headerlink" title="defaultdict"></a>defaultdict</h3><p>可以简单理解为一个<strong>map</strong>,</p><pre class=" language-python"><code class="language-python">a <span class="token operator">=</span> defaultdict<span class="token punctuation">(</span><span class="token punctuation">[</span>Type of value<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span>a<span class="token punctuation">[</span><span class="token string">'key'</span><span class="token punctuation">]</span> type <span class="token keyword">is</span> <span class="token punctuation">[</span>Type of value<span class="token punctuation">]</span></code></pre><h3 id="deque"><a href="#deque" class="headerlink" title="deque"></a>deque</h3><pre class=" language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">from</span> collections <span class="token keyword">import</span> deque<span class="token operator">>></span><span class="token operator">></span> d <span class="token operator">=</span> deque<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span> d<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span> ddeque<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span> d<span class="token punctuation">.</span>appendleft<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span> ddeque<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span> d<span class="token punctuation">.</span>clear<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span> ddeque<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span> d<span class="token punctuation">.</span>extend<span class="token punctuation">(</span><span class="token string">'1'</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span> ddeque<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'1'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span> d<span class="token punctuation">.</span>extendleft<span class="token punctuation">(</span><span class="token string">'234'</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span> ddeque<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'4'</span><span class="token punctuation">,</span> <span class="token string">'3'</span><span class="token punctuation">,</span> <span class="token string">'2'</span><span class="token punctuation">,</span> <span class="token string">'1'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span> d<span class="token punctuation">.</span>count<span class="token punctuation">(</span><span class="token string">'1'</span><span class="token punctuation">)</span><span class="token number">1</span><span class="token operator">>></span><span class="token operator">></span> d<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token string">'1'</span><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span> ddeque<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'4'</span><span class="token punctuation">,</span> <span class="token string">'3'</span><span class="token punctuation">,</span> <span class="token string">'2'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span> d<span class="token punctuation">.</span>popleft<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token string">'4'</span><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span> ddeque<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'3'</span><span class="token punctuation">,</span> <span class="token string">'2'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span> d<span class="token punctuation">.</span>extend<span class="token punctuation">(</span><span class="token string">'7896'</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span> ddeque<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'3'</span><span class="token punctuation">,</span> <span class="token string">'2'</span><span class="token punctuation">,</span> <span class="token string">'7'</span><span class="token punctuation">,</span> <span class="token string">'8'</span><span class="token punctuation">,</span> <span class="token string">'9'</span><span class="token punctuation">,</span> <span class="token string">'6'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span> d<span class="token punctuation">.</span>remove<span class="token punctuation">(</span><span class="token string">'2'</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span> ddeque<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'3'</span><span class="token punctuation">,</span> <span class="token string">'7'</span><span class="token punctuation">,</span> <span class="token string">'8'</span><span class="token punctuation">,</span> <span class="token string">'9'</span><span class="token punctuation">,</span> <span class="token string">'6'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span> d<span class="token punctuation">.</span>reverse<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span> ddeque<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'6'</span><span class="token punctuation">,</span> <span class="token string">'9'</span><span class="token punctuation">,</span> <span class="token string">'8'</span><span class="token punctuation">,</span> <span class="token string">'7'</span><span class="token punctuation">,</span> <span class="token string">'3'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span> d<span class="token punctuation">.</span>rotate<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span> ddeque<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'8'</span><span class="token punctuation">,</span> <span class="token string">'7'</span><span class="token punctuation">,</span> <span class="token string">'3'</span><span class="token punctuation">,</span> <span class="token string">'6'</span><span class="token punctuation">,</span> <span class="token string">'9'</span><span class="token punctuation">]</span><span class="token punctuation">)</span></code></pre><h1 id="自省"><a href="#自省" class="headerlink" title="自省"></a>自省</h1><h2 id="-4"><a href="#-4" class="headerlink" title="."></a>.</h2><h3 id="-5"><a href="#-5" class="headerlink" title="."></a>.</h3><h4 id="getattr"><a href="#getattr" class="headerlink" title="getattr()"></a>getattr()</h4><pre class=" language-python"><code class="language-python"><span class="token triple-quoted-string string">'''getattr(object, name[, default]) -> value其中 name 可以是字符串.这样的话 相当于 name可以用字符串代替 就不用一大堆`if elif else`了'''</span>getattr<span class="token punctuation">(</span>object<span class="token punctuation">,</span> name<span class="token punctuation">[</span><span class="token punctuation">,</span> default<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> value<span class="token operator">&lt;=</span><span class="token operator">=</span><span class="token operator">></span>object<span class="token punctuation">.</span>name<span class="token punctuation">(</span>value<span class="token punctuation">)</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试经历.</title>
      <link href="/2018/01/31/experienceofinterview/"/>
      <url>/2018/01/31/experienceofinterview/</url>
      
        <content type="html"><![CDATA[<blockquote><p>总结下所有的面试, 这样才能<strong>慢慢</strong>进步呀,,,,</p></blockquote><h2 id="哈尔滨某小公司-C-岗实习-现场面-offer"><a href="#哈尔滨某小公司-C-岗实习-现场面-offer" class="headerlink" title="哈尔滨某小公司 - C++岗实习 [现场面] - offer"></a>哈尔滨某小公司 - C++岗实习 [现场面] - offer</h2><p>除了问一个多态,没有技术问题,大概是给答上了 意思对,但不专业</p><hr><p>小公司估计是真的没人了,,,,待遇实在…拒绝</p><h2 id="头条-后台开发实习生-视频面试-一面-跪"><a href="#头条-后台开发实习生-视频面试-一面-跪" class="headerlink" title="头条 - 后台开发实习生 [视频面试] 一面 - 跪"></a>头条 - 后台开发实习生 [视频面试] 一面 - 跪</h2><p>可能是紧张吧,开始闲聊然后给了个编程题<br>给一个化学表达式</p><pre class=" language-math"><code class="language-math">eg: HMg_{_2}(H_2O(N_3Ag)_2)_3N_2</code></pre><p>,让算每个元素有多少个.</p><p>这种题本就不难 问题就是怎么处理括号<br>之前在hiho上还遇到过类似的问题<a href="http://www.hihocoder.com/contest/offers41/problem/2" target="_blank" rel="noopener">http://www.hihocoder.com/contest/offers41/problem/2</a></p><p>然后不知道紧张还是什么的就写的很乱,然后面试官提示递归,然后墨迹了好久才用stack写了下来…..</p><p>因为我没有项目,就没有问项目.<br>然后问我们学了数据库,操作系统,网络没有,,,,   嗯 学校确实讲过,但我没听过课…</p><p>问了个进程调度,</p><p>我就知道有个算法叫FIFO, 具体是啥还忘了, 然后说错了,,GG</p><p>然后唠了两句面试官说结束,等HR通知,,,  嗯.感谢面试官浪费40+分钟陪我 hhhh.</p><hr><p>总结:<br>有点紧张. 代码能力差 ,<strong>[数据库,操作系统,网络]</strong> 知识严重匮乏.</p><p>之前看面经说,遇到不会的或者把不准的都应该说<strong>不会</strong>. 下次注意.</p><h2 id="达内-NOIP助教-现场面"><a href="#达内-NOIP助教-现场面" class="headerlink" title="达内 - NOIP助教 现场面"></a>达内 - NOIP助教 现场面</h2><p>达内这个大家都懂.</p><p>突然有天接到达内一个经理的电话,问我能不能去当助教,去教小朋友普及组的NOIP.<br>我心想,这也还不错呀.<br>然后去了,开始跟我吹了1个小时的牛逼,达内多么多么牛逼.怎么怎么地.<br>然后给了我一份NOIP普及组的题让我做..</p><p>说来惭愧,中文题面,我竟读错一道题卡了好久,,,然后花了1个多小时终于把4个题做出来了,最后一题还做得很麻烦…<br>然后来了一个小伙子,谈了谈对NOIP的认识,以及我的学习情况.<br>交上去给了一个小姐姐,然后看见三个人对着电脑看了半天..</p><p>然后说一定要一年,但我最多只能半年,于是据.</p><hr><p>体验美滋滋,没有麻烦的题目,没有操作系统,没有计算机网络,没有数据库.真棒 hhh</p><h2 id="深信服-C-C-电话面试-一面-估计跪了"><a href="#深信服-C-C-电话面试-一面-估计跪了" class="headerlink" title="深信服 - C/C++ 电话面试 一面-估计跪了"></a>深信服 - C/C++ 电话面试 一面-估计跪了</h2><p>深圳打来的电话, 不知道哪里人, 浓重的方言口音, 他说话我都要问好多遍才能听懂…交流真滴有障碍…</p><p>一共22分钟,三个问题</p><p>1 . 两个字符串,一个大串,一个小串,问小串是不是大串的子串(不连续)的.</p><p>我回答了: 遍历大串,然后对小串维护一个遍历的指针就行了</p><p>然后他说不是他想要的,问的是正则?</p><p>我记得有正则查询可以模糊匹配,只要在两个相邻的字母中插进去就好了,,但我忘记了具体插什么,</p><p>结束后一查知道是 <code>.*</code> [. 匹配任意非\n的字符 *是0个或多个]</p><p>2 . 给一个100万的字符串,然后找到最短的循环覆盖的子串.</p><p>我开始以为是ABCABC这样的 最短就是ABC了 ,拿next数组直接做就行了,</p><p>然后说了半天,最后知道,他说的可以是这样ABCABCAB,还可以是ABC</p><p>想了想发现和之前的一样, 还是求next数组,然后就可以把结尾的AB给去掉了,然后就和之前一样了.</p><p>然后不知怎么就陷入了一阵交流障碍,我不知道他说的啥,他不知道我说的啥.</p><p>然后我发现他是想让我说一下next怎么求…</p><p>想了想,不能画图 怎么说呀, 问写代码行吗, 额 他也看不见….</p><p>然后勉强解释了下 维护两个指针,一个i遍历大串,j是维护匹配到的位置,balabala的,</p><p>也不知道他明白没有…</p><hr><p>然后他问我用linux还是windows多,</p><p>我说用过linux,但还是windows多.</p><p>然后问我一个问题,我听成了python.. 我说我会python…..但他好像问的根本不是这个问题,,,</p><hr><p>3 . 最后问我进程的内存分布</p><p>我不会呀..</p><p>说了一个堆栈..就说不知道了, </p><p>于是结束…</p><p>目测GG</p><hr><p>总结: 说好的12点,结果15点电话过来了,,,措手不及,以为没我事儿了呢,</p><p>交流障碍导致前面两个问题说的不太好,而且电话面试真的不如视频面试呀,更别说现场面试了,,,后面确实不会, 操作系统,网络,数据库 多看看呀..</p><h2 id="阿里云-分布式-大数据-基础平台研发工程师实习-电话面试-一面-跪了"><a href="#阿里云-分布式-大数据-基础平台研发工程师实习-电话面试-一面-跪了" class="headerlink" title="阿里云, 分布式,大数据   - 基础平台研发工程师实习 电话面试 一面-跪了"></a>阿里云, 分布式,大数据   - 基础平台研发工程师实习 电话面试 一面-跪了</h2><p>redis和MongoDB的区别。 谈一谈这两个数据库 。   (他以为我是自己搭建的数据库，，但我就是安装然后用的呀)<br>说一下大数据: hadoop - HDFS，hive 和 MapReduce ，问哪个是存储的，脑抽说了个hive，，， 后来改正了，然后问HDFS里面都有什么，答NameNode 和 DataNode，<br>问我还有什么，我不知道，他告诉我还有sdk。</p><p>然后让我说竞赛中做过的经典，印象深刻的题目，想了好久，随便说了一个题，题目不怎么难，其实说的很模糊，而且说的时候还把那个题给弱化了，，记不太清那个题目了，</p><p>然后问了我一个问题，现在都没想明白，说HDFS传3个副本，然后又客户在另一端访问这个。 然后是传完这<strong>三</strong>个副本告诉客户传完了有一个延迟时间，这<strong>两</strong>个副本告诉客户传完了有一个延迟时间，，<br>两个的会比三个的地低，<br>然后给初问题，给一个T，求N，M。 T是客户允许的最长延迟时间，N是副本总数，M是传完M个告诉客户传完了。<br>我只知道可以通过传好多次 算一个副本的时间t，但是不会算大T， 跟概率，期望，有关</p><p>最后让写了一个编程题，很简单的n个区间 问覆盖的长度总和是多少。 谈了50多分种 脑子有点蒙，写了好几分钟。。 但他看了好长时间，难道是我写的错啦？？。。</p><p>然后问了面试官几个问题，<br>大数据如何高效学习，论文，跟进<br>分布式如何学习，</p><p>他们这个是做底层的，，，</p><p>然后就是如果通过了 下次面试是什么时候，，，，但估计没有下次了，，，，，</p><hr><p>虽然啥都不会，什么都没有答上来。 体验非常好的一次面试，面试官人特别好，面对我这样的垃圾面试人员，应该很无奈，但依然很耐心的面试我，最后还提了好多问题。</p><p>但是很奇怪，这次竟然一点操作系统和数据结构的问题都没有问， 之前看到牛客网一个基础平台研发，问了这些问题的呀。</p><h2 id="瓜子二手车-后台研发实习生-现场一二面-给了offer邀请"><a href="#瓜子二手车-后台研发实习生-现场一二面-给了offer邀请" class="headerlink" title="瓜子二手车 后台研发实习生 现场一二面, 给了offer邀请."></a>瓜子二手车 后台研发实习生 现场一二面, 给了offer邀请.</h2><ul><li><p>1面<br>  自我介绍,没准备,随便说了下<br>  唠了两句家常.</p><p>  绳子不均匀,燃烧的问题,一根绳子1个小时烧完.<br>  怎么找30分钟,75分钟.</p><p>  说下栈和队列<br>  双栈怎么实现队列</p><p>  计算机网络的几个零碎的小问题,没记住.</p><p>  然后写了两个代码题</p><ul><li>交叉的链表,找交叉的位置,<br>链表的代码思路对,但是head节点没有val这点被我忘记了</li><li><p>单链表找倒数第k个节点,</p><p>数据库索引怎么实现的 -&gt; b+树<br>b+树为什么会快 -&gt; 搜索树,有剪枝<br>非**和**的区别 -&gt; 不知道,没听说过 (告诉我是 index 和 index+data的区别,名字想不起来了)<br>数据库事务的四个特性ACID -&gt; 我分不清那个是哪个了,就举个例子说了,<br>还有两个数据库的问题,想不起来了,</p><p>问问题,问了技术栈和分布式的东西.</p></li></ul></li><li><p>2面<br>  领我进去的小哥哥说是总监面</p><p>  自我介绍.唠家常.</p><p>  两个集合求交,写代码 谢了归并排序+二分, 然后过了会说了个更简单的方法,</p><p>  几个小问题,没记住</p><p>  给我写了几个词,让我谈一谈</p><ul><li>set,stack,链表,数组,map,hash</li><li><p>tcp,udp,http,https,ftp</p><p>聊了聊最近在学习什么.说我基础薄弱..</p><p>问问题. 问了职业规划.答:选择做技术就一直做技术.</p></li></ul></li></ul><hr><p>可能因为是小公司吧,问的问题都比较简单.算法为了体现水平,学习了网上的套路,先给出一个不是很好的做法,然后再给一个优秀的做法.[斜眼笑]<br>走的时候小哥哥看了看评价表和我说不错,应该很稳,让我回去等消息就行啦.<br>面试官都很随和,出去的时候和一个工大研一的同来面试的小哥哥聊天才知道那个总监挺牛逼的.</p><h2 id="今日头条-后端研发实习生-12面-GG"><a href="#今日头条-后端研发实习生-12面-GG" class="headerlink" title="今日头条 后端研发实习生  - 12面 [GG]"></a>今日头条 后端研发实习生  - 12面 [GG]</h2><h3 id="一面"><a href="#一面" class="headerlink" title="一面"></a>一面</h3><p>一面直接给了一个问题,<br>S_0 = {1}<br>S_0 = {1,2,1}<br>…<br>S_n = S_{n-1},n+1,S_{n-1}</p><p>问: 1. |S_n|  开始嘴飘,想当然的就说了,,后来说对了 2^{n+1}-1<br>            然后让我证明,,, 不会证,,,</p><pre><code>2. 让实现一个函数int get_value(int n,int i) ,S_n的第i个元素,从0开始,,,,    然后我写了一个从1开始的,就被嘲讽了,,,然后一个变量打错,被指漏洞百出...    准备说的最优解还没有开始,就不理我了, (第i个数就是0~2^{n+1}-1的第i个数二进制小的最后一个一的长度,或者理解为lowbit(i)的二进制长度)</code></pre><p>然后有趣,hr给我打电话,委婉的告诉我挂了,,然后突然来了二面,,,,,</p><h3 id="二面"><a href="#二面" class="headerlink" title="二面"></a>二面</h3><p>好吧,二面,啥都不会呀 …</p><p>开始看了我一面写的代码,说风格太老了,,,现在C11已经不这么写了,,</p><p>然后问我平时用的数据结构是stl的还是C11的,,讲道理我只知道STL的,不知道c11有什么数据结构,难道是传说中的那个能重写pushup,pushdown的内个??</p><p>谈了谈我用到的那些数据结构,说我只用过基础的数据结构,,<br>然后让说了一下vector的实现,我就说了一下仅了解的它为什么能像数组那个用,,</p><p>然后问一堆c11的问题,动态指针什么的,不会</p><p>其中夹杂着问</p><p>问会计组么,,tm不会呀,说你问吧,我试试<br>问了int是反码还是补码,隐隐约约记得是补码,磨磨唧唧说了,</p><p>问socket编程, 不会, 没接触过.<br>问多线程编程, 我说接触过一点点, 只写过多线程循环打印的.</p><pre><code>class Test{    private int a;    private int b;    int test(){};}struct Test2{    int a;    char b;    char c;}sizeof(Test)是多少. 我说12 ,(不知道对错,开始答8然后他沉默就改了, **其实就是8** )  sizeof(Test2)是多少. 我说8 , 因为要内存对齐</code></pre><p>让我写一个函数验证机器的大小端 表示不知道大小端是什么,</p><pre><code>int main(){    int a = 1;    char s = *(char *)&amp;a;    if(s == 1) puts(&quot;small&quot;);    else       puts(&quot;big&quot;);}</code></pre><p>class 和 struct的区别, 只知道class默认是private,struct默认是public, 问我还有什么 不知道</p><p>问我sizeof(一个指针)是多少,不知道,叨咕了一个8,然后他告诉我32位机器是4,64位机器是8;</p><p>给了一个代码</p><pre><code>void test(int *p){    p = (int *)malloc(sizeof(int))}</code></pre><p>问p改没改变</p><p>蒙的改变, p指向了新开辟的那个地址.</p><p>编程题,大数加法,不让用char a[],只让用string… 写的稍墨迹</p><p>然后问string += 和 +的区别</p><p>就是 a+=b 和a=a+b<br>表示没看过string源码,也不了解string咋实现的,类比vector说了一下. 又错了</p><p>问数据库, 我说了解的不是很深入, 然后就没问. (其实以后应该说,试一试,,)</p><p>然后就问问题,唠家常了,,,,</p><p>最后再见,</p><p>结果在一个小时之内,听到了两次同一个hr小姐姐的拒绝电话,,,,</p><hr><p>体验是真几把刺激,面挂了一面还面了第二面,hhhh,于是二面的时候就很懵逼,,,</p><p>但是确实啥都不会呀….</p><p>总结就是多学习吧. </p><p>但是有个大失误,问计网,操作系统,数据库的时候,应该说试一下的,,毕竟还是看了一些的呀,多少还是能答上来一点的,,</p><h2 id="美团-后台开发-搞笑"><a href="#美团-后台开发-搞笑" class="headerlink" title="美团 后台开发 (搞笑)"></a>美团 后台开发 (搞笑)</h2><p>开始自我介绍,聊了聊最近看什么数,还有数据库啥的</p><p>十分钟过后,跟我说只要Java, 不合适, 嗯 ,然后88</p><hr><p>傻逼美团,怎么筛选的简历,岗位要求上不是写的4中语言之一吗,,,,,而且不准备培养实习生的吗,,还听说之前实习生一个转正的都没有??!</p><h2 id="吉比特-游戏开发-实习"><a href="#吉比特-游戏开发-实习" class="headerlink" title="吉比特 游戏开发(实习)"></a>吉比特 游戏开发(实习)</h2><h3 id="一面-1"><a href="#一面-1" class="headerlink" title="一面"></a>一面</h3><p>自我介绍<br>多线程<br>内联函数和宏函数<br>python闭包<br>socket编程<br>函数内的malloc 存在哪里<br>内联函数<br>右值引用<br>进程间通信<br>连续子序列最大和<br>vector<br>set 和 map的底层数据结构<br>hash冲突解决<br>内存泄漏解决<br>C++调用函数<br>虚析构函数<br>一个文本相同的行去除, 保留第一个 (内存存的下/存不下)<br>还有问题 记不起来了</p><hr><p>表现很差呀, 算法也没有问，代码都没让写，，，</p><h2 id="腾讯-后台开发-实习"><a href="#腾讯-后台开发-实习" class="headerlink" title="腾讯 后台开发(实习)"></a>腾讯 后台开发(实习)</h2><h3 id="一面-2"><a href="#一面-2" class="headerlink" title="一面"></a>一面</h3><p>自我介绍,</p><p>闲聊<br>介绍了ACM比赛<br>最近在干什么</p><p>技术上的问了<br>网络编程接触过没 -&gt;没接触过<br>数据一致性怎么保证 -&gt; 不会<br>两个文件都是100W个整数,找出相同的 -&gt; 排序,然后归并的过程<br>进程间通信 并举例说出场景 -&gt; 管道不知道,剩下三个举例了,<br>说说STL -&gt; 说了下vector怎么保证可变长度而且复杂度还是O(1),map和set都是红黑树啥啥啥的<br>new/delete 和malloc/free的区别 -&gt; 说没怎么用过后者,一直用前者,因为后者长.面试官笑..然后说了几个new/delete使用的时候需要注意的问题.<br>谈到指针,问多线程删除map元素怎么办 -&gt; 先回答把多个线程要删除的记下来,然后统一删除, 他说可以, 但是希望我在指针的方式考虑, 想了想不会, 他让我回去看下map的源码关于元素删除的部分, 看过之后会有想法.<br>多线程有什么了解 -&gt; 说了下ABC循环打印的那个, 然后就没有了<br>高并发怎么处理, -&gt; 读的不加锁,写的加锁<br>接上个问我脏读怎么办 -&gt; 我说加个时间戳,他说不太好,然后不会了<br>对安全了解多少 -&gt; 把只会的凯撒加密和RSA加密说了说<br>对称加密和非对称加密 -&gt; 忘记了,说不太清了,告诉他不强答<br>C++的封装/继承/多态-&gt; 说了说多态和继承,封装我觉得没啥说的呀,,</p><p>还有几个问题,忘了</p><p>非技术问题<br>说给我安排一个任务,一周上线,这个任务我现在不会,怎么办 -&gt; 我觉得时间够用,没有问题,2天时间学习,3天时间实现, 具体实施的时候先请教别人,翻论文<br>如果我现在时间很紧的赶一个任务,有人请教我会的东西,我怎么做 -&gt; 甩给他相关的资料让他自己学习, 如果还不懂,粗浅的指点一下  还不懂,就对不起了,(这个很坑呀,步步紧逼)</p><p>问问题<br>就问了怎么学习linux,<br>之前准备问的问题,都忘记问了</p><hr><p>面试官挺随和的, 开始挺紧张的 ,后来就不紧张了, 现场面试还是比电面/视频面舒服.<br>过程就像实在闲聊<br>还是什么都不会, 面试官让我把学习重心放在网络编程和安全这方面,说用到的多,学习的时候多看看源码.</p><h3 id="二面-1"><a href="#二面-1" class="headerlink" title="二面"></a>二面</h3><p>问的和一面差不多,<br>多问了几个小问题而已</p><p>数据库的东西问了很多, 但不会<br>然后和一面有重复的问题,但是昨天回去查了下,答得比较完整<br>Hash处理冲突,解决办法<br>内存泄露的时候如何定位 -&gt; 说调用系统的函数监控内存<br>内存分布 -&gt; 有一个忘记了,其他的说的没问题<br>进程调度算法 -&gt; 先到先服务 , 短作业优先, 多级反馈队列<br>接上个问现在系统的调度算法 -&gt; 在提示说同时能音乐,处理网页这些 想起来时间片轮转算法,说了些,<br>std::sort()怎么实现的 -&gt; 内省排序,<br>接上个std::sort()什么时候采用插入排序,归并排序,快排 -&gt; 举了什么时候插排会更快, 和归并是为了防止快排退化 balabala</p><p>剩下的暂时想不起来了,</p><hr><p>面试官看起来挺年轻的, 数据库东西确实不太会, 而且又没让写代码, 以为凉凉了,,,<br>5点多接到明天hr面的消息,</p><h2 id="旷视-Face-后台实习生"><a href="#旷视-Face-后台实习生" class="headerlink" title="旷视 Face++   后台实习生"></a>旷视 Face++   后台实习生</h2><h3 id="一面-3"><a href="#一面-3" class="headerlink" title="一面"></a>一面</h3><p>就两个问题<br>一个拓扑排序,拓扑序计数,<br>一个二分check的问题</p><p>开始网站打不开,只写了第二个的代码</p><p>然后就问我最近学什么, 以后的方向什么的 聊了好久</p><p>问了几个问题就结束了</p><hr><p>感觉不错,面试官说重视的就是coding能力,其他的都可以在学,<br>等消息<br><del>智障,问面试官需要什么样的人才,说我这样的,一周后问面试官,说挂了</del></p><h2 id="京东云-C-实习"><a href="#京东云-C-实习" class="headerlink" title="京东云 C++(实习)"></a>京东云 C++(实习)</h2><h3 id="一面-4"><a href="#一面-4" class="headerlink" title="一面"></a>一面</h3><p>刚面完腾讯的hr面回来到实验室扯了两句,就收到面试了</p><p>给了个写代码的网页死活打不开,然后就改手写发照片了<br>写了一个矩阵,一层一层输出的代码</p><p>然后说了C++的stl<br>vector的变长机制<br>平衡树</p><p>tcp的三次握手,四次挥手,为什么三次,为什么四次<br>网络分层,说了下osi的七层<br>问tcp在那层,不知道,猜了个网络层,,,然后面试官问tcp的t是什么,想起是transfer,说出了传输层</p><p>然后还有几个问题,忘了</p><h2 id="日常问面试官问题结束"><a href="#日常问面试官问题结束" class="headerlink" title="日常问面试官问题结束"></a>日常问面试官问题结束</h2><p>面试官挺nice的</p><h3 id="二面-2"><a href="#二面-2" class="headerlink" title="二面"></a>二面</h3><p>感觉效率很高 上午面完下午5点就来二面了,</p><p>面向对象编程谈谈<br>C++ stl<br>内存分布<br>网络的那几个老生常谈的问题<br>进程间通信<br>数据库谈了谈</p><p>一个linux 操作的问题,不会</p><p>还有几个问题 忘了</p><h3 id="hr面"><a href="#hr面" class="headerlink" title="hr面"></a>hr面</h3><p>因为一二面是周五 周一去考科四的时候来的电话</p><p>瞎聊天 结束</p>]]></content>
      
      
      <categories>
          
          <category> 求职 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> C++ </tag>
            
            <tag> 数据库 </tag>
            
            <tag> 操作系统 </tag>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试学习.</title>
      <link href="/2018/01/29/studyofinterview/"/>
      <url>/2018/01/29/studyofinterview/</url>
      
        <content type="html"><![CDATA[<blockquote><p>记录下我针对面试的学习</p></blockquote><h2 id="算法-编程题"><a href="#算法-编程题" class="headerlink" title="算法/编程题"></a>算法/编程题</h2><h3 id="a"><a href="#a" class="headerlink" title="a"></a>a</h3><h4 id="√-荷兰国旗问题"><a href="#√-荷兰国旗问题" class="headerlink" title="[√]荷兰国旗问题"></a>[√]<a href="http://acm.nyist.edu.cn/JudgeOnline/problem.php?pid=268" target="_blank" rel="noopener">荷兰国旗问题</a></h4><p> 噗 , 被高大上的名字给吓到了,其实就是简单的C语言入门题.</p><h4 id="实现一个LRU算法"><a href="#实现一个LRU算法" class="headerlink" title="实现一个LRU算法"></a>实现一个LRU算法</h4><h4 id="√-双栈实现一个队列"><a href="#√-双栈实现一个队列" class="headerlink" title="[√]双栈实现一个队列"></a>[√]双栈实现一个队列</h4><p><a href="https://github.com/tabris233/slove-problems/blob/master/2018-1/29/QUEUE-two%20stack.cpp" target="_blank" rel="noopener">实现代码</a></p><h4 id="√-编程题"><a href="#√-编程题" class="headerlink" title="[√]编程题"></a>[√]编程题</h4><p>问题: 两个数组 A 表示一串螺丝 B 表示一串螺帽 螺丝和螺帽能够配对，但是A中螺丝之间不能比较大小，B中螺帽之间也不能比较大小，螺丝和螺帽可以比较大小，返回所有螺丝和螺帽的对应关系，要求复杂度小于O(n^2)</p><p>解: 类似快速排序,一个和另一个比较就可以了.<br><a href="https://github.com/tabris233/slove-problems/blob/master/2018-1/30/%E8%9E%BA%E4%B8%9D%E5%92%8C%E8%9E%BA%E5%B8%BD.cpp" target="_blank" rel="noopener">code</a></p><h4 id="今日头条笔试真题"><a href="#今日头条笔试真题" class="headerlink" title="今日头条笔试真题"></a>今日头条笔试真题</h4><p><a href="https://www.nowcoder.com/test/8537140/summary" target="_blank" rel="noopener">https://www.nowcoder.com/test/8537140/summary</a></p><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><h3 id="算法与数据结构"><a href="#算法与数据结构" class="headerlink" title="算法与数据结构"></a>算法与数据结构</h3><h3 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h3><h4 id="一个进程"><a href="#一个进程" class="headerlink" title="一个进程"></a>一个进程</h4><p>一个进程是<strong>PCB结构与程序与数据的组合</strong></p><h4 id="产生死锁的必要条件"><a href="#产生死锁的必要条件" class="headerlink" title="[-]产生死锁的必要条件"></a>[-]产生死锁的必要条件</h4><ul><li><p>互斥条件: 即某个资源在一段时间内只能由一个进程占有,不能同事被两个或两个以上的进程占有.这种独占资源如CD-ROM驱动器,打印机等等,必须在占有该资源的进程主动释放它之后,其他进程才能占有该资源.这是有资源本身的属性所决定的.如独木桥就是一种独占资源,两方的人不能同时过桥.</p></li><li><p>不可抢占条件: 进程所获得的资源在未使用完毕之前,资源申请者不能强行地从资源占有者中夺取资源.而只能由该资源的占有者进程自行释放.如过独木桥的人自己不能强迫对方后退,也不能非法地将对方退下桥,必须是桥上的人自己过桥后空出桥面(即主动释放占有资源),对方的人才能过桥.</p></li><li><p>占有且申请条件: 进程至少已经占有一个资源,但又申请新的资源; 由于该资源已经被另外进程占有,此时该进程阻塞; 但是,它在等待新资源之时,扔继续占用已占有的资源.还以过独木桥为例,甲乙两人在桥上相遇. 甲走过一段桥面(即占有了一些资源),还需要走其余的桥面(申请新的资源),但那部分桥面被已占有(已走过一段桥面).甲过不去,前进不能,又不后退;乙也处于同样的状况.</p></li><li><p>循环等待条件: 存在一个进程等待序列{P1,P2, … ,Pn}, 其中P1等待P2所占有的某一资源, P2等待P3所占有的某一源, …… ,而Pn等待P1所占有的某一资源形成一个进程循环等待环.就像前面的过独木桥问题,甲等待乙占有的桥面,而乙有等待甲占有的桥面, 从而彼此循环等待.</p></li></ul><h4 id="死锁预防"><a href="#死锁预防" class="headerlink" title="[-]死锁预防"></a>[-]死锁预防</h4><ul><li><p>打破互斥条件: 即允许进程同事访问某些资源.但是,有的资源不允许被同时访问的,像打印机等等.这是由资源本身的属性所决定的. 所以,这种办法并无实用价值</p></li><li><p>打破不可抢占条件: 即允许进程强行从占有者哪里夺取某些资源. 就是说, 当一个进程已占有了某些资源,他又申请新的资源,但不能立即被满足,它必须释放所占有的全部资源, 以后再重新申请. 他所释放的资源可以分配给其他进程.这就相当于该进程占有的资源被隐蔽性地强占了. 这种预防死锁的方法实现起来困难,会降低系统性能.</p></li><li><p>打破占有且申请条件: 可以实行资源预先分配策略. 即进程在运行前一次地向系统申请它所需要的全部资源. 如果某个进程所需的全部资源得不到满足,则不分配任何资源,此进程在不运行.只有当系统能够满足当前进程的全部资源需求时,才一次性地将所申请的资源全部分配给该进程. 由于运行的进程已占有它所需要的全部资源所以不会发生占有资源有申请资源的现象, 因此不会发生死锁. 但是,这种策略也有如下缺点:</p><ul><li>在许多情况下,一个进程在执行之前不可能知道它所需要的全部资源. 这是由于进程在执行时是动态的,不可预测的.</li><li>资源利用率低.无论所分资源何时用到,一个进程只有在占有所需要的全部资源后才能执行.即使有些资源最后才被该进程用到一次,但该进程生存期间一直占有他们,造成长期占着不用的状况.这显然是一种极大的资源浪费.</li><li>降低了进程的并发性.因为资源有限,又加上存在浪费,能分配到所需全部资源的进程个数就必然少了.</li></ul></li><li>打破循环等待条件:<strong>实行资源有序分配策略</strong>.采用这种策略,即把资源事先分类编号,按号分配,使进程在申请,占用资源是不会形成环路.所有进程对资源的请求必须严格按字元序号递增的顺序提出.进程占用了小号资源,才能申请大耗资源,就不会产生环路, 从而预防了死锁.这种策略与前面的策略相比, 资源的利用率和系统的吞吐量都有了很大的提高,但是也存在一下缺点:<ul><li>限制了进程对资源的请求,同事给系统中所有资源合理编号也是件困难时,并增加了系统的开销.</li><li>为了遵循按编号申请的次序,在不使用的资源也需要提前申请,从而增加了进程对资源的占用时间.</li></ul></li></ul><h4 id="死锁避免"><a href="#死锁避免" class="headerlink" title="死锁避免"></a>死锁避免</h4><ul><li>银行家算法<br>系统给当前进程分配资源时,先检查是否安全.<br>在满足当前的进程X资源申请后,是否还能有足够的资源去满足下一个距最大资源需求最近的进程(如某进程最大需要5个单位资源,已拥有1个,还需4个),若可以满足,则继续检查下一个距最大资源需求最近的进程,若均能满足所有进程,则表示为安全,可以允许给当前进程X分配其所需的资源申请,否则让该进程X进入等待.</li><li>哲学家进餐问题</li></ul><h4 id="进程和线程的区别"><a href="#进程和线程的区别" class="headerlink" title="[-]进程和线程的区别"></a>[-]进程和线程的区别</h4><blockquote><p>定义<br><strong>进程</strong>是具有一定独立功能的程序关于某个数据集合上的一次运行活动,进程是系统进行资源分配和调度的一个独立单位.<br><strong>线程</strong>是进程的一个实体,是CPU调度和分派的基本单位,它是比进程更小的能独立运行的基本单位.线程自己基本上不拥有系统资源,只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈),但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源.<br>关系<br>一个线程可以创建和撤销另一个线程;同一个进程中的多个线程之间可以并发执行.<br>相对进程而言，线程是一个更加接近于执行体的概念，它可以与同进程中的其他线程共享数据，但拥有自己的栈空间，拥有独立的执行序列。<br>区别<br>进程和线程的主要差别在于它们是不同的操作系统资源管理方式。进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，而线程只是一个进程中的不同执行路径。线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个线程死掉就等于整个进程死掉，所以多进程的程序要比多线程的程序健壮，但在进程切换时，耗费资源较大，效率要差一些。但对于一些要求同时进行并且又要共享某些变量的并发操作，只能用线程，不能用进程。</p><blockquote><p>简而言之,一个程序至少有一个进程,一个进程至少有一个线程.<br>线程的划分尺度小于进程，使得多线程程序的并发性高。<br>另外，进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率。<br>线程在执行过程中与进程还是有区别的。每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。<br>从逻辑角度来看，多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。但操作系统并没有将多个线程看做多个独立的应用，来实现进程的调度和管理以及资源分配。这就是进程和线程的重要区别。<br>优缺点<br>线程和进程在使用上各有优缺点：线程执行开销小，但不利于资源的管理和保护；而进程正相反。同时，线程适合于在SMP机器上运行，而进程则可以跨机器迁移。</p></blockquote></blockquote><h4 id="进程间通信"><a href="#进程间通信" class="headerlink" title="[]进程间通信"></a>[]进程间通信</h4><p>####### 为什么需要进程间通信？？</p><p>进程是一个独立的资源分配单元，不同进程（这里所说的进程通常指的是用户进程）之间的资源是独立的，没有关联，不能在一个进程中直接访问另一个进程的资源（例如打开的文件描述符）。</p><p>但是，进程不是孤立的，不同的进程需要进行信息的交互和状态的传递等，因此需要进程间通信( IPC：Inter Processes Communication )。</p><p>进程间通信的目的：</p><ul><li>数据传输：一个进程需要将它的数据发送给另一个进程。</li><li>通知事件：一个进程需要向另一个或一组进程发送消息，通知它（它们）发生了某种事件（如进程终止时要通知父进程）。</li><li>资源共享：多个进程之间共享同样的资源。为了做到这一点，需要内核提供互斥和同步机制。</li><li>进程控制：有些进程希望完全控制另一个进程的执行（如 Debug 进程），此时控制进程希望能够拦截另一个进程的所有陷入和异常，并能够及时知道它的状态改变。<br>Linux 操作系统支持的主要进程间通信的通信机制：</li></ul><p><img src="../images/StudyOfInterview/jcjtx.jpg" alt="进程间通信-1" title="进程间通信"></p><h6 id="进程间通信-IPC-介绍"><a href="#进程间通信-IPC-介绍" class="headerlink" title="进程间通信(IPC)介绍"></a><a href="https://www.cnblogs.com/CheeseZH/p/5264465.html" target="_blank" rel="noopener">进程间通信(IPC)介绍</a></h6><h4 id="进程调度"><a href="#进程调度" class="headerlink" title="[]进程调度"></a>[]进程调度</h4><h4 id="进程的内存分布"><a href="#进程的内存分布" class="headerlink" title="[]进程的内存分布"></a>[]进程的内存分布</h4><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>代码段</td><td>全局常量（const）、字符串常量、函数以及编译时可决定的某些东西</td></tr><tr><td>数据段</td><td>存储初始化的全局变量 和 初始化的静态变量(全局和局部)</td></tr><tr><td>BSS段</td><td>存储未初始化的全局变量 和 未初始化的静态变量(全局和局部)</td></tr><tr><td>堆</td><td>动态分配的区域（malloc、new等）</td></tr><tr><td>栈</td><td>l临时声明的局部变量(初始化以及未初始化的,但不包含静态变量),局部常量(const)</td></tr><tr><td>命令行参数和环境变量</td><td>顾名思义</td></tr></tbody></table><p><img src="https://images2015.cnblogs.com/blog/978007/201702/978007-20170208113706760-1208301174.png" alt></p><h4 id="进程调度-1"><a href="#进程调度-1" class="headerlink" title="进程调度"></a>进程调度</h4><ul><li><p>先来先服务 （FCFS，first come first served）<br>在所有调度算法中，最简单的是非抢占式的FCFS算法。<br>算法原理：进程按照它们请求CPU的顺序使用CPU.就像你买东西去排队，谁第一个排，谁就先被执行，在它执行的过程中，不会中断它。当其他人也想进入内存被执行，就要排队等着，如果在执行过程中出现一些事，他现在不想排队了，下一个排队的就补上。此时如果他又想排队了，只能站到队尾去。<br>算法优点：易于理解且实现简单，只需要一个队列(FIFO)，且相当公平<br>算法缺点：比较有利于长进程，而不利于短进程，有利于CPU 繁忙的进程，而不利于I/O 繁忙的进程</p></li><li><p>最短作业优先（SJF, Shortest Job First）<br>短作业优先（SJF, Shortest Job First）又称为“短进程优先”SPN(Shortest Process Next)；这是对FCFS算法的改进，其目标是减少平均周转时间。<br>算法原理：对预计执行时间短的进程优先分派处理机。通常后来的短进程不抢先正在执行的进程。<br>算法优点：相比FCFS 算法，该算法可改善平均周转时间和平均带权周转时间，缩短进程的等待时间，提高系统的吞吐量。<br>算法缺点：对长进程非常不利，可能长时间得不到执行，且未能依据进程的紧迫程度来划分执行的优先级，以及难以准确估计进程的执行时间，从而影响调度性能。</p></li><li><p>最高响应比优先法(HRRN，Highest Response Ratio Next)<br>最高响应比优先法(HRRN，Highest Response Ratio Next)是对FCFS方式和SJF方式的一种综合平衡。FCFS方式只考虑每个作业的等待时间而未考虑执行时间的长短，而SJF方式只考虑执行时间而未考虑等待时间的长短。因此，这两种调度算法在某些极端情况下会带来某些不便。HRN调度策略同时考虑每个作业的等待时间长短和估计需要的执行时间长短，从中选出响应比最高的作业投入执行。这样，即使是长作业，随着它等待时间的增加，W / T也就随着增加，也就有机会获得调度执行。这种算法是介于FCFS和SJF之间的一种折中算法。<br>算法原理：响应比R定义如下： R =(W+T)/T = 1+W/T<br>其中T为该作业估计需要的执行时间，W为作业在后备状态队列中的等待时间。每当要进行作业调度时，系统计算每个作业的响应比，选择其中R最大者投入执行。<br>算法优点：由于长作业也有机会投入运行，在同一时间内处理的作业数显然要少于SJF法，从而采用HRRN方式时其吞吐量将小于采用SJF 法时的吞吐量。<br>算法缺点：由于每次调度前要计算响应比，系统开销也要相应增加。</p></li><li><p>时间片轮转算法（RR，Round-Robin）<br>该算法采用剥夺策略。时间片轮转调度是一种最古老，最简单，最公平且使用最广的算法，又称RR调度。每个进程被分配一个时间段，称作它的时间片，即该进程允许运行的时间。<br>算法原理：让就绪进程以FCFS 的方式按时间片轮流使用CPU 的调度方式，即将系统中所有的就绪进程按照FCFS 原则，排成一个队列，每次调度时将CPU 分派给队首进程，让其执行一个时间片，时间片的长度从几个ms 到几百ms。在一个时间片结束时，发生时钟中断，调度程序据此暂停当前进程的执行，将其送到就绪队列的末尾，并通过上下文切换执行当前的队首进程，进程可以未使用完一个时间片，就出让CPU（如阻塞）。<br>算法优点：时间片轮转调度算法的特点是简单易行、平均响应时间短。<br>算法缺点：不利于处理紧急作业。在时间片轮转算法中，时间片的大小对系统性能的影响很大，因此时间片的大小应选择恰当<br>怎样确定时间片的大小：</p><ul><li>时间片大小的确定<br>1.系统对响应时间的要求<br>2.就绪队列中进程的数目<br>3.系统的处理力</li></ul></li><li><p>多级反馈队列(Multilevel Feedback Queue)<br>多级反馈队列调度算法是一种CPU处理机调度算法，UNIX操作系统采取的便是这种调度算法。<br>多级反馈队列调度算法描述：<br>　　1、进程在进入待调度的队列等待时，首先进入优先级最高的Q1等待。<br>　　2、首先调度优先级高的队列中的进程。若高优先级中队列中已没有调度的进程，则调度次优先级队列中的进程。例如：Q1,Q2,Q3三个队列，只有在Q1中没有进程等待时才去调度Q2，同理，只有Q1,Q2都为空时才会去调度Q3。<br>　　3、对于同一个队列中的各个进程，按照时间片轮转法调度。比如Q1队列的时间片为N，那么Q1中的作业在经历了N个时间片后若还没有完成，则进入Q2队列等待，若Q2的时间片用完后作业还不能完成，一直进入下一级队列，直至完成。<br>　　4、在低优先级的队列中的进程在运行时，又有新到达的作业，那么在运行完这个时间片后，CPU马上分配给新到达的作业（抢占式）。<br>　　在多级反馈队列调度算法中，如果规定第一个队列的时间片略大于多数人机交互所需之处理时间时，便能够较好的满足各种类型用户的需要。</p></li></ul><h3 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h3><h4 id="TCP和UDP区别"><a href="#TCP和UDP区别" class="headerlink" title="[]TCP和UDP区别"></a>[]TCP和UDP区别</h4><table><thead><tr><th></th><th>TCP</th><th>UDP</th></tr></thead><tbody><tr><td>传输</td><td>提供面向连接的、可靠地数据流传输</td><td>提供的是非面向连接的、不可靠的数据流传输</td></tr><tr><td>传输单位</td><td>TCP报文段</td><td>用户数据报</td></tr><tr><td>安全性</td><td>TCP注重数据安全性</td><td>UDP数据传输快，因为不需要链接等待，少了许多操作，但是起安全性却一般</td></tr><tr><td></td><td></td><td></td></tr><tr><td>协议</td><td>FTP:定义了文件传输协议,使用21端口;</td><td>DNS: 用于域名解析服务,将域名地址转换成IP地址.DNS用的是53号端口.</td></tr><tr><td>协议</td><td>Telnet: 一种用于远程登录的端口,使用23端口,用户可以以自己的身份远程连接到计算机上,可提供基于DOS模式下的通信服务</td><td>SNMP: 简单网络管理协议,使用161端口,是用来管理网络十倍的.由于网络设备很多,无连接的服务就体现出其优势.</td></tr><tr><td>协议</td><td>SMTP: 邮件传送协议,用于发送邮件.服务端开放的是25号端口</td><td>TFTP(Trival File Transfer Protocal): 简单文件传输协议,该协议在熟知端口69上使用UDP服务</td></tr><tr><td>协议</td><td>POP3: 它是和SMTP对应,POP3用于接收邮件.POP3协议所用的是110端口</td><td></td></tr><tr><td>协议</td><td>HTTP: 是从Web服务器传输超文本到本地浏览器的传送协议</td></tr></tbody></table><p><a href="http://blog.csdn.net/li_ning_/article/details/52117463" target="_blank" rel="noopener">详细介绍,戳&lt;&lt;&lt;–</a></p><blockquote><p>TCP与UDP区别总结：<br>TCP面向连接（如打电话要先拨号建立连接）;UDP是无连接的，即发送数据之前不需要建立连接<br>TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP尽最大努力交付，即不保   证可靠交付<br>TCP面向字节流，实际上是TCP把数据看成一连串无结构的字节流;UDP是面向报文的UDP没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如IP电话，实时视频会议等）<br>每一条TCP连接只能是点到点的;UDP支持一对一，一对多，多对一和多对多的交互通信<br>TCP首部开销20字节;UDP的首部开销小，只有8个字节<br>TCP的逻辑通信信道是全双工的可靠信道，UDP则是不可靠信道</p></blockquote><h4 id="TCP三次握手-四次挥手"><a href="#TCP三次握手-四次挥手" class="headerlink" title="[-]TCP三次握手/四次挥手"></a>[-]TCP三次握手/四次挥手</h4><p><a href="http://blog.csdn.net/qzcsu/article/details/72861891" target="_blank" rel="noopener">详细介绍,戳&lt;&lt;&lt;—</a><br><a href="https://www.cnblogs.com/myvin/p/4862167.html" target="_blank" rel="noopener">更亲民的介绍,戳&lt;&lt;&lt;—</a></p><p>建立连接的过程是利用客户服务器模式,假设主机A为客户端,主机B为服务端</p><ul><li>TCP的三次握手过程：主机Ａ向Ｂ发送链接请求; -&gt; 主机B对收到的主机A的报文段进行确认; -&gt; 主机A再次对主机B的确认进行确认</li><li>采用三次握手是为了防止失效的链接请求报文段突然有传送到主机B,因而产生错误.失效的链接请求报文段是指: 主机A出的连接请求没有收到主机B的确认,于是经过一段时间后,主机A又重新向主机B发送连接请求,且建立成功,顺序完成数据传输. 考虑这样一个特殊情况,主机A第一次发送的连接请求并没有丢失,而是因为网络节点导致延迟到达主机B,主机B以为是主机又发起的新连接,于是主机B同意连接,并向主机A发回确认,但是此时主机A根本不会理会,主机B就一直在等待主机A发送数据，导致主机Ｂ的资源浪费．</li><li>采用两次握手不行, 原因就是上面说的实效的连接请求的特殊情况.</li></ul><h4 id="TCP里的一些机制"><a href="#TCP里的一些机制" class="headerlink" title="TCP里的一些机制"></a>TCP里的一些机制</h4><h4 id="OSI-TCP-IP-五层协议的体系结构-以及各层协议"><a href="#OSI-TCP-IP-五层协议的体系结构-以及各层协议" class="headerlink" title="OSI,TCP/IP,五层协议的体系结构,以及各层协议"></a>OSI,TCP/IP,五层协议的体系结构,以及各层协议</h4><p>OSI分层(7层): 物理层,数据链路层,网络层,传输层,会话层,表示层,应用层.<br>TCP/IP分层(4层): 网络接口层,网际层,运输层,应用层.<br>五层协议(5层): 物理层,数据链路层,网络层,运输层,应用层.</p><p>每一层的协议如下:<br>物理层: RJ45,CLOCK,IEEE802.3(中继器,集线器)<br>数据链路: POP,FR,HDLC,VLAN,MAX(网桥,交换机)<br>网络层: IP,UCMP,ARP,RARP,OSPF,IPX,RIP,IGRP(路由器)<br>传输层: TCP,UDP,SPX<br>会话层: NFS,SQL,NETBIOS,RPC<br>表示层: JPEG,MPEG,ASII<br>应用层: FTP,DNS,Telnet,SMTP,HTTP,WWW,NFS</p><p>每一层的作用如下</p><p>物理层: 通过媒介传输比特,确定机械及电器规范(比特Bit)<br>数据链路: 将比特组装成帧和点到点的传递(帧Frame)<br>网络层: 负责数据包从源到宿的传递和网际互联(包PackeT)<br>传输层: 提供端到端的可靠报文传递和错误回复(段Segment)<br>会话层: 简历,管理和中智慧化(会话协议数据单元SPDU)<br>表示层: 对数据进行翻译,加密和压缩(表示协议数据单元PPDU)<br>应用层: 允许方位OSI环境的手段(应用协议数据单元APDU)</p><h4 id="IP地址的分类"><a href="#IP地址的分类" class="headerlink" title="IP地址的分类"></a>IP地址的分类</h4><p>A类地址: 以0开头, 第一个字节范围1~127(1.0.0.0~127.255.255.255);<br>B类地址: 以10开头, 第一个字节范围128~191(128.0.0.0~191.255.255.255);<br>C类地址: 以110开头, 第一个字节范围192~223(192.0.0.0~223.255.255.255);<br>D类地址: 以1110开头, 第一个字节范围224~239(224.0.0.0~239.255.255.255);<br>E类地址: 保留</p><p>一种A,B,C是基本类,D,E类作为多播和保留使用.<br>以下是留用的内部私有地址:<br>A类 10.0.0.0  – 10.255.255.255<br>B类 182.16.00 – 192.31.255.255<br>C类 192.168.0.0 – 192.168.255.255</p><p>IP地址与子网掩码相与(&amp;)得到网络号<br>ip 192.168.2.110<br>&amp;<br>submask:255.255.255.0<br>.———————————<br>网络号 192.168.2.0</p><p>注: 主机号,全是0的网络号(例如192.168.2.0),主机号全为1的为广播地址(192.168.2.255)</p><h4 id="ARP是地址解析协议-简单语言解释一下工作原理"><a href="#ARP是地址解析协议-简单语言解释一下工作原理" class="headerlink" title="ARP是地址解析协议,简单语言解释一下工作原理."></a>ARP是地址解析协议,简单语言解释一下工作原理.</h4><ul><li>首先,每个主机都会在自己的ARP缓冲区中建立一个ARP列表,以表示IP地址和MAC地址之间的对应关系.</li><li>当源主机要发送数据时,首先检查ARP列表中是否有对应IP地址的目的主机的MAC地址,如果有,则直接发送数据,如果没有,就向本网段的所有主机发送ARP数据包,该数据包包括的内容有: 源主机的IP地址,源主机的MAC地址,目的主机的IP地址.</li><li>当本网络中的所有主机收到该ARP数据包时,首先检查数据包中的IP地址是否是自己的IP地址,如果不是,则忽略该数据包,,如果是,则首先从数据包中去除源主机的IP和MAC地址写入到ARP列表中,如果已经存在,则覆盖,然后将自己的MAC地址写入ARP响应包中,告诉源主机自己是它想要找的MAC地址</li><li>源主机收到ARP响应后.将目的主机的IP和MAC地址写入ARP列表,并利用此信息发送数据. 如果源主机一直没有收到ARP相应数据包,表示ARP查询失败.</li></ul><p>广播发送ARP请求,单播发送ARP相应. </p><h4 id="RARP协议"><a href="#RARP协议" class="headerlink" title="RARP协议"></a>RARP协议</h4><p>RARP是逆地址解析协议,作用是完成硬件地址到IP地址的映射,主要用于无盘工作站,因为给无盘工作站配置的IP地址不能保存.<br>工作流畅: 在网络中配置一台RARP服务器,里面保存者IP地址和MAC地址的映射关系,当无盘工作站启动后,就封装一个RARP数据包,里面有其MAC地址,然后广播到网络上去,当服务器收到请求包后,就查找对应的MAC地址的IP地址装入响应报文中发回给请求者. 因为需要广播请求报文,因此RARP只能用于具有广播能力的网络.</p><h4 id="各种协议的介绍"><a href="#各种协议的介绍" class="headerlink" title="各种协议的介绍"></a>各种协议的介绍</h4><ul><li><strong>ICMP协议</strong>: 因特网控制报文协议.它是TCP/IP协议族的一个自协议,用于在IP主机/路由器之间传递控制消息.</li><li><strong>TFTP协议</strong>: 是TCP/IP协议族中的一个用来在客户机与服务器之间进行简单文件传输的协议,提供不复杂,开销不大的文件传输服务.</li><li><strong>HTTP协议</strong>: 超文本传输协议,是一个属于应用层的面向对象的协议,由于其简捷,快速的方式,适用于分布式超媒体信息系统</li><li><strong>NAT协议</strong>: 网络地址转换属介入广域网(WAN)技术,是一种将私有(保留)地址转化为合法IP地址的转换技术.</li><li><strong>DHCP协议</strong>: 动态主机配置协议,给用户或者内部网络管理员作为对所有计算机作中央管理的手段.</li></ul><h4 id="在浏览器中输入www-baidu-com后执行的全部过程"><a href="#在浏览器中输入www-baidu-com后执行的全部过程" class="headerlink" title="在浏览器中输入www.baidu.com后执行的全部过程"></a>在浏览器中输入<a href="http://www.baidu.com后执行的全部过程" target="_blank" rel="noopener">www.baidu.com后执行的全部过程</a></h4><ul><li><ol><li>客户端浏览器通过DNS解析到<a href="http://www.baidu.com的IP地址为220.181.27.48" target="_blank" rel="noopener">www.baidu.com的IP地址为220.181.27.48</a>, 通过这个IP地址找到客户端到服务器的路径. 客户端浏览器发起一个HTTP回话到220.181.27.48, 然后通过TCP进行封装数据包, 输入到网络层.</li></ol></li><li><ol start="2"><li>在客户端的传输层,把HTTP回话请求分成报文段,添加源和目的端口, 如服务器使用80端口监听客户端的请求, 客户端有系统随机选择一个端口如5000, 与服务器进行交换,服务器吧相应的请求返回给客户端的5000端口. 然后使用IP层的IP地址查找目的端.</li></ol></li><li><ol start="3"><li>客户端的网络层不用关心应用层或者传输层的东西, 主要做到的是通过查找路由表确定如何到达服务器,期间可能经过多个路由器,这些都是有路由器来完成的工作, 我不做过多的描述, 无非就是通过查找路由表决定通过哪个路径到达服务器.</li></ol></li><li><ol start="4"><li>客户端的链路层, 包通过链路层发送到路由器, 通过邻居协议查找给定IP地址的MAC地址,然后发送ARP请求查找到目的地址, 如果得到回应后就可以使用ARP的请求应答交换的IP数据包,现在就可以传输了,然后发送IP数据包到达服务器的地址.</li></ol></li></ul><h4 id="DNS域名系统-简单描述其工作原理"><a href="#DNS域名系统-简单描述其工作原理" class="headerlink" title="DNS域名系统,简单描述其工作原理"></a>DNS域名系统,简单描述其工作原理</h4><p>当DNS客户机需要在程序中使用名称时, 它会查询DNS服务器来解析该名称. 客户机发送的每条查询信息包括三条信息: 包括: 指定的DNS域名,DNS域名的指定类型. 基于UDP服务,端口53. 该应用一般不直接为用户使用, 而是为其他应用服务,如 HTTP,SMTO等在其中需要完成主机名到地址的转换.</p><h4 id="了解交换机-路由器-网关的概念-并知道各自的用途"><a href="#了解交换机-路由器-网关的概念-并知道各自的用途" class="headerlink" title="了解交换机,路由器,网关的概念, 并知道各自的用途"></a>了解交换机,路由器,网关的概念, 并知道各自的用途</h4><ul><li><p><strong>交换机</strong><br>在计算机网络系统中,交换机是针对共享工作模式的弱点而推出的.交换机拥有一条高带宽的背部总线和内部交换矩阵.交换机的所有的端口都挂接在这条背部总线上,当控制电路收到数据包以后,处理端口会查找内存中的地址对照表以确定目的端口.目的MAC若不存在,交换机才广播到所有的端口, 接手端口回应后交换机会’学习’新的地址,并把它添加入内部地址表中.<br>交换机工作于OSI参考模型的第二层,即数据链路层. 交换机内部的CPU会在每个端口成功连接时,通过ARP协议学习它的MAC地址,保存成一张ARP表. 在今后的通讯中, 发往该MAC地址的数据包将仅送往其对应的端口,而不是所有端口. 因此,交换机可用于划分数据链路层广播,即冲突域; 但它不能划分网络层广播, 即广播域.<br>交换机被广泛应用于二层网络交换,俗称’二层交换机’.<br>交换机的种类有: 二层交换机,三层交换机,四层交换机,七层交换机分别工作在OSI七层模型中的第二层,第三层,第四层和第七层,并因此而得名.</p></li><li><p>路由器<br>路由器(Router)是一种计算机网络设备,提供了路由与传送两种重要机制,可以决定数据包从来源端到目的端所经过的路由路径(host到host之间的传输路径),这个过程称为<strong>路由</strong>; 将路由器输入端的数据包移送至适当的路由器输出端(在路由器内部进行),这成为<strong>传动</strong>. 路由工作在OSI模型的第三层 -&gt; 即网络层,例如网际协议.<br>路由器的一个作用是连通不同的网络另一个作用是选择信息传送的线路. 路由器与交换机的差别, 路由器是属于OSI第三层的产品,交换机是OSI第二层的产品(这里至二层交换机)</p></li><li><p>网关<br>网关(Gateway), 网关顾名思义就是连接两个网络的设备,区别与路由器(由于历史的原因,许多有关TCP/IP的文献曾经把网络层使用的路由器成为网关,在今天很多局域网采用的都是路由器来接入网络,因此现在通常指的网关就是路由器的IP),经常在家庭中或者小型企业网络中使用,用于连接局域网和Internet. 网关也经常把一种协议转成另一种协议的设备,比如语音网关.<br>在传统TCP/IP术语中,网络设备只分成两种,一种为网关(Gateway),另一种称为主机(host). 网关能在网络间传递数据包,但主机不能传送数据包.在主机(又称终端系统,end system)中,数据包需经过TCP/IP四层协议处理,但是在网关(又称中介系统,intermediate system)只需要到达网际层(Internet layer),决定路径之后就可以传送. 在当时,网关(Gateway)和路由(Router)还没有区别.<br>在现代网络术语中,网关(Gateway)和路由(Router)的定义不同,网关(Gateway)能在不同协议间移动数据,而路由器(Router)是在不同网络间移动数据,相当于传统所说的IP网关(IP Gateway).<br>网关是连接两个网络的设备,对于语音网关来说,它可以连接PSTN网络和以太网,这就相当于VOIP,把不同电话的模拟信号通过网关而转换成数字信号,而且加入协议再去传输. 在到了接收端的时候再通过网关还原成模拟的电话信号,最后才能在电话机上听到.<br>对于以太网中的网关只能转发三层以上数据包,这一点和路由是一样的.而不同的是网关中并没有路由表,他只能按照预先设定的不同网段来进行转发.网关最重要的一层就是端口映射,子网内用户在外网看来只是外网的IP地址对应着不同的端口,这样看来就会保护子网内的用户.</p></li></ul><h3 id="C-C"><a href="#C-C" class="headerlink" title="C/C++"></a>C/C++</h3><h4 id="BSS段的功能"><a href="#BSS段的功能" class="headerlink" title="BSS段的功能"></a>BSS段的功能</h4><h4 id="char-p1-“123”-与char-p2-”123”-其中p1-p2区别"><a href="#char-p1-“123”-与char-p2-”123”-其中p1-p2区别" class="headerlink" title="char *p1 = “123” 与char p2[]=”123”,其中p1,p2区别"></a>char *p1 = “123” 与char p2[]=”123”,其中p1,p2区别</h4><p>答: 常量是存储在内存中的,<br>*p1 是指针 指向”123”中的”1”的地址<br>p2[] 是数组 本质是在堆栈中定义的一段内存</p><h4 id="sizeof-struct-char-c-int-a"><a href="#sizeof-struct-char-c-int-a" class="headerlink" title="sizeof(struct{char c;int a;}) = ?"></a>sizeof(struct{char c;int a;}) = ?</h4><p>答: 4</p><p>内存对其,整体占得内存一定是<strong>最大数据元素的整数倍</strong>.<br>这里最大的是int(4字节)整体就是(4*n字节)<br>大概是这个样子<br>|int|char|<br>△△△△|△—|</p><h4 id="多线程编程经验"><a href="#多线程编程经验" class="headerlink" title="多线程编程经验"></a>多线程编程经验</h4><h4 id="C-网络编程"><a href="#C-网络编程" class="headerlink" title="C++网络编程"></a>C++网络编程</h4><h4 id="C-11新增了什么-了解的有哪些"><a href="#C-11新增了什么-了解的有哪些" class="headerlink" title="C++11新增了什么,了解的有哪些."></a>C++11新增了什么,了解的有哪些.</h4><h4 id="√-const关键字作用"><a href="#√-const关键字作用" class="headerlink" title="[√]const关键字作用."></a>[√]const关键字作用.</h4><p><a href="https://www.cnblogs.com/chogen/p/4574118.html" target="_blank" rel="noopener">好文</a></p><h4 id="多态-虚函数"><a href="#多态-虚函数" class="headerlink" title="[-]多态/虚函数"></a>[-]多态/虚函数</h4><p><a href="https://www.cnblogs.com/qiaoconglovelife/p/5128523.html" target="_blank" rel="noopener">介绍</a></p><h3 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h3><h4 id="√-HashMap"><a href="#√-HashMap" class="headerlink" title="[√]HashMap"></a>[√]HashMap</h4><p><a href="https://mp.weixin.qq.com/s?__biz=MzIxMjE5MTE1Nw==&amp;mid=2653191907&amp;idx=1&amp;sn=876860c5a9a6710ead5dd8de37403ffc&amp;chksm=8c990c39bbee852f71c9dfc587fd70d10b0eab1cca17123c0a68bf1e16d46d71717712b91509&amp;scene=38#wechat_redirect" target="_blank" rel="noopener">介绍链接</a></p><h4 id="Synchronze-和-Lock的区别和用法"><a href="#Synchronze-和-Lock的区别和用法" class="headerlink" title="Synchronze 和 Lock的区别和用法"></a>Synchronze 和 Lock的区别和用法</h4><table><thead><tr><th>Synchronze(隐式锁)</th><th>Lock(显示锁)</th></tr></thead><tbody><tr><td>在需要同步的对象中加入此控制,synchronize可以加在方法上,也可以加在特定代码块中,括号中表示需要所得对象</td><td>需要显示指定起始位置和终止位置.一般使用ReentrantLock类作为锁,多个线程中必须要使用一个ReentrantLock类作为对象才能保证锁的生效.且在加锁和解锁处需要通过lock()和unlock()显示指出.所以一般会在finally块中写unlock()以防死锁</td></tr><tr><td>托管给JVM执行的</td><td>java写的控制锁代码</td></tr><tr><td>采用的的CPU的悲观锁机制,即线程获得的是独占锁.独占锁意味着其他线程只能依靠阻塞来等待线程释放锁</td><td>乐观锁方式,每次不加锁而是假设没有冲突而去完成某项操作,如果因为冲突失败就重试,直到成功为止.乐观锁实现的机制就是CAS操作(Compare and Swap)</td></tr></tbody></table><p>Ps: 在Java1.5中, syncchronize是性能低效的,因为这是一个重量级操作,需要调用操作接口,导致有可能加锁消耗的系统时间比加锁以外的操作还多. 相比之下使用Java提供的Lock对象,性能更高一些.但是到了Java1.6,发生了变化. synchronize在语义上很清晰,可以进行很多优化,有适应自旋,锁消除,锁粗化,轻量级锁,偏向锁等等. 导致在Java1.6上synchronize的性能并不比Lock差.</p><h4 id="乐观锁-悲观锁"><a href="#乐观锁-悲观锁" class="headerlink" title="乐观锁,悲观锁"></a>乐观锁,悲观锁</h4><ul><li><strong>乐观锁（ Optimistic Locking ）</strong> 相对悲观锁而言，乐观锁机制采取了更加宽松的加锁机制。悲观锁大多数情况下依靠数据库的锁机制实现，以保证操作最大程度的独占性。但随之而来的就是数据库性能的大量开销，特别是对长事务而言，这样的开销往往无法承受。而乐观锁机制在一定程度上解决了这个问题。乐观锁，大多是基于数据版本（ Version ）记录机制实现。何谓数据版本？即为数据增加一个版本标识，在基于数据库表的版本解决方案中，一般是通过为数据库表增加一个 “version” 字段来实现。读取出数据时，将此版本号一同读出，之后更新时，对此版本号加一。此时，将提交数据的版本数据与数据库表对应记录的当前版本信息进行比对，如果提交的数据版本号大于数据库表当前版本号，则予以更新，否则认为是过期数据。</li><li><strong>悲观锁（Pessimistic Lock）</strong>，正如其名，具有强烈的独占和排他特性。它指的是对数据被外界（包括本系统当前的其他事务，以及来自外部系统的事务处理）修改持保守态度，因此，在整个数据处理过程中，将数据处于锁定状态。悲观锁的实现，往往依靠数据库提供的锁机制（也只有数据库层提供的锁机制才能真正保证数据访问的排他性，否则，即使在本系统中实现了加锁机制，也无法保证外部系统不会修改数据）。</li></ul><h3 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h3><h4 id="进程的内存分布-1"><a href="#进程的内存分布-1" class="headerlink" title="进程的内存分布"></a>进程的内存分布</h4><table><thead><tr><th>名称</th><th>内容</th></tr></thead><tbody><tr><td>代码段</td><td>可执行代码</td></tr><tr><td>数据段</td><td>已初始化全局变量,已初始化全局静态变量,局部静态变量,常量数据</td></tr><tr><td>BSS段</td><td>未初始化全局变量,未初始化全局静态变量</td></tr><tr><td>栈</td><td>局部变量,函数参数</td></tr><tr><td>堆</td><td>动态内存分配</td></tr></tbody></table><h4 id="那个命令可以常看内存使用情况"><a href="#那个命令可以常看内存使用情况" class="headerlink" title="那个命令可以常看内存使用情况"></a>那个命令可以常看内存使用情况</h4><p>答:<br>top<br>free [-h]<br><!-- ps aux --sort -rss --></p><h4 id="touch有什么用"><a href="#touch有什么用" class="headerlink" title="touch有什么用"></a>touch有什么用</h4><p>答: 两个作用</p><ul><li>一,用于吧已存在文件的时间标签更新为系统当前的时间(默认方式),它们的数据将原封不动地保留下来;</li><li>二,用来创建新的空文件</li></ul><h4 id="僵尸进程-孤儿进程-守护进程"><a href="#僵尸进程-孤儿进程-守护进程" class="headerlink" title="僵尸进程,孤儿进程,守护进程"></a>僵尸进程,孤儿进程,守护进程</h4><p><a href="https://blog.csdn.net/gogokongyin/article/details/51340432" target="_blank" rel="noopener">详细介绍</a></p><ul><li><p><strong>僵尸进程:</strong> 在fork()/execve()过程中,假设子进程结束时父进程仍存在,而父进程fork()之前既没安装SIGCHLD信号处理函数调用waitpid()等待子进程结束,又没有显示忽略该信号,则子进程成为僵尸进程.</p></li><li><p><strong>孤儿进程:</strong> 一个父进程退出,而它的一个或多个子进程还在运行,那么那些子进程将成为孤儿进程. 孤儿进程将被init进程(进程号为1)所收养,并由init进程对他们完成状态收集工作. </p></li><li><p><strong>守护进程:</strong> Linux系统中的守护进程是一种运行在后台的进程. 而守护进程,也就是通常说的Daemon进程. 它通常独立于控制终端并且周期性的执行某种任务或等待处理某些发生的事件. Linux大多数服务器进程就是用这种守护进程实现的, 例如Web服务.守护进程常常在系统引导装入时启动, 在系统关闭时终止. 守护进程最大的特点是运行在后台,与终端无连接, 除非特殊情况下, 用户不能操作守护进程.</p></li></ul><h3 id="python"><a href="#python" class="headerlink" title="python"></a>python</h3><h3 id="大数据"><a href="#大数据" class="headerlink" title="大数据"></a>大数据</h3><h4 id="MongoDB-vs-Redis"><a href="#MongoDB-vs-Redis" class="headerlink" title="MongoDB vs Redis"></a>MongoDB vs Redis</h4><p>MongoDB和Redis都是NoSQL，采用结构型数据存储。二者在使用场景中，存在一定的区别，这也主要由于二者在内存映射的处理过程，持久化的处理方法不同。</p><p> MongoDB建议集群部署，更多的考虑到集群方案，Redis更偏重于进程顺序写入，虽然支持集群，也仅限于主-从模式。</p><table><thead><tr><th>比较指标</th><th>MongoDB(v2.4.9)</th><th>Redis(v2.4.17)</th><th>比较说明</th></tr></thead><tbody><tr><td>实现语言</td><td>c++</td><td>c/c++</td><td>-</td></tr><tr><td>协议</td><td>BSON,自定义二进制</td><td>类telnet</td><td>-</td></tr><tr><td>性能</td><td>依赖内存,TPS{(transaction per second)代表每秒执行的事务数量}较高</td><td>依赖内存,TPS非常高</td><td>Redis优于MongoDB</td></tr><tr><td>可操作性</td><td>丰富的数据表达,索引;最类似于关系型数据库,支持丰富的查询语句</td><td>数据丰富,较少的IO</td><td>MongoDB优于Redis</td></tr><tr><td>内存及存储</td><td>适合大数据量存储,依赖系统虚拟内存,采用镜像文件存储;内存占用率比较高,官方建议独立部署在64位系统</td><td>Redis2.0后支持虚拟内存特性(VM) 突破物理内存限制;数据可以设置时效性,类似于memcache</td><td>不同的应用场景,各有千秋</td></tr><tr><td>可用性</td><td>支持master-slave,replicatset(内部采用paxos选举算法,自动故障恢复),auto sharding机制,对客户端屏蔽了故障转移和切片机制</td><td>依赖客户端来实现分布式读写;主从复制时,每次从节点重新连接主节点都要依赖整个快照,无增量复制;不支持auto sharding,需要依赖程序设定一致性hash机制</td><td>MongoDB优于Redis；单点问题上,MongoDB应用简单,相对用户透明,Redis比较复杂,需要客户端主动解决.(MongoDB一般使用replicasets和sharding相结合,replicasets侧重高可用性以及高可靠,sharding侧重性能,水平扩展)</td></tr><tr><td>可靠性</td><td>从1.8版本后,采用binlog方式(类似Mysql) 支持持久化</td><td>依赖快照进行持久化;AOF增强可靠性;增强性的同时,影响访问性能</td><td>-</td></tr><tr><td>一致性</td><td>不支持事务,靠客户端保证</td><td>支持事务,比较脆,仅能保证事务中的操作按顺序执行</td><td>Redis优于MongoDB</td></tr><tr><td>数据分析</td><td>内置数据分析功能(mapreduce)</td><td>不支持</td><td>MongoDB优于Redis</td></tr><tr><td>应用场景</td><td>海量数据的访问效率提升</td><td>较小数据量的性能和运算</td><td>MongoDB优于Redis</td></tr></tbody></table><h3 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h3><h4 id="数据库事务的四大特性-ACID"><a href="#数据库事务的四大特性-ACID" class="headerlink" title="数据库事务的四大特性(ACID)"></a>数据库事务的四大特性(ACID)</h4><ul><li><strong>原子性(Atomicity)</strong><br>事务是数据库的逻辑工作单位,它对数据库的修改要么全部执行,要么全部不执行.</li><li><strong>一致性(Consistemcy)</strong><br>事务前后,数据库的状态都满足所有的完整性约束</li><li><strong>隔离性(lsolation)</strong><br>并发执行的事务是隔离的,一个不影响一个.如果有两个事务,运行在相同的时间内,执行相同的功能,事务的隔离性将确保每一事务在系统中认为只有该事物在使用系统. 这种属性有时称为串行化,为了防止事务操作间的混淆,必须串行化或序列化请求,使得在同一时间仅有y一个请求用于统一数据.通过设置数据库的<strong>隔离级别</strong>,可以达到不同的隔离效果.</li><li>持久性(Durability)<br>在事务完成后,该事务所对数据库所作的更改便持久的保存在数据库之中,并不会被回滚.</li></ul><h4 id="并发事务引起的问题"><a href="#并发事务引起的问题" class="headerlink" title="并发事务引起的问题"></a>并发事务引起的问题</h4><ul><li><p><strong>更新丢失</strong><br>两个事务都同时更新一行数据，但是第二个事务却中途失败退出，导致对数据的两个修改都失效了。这是因为系统没有执行任何的锁操作，因此并发事务并没有被隔离开来。</p></li><li><p><strong>脏读</strong><br>脏读又称无效数据读出。一个事务读取另外一个事务还没有提交的数据叫脏读。<br>例如：事务T1修改了一行数据，但是还没有提交，这时候事务T2读取了被事务T1修改后的数据，之后事务T1因为某种原因Rollback了，那么事务T2读取的数据就是脏的。</p></li></ul><h2 id="设计题-系统题"><a href="#设计题-系统题" class="headerlink" title="设计题/系统题"></a>设计题/系统题</h2><h3 id><a href="#" class="headerlink" title="."></a>.</h3><h4 id="设计一个ID分配器"><a href="#设计一个ID分配器" class="headerlink" title="[]设计一个ID分配器"></a>[]设计一个ID分配器</h4><h4 id="-1"><a href="#-1" class="headerlink" title="."></a>.</h4><h2 id="技术无关"><a href="#技术无关" class="headerlink" title="技术无关"></a>技术无关</h2><h3 id="-2"><a href="#-2" class="headerlink" title="."></a>.</h3><h4 id="能抗住压力么"><a href="#能抗住压力么" class="headerlink" title="能抗住压力么"></a>能抗住压力么</h4><p>答:作为应届生,本就应该吃苦耐劳学技术,人都是逼出来的,有压力才有动力,这点压力不算什么.</p><h4 id="有女朋友么"><a href="#有女朋友么" class="headerlink" title="有女朋友么"></a>有女朋友么</h4><p>答: 没有,一心向学,不找女朋友浪费时间.(TM是找不到好不2333)</p><h4 id="你有什么问题吗"><a href="#你有什么问题吗" class="headerlink" title="你有什么问题吗"></a>你有什么问题吗</h4><ol><li>这个岗位做的主要业务是什么</li><li>岗位的技术栈</li><li>招这个岗位的校招或者实习生更看重哪方面的能力</li></ol>]]></content>
      
      
      <categories>
          
          <category> 求职 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> C++ </tag>
            
            <tag> 操作系统 </tag>
            
            <tag> 计算机网络 </tag>
            
            <tag> 大数据 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  goodbye CSDN</title>
      <link href="/2018/01/28/79186055/"/>
      <url>/2018/01/28/79186055/</url>
      
        <content type="html"><![CDATA[<h1 id="goodbye-CSDN"><a href="#goodbye-CSDN" class="headerlink" title="goodbye CSDN"></a>goodbye CSDN</h1><p>2018年01月28日 13:00:52  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：294</p><hr><p> 博客爬取于<code>2019-04-18 17:15:20</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/79186055" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/79186055</a></p><p>以后除了下载东西,应该不会用CSDN了.</p><p>搭了个博客.<br><a href="https://tabris.top"> tabris.top </a></p><p>以后就在这里玩耍了.<br>因为也没人看,想咋写咋瞎写. 哈哈哈哈哈哈哈哈.</p>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2018/01/25/hello-world/"/>
      <url>/2018/01/25/hello-world/</url>
      
        <content type="html"><![CDATA[<h1 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h1><p>tabris的个人博客终于搭建成功啦,百度不收录的博客权当自己的学习笔记+矫情的地方.</p><p>ACM退役啦,不知道学些什么:<br>机器学习感觉智商和数学水平够不上.<br>C++也不好找工作.<br>Java还不想学.<br>前端更是不想学.</p><p>学学大数据<br>投后台开发岗和大数据岗</p><p>失业了就回家种地</p><p>所以先学些必备的技能.</p><ul><li>git</li><li>IDE 使用.</li><li>so on</li></ul><blockquote><p>let’s begin.<br>       –tabris</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  退役贴</title>
      <link href="/2017/11/08/78479380/"/>
      <url>/2017/11/08/78479380/</url>
      
        <content type="html"><![CDATA[<h1 id="退役贴"><a href="#退役贴" class="headerlink" title="退役贴"></a>退役贴</h1><p>2017年11月08日 15:31:29  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：445</p><hr><p> 博客爬取于<code>2019-04-18 17:15:21</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/78479380" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/78479380</a></p><p>2017 青岛 icpc 打铁 退役</p><p>正常发挥 玩的很开新</p><p>——Update—–</p><p>好久没看博客了 ,想想应该更新下.<br>12月又去了上海打了ECL-FINAL 嗯 铁了.<br>事实证明了我就是一个铁牌的菜鸡.</p><p>这两年多,也后悔也不后悔……</p><p>爱咋咋地吧,反正也失业了.</p><p>最后希望自己能,<br>好好学英语!<br>好好学英语!<br>……<br>好好学英语!</p><p>这个年头不拿个银牌都不好意思说自己是个ACMer,更何况我也个垃圾万年铁牌菜逼.</p><p>引用某大牛的退役帖作结尾巴. <del> (当然我和大牛的失败与遗憾根本不是同一个层面上的,引用大牛的话也真是臭不要脸…) </del></p><blockquote><p>ACM之于我，真正获得的或许也就两样，表面上的基础、算法之流，深层处的不屈与倔强。当最后比赛输了的时候，没怎么去惋惜学了那么多算法怎么如此啥的，真正感到<br>遗憾的是那一份执着没有完美的结局，果真是不完美的结局才最让人回味么~？</p></blockquote><p>ACM!再见.</p>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  vijos P2026 几乎奇偶等和数 [数位dp]【动态规划】</title>
      <link href="/2017/10/08/78175188/"/>
      <url>/2017/10/08/78175188/</url>
      
        <content type="html"><![CDATA[<h1 id="vijos-P2026-几乎奇偶等和数-数位dp-【动态规划】"><a href="#vijos-P2026-几乎奇偶等和数-数位dp-【动态规划】" class="headerlink" title="vijos P2026 几乎奇偶等和数 [数位dp]【动态规划】"></a>vijos P2026 几乎奇偶等和数 [数位dp]【动态规划】</h1><p>2017年10月08日 15:24:34  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：430</p><p>个人分类：  <a href="https://blog.csdn.net/qq_33184171/article/category/6362379" target="_blank" rel="noopener"> ===== 各OJ =====</a> <a href="https://blog.csdn.net/qq_33184171/article/category/6362438" target="_blank" rel="noopener"> ==== 动态规划 ====</a></p><hr><p> 博客爬取于<code>2019-04-18 17:15:22</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/78175188" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/78175188</a></p><p>题目链接： <a href="https://vijos.org/p/2026" target="_blank" rel="noopener"> https://vijos.org/p/2026 </a><br>——————————————————————————————————————<br>描述</p><p>我们称一个整数是奇偶等和数，是说它的数位个数是偶数（比如二位数，四位数，六位数等，且特殊说明  0<br>是一位数字），且其中所有奇数位数字之和恰好等于所有偶数位数字之和。<br>我们称一个整数是几乎奇偶等和数，是说在恰好修改其中一位数字后，得到的新数字是一个奇偶等和数。这里说恰好修改一位数字，要求必须发生了实质性修改，也就是说修改后<br>的数字必须与之前的数字不同（例如将  1234  修改为  1234  就是不合法的，因为修改后的数字和之前是一样的）；同时要求不能将最高位修改为  0<br>。<br>现在给定整数  A  和  B  ，问有多少几乎奇偶等和数  x  满足  A  ≤  x  ≤  B  。<br>格式</p><p>输入格式</p><p>输入只有一行，是两个整数  A  和  B  ，满足  0  ≤  A  ≤  B  ≤  10  9  。</p><p>输出格式</p><p>输出一个正整数，表示有多少几乎奇偶等和数。<br>样例1</p><p>样例输入1</p><p>1 33<br>Copy<br>样例输出1</p><p>21<br>Copy<br>样例2</p><p>样例输入2</p><p>51 78<br>Copy<br>样例输出2</p><p>25<br>Copy<br>限制</p><p>对于 30\%30% 的数据，  0  ≤  A  ≤  B  ≤  130000  。<br>对于所有数据，  0  ≤  A  ≤  B  ≤  10  9  .<br>存在额外的  10  %  的数据，  −  A  ≤  10  7  ；还有另外的额外 10\%10% 的数据，  B  −  A  ≤  5  ×<br>10  7  。<br>每一组数据的时限为  0.3  秒。<br>——————————————————————————————————————</p><p>注意的是 <strong> 一定 </strong> 要修改一个数字,然后是奇数位上和偶数位上,不算是奇数数字和偶数数字的和的比较,,,</p><p>对于一个数字 判定是否是奇偶等和数 ,只要把奇位和与偶位和的差算出来,然后<br>逐位判断每个数字的大小关系就行,小的数字变大的,大的数字变小的然后对奇位和与偶位和的差的改变就确定了,到这步就能O(1)判断这个是否合法了.</p><p>直接数位dp算下去就行了,然后记忆化一下,</p><p>int dp[10][120][10][10][10];<br>//数位 奇位和与偶位和的差 对差的影响的正值 对差的影响的负值 当前数字的长度<br>int dfs(int pos,int sub,int posi,int nop,bool limit,int bt)<br>// 数位 奇位和与偶位和的差 对差的影响的正值 对差的影响的负值 限制 当前数字的长度</p><p>附本题代码<br>——————————————————————————————————————</p><pre><code>#include &lt;bits/stdc++.h&gt;typedef long long int LL;using namespace std;const int N   = 1e7+7;const int MOD = 998244353;const double eps = 1e-6;#define rep(aa,bb,cc) for(int aa=(bb),ee=(cc);aa&lt;=ee;aa++)#define abs(x)        ((x)&gt;0?(x):-(x))/*********************************************/int num[10],len;int dp[10][120][10][10][10];//数位 奇位和与偶位和的差 对差的影响的正值 对差的影响的负值 int dfs(int pos,int sub,int posi,int nop,bool limit,int bt){    if(pos&lt;0) return bt%2==0 &amp;&amp; sub!=0 &amp;&amp; (sub*(sub+posi)&lt;=0||sub*(sub-nop)&lt;=0);    int &amp;d = dp[pos][sub+60][posi][nop][bt];    if(!limit &amp;&amp; d!=-1) return d;    int endi=9;if(limit) endi=num[pos];    int res = 0;    for(int i=0;i&lt;=endi;i++){        if(bt == 0){            if(i == 0)   res+=dfs(pos-1,0,0,0,0,0);            else {                if(bt&amp;1) res+=dfs(pos-1,sub+i,9-i,i-1,limit&amp;&amp;i==endi,1);                else     res+=dfs(pos-1,sub-i,i-1,9-i,limit&amp;&amp;i==endi,1);            }        }        else {            if(bt&amp;1) res += dfs(pos-1,sub+i,max(posi,9-i),max(nop,i),limit&amp;&amp;i==endi,bt+1);            else     res += dfs(pos-1,sub-i,max(posi,i),max(nop,9-i),limit&amp;&amp;i==endi,bt+1);        }    }    if(!limit) d = res;    return res;}int cal(int x){    if(x&lt;=0) return 0;    for(len = 0;x;x/=10) num[len++]=x%10;    return dfs(len-1,0,0,0,1,0);}int x,y;int main(){    memset(dp,-1,sizeof(dp));    while(~scanf(&quot;%d%d&quot;,&amp;x,&amp;y)){        printf(&quot;%d\n&quot;,cal(y)-cal(x-1));    }    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
            <tag> 各OJ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  Codeforces 794F</title>
      <link href="/2017/09/21/codeforces-794f/"/>
      <url>/2017/09/21/codeforces-794f/</url>
      
        <content type="html"><![CDATA[<h1 id="Codeforces-794F-Leha-and-security-system-线段树-区间更新-【数据结构】"><a href="#Codeforces-794F-Leha-and-security-system-线段树-区间更新-【数据结构】" class="headerlink" title="Codeforces 794F - Leha and security system [线段树-区间更新]【数据结构】"></a>Codeforces 794F - Leha and security system [线段树-区间更新]【数据结构】</h1><p>2017年09月21日 16:44:50  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：272</p><hr><p> 博客爬取于<code>2019-04-17 20:56:22</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/78053974" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/78053974</a></p><h2 id="题目链接：-http-codeforces-com-problemset-problem-794-F"><a href="#题目链接：-http-codeforces-com-problemset-problem-794-F" class="headerlink" title="题目链接：  http://codeforces.com/problemset/problem/794/F  "></a>题目链接： <a href="http://codeforces.com/problemset/problem/794/F" target="_blank" rel="noopener"> http://codeforces.com/problemset/problem/794/F</a>  </h2><p>F. Leha and security system<br>time limit per test2 seconds<br>memory limit per test512 megabytes<br>inputstandard input<br>outputstandard output<br>Bankopolis, the city you already know, finally got a new bank opened!<br>Unfortunately, its security system is not yet working fine… Meanwhile hacker<br>Leha arrived in Bankopolis and decided to test the system!</p><p>Bank has n cells for clients’ money. A sequence from n numbers a1, a2, …, an<br>describes the amount of money each client has. Leha wants to make requests to<br>the database of the bank, finding out the total amount of money on some<br>subsegments of the sequence and changing values of the sequence on some<br>subsegments. Using a bug in the system, Leha can requests two types of queries<br>to the database:</p><p>1 l r x y denoting that Leha changes each digit x to digit y in each element<br>of sequence ai, for which l ≤ i ≤ r is holds. For example, if we change in<br>number 11984381 digit 8 to 4, we get 11944341. It’s worth noting that Leha, in<br>order to stay in the shadow, never changes digits in the database to 0, i.e. y<br>≠ 0.<br>2 l r denoting that Leha asks to calculate and print the sum of such elements<br>of sequence ai, for which l ≤ i ≤ r holds.<br>As Leha is a white-hat hacker, he don’t want to test this vulnerability on a<br>real database. You are to write a similar database for Leha to test.</p><p>Input<br>The first line of input contains two integers n and q (1 ≤ n ≤ 105, 1 ≤ q ≤<br>105) denoting amount of cells in the bank and total amount of queries<br>respectively.</p><p>The following line contains n integers a1, a2, …, an (1 ≤ ai &lt; 109) denoting<br>the amount of money in each cell initially. These integers do not contain<br>leading zeros.</p><p>Each of the following q lines has one of the formats:</p><p>1 l r x y (1 ≤ l ≤ r ≤ n, 0 ≤ x ≤ 9, 1 ≤ y ≤ 9), denoting Leha asks to change<br>each digit x on digit y for each element ai of the sequence for which l ≤ i ≤<br>r holds;<br>2 l r (1 ≤ l ≤ r ≤ n), denoting you have to calculate and print the sum of<br>elements ai for which l ≤ i ≤ r holds.<br>Output<br>For each second type query print a single number denoting the required sum.</p><p>Examples<br>input<br>5 5<br>38 43 4 12 70<br>1 1 3 4 8<br>2 2 4<br>1 4 5 0 8<br>1 2 5 8 7<br>2 1 5<br>output<br>103<br>207<br>input<br>5 5<br>25 36 39 40 899<br>1 1 3 2 7<br>2 1 2<br>1 3 5 9 1<br>1 4 4 0 9<br>2 1 5<br>output<br>111<br>1002<br>Note<br>Let’s look at the example testcase.</p><p>Initially the sequence is [38, 43, 4, 12, 70].</p><p>After the first change each digit equal to 4 becomes 8 for each element with<br>index in interval [1; 3]. Thus, the new sequence is [38, 83, 8, 12, 70].</p><p>The answer for the first sum’s query is the sum in the interval [2; 4], which<br>equal 83 + 8 + 12 = 103, so the answer to this query is 103.</p><p>The sequence becomes [38, 83, 8, 12, 78] after the second change and [38, 73,<br>7, 12, 77] after the third.</p><p>The answer for the second sum’s query is 38 + 73 + 7 + 12 + 77 = 207.<br>——————————————————————————————————————<br>题目大意:</p><p>一个长度为n的序列 ，有两种操作，</p><ol><li>将[l, r]上所有数中 数位为x的都改为y </li><li>求[l, r]上所有数的和 </li></ol><hr><p>解题思路：</p><p>还是考虑直接的线段树维护，<br>每个节点维护10个信息，分别是数位为0~9的和，同时维护延迟标记</p><p>求和部分略，</p><p>对于数位修改，最大的问题就是考虑 如何维护lazy了，</p><p>这里维护的lazy同样有10个，lazy[i]表示的是接下来的数中数位为i的要变成数位lazy[i]</p><p>那么问题就是标记下传怎么搞了</p><p>和普通的标记下传相比 较为复杂,但也无非是把左右儿子的值先改过来 ,再把lazy合并过去,</p><p>还是看代码 比较好理解</p><pre class=" language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">//这是对左儿子进行pushdown的</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token number">10</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>vis<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>lazy<span class="token punctuation">[</span>rt<span class="token operator">&lt;&lt;</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span>sum2<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>sum<span class="token punctuation">[</span>rt<span class="token operator">&lt;&lt;</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 找两个临时变量代替左儿子的信息</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token number">10</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token keyword">if</span><span class="token punctuation">(</span>lazy<span class="token punctuation">[</span>rt<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">!=</span>i<span class="token punctuation">)</span><span class="token punctuation">{</span>                           <span class="token comment" spellcheck="true">//</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>j<span class="token operator">&lt;</span><span class="token number">10</span><span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token keyword">if</span><span class="token punctuation">(</span>lazy<span class="token punctuation">[</span>rt<span class="token operator">&lt;&lt;</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">==</span>i<span class="token punctuation">)</span> vis<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>lazy<span class="token punctuation">[</span>rt<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//数位变化</span>    sum2<span class="token punctuation">[</span>lazy<span class="token punctuation">[</span>rt<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">+</span><span class="token operator">=</span>sum<span class="token punctuation">[</span>rt<span class="token operator">&lt;&lt;</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>                              <span class="token comment" spellcheck="true">// 变过去的就要加上 </span>    sum2<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">-</span><span class="token operator">=</span>sum<span class="token punctuation">[</span>rt<span class="token operator">&lt;&lt;</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>                                        <span class="token comment" spellcheck="true">// 因为可能是变过来在变过去,所以不能直接赋0</span><span class="token punctuation">}</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token number">10</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span> sum<span class="token punctuation">[</span>rt<span class="token operator">&lt;&lt;</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>sum2<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span>lazy<span class="token punctuation">[</span>rt<span class="token operator">&lt;&lt;</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>vis<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span></code></pre><p>附本题代码  </p><pre class=" language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;bits/stdc++.h></span></span><span class="token keyword">typedef</span> <span class="token keyword">long</span> <span class="token keyword">long</span> <span class="token keyword">int</span> LL<span class="token punctuation">;</span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">const</span> <span class="token keyword">int</span> N <span class="token operator">=</span> <span class="token number">1e5</span><span class="token operator">+</span><span class="token number">7</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/*****************************************/</span>LL sum<span class="token punctuation">[</span>N<span class="token operator">&lt;&lt;</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">11</span><span class="token punctuation">]</span><span class="token punctuation">,</span>sum2<span class="token punctuation">[</span><span class="token number">11</span><span class="token punctuation">]</span><span class="token punctuation">,</span>a<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">int</span> lazy<span class="token punctuation">[</span>N<span class="token operator">&lt;&lt;</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">11</span><span class="token punctuation">]</span><span class="token punctuation">,</span>vis<span class="token punctuation">[</span><span class="token number">11</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">pushdown</span><span class="token punctuation">(</span><span class="token keyword">int</span> rt<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token number">10</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>vis<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>lazy<span class="token punctuation">[</span>rt<span class="token operator">&lt;&lt;</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span>sum2<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>sum<span class="token punctuation">[</span>rt<span class="token operator">&lt;&lt;</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token number">10</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token keyword">if</span><span class="token punctuation">(</span>lazy<span class="token punctuation">[</span>rt<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">!=</span>i<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>j<span class="token operator">&lt;</span><span class="token number">10</span><span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token keyword">if</span><span class="token punctuation">(</span>lazy<span class="token punctuation">[</span>rt<span class="token operator">&lt;&lt;</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">==</span>i<span class="token punctuation">)</span> vis<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>lazy<span class="token punctuation">[</span>rt<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        sum2<span class="token punctuation">[</span>lazy<span class="token punctuation">[</span>rt<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">+</span><span class="token operator">=</span>sum<span class="token punctuation">[</span>rt<span class="token operator">&lt;&lt;</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        sum2<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">-</span><span class="token operator">=</span>sum<span class="token punctuation">[</span>rt<span class="token operator">&lt;&lt;</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token number">10</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span> sum<span class="token punctuation">[</span>rt<span class="token operator">&lt;&lt;</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>sum2<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span>lazy<span class="token punctuation">[</span>rt<span class="token operator">&lt;&lt;</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>vis<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token number">10</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span> vis<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>lazy<span class="token punctuation">[</span>rt<span class="token operator">&lt;&lt;</span><span class="token number">1</span><span class="token operator">|</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span>sum2<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>sum<span class="token punctuation">[</span>rt<span class="token operator">&lt;&lt;</span><span class="token number">1</span><span class="token operator">|</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token number">10</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token keyword">if</span><span class="token punctuation">(</span>lazy<span class="token punctuation">[</span>rt<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">!=</span>i<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>j<span class="token operator">&lt;</span><span class="token number">10</span><span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token keyword">if</span><span class="token punctuation">(</span>lazy<span class="token punctuation">[</span>rt<span class="token operator">&lt;&lt;</span><span class="token number">1</span><span class="token operator">|</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">==</span>i<span class="token punctuation">)</span> vis<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>lazy<span class="token punctuation">[</span>rt<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        sum2<span class="token punctuation">[</span>lazy<span class="token punctuation">[</span>rt<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">+</span><span class="token operator">=</span>sum<span class="token punctuation">[</span>rt<span class="token operator">&lt;&lt;</span><span class="token number">1</span><span class="token operator">|</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        sum2<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">-</span><span class="token operator">=</span>sum<span class="token punctuation">[</span>rt<span class="token operator">&lt;&lt;</span><span class="token number">1</span><span class="token operator">|</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token number">10</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span> sum<span class="token punctuation">[</span>rt<span class="token operator">&lt;&lt;</span><span class="token number">1</span><span class="token operator">|</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>sum2<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span>lazy<span class="token punctuation">[</span>rt<span class="token operator">&lt;&lt;</span><span class="token number">1</span><span class="token operator">|</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>vis<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token number">10</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span> lazy<span class="token punctuation">[</span>rt<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">pushup</span><span class="token punctuation">(</span><span class="token keyword">int</span> rt<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token number">10</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span> sum<span class="token punctuation">[</span>rt<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>sum<span class="token punctuation">[</span>rt<span class="token operator">&lt;&lt;</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">+</span>sum<span class="token punctuation">[</span>rt<span class="token operator">&lt;&lt;</span><span class="token number">1</span><span class="token operator">|</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">build</span><span class="token punctuation">(</span><span class="token keyword">int</span> rt<span class="token punctuation">,</span><span class="token keyword">int</span> l<span class="token punctuation">,</span><span class="token keyword">int</span> r<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token number">10</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span> sum<span class="token punctuation">[</span>rt<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token number">10</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>lazy<span class="token punctuation">[</span>rt<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>i<span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>l<span class="token operator">==</span>r<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">for</span><span class="token punctuation">(</span>LL t<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>a<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token punctuation">;</span>a<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token operator">/</span><span class="token operator">=</span><span class="token number">10</span><span class="token punctuation">,</span>t<span class="token operator">*</span><span class="token operator">=</span><span class="token number">10</span><span class="token punctuation">)</span>            sum<span class="token punctuation">[</span>rt<span class="token punctuation">]</span><span class="token punctuation">[</span>a<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token operator">%</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token operator">+</span><span class="token operator">=</span>t<span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> m <span class="token operator">=</span> r<span class="token operator">+</span>l <span class="token operator">>></span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token function">build</span><span class="token punctuation">(</span>rt<span class="token operator">&lt;&lt;</span><span class="token number">1</span>  <span class="token punctuation">,</span>l  <span class="token punctuation">,</span>m<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">build</span><span class="token punctuation">(</span>rt<span class="token operator">&lt;&lt;</span><span class="token number">1</span><span class="token operator">|</span><span class="token number">1</span><span class="token punctuation">,</span>m<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>r<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">pushup</span><span class="token punctuation">(</span>rt<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">update</span><span class="token punctuation">(</span><span class="token keyword">int</span> rt<span class="token punctuation">,</span><span class="token keyword">int</span> l<span class="token punctuation">,</span><span class="token keyword">int</span> r<span class="token punctuation">,</span><span class="token keyword">int</span> L<span class="token punctuation">,</span><span class="token keyword">int</span> R<span class="token punctuation">,</span><span class="token keyword">int</span> x<span class="token punctuation">,</span><span class="token keyword">int</span> y<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>L<span class="token operator">&lt;=</span>l<span class="token operator">&amp;&amp;</span>r<span class="token operator">&lt;=</span>R<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token number">10</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token keyword">if</span><span class="token punctuation">(</span>lazy<span class="token punctuation">[</span>rt<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span>x<span class="token punctuation">)</span><span class="token punctuation">{</span>            sum<span class="token punctuation">[</span>rt<span class="token punctuation">]</span><span class="token punctuation">[</span>y<span class="token punctuation">]</span><span class="token operator">+</span><span class="token operator">=</span>sum<span class="token punctuation">[</span>rt<span class="token punctuation">]</span><span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">;</span>            sum<span class="token punctuation">[</span>rt<span class="token punctuation">]</span><span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>            lazy<span class="token punctuation">[</span>rt<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>y<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">pushdown</span><span class="token punctuation">(</span>rt<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> m <span class="token operator">=</span> r<span class="token operator">+</span>l <span class="token operator">>></span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>L<span class="token operator">&lt;=</span>m<span class="token punctuation">)</span> <span class="token function">update</span><span class="token punctuation">(</span>rt<span class="token operator">&lt;&lt;</span><span class="token number">1</span>  <span class="token punctuation">,</span>l  <span class="token punctuation">,</span>m<span class="token punctuation">,</span>L<span class="token punctuation">,</span>R<span class="token punctuation">,</span>x<span class="token punctuation">,</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>R<span class="token operator">></span> m<span class="token punctuation">)</span> <span class="token function">update</span><span class="token punctuation">(</span>rt<span class="token operator">&lt;&lt;</span><span class="token number">1</span><span class="token operator">|</span><span class="token number">1</span><span class="token punctuation">,</span>m<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>r<span class="token punctuation">,</span>L<span class="token punctuation">,</span>R<span class="token punctuation">,</span>x<span class="token punctuation">,</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">pushup</span><span class="token punctuation">(</span>rt<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>LL <span class="token function">query</span><span class="token punctuation">(</span><span class="token keyword">int</span> rt<span class="token punctuation">,</span><span class="token keyword">int</span> l<span class="token punctuation">,</span><span class="token keyword">int</span> r<span class="token punctuation">,</span><span class="token keyword">int</span> L<span class="token punctuation">,</span><span class="token keyword">int</span> R<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>L<span class="token operator">&lt;=</span>l<span class="token operator">&amp;&amp;</span>r<span class="token operator">&lt;=</span>R<span class="token punctuation">)</span><span class="token punctuation">{</span>        LL ans <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span>LL i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token number">10</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span> ans<span class="token operator">+</span><span class="token operator">=</span>sum<span class="token punctuation">[</span>rt<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">*</span>i<span class="token punctuation">;</span>        <span class="token keyword">return</span> ans<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">pushdown</span><span class="token punctuation">(</span>rt<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> m <span class="token operator">=</span> r<span class="token operator">+</span>l <span class="token operator">>></span> <span class="token number">1</span><span class="token punctuation">;</span>LL ans <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>L<span class="token operator">&lt;=</span>m<span class="token punctuation">)</span> ans <span class="token operator">+</span><span class="token operator">=</span> <span class="token function">query</span><span class="token punctuation">(</span>rt<span class="token operator">&lt;&lt;</span><span class="token number">1</span>  <span class="token punctuation">,</span>l  <span class="token punctuation">,</span>m<span class="token punctuation">,</span>L<span class="token punctuation">,</span>R<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>R<span class="token operator">></span> m<span class="token punctuation">)</span> ans <span class="token operator">+</span><span class="token operator">=</span> <span class="token function">query</span><span class="token punctuation">(</span>rt<span class="token operator">&lt;&lt;</span><span class="token number">1</span><span class="token operator">|</span><span class="token number">1</span><span class="token punctuation">,</span>m<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>r<span class="token punctuation">,</span>L<span class="token punctuation">,</span>R<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">pushup</span><span class="token punctuation">(</span>rt<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> ans<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> n<span class="token punctuation">,</span>m<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">~</span><span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d%d"</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>n<span class="token punctuation">,</span><span class="token operator">&amp;</span>m<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%lld"</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">build</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> op<span class="token punctuation">,</span>l<span class="token punctuation">,</span>r<span class="token punctuation">,</span>x<span class="token punctuation">,</span>y<span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>m<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d%d%d"</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>op<span class="token punctuation">,</span><span class="token operator">&amp;</span>l<span class="token punctuation">,</span><span class="token operator">&amp;</span>r<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">==</span>op<span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d%d"</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>x<span class="token punctuation">,</span><span class="token operator">&amp;</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>x<span class="token operator">==</span>y<span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span>                <span class="token function">update</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span>n<span class="token punctuation">,</span>l<span class="token punctuation">,</span>r<span class="token punctuation">,</span>x<span class="token punctuation">,</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">else</span> <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%lld\n"</span><span class="token punctuation">,</span><span class="token function">query</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span>n<span class="token punctuation">,</span>l<span class="token punctuation">,</span>r<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Typora </tag>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  Codeforces 794F - Leha and security system [线段树-区间更新]【数据结构】</title>
      <link href="/2017/09/21/78053974/"/>
      <url>/2017/09/21/78053974/</url>
      
        <content type="html"><![CDATA[<h1 id="Codeforces-794F-Leha-and-security-system-线段树-区间更新-【数据结构】"><a href="#Codeforces-794F-Leha-and-security-system-线段树-区间更新-【数据结构】" class="headerlink" title="Codeforces 794F - Leha and security system [线段树-区间更新]【数据结构】"></a>Codeforces 794F - Leha and security system [线段树-区间更新]【数据结构】</h1><p>2017年09月21日 16:44:50  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：277</p><hr><p> 博客爬取于<code>2019-04-18 17:15:23</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/78053974" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/78053974</a></p><p>题目链接： <a href="http://codeforces.com/problemset/problem/794/F" target="_blank" rel="noopener"> http://codeforces.com/problemset/problem/794/F</a><br>——————————————————————————————————————<br>F. Leha and security system<br>time limit per test2 seconds<br>memory limit per test512 megabytes<br>inputstandard input<br>outputstandard output<br>Bankopolis, the city you already know, finally got a new bank opened!<br>Unfortunately, its security system is not yet working fine… Meanwhile hacker<br>Leha arrived in Bankopolis and decided to test the system!</p><p>Bank has n cells for clients’ money. A sequence from n numbers a1, a2, …, an<br>describes the amount of money each client has. Leha wants to make requests to<br>the database of the bank, finding out the total amount of money on some<br>subsegments of the sequence and changing values of the sequence on some<br>subsegments. Using a bug in the system, Leha can requests two types of queries<br>to the database:</p><p>1 l r x y denoting that Leha changes each digit x to digit y in each element<br>of sequence ai, for which l ≤ i ≤ r is holds. For example, if we change in<br>number 11984381 digit 8 to 4, we get 11944341. It’s worth noting that Leha, in<br>order to stay in the shadow, never changes digits in the database to 0, i.e. y<br>≠ 0.<br>2 l r denoting that Leha asks to calculate and print the sum of such elements<br>of sequence ai, for which l ≤ i ≤ r holds.<br>As Leha is a white-hat hacker, he don’t want to test this vulnerability on a<br>real database. You are to write a similar database for Leha to test.</p><p>Input<br>The first line of input contains two integers n and q (1 ≤ n ≤ 105, 1 ≤ q ≤<br>105) denoting amount of cells in the bank and total amount of queries<br>respectively.</p><p>The following line contains n integers a1, a2, …, an (1 ≤ ai &lt; 109) denoting<br>the amount of money in each cell initially. These integers do not contain<br>leading zeros.</p><p>Each of the following q lines has one of the formats:</p><p>1 l r x y (1 ≤ l ≤ r ≤ n, 0 ≤ x ≤ 9, 1 ≤ y ≤ 9), denoting Leha asks to change<br>each digit x on digit y for each element ai of the sequence for which l ≤ i ≤<br>r holds;<br>2 l r (1 ≤ l ≤ r ≤ n), denoting you have to calculate and print the sum of<br>elements ai for which l ≤ i ≤ r holds.<br>Output<br>For each second type query print a single number denoting the required sum.</p><p>Examples<br>input<br>5 5<br>38 43 4 12 70<br>1 1 3 4 8<br>2 2 4<br>1 4 5 0 8<br>1 2 5 8 7<br>2 1 5<br>output<br>103<br>207<br>input<br>5 5<br>25 36 39 40 899<br>1 1 3 2 7<br>2 1 2<br>1 3 5 9 1<br>1 4 4 0 9<br>2 1 5<br>output<br>111<br>1002<br>Note<br>Let’s look at the example testcase.</p><p>Initially the sequence is [38, 43, 4, 12, 70].</p><p>After the first change each digit equal to 4 becomes 8 for each element with<br>index in interval [1; 3]. Thus, the new sequence is [38, 83, 8, 12, 70].</p><p>The answer for the first sum’s query is the sum in the interval [2; 4], which<br>equal 83 + 8 + 12 = 103, so the answer to this query is 103.</p><p>The sequence becomes [38, 83, 8, 12, 78] after the second change and [38, 73,<br>7, 12, 77] after the third.</p><p>The answer for the second sum’s query is 38 + 73 + 7 + 12 + 77 = 207.<br>——————————————————————————————————————<br>题目大意:</p><p>一个长度为n的序列 ，有两种操作，</p><ol><li>将[l, r]上所有数中 数位为x的都改为y </li><li>求[l, r]上所有数的和 </li></ol><hr><p>解题思路：</p><p>还是考虑直接的线段树维护，<br>每个节点维护10个信息，分别是数位为0~9的和，同时维护延迟标记</p><p>求和部分略，</p><p>对于数位修改，最大的问题就是考虑 如何维护lazy了，</p><p>这里维护的lazy同样有10个，lazy[i]表示的是接下来的数中数位为i的要变成数位lazy[i]</p><p>那么问题就是标记下传怎么搞了</p><p>和普通的标记下传相比 较为复杂,但也无非是把左右儿子的值先改过来 ,再把lazy合并过去,</p><p>还是看代码 比较好理解</p><pre><code>这是对左儿子进行pushdown的    for(int i=0;i&lt;10;i++)vis[i]=lazy[rt&lt;&lt;1][i],sum2[i]=sum[rt&lt;&lt;1][i];  // 找两个临时变量代替左儿子的信息    for(int i=0;i&lt;10;i++)if(lazy[rt][i]!=i){                           //        for(int j=0;j&lt;10;j++)if(lazy[rt&lt;&lt;1][j]==i) vis[j]=lazy[rt][i]; //数位变化        sum2[lazy[rt][i]]+=sum[rt&lt;&lt;1][i];                              // 变过去的就要加上值        sum2[i]-=sum[rt&lt;&lt;1][i];                                        // 因为可能是变过来在变过去,所以不能直接赋0    }    for(int i=0;i&lt;10;i++) sum[rt&lt;&lt;1][i]=sum2[i],lazy[rt&lt;&lt;1][i]=vis[i];</code></pre><hr><p>附本题代码<br>——————————————————————————————————————</p><pre><code>#include &lt;bits/stdc++.h&gt;typedef long long int LL;using namespace std;const int N = 1e5+7;/*****************************************/LL sum[N&lt;&lt;2][11],sum2[11],a[N];int lazy[N&lt;&lt;2][11],vis[11];void pushdown(int rt){    for(int i=0;i&lt;10;i++)vis[i]=lazy[rt&lt;&lt;1][i],sum2[i]=sum[rt&lt;&lt;1][i];    for(int i=0;i&lt;10;i++)if(lazy[rt][i]!=i){        for(int j=0;j&lt;10;j++)if(lazy[rt&lt;&lt;1][j]==i) vis[j]=lazy[rt][i];        sum2[lazy[rt][i]]+=sum[rt&lt;&lt;1][i];        sum2[i]-=sum[rt&lt;&lt;1][i];    }    for(int i=0;i&lt;10;i++) sum[rt&lt;&lt;1][i]=sum2[i],lazy[rt&lt;&lt;1][i]=vis[i];    for(int i=0;i&lt;10;i++) vis[i]=lazy[rt&lt;&lt;1|1][i],sum2[i]=sum[rt&lt;&lt;1|1][i];    for(int i=0;i&lt;10;i++)if(lazy[rt][i]!=i){        for(int j=0;j&lt;10;j++)if(lazy[rt&lt;&lt;1|1][j]==i) vis[j]=lazy[rt][i];        sum2[lazy[rt][i]]+=sum[rt&lt;&lt;1|1][i];        sum2[i]-=sum[rt&lt;&lt;1|1][i];    }    for(int i=0;i&lt;10;i++) sum[rt&lt;&lt;1|1][i]=sum2[i],lazy[rt&lt;&lt;1|1][i]=vis[i];    for(int i=0;i&lt;10;i++) lazy[rt][i] = i;}void pushup(int rt){    for(int i=0;i&lt;10;i++) sum[rt][i]=sum[rt&lt;&lt;1][i]+sum[rt&lt;&lt;1|1][i];}void build(int rt,int l,int r){    for(int i=0;i&lt;10;i++) sum[rt][i]=0;    for(int i=0;i&lt;10;i++)lazy[rt][i]=i;    if(l==r){        for(LL t=1;a[l];a[l]/=10,t*=10)            sum[rt][a[l]%10]+=t;        return ;    }    int m = r+l &gt;&gt; 1;    build(rt&lt;&lt;1  ,l  ,m);    build(rt&lt;&lt;1|1,m+1,r);    pushup(rt);}void update(int rt,int l,int r,int L,int R,int x,int y){    if(L&lt;=l&amp;&amp;r&lt;=R){        for(int i=0;i&lt;10;i++)if(lazy[rt][i]==x){            sum[rt][y]+=sum[rt][x];            sum[rt][x]=0;            lazy[rt][i]=y;        }        return ;    }    pushdown(rt);    int m = r+l &gt;&gt; 1;    if(L&lt;=m) update(rt&lt;&lt;1  ,l  ,m,L,R,x,y);    if(R&gt; m) update(rt&lt;&lt;1|1,m+1,r,L,R,x,y);    pushup(rt);}LL query(int rt,int l,int r,int L,int R){    if(L&lt;=l&amp;&amp;r&lt;=R){        LL ans = 0;        for(LL i=1;i&lt;10;i++) ans+=sum[rt][i]*i;        return ans;    }    pushdown(rt);    int m = r+l &gt;&gt; 1;LL ans = 0;    if(L&lt;=m) ans += query(rt&lt;&lt;1  ,l  ,m,L,R);    if(R&gt; m) ans += query(rt&lt;&lt;1|1,m+1,r,L,R);    pushup(rt);    return ans;}int n,m;int main(){    while(~scanf(&quot;%d%d&quot;,&amp;n,&amp;m)){        for(int i=1;i&lt;=n;i++) scanf(&quot;%lld&quot;,&amp;a[i]);        build(1,1,n);        int op,l,r,x,y;        for(int i=1;i&lt;=m;i++){            scanf(&quot;%d%d%d&quot;,&amp;op,&amp;l,&amp;r);            if(1==op){                scanf(&quot;%d%d&quot;,&amp;x,&amp;y);                if(x==y) continue;                update(1,1,n,l,r,x,y);            }            else printf(&quot;%lld\n&quot;,query(1,1,n,l,r));        }    }    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  hdu 6134 Battlestation Operational [反演]【数学】</title>
      <link href="/2017/08/18/77349012/"/>
      <url>/2017/08/18/77349012/</url>
      
        <content type="html"><![CDATA[<h1 id="hdu-6134-Battlestation-Operational-反演-【数学】"><a href="#hdu-6134-Battlestation-Operational-反演-【数学】" class="headerlink" title="hdu 6134 Battlestation Operational [反演]【数学】"></a>hdu 6134 Battlestation Operational [反演]【数学】</h1><p>2017年08月18日 01:01:18  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：348</p><hr><p> 博客爬取于<code>2019-04-18 17:15:29</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/77349012" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/77349012</a></p><p>题目链接: <a href="http://acm.hdu.edu.cn/showproblem.php?pid=6134" target="_blank" rel="noopener"> http://acm.hdu.edu.cn/showproblem.php?pid=6134</a><br>———————————————————————————————————————————<br>Battlestation Operational</p><p>Time Limit: 6000/3000 MS (Java/Others) Memory Limit: 65536/65536 K<br>(Java/Others)<br>Total Submission(s): 187 Accepted Submission(s): 100</p><p>Problem Description</p><blockquote><p>The Death Star, known officially as the DS-1 Orbital Battle Station, also<br>known as the Death Star I, the First Death Star, Project Stardust internally,<br>and simply the Ultimate Weapon in early development stages, was a moon-sized,<br>deep-space mobile battle station constructed by the Galactic Empire. Designed<br>to fire a single planet-destroying superlaser powered by massive kyber<br>crystals, it was the pet project of the Emperor, Darth Vader, and its eventual<br>commander Grand Moff Wilhuff Tarkin to expound the military philosophy of the<br>aptly named Tarkin Doctrine.</p></blockquote><blockquote></blockquote><blockquote><p>— Wookieepedia</p></blockquote><p>In the story of the Rogue One, the rebels risked their lives stolen the<br>construction plan of the Death Star before it can cause catastrophic damage to<br>the rebel base. According to the documents, the main weapon of the Death Star,<br>the Superlaser, emits asymmetric energy in the battlefield that cause photons<br>to annihilate and burns everything in a single shot.</p><p>You are assigned the task to estimate the damage of one shot of the<br>Superlaser.</p><p>Assuming that the battlefield is an n×n grid. The energy field ignited by the<br>Superlaser is asymmetric over the grid. For the cell at i-th row and j-th<br>column, ⌈i/j⌉ units of damage will be caused. Furthermore, due to the quantum<br>effects, the energies in a cell cancel out if gcd(i,j)≠1 or i&lt; j.</p><p>The figure below illustrates the damage caused to each cell for n=100. A cell<br>in black indicates that this cell will not be damaged due to the quantum<br>effects. Otherwise, different colors denote different units of damages.</p><p><img src="http://acm.hdu.edu.cn/data/images/C766-1002-1.jpg" alt></p><p>Your should calculate the total damage to the battlefield. Formally, you<br>should compute</p><p>f  (  n  )  =  ∑  n  i  =  1  ∑  i  j  =  1  ⌈  i  j  ⌉  [  (  i  ,  j  )  =<br>1  ]  ,</p><p>where [(i,j)=1] evaluates to be 1 if gcd(i,j)=1, otherwise 0.</p><p>Input<br>There are multiple test cases.</p><p>Each line of the input, there is an integer n (1≤n≤106), as described in the<br>problem.</p><p>There are up to 104 test cases.</p><p>Output<br>For each test case, output one integer in one line denoting the total damage<br>of the Superlaser, f(n) mod 109+7.</p><p>Sample Input<br>1<br>2<br>3<br>10</p><p>Sample Output<br>1<br>3<br>8<br>110</p><p>Source<br>2017 Multi-University Training Contest - Team 8<br>———————————————————————————————————————————<br>题意：给你一个n让你计算  f  (  n  )  =  ∑  n  i  =  1  ∑  i  j  =  1  ⌈  i  j  ⌉  [  (  i<br>,  j  )  =  1  ]  ,</p><hr><p>考虑  g  [  i  ]  =  ∑  i  j  =  1  ⌈  i  j  ⌉  ,  h  [  i  ]  =  ∑  i  j  =  1<br>⌈  i  j  ⌉  [  (  i  ,  j  )  =  1  ]  ,  f  [  n  ]  =  ∑  n  i  =  1  h  [<br>i  ]</p><p>显然有  </p><p>g  [  i  ]  =  ∑  d  |  i  h  [  i  d  ]  反  演  得  h  [  i  ]  =  ∑  d  |  i<br>μ  (  d  )  g  [  i  d  ]</p><p>所以得到  g  [  i  ]  后,可以通过筛法计算出  h  [  i  ]  ,然后前缀和处理一下就得到了  f  [  i  ]</p><p>所以问题就是如何求  g  [  i  ]  ,<br>很显然 枚举  i  有  n  n  √  的做法求出来,但是有点爆啊</p><p>所以这里采取枚举  j  的做法,<br>有  g  [  j  ]  =  1  ,  g  [  j  +  1  ,  j  ∗  2  ]  =  2  ,  g  [  j  ∗  2<br>+  1  ,  j  ∗  3  ]  =  3  ,  .  .  .  ,  g  [  j  ∗  k  +  1  ,  n  ]  =  k<br>+  1</p><p>转化一下,就是<br>g  [  j  ,  n  ]  +  =  1  ,  g  [  j  +  1  ,  n  ]  +  =  1  ,  g  [  j<br>∗  2  +  1  ,  n  ]  +  =  1  ,  .  .  .  ,  g  [  j  ∗  k  +  1  ,  n  ]<br>+  =  1</p><p>所以在每个  +  1  开始的位置加上1,然后前缀和处理一下就行了</p><p>我这里写的麻烦了,其实不用把  m  u  [  ]  求出来,直接计算就行.</p><p>附本题代码<br>———————————————————————————————————————————</p><pre><code>int n;LL g[N],f[N];int mu[N],prime[N],vis[N],cnt;void Init(){    memset(vis,0,sizeof(vis));    mu[1] = 1;    cnt = 0;    for(int i=2; i&lt;N; i++)    {        if(!vis[i])        {            prime[cnt++] = i;            mu[i] = -1;        }        for(int j=0; j&lt;cnt&amp;&amp;i*prime[j]&lt;N; j++)        {            vis[i*prime[j]] = 1;            if(i%prime[j]) mu[i*prime[j]] = -mu[i];            else            {                mu[i*prime[j]] = 0;                break;            }        }    }}int main(){    Init();    for(int i=1;i&lt;N;i++){        g[i]++;        for(int j=i;j&lt;N;j+=i) g[j+1]++;    }    for(int i=1;i&lt;N;i++) g[i]+=g[i-1];    for(int i=1;i&lt;N;i++)        for(int j=i;j&lt;N;j+=i)            f[j]=(f[j]+mu[i]*g[j/i])%MOD;    for(int i=1;i&lt;N;i++) f[i]=(f[i]+f[i-1])%MOD;    while(~scanf(&quot;%d&quot;,&amp;n)) printf(&quot;%lld\n&quot;,f[n]);    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  CA Academy 0-K Multiple [bfs，记录路径]【思维建图】</title>
      <link href="/2017/08/10/77044181/"/>
      <url>/2017/08/10/77044181/</url>
      
        <content type="html"><![CDATA[<h1 id="CA-Academy-0-K-Multiple-bfs，记录路径-【思维建图】"><a href="#CA-Academy-0-K-Multiple-bfs，记录路径-【思维建图】" class="headerlink" title="CA Academy 0-K Multiple [bfs，记录路径]【思维建图】"></a>CA Academy 0-K Multiple [bfs，记录路径]【思维建图】</h1><p>2017年08月10日 11:26:27  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：337</p><hr><p> 博客爬取于<code>2019-04-18 17:15:30</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/77044181" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/77044181</a></p><p>题目链接： <a href="https://csacademy.com/contest/archive/task/0-k-multiple/solution/" target="_blank" rel="noopener"> https://csacademy.com/contest/archive/task/0-k-multiple/solution/</a></p><p>————————————————————————————————————————</p><p>0-K Multiple<br>Time limit: 1000 ms<br>Memory limit: 128 MB</p><p>You are given an integer  N  and a digit  K  . Find the smallest multiple of<br>N  that consists only of digits  K  and  0  .</p><p>Standard input<br>The first line contains two integers NN and KK.</p><p>Standard output<br>Print the result on a single line.</p><p>Constraints and notes<br>1  ≤  N  ≤  10  5  ,  1  ≤  K  ≤  9</p><p>Input<br>5 2<br>Output<br>20</p><p>Input<br>7 4<br>Output<br>4004</p><p>Input<br>13 7<br>Output<br>7007<br>————————————————————————————————————————</p><p>题意：<br>给你一个数N和一个数字K</p><p>让你找到一个最小的有K和0组成的数字，能被N整除</p><hr><p>解题思路：</p><p>对于这个数字能确定第一位一定是K,<br>有了下一位 就是K*10+0/K了,</p><p>这种操作下出现的所有数字对N取模依然会有一个结果,且不超过N的.且最后一定有一个是%N为0的.这种情况就是答案了,</p><p>所以我们可以的枚举K*10+0/K这样的数来计算,但是注意题目要求的是最小的,</p><p>这时候有 我们可以类似于建立一个有向图</p><p><img src="https://img-blog.csdn.net/20170810112508933?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzMxODQxNzE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>然后bfs下去就好了，先处理0，在处理k，这样到达每个%N的位置均能保证最小，然后处理一个数组记录下路径就好了</p><p>附本题代码<br>————————————————————————————————————</p><pre><code>int n,k;int d[N],f[N],c[N];int main(){    while(cin&gt;&gt;n&gt;&gt;k){        for(int i=0;i&lt;=n;i++) d[i]=INF;        queue&lt;int&gt;q;        q.push(k%n);        d[k%n]=1;        c[k%n]=k;        f[k%n]=-1;        while(!q.empty()){            int t = q.front();q.pop();            int tem = (t*10)%n;            int tmp = (t*10+k)%n;            if(d[tem]==INF){                d[tem]=d[t]+1;                c[tem]=0;                f[tem]=t;                q.push(tem);            }            if(d[tmp]==INF){                d[tmp]=d[t]+1;                c[tmp]=k;                f[tmp]=t;                q.push(tmp);            }        }        string s = &quot;&quot;;        int x = 0;        while(x&gt;=0){            s+=(char)(&#39;0&#39;+c[x]);            x=f[x];        }        reverse(s.begin(),s.end());        cout &lt;&lt; s&lt;&lt; &quot;\n&quot;;    }    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  HDU 5239 Doom [线段树,更新有上界]【数据结构】</title>
      <link href="/2017/08/03/76158441/"/>
      <url>/2017/08/03/76158441/</url>
      
        <content type="html"><![CDATA[<h1 id="HDU-5239-Doom-线段树-更新有上界-【数据结构】"><a href="#HDU-5239-Doom-线段树-更新有上界-【数据结构】" class="headerlink" title="HDU 5239 Doom [线段树,更新有上界]【数据结构】"></a>HDU 5239 Doom [线段树,更新有上界]【数据结构】</h1><p>2017年08月03日 22:57:34  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：384</p><hr><p> 博客爬取于<code>2019-04-18 17:15:31</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/76158441" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/76158441</a></p><p>好久没有更新博客了 更新一波吧，，，</p><p>题目链接: <a href="http://acm.hdu.edu.cn/showproblem.php?pid=5239" target="_blank" rel="noopener"> http://acm.hdu.edu.cn/showproblem.php?pid=5239</a></p><p>——————————————————————————————————————</p><p>Doom</p><p>Time Limit: 12000/6000 MS (Java/Others) Memory Limit: 524288/524288 K<br>(Java/Others)<br>Total Submission(s): 1524 Accepted Submission(s): 419</p><p>Problem Description<br>THE END IS COMINGGGGGG!</p><p>Mike has got stuck on a mystery machine. If he cannot solve this problem, he<br>will go to his doom.</p><p>This machine is consist of n cells, and a screen. The i-th cell contains a<br>number ai(1≤i≤n). The screen also contains a number s, which is initially 0.</p><p>There is a button on each cell. When the i-th is pushed, Mike observes that,<br>the number on the screen will be changed to s+ai, where s is the original<br>number. and the number on the i-th cell will be changed to a2i.</p><p>Mike observes that the number is stored in radix p, where<br>p=9223372034707292160. In other words , the operation is under modulo p.</p><p>And now, Mike has got a list of operations. One operation is to push buttons<br>between from l-th to r-th (both included), and record the number on the<br>screen. He is tired of this stupid work, so he asks for your help. Can you<br>tell him, what are the numbers recorded.</p><p>Input<br>The first line contains an integer T(T≤5), denoting the number of test cases.</p><p>For each test case, the first line contains two integers n,m(1≤n,m≤105).</p><p>The next line contains n integers ai(0≤ai&lt; p), which means the initial values<br>of the n cells.</p><p>The next m lines describe operations. In each line, there are two integers<br>l,r(1≤l≤r≤n), representing the operation.</p><p>Output<br>For each test case, output ”Case #t:”, to represent this is the t-th case. And<br>then output the answer for each query operation, one answer in a line.</p><p>For more details you can take a look at the example.</p><p>Sample Input<br>2<br>4 4<br>2 3 4 5<br>1 2<br>2 3<br>3 4<br>1 4<br>1 3<br>2<br>1 1<br>1 1<br>1 1</p><p>Sample Output<br>Case #1:<br>5<br>18<br>39<br>405<br>Case #2:<br>2<br>6<br>22</p><p>——————————————————-.</p><p>题目大意:<br>给你一个序列,每个序列有一个值.</p><p>每次选择一个区间,将这个区间的数的和加起来,然后让这个区间的每个数都平方.</p><p>所有数都是对9223372034707292160取模的</p><hr><p>注意这个模数，和正常的模数不一样，那么就一定有问题</p><p>然后通过打表能发现，每个数不断自身平方对p取模后经过有限次 就不会变化了，</p><p>测试少于30次</p><p>所以也就是说每个节点至多会被更新30次，</p><p>所以可以直接维护线段树，打上平方标记后，还要打一个标记表示这个区间的数已经不会变化了，这样这个位置就不用再更新了</p><p>这样的话 复杂度就是  O  (  n  log  n  ∗  30  )</p><p>附本题代码</p><hr><pre><code>#include &lt;bits/stdc++.h&gt;typedef unsigned long long int LLu;typedef unsigned __int64 LL;using namespace std;const int N   = 100000+7;const LL  MOD = (LL)9223372034707292160 ;#define lal puts(&quot;****&quot;);#define pb push_back#define mp make_pairinline int read(){    int x = 0,f=1;char ch = getchar();    for(;ch&lt;&#39;0&#39;||&#39;9&#39;&lt;ch;ch=getchar()) if(ch == &#39;-&#39;) getchar();    for(;&#39;0&#39;&lt;=ch&amp;&amp;ch&lt;=&#39;9&#39;;ch=getchar()) x=(x&lt;&lt;3)+(x&lt;&lt;1)+ch-&#39;0&#39;;    return x*f;}/********************************************************/int n,m,x;LL a[N];LL qmul(LL a,LL b){    LL res = 0;    while(b){        if(b&amp;1) res=(res+a)%MOD;        b&gt;&gt;=1,a=(a+a)%MOD;    }    return res;}LL sum[N&lt;&lt;2];bool vis[N&lt;&lt;2];void pushup(int rt){    vis[rt]=vis[rt&lt;&lt;1]&amp;vis[rt&lt;&lt;1|1];    sum[rt]=(sum[rt&lt;&lt;1]+sum[rt&lt;&lt;1|1])%MOD;}void build(int rt,int l,int r){    sum[rt]=0,vis[rt]=false;    if(l==r) {sum[rt]=a[l];return ;}    int m = r+l &gt;&gt;1;    build(rt&lt;&lt;1  ,l  ,m);    build(rt&lt;&lt;1|1,m+1,r);    pushup(rt);}void update(int rt,int l,int r,int L,int R){    if(vis[rt]&amp;&amp;L&lt;=l&amp;&amp;r&lt;=R)return ;    if(l==r){        LL tmp = qmul(sum[rt],sum[rt]);        if(tmp == sum[rt]) vis[rt]=true;        sum[rt]=tmp;        return ;    }    int m =r+l &gt;&gt; 1;    if(L&lt;=m) update(rt&lt;&lt;1  ,l  ,m,L,R);    if(R&gt; m) update(rt&lt;&lt;1|1,m+1,r,L,R);    pushup(rt);}LL query(int rt,int l,int r,int L,int R){    if(L&lt;=l&amp;&amp;r&lt;=R) return sum[rt];    int m = r+l &gt;&gt; 1;    LL ans = 0;    if(L&lt;=m) ans+= query(rt&lt;&lt;1  ,l  ,m,L,R),ans%=MOD;    if(R&gt; m) ans+= query(rt&lt;&lt;1|1,m+1,r,L,R),ans%=MOD;    return ans;}int main(){//    cout &lt;&lt; MOD &lt;&lt; endl;//    for(int i=2;i&lt;=10;i++){//        LL x=i;//        for(int j=1;j&lt;=100;j++){//            cout&lt;&lt;x&lt;&lt;&quot;\n&quot;;//            x=qmul(x,x);//        }//        puts(&quot;-------------------------------&quot;);//    }    int _ = 1,kcase = 0;    for(scanf(&quot;%d&quot;,&amp;_);_--;){        scanf(&quot;%d%d&quot;,&amp;n,&amp;m);        for(int i=1;i&lt;=n;i++) scanf(&quot;%llu&quot;,&amp;a[i]);        LL ans = 0;        build(1,1,n);        printf(&quot;Case #%d:\n&quot;,++kcase);        for(int l,r;m--;){            scanf(&quot;%d%d&quot;,&amp;l,&amp;r);            ans += query(1,1,n,l,r);ans%=MOD;            update(1,1,n,l,r);            printf(&quot;%llu\n&quot;,ans);        }    }    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  2016女生赛 【（7+2）/10】</title>
      <link href="/2017/07/24/76037429/"/>
      <url>/2017/07/24/76037429/</url>
      
        <content type="html"><![CDATA[<h1 id="2016女生赛-【（7-2）-10】"><a href="#2016女生赛-【（7-2）-10】" class="headerlink" title="2016女生赛 【（7+2）/10】"></a>2016女生赛 【（7+2）/10】</h1><p>2017年07月24日 20:01:34  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：314</p><hr><p> 博客爬取于<code>2019-04-18 17:15:33</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/76037429" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/76037429</a></p><p>感觉今天都好没状态啊。</p><p><a href="http://www.mamicode.com/info-detail-1368322.html" target="_blank" rel="noopener"> dalao题解 </a></p><h1 id="A-HDU-5702-Solving-Order"><a href="#A-HDU-5702-Solving-Order" class="headerlink" title="A HDU 5702 Solving Order"></a>A HDU 5702 Solving Order</h1><p>——————————————————————————————————————<br>结构体排序没什么好说的。。</p><hr><h1 id="B-HDU-5703-Desert"><a href="#B-HDU-5703-Desert" class="headerlink" title="B HDU 5703 Desert"></a>B HDU 5703 Desert</h1><p>——————————————————————————————————————<br>给你一个整数，问你划分方法有多少种，然后用二进制输出，{1,2}{2,1}算两种</p><hr><p>退了一下，发现 结果就是  2  n  −  1</p><p>所以输出个  1  ,和  n  −  1  个  0  就行了</p><h1 id="C-HDU-5704-Luck-Competition"><a href="#C-HDU-5704-Luck-Competition" class="headerlink" title="C HDU 5704 Luck Competition"></a>C HDU 5704 Luck Competition</h1><p>——————————————————————————————————————<br>n（2~100）个人参加一个游戏，<br>每个人选择1~100范围的数。<br>然后得到所有数的平均数，再*=2/3，设得到的数为m。<br>如果一个人选的数，比m小，且相距m最为接近，那么其便在所有选数相同的人中等概率中奖。</p><p>现在，我们也参加比赛，其他n-1个人所选择的数也已经确定了，并且我们知道。<br>问你，选什么数拥有最高中奖率，并输出。</p><hr><p>数据量比较小,暴力枚举然后在模拟计算就行了</p><pre><code>#include &lt;bits/stdc++.h&gt;using namespace std;int vis[150];int main(){    int t;    scanf(&quot;%d&quot;,&amp;t);    while(t--)    {        memset(vis,0,sizeof(vis));        int n;        scanf(&quot;%d&quot;,&amp;n);        for(int i=1;i&lt;=n-1;i++)        {            int x;            scanf(&quot;%d&quot;,&amp;x);            vis[x]++;        }        double P=-1;        int output=-1;        for(int ans=100;ans&gt;=0;ans--)        {            vis[ans]++;            int sum=0;            for(int j=0;j&lt;=100;j++)            {                sum+=vis[j]*j;            }            double ave=sum;            ave=(ave/(double)n);            ave*=2;            ave=ave*1.0/3.0;            if(ans&lt;=ave)            {                int pos;                for(int j=(int)ave;j&gt;=0;j--)                {                    if(vis[j]&gt;0)                    {                        pos=j;                        break;                    }                }                if(pos==ans)                {                    double pp=1/(double)vis[ans];                    if(pp&gt;P)                    {                        P=pp;                        output=ans;                    }                }                else                {                    if(0&gt;P)                    {                        P=0;                        output=ans;                    }                }            }            vis[ans]--;        }        printf(&quot;%d %.2f\n&quot;,output,P);    }}</code></pre><h1 id="D-HDU-5705-Clock"><a href="#D-HDU-5705-Clock" class="headerlink" title="D HDU 5705 Clock"></a>D HDU 5705 Clock</h1><p>——————————————————————————————————————<br>给你一个时间,问你下一次时针和分针夹角为a度的时刻是多少,如果不是整数则把秒数向下取整</p><hr><p>暴力模拟即可,</p><p>为了方便比较 可以扩大倍数,使得时针1s动1个单位</p><pre><code>#include &lt;bits/stdc++.h&gt;#define maxs 20002020#define mme(i,j) memset(i,j,sizeof(i))using namespace std;#define abs(x) ((x)&lt;0?-(x):(x))int deg(int &amp;h,int &amp;m,int &amp;s){    int hh = (h*60*60+m*60+s);    int mm = (h*60*60+m*60+s)*12;    hh %= 720*60;    mm %= 720*60;    int t = abs(hh-mm);    return min(t,720*60-t);}void add1(int &amp;h,int &amp;m,int &amp;s){    s++;    if(s == 60){        m++;        s=0;    }    if(m == 60) {        h++;        m=0;    }    if(h == 12){        h = 0;    }}int main(){    // h  1/720   1    // m  1/60    12    // s  1       720    int _ = 1,kcase=0;    int h,m,s,x,p,tp,th,tm,ts;    while(~scanf(&quot;%d:%d:%d&quot;,&amp;h,&amp;m,&amp;s)){        scanf(&quot;%d&quot;,&amp;x); x*=120;        p = deg(h,m,s);        while(true){            th=h,tm=m,ts=s;            add1(h,m,s);            tp = deg(h,m,s);            if(tp == x) break;            if(tp&lt;x&amp;&amp;p&gt;x){                h=th,m=tm,s=ts;                break;            }            if(x&lt;tp&amp;&amp;p&lt;x){                h=th,m=tm,s=ts;                break;            }            p=tp;//            printf(&quot;%d:%d:%d  %d - %d\n&quot;,h,m,s,tp,x);        }        printf(&quot;Case #%d: %02d:%02d:%02d\n&quot;,++kcase,h,m,s);    }    return 0;}</code></pre><h1 id="E-HDU-5706-GirlCat"><a href="#E-HDU-5706-GirlCat" class="headerlink" title="E HDU 5706 GirlCat"></a>E HDU 5706 GirlCat</h1><p>——————————————————————————————————————<br>一个n*m的网格,每个格子有一个字母 ,问你能构成的girl和cat的个数</p><hr><p>爆搜即可</p><pre><code>#include &lt;bits/stdc++.h&gt;#define maxs 202002using namespace std;int ok;int n,m;char a[1005][1005];int fx[4]={0,0,1,-1};int fy[4]={1,-1,0,0};void Dfs(int x,int y,int num){    if(num==0)if(a[x][y]!=&#39;g&#39;)return ;    if(num==1)if(a[x][y]!=&#39;i&#39;)return ;    if(num==2)if(a[x][y]!=&#39;r&#39;)return ;    if(num==3)if(a[x][y]!=&#39;l&#39;)return ;    if(num==3)    {        ok++;        return ;    }    for(int i=0;i&lt;4;i++)    {        int xx=x+fx[i];        int yy=y+fy[i];        if(xx&gt;=0&amp;&amp;x&lt;n&amp;&amp;yy&gt;=0&amp;&amp;yy&lt;m)        {            Dfs(xx,yy,num+1);        }    }}void Dfs2(int x,int y,int num){    if(num==0)if(a[x][y]!=&#39;c&#39;)return ;    if(num==1)if(a[x][y]!=&#39;a&#39;)return ;    if(num==2)if(a[x][y]!=&#39;t&#39;)return ;    if(num==2)    {        ok++;        return ;    }    for(int i=0;i&lt;4;i++)    {        int xx=x+fx[i];        int yy=y+fy[i];        if(xx&gt;=0&amp;&amp;x&lt;n&amp;&amp;yy&gt;=0&amp;&amp;yy&lt;m)        {            Dfs2(xx,yy,num+1);        }    }}int main(){    int t;    scanf(&quot;%d&quot;,&amp;t);    while(t--)    {        scanf(&quot;%d%d&quot;,&amp;n,&amp;m);        for(int i=0;i&lt;n;i++)scanf(&quot;%s&quot;,a[i]);        int output=0;        for(int i=0;i&lt;n;i++)        {            for(int j=0;j&lt;m;j++)            {                if(a[i][j]==&#39;g&#39;)                {                    ok=0;                    Dfs(i,j,0);                    output+=ok;                }            }        }        printf(&quot;%d &quot;,output);        output=0;        for(int i=0;i&lt;n;i++)        {            for(int j=0;j&lt;m;j++)            {                if(a[i][j]==&#39;c&#39;)                {                    ok=0;                    Dfs2(i,j,0);                    output+=ok;                }            }        }        printf(&quot;%d\n&quot;,output);    }}</code></pre><h1 id="F-HDU-5707-Combine-String"><a href="#F-HDU-5707-Combine-String" class="headerlink" title="F HDU 5707 Combine String"></a>F HDU 5707 Combine String</h1><p>——————————————————————————————————————<br>给你三个字符串,问你能不能将a,b合并成c,且a,b字符串的字母顺序不被改变</p><hr><p>设f[i][j] 表示当前,到达a[i],b[j]的时候,能不能凑成c[0~i+j-1],,</p><p>转移的时候就是</p><p>i  f  (  a  [  i  −  1  ]  =  =  c  [  i  +  j  −  1  ]  )  f  [  i  ]  [  j<br>]  ∣  ∣  (  位  或  )  =  f  [  i  −  1  ]  [  j  ]  ;  i  f  (  b  [  j  −  1<br>]  =  =  c  [  i  +  j  −  1  ]  )  f  [  i  ]  [  j  ]  ∣  ∣  (  位  或  )  =<br>f  [  i  ]  [  j  −  1  ]  ;</p><pre><code>#include&lt;bits/stdc++.h&gt;typedef long long int LL;using namespace std;#define abs(x) ((x)&gt;0?(x):-(x))const int N = 100000+7;const int M = 10000000+7;/***************************************************/char a[2222],b[2222],c[2222];int f[2222][2222];int main(){    while(~scanf(&quot;%s&quot;,a)){        scanf(&quot;%s&quot;,b);        scanf(&quot;%s&quot;,c);        int la=strlen(a);        int lb=strlen(b);        int lc=strlen(c);        if(lc!=la+lb){            puts(&quot;No&quot;);            continue;        }        memset(f,0,sizeof(f));        f[0][0]=1;        for(int i=0;i&lt;=la;i++)for(int j=0;j&lt;=lb;j++){            if(i==0&amp;&amp;j==0) continue;            if(i&gt;0&amp;&amp;a[i-1]==c[i+j-1]) f[i][j] |=f[i-1][j];            if(j&gt;0&amp;&amp;b[j-1]==c[i+j-1]) f[i][j] |=f[i][j-1];        }        puts(f[la][lb]?&quot;Yes&quot;:&quot;No&quot;);    }    return 0;}</code></pre><h1 id="G-HDU-5708-Alice-and-Bob"><a href="#G-HDU-5708-Alice-and-Bob" class="headerlink" title="G HDU 5708 Alice and Bob"></a>G HDU 5708 Alice and Bob</h1><p>——————————————————————————————————————<br>两个人走格子，从(1,1)开始走 ,每次可以从(x,y)走到(x+1,y),(x,y+1),(x+k,y+k)<br>轮到谁的时候不能走了 就输了.<br>两个人足够聪明 然后问你谁能赢,Alice先</p><hr><p>手写了几组k,然后发现有一个规律, 然后就打表观察了下 ,然后就总结了下规律然后AC.了..</p><p>这个规律有点不好描述 自己看吧 打表代码为solve()函数</p><pre><code>#include &lt;bits/stdc++.h&gt;#define maxs 20002020#define mme(i,j) memset(i,j,sizeof(i))using namespace std;#define abs(x) ((x)&lt;0?-(x):(x))int a[111][111],b[111][111];void solve(){    int n = 20;    int m = 20;    int k =  4;    for(int i=1;i&lt;=n;i++){        for(int j=1;j&lt;=m;j++){            if(a[i][j]==0){                a[i][j+1]=1;                a[i+1][j]=1;                a[i+k][j+k]=1;            }        }    }    for(int i=1;i&lt;=n;i++){        for(int j=1;j&lt;=m;j++){            b[i][j]=b[i-1][j]+b[i][j-1]-b[i-1][j-1]+a[i][j];        }    }    for(int i=1;i&lt;=n;i++){        for(int j=1;j&lt;=i;j++)            printf(&quot; %d&quot;,a[i][j],i+j);        puts(&quot;&quot;);    }    return ;}int main(){//    solve();    int _ = 1,q,k,n,m;    for(scanf(&quot;%d&quot;,&amp;_);_--;){        scanf(&quot;%d%d&quot;,&amp;q,&amp;k);        for(int i=1;i&lt;=q;i++){            scanf(&quot;%d%d&quot;,&amp;n,&amp;m);            if(n&lt;m) swap(n,m);            int flag = m/(k+1);            if(k == 1){                if(n%2==0||m%2==0) puts(&quot;Alice&quot;);                else               puts(&quot;Bob&quot;);            }            else {                if(m%(k+1)==0||(m-flag+n)&amp;1)  puts(&quot;Alice&quot;);                else               puts(&quot;Bob&quot;);            }        }    }    return 0;}</code></pre><h1 id="H-HDU-5709-Claris-Loves-Painting"><a href="#H-HDU-5709-Claris-Loves-Painting" class="headerlink" title="H HDU 5709 Claris Loves Painting"></a>H HDU 5709 Claris Loves Painting</h1><p>——————————————————————————————————————<br>有n(&lt;=1e5)个点的树，每个点都有颜色（颜色可能重复），有m(&lt;=1e5)个询问，每次询问(x,d)问在x的子树中，与x的距离不超过d的节点有多少种不同<br>的颜色。强制要求在线。</p><hr><p>维护两颗线段树,并还要有合并的操作,不是特别懂….<br>看 <a href="http://www.cnblogs.com/clrs97/p/5538804.html" target="_blank" rel="noopener"> claris的博客吧 </a></p><h1 id="I-HDU-5710-Digit-Sum"><a href="#I-HDU-5710-Digit-Sum" class="headerlink" title="I HDU 5710 Digit-Sum"></a>I HDU 5710 Digit-Sum</h1><p>——————————————————————————————————————<br>我们要找出最小的正整数n满足——<br>a<em>S(n)==b</em>S(2n)<br>a,b的范围都在[1,100]<br>s(x)为x的所有位的和</p><hr><p>首先能明确的是</p><p>s  (  2  n  )  =  2  s  (  n  )  −  9  L  _ _ _ L  为  n  里  面  大  于  5  的  数<br>字  的  个  数</p><p>因为大于  5  就会进位,相当于  −  10  +  1  =  9</p><p>所以有  </p><p>a  ×  s  (  n  )  =  b  ×  s  (  2  n  )  =  &gt; a  ×  s  (  n  )  =  b  ×  (  2<br>s  (  n  )  −  9  L  )  =  &gt; (  2  ∗  b  −  a  )  ×  s  (  n  )  =  b  ×  9  L<br>=  &gt; L  s  (  n  )  =  2  ∗  b  −  a  b  ∗  9</p><ol><li>a  =  2  b  ，则  L  =  0  ，S为任意值。可得最小的  n  =  1  ； </li><li>a  &gt; 2  b  ，则  L  &lt; 0  ，矛盾！则无满足的  n  ，输出  0  ； </li><li>a  &lt; 2  b  ，  S  =  9  b  L  2  b  −  a  ≤  5  L  (至少有L个5)，即必须满足  b  ≤  5  a  ，否则无满足的n，输出0。 </li></ol><p>然后考虑数n的选取，</p><p>我们假设有l的长度是[0,4]范围，有L的长度是[5,9]范围</p><p>我们不妨假设答案n仅有长度为L，且每一位都是5<br>然后得到了把数位和sum分撒出去。</p><p>对于sum余下的数值，我们依次加到尾巴上。<br>如果sum最后把长度为L的字串都填充为‘9‘之后，还有剩余，那么在前面贪心填充。</p><h1 id="J-HDU-5711-Ingress"><a href="#J-HDU-5711-Ingress" class="headerlink" title="J HDU 5711 Ingress"></a>J HDU 5711 Ingress</h1><p>——————————————————————————————————————<br>n（16）个点<br>m（n^2）条双向边<br>K（50）次hack机会<br>最远走L（2000）路程</p><p>每个点的初始点权为a <a href="500"> i </a><br>每个点每hack一次点权下降b <a href="不会变为负"> i </a></p><hr><p>队友补的 我还不会 待补…</p>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  2014上海全国邀请赛 【(5+3)/10】</title>
      <link href="/2017/07/23/75948179/"/>
      <url>/2017/07/23/75948179/</url>
      
        <content type="html"><![CDATA[<h1 id="2014上海全国邀请赛-【-5-3-10】"><a href="#2014上海全国邀请赛-【-5-3-10】" class="headerlink" title="2014上海全国邀请赛 【(5+3)/10】"></a>2014上海全国邀请赛 【(5+3)/10】</h1><p>2017年07月23日 20:46:34  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：390</p><hr><p> 博客爬取于<code>2019-04-18 17:15:34</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/75948179" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/75948179</a></p><p>日常血崩。<br>菜到爆了.</p><h1 id="A-HDU-5090-Game-with-Pearls"><a href="#A-HDU-5090-Game-with-Pearls" class="headerlink" title="A HDU 5090 Game with Pearls"></a>A HDU 5090 Game with Pearls</h1><p>——————————————————————————————————————————<br>给你一个序列，可以把每个元素加上k的倍数或者不加， 问你最后能不能组成一个序列，第1个元素是1，第2个元素是2，第3个元素是3，。。</p><hr><p>暴力模拟就行，从大小1的数开始，留下本身需要的1个，剩下的不断加K，知道当前的数没出现过。</p><p>最后扫一下判断就行</p><hr><pre><code>#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long int LL;const int N = 1e5+7;/******************************************************/int a[N];int vis[N];int n,k;int main(){    int _;    scanf(&quot;%d&quot;,&amp;_);    while(_--){        memset(vis,0,sizeof(vis));        scanf(&quot;%d%d&quot;,&amp;n,&amp;k);        for(int i=1;i&lt;=n;i++){            scanf(&quot;%d&quot;,&amp;a[i]);            vis[a[i]]++;        }        int flag = 1;        for(int i=1;i&lt;=n;i++){            for(int j=1;vis[i]&gt;1;j++){                if(vis[j*k+i] == 0){                    vis[j*k+i] = 1;                    vis[i]--;                }            }        }        for(int i=1;i&lt;=n;i++){            if(vis[i]!=1){                flag=0;                break;            }        }        if(flag) puts(&quot;Jerry&quot;);        else     puts(&quot;Tom&quot;);    }    return 0;}</code></pre><h1 id="B-HDU-5091-Beam-Cannon"><a href="#B-HDU-5091-Beam-Cannon" class="headerlink" title="B HDU 5091 Beam Cannon"></a>B HDU 5091 Beam Cannon</h1><p>——————————————————————————————————————————<br>在二维坐标系上给你一堆点,然后问你w*h这么大的矩形,最多能包含多少个点</p><hr><p>用到了扫描线;</p><p>首先考虑一维的情况<br>如果是一维的,要统计长为w的线段最多能包括多少个位置怎么搞?</p><p>可以反过来考虑,然后变成一堆长w的线段覆盖,然后求的就是那个被覆盖最多的点,区间更新后求最大值就行了</p><p>而这个题<br>可以考虑将一个点变成一个矩形,<br>然后从左向右扫描</p><p>使扫描过程中,遇到矩形的左边就+1,右边就-1,</p><p>并维护一个线段树区间更新取最大值就好了</p><hr><pre><code>#include &lt;bits/stdc++.h&gt;typedef long long int LL;using namespace std;const int N   = 1e6+7;const int MOD = 1e9+7;#define mp make_pair#define pb push_back#define yy1 second.first#define yy2 second.second#define vv  first.second/*********************************************/vector&lt;pair&lt;pair&lt;int,int&gt;,pair&lt;int,int&gt; &gt; &gt;line;int mx[N&lt;&lt;2],lazy[N&lt;&lt;2];void pushdown(int rt){    if(lazy[rt]){        lazy[rt&lt;&lt;1  ]+=lazy[rt];        lazy[rt&lt;&lt;1|1]+=lazy[rt];        mx[rt&lt;&lt;1  ]+=lazy[rt];        mx[rt&lt;&lt;1|1]+=lazy[rt];        lazy[rt]=0;    }}void pushup(int rt){    mx[rt]=max(mx[rt&lt;&lt;1],mx[rt&lt;&lt;1|1]);}void update(int rt,int l,int r,int L,int R,int v){    if(L&lt;=l&amp;&amp;r&lt;=R){        lazy[rt]+=v;        mx[rt]+=v;        return ;    }    int m = r+l &gt;&gt; 1;    pushdown(rt);    if(L&lt;=m) update(rt&lt;&lt;1  ,l  ,m,L,R,v);    if(R&gt; m) update(rt&lt;&lt;1|1,m+1,r,L,R,v);    pushup(rt);}int query(int rt,int l,int r,int L,int R){}int n,w,h;int main(){    int _ = 1;    for(;scanf(&quot;%d&quot;,&amp;n);){        if(n==-1) break;        scanf(&quot;%d%d&quot;,&amp;w,&amp;h);        memset(mx,0,sizeof(mx));        memset(lazy,0,sizeof(lazy));        line.clear();        for(int i=1,x,y;i&lt;=n;i++){            scanf(&quot;%d%d&quot;,&amp;x,&amp;y);            line.pb(mp(mp(x  , 1),mp(y,y+h)));            line.pb(mp(mp(x+w, 2),mp(y,y+h)));        }        sort(line.begin(),line.end());        int X = 90000;        int ans = 0;        for(int i=0;i&lt;line.size();i++){            if(line[i].vv == 1){                update(1,1,X,line[i].yy1+20001,line[i].yy2+20001, 1);                ans = max(ans,mx[1]);            }            else {                ans = max(ans,mx[1]);                update(1,1,X,line[i].yy1+20001,line[i].yy2+20001,-1);            }        }        printf(&quot;%d\n&quot;,ans);    }    return 0;}</code></pre><h1 id="C-HDU-5092-Seam-Carving"><a href="#C-HDU-5092-Seam-Carving" class="headerlink" title="C HDU 5092 Seam Carving"></a>C HDU 5092 Seam Carving</h1><p>——————————————————————————————————————————<br>给你一个矩阵,让你找一个从上到下的路线,使得这个路线经过数的和最小,并且尽量靠右.</p><p>注意 a[i][j] 只能走到 a[i+1][j-1],a[i+1][j],a[i+1][j+1]</p><hr><p>所以我们知道dp下到每个点的最小和，然后在最后一行找到最后一个最小的位置不算向回找就好了</p><pre><code>#include &lt;bits/stdc++.h&gt;typedef long long int LL;using namespace std;const int N   = 1e6+7;const int MOD = 1e9+7;/*********************************************/LL dp[111][111],a[111][111];int ms[111],len,n,m;int main(){    int _ = 1,kcase = 0;    for(scanf(&quot;%d&quot;,&amp;_);_--;){        scanf(&quot;%d%d&quot;,&amp;n,&amp;m);        len = 0;        memset(dp,0,sizeof(dp));        for(int i=1;i&lt;=n;i++){             a[i][0]= a[i][m+1]=10000000000000ll;            dp[i][0]=dp[i][m+1]=10000000000000ll;            for(int j=1;j&lt;=m;j++)                scanf(&quot;%lld&quot;,&amp;a[i][j]);        }        for(int i=1;i&lt;=n;i++){            for(int j=1;j&lt;=m;j++){                dp[i][j]=a[i][j]+                min(dp[i-1][j-1],min(dp[i-1][j],dp[i-1][j+1]));            }        }        int p,mi = 10000000000000ll;;        for(int i=1;i&lt;=m;i++){            if(dp[n][i]&lt;=mi){                mi = dp[n][i];                p  = i;            }        }        ms[++len] = p;        int tp;        for(int i=n-1;i;i--){            mi = dp[i][p-1];            tp = p-1;            if(mi&gt;=dp[i][p]){                mi = dp[i][p];                tp = p;            }            if(mi&gt;=dp[i][p+1]){                mi = dp[i][p+1];                tp = p+1;            }            p=tp;            ms[++len]=p;        }        printf(&quot;Case %d\n&quot;,++kcase);        for(int i=len;i;i--)            printf(&quot;%d%c&quot;,ms[i],(i==1)?&#39;\n&#39;:&#39; &#39;);    }    return 0;}</code></pre><h1 id="D-HDU-5093-Battle-ships"><a href="#D-HDU-5093-Battle-ships" class="headerlink" title="D HDU 5093 Battle ships"></a>D HDU 5093 Battle ships</h1><p>——————————————————————————————————————————<br>给你一个N<em>M的图,其中’</em>’可以放传,但是注意同一行一列只能放一个船,除非被’#’隔开,问你最多能放几个船.</p><hr><p>首先考虑每个行和列分开之后,没有被隔开的部分就是一个整体了,</p><p>然后考虑 ,处理完的这一个个, 行与列没有被隔开的中</p><p>假设行1 和列1,列2,列3, 没有被隔开,</p><p>那么行1只能找一个列对应的位置来放船，</p><p>然后这就是一个二分匹配模型了，、、</p><p>然后就用行与列建二分图求最大匹配就好了</p><pre><code>#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;vector&gt;using namespace std;vector&lt;int&gt;mp[25000+50];int vis[25000+50];int match[25000+50];int find(int u){  //  printf(&quot;%d %d\n&quot;,u,mp[u].size());    for(int i=0;i&lt;mp[u].size();i++){        int v=mp[u][i];        if(vis[v]==0){            vis[v]=1;            if(match[v]==-1||find(match[v])){                match[v]=u;                return 1;            }        }    }    return 0;}int h[111][111],l[111][111];char a[111][111];int n,m;void add(int u,int v){  //  printf(&quot;%d %d&lt; -\n&quot;,u,v);    mp[u].push_back(v);}void solve(){    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);    for(int i=1;i&lt;=n;i++) scanf(&quot;%s&quot;,a[i]+1);    int cnt = 0;    for(int i=1;i&lt;=n;i++)for(int j=1;j&lt;=m;j++)        h[i][j]=l[i][j]=-1;    memset(h,-1,sizeof(h));    memset(l,-1,sizeof(l));    for(int i=1;i&lt;=n;i++){        for(int j=1;j&lt;=m;j++){            if(a[i][j]==&#39;#&#39;) continue;            if(-1==h[i][j-1])h[i][j]=++cnt;            else h[i][j]=h[i][j-1];        }    }    for(int j=1;j&lt;=m;j++){        for(int i=1;i&lt;=n;i++){            if(a[i][j]==&#39;#&#39;) continue;            if(-1==l[i-1][j])l[i][j]=++cnt;            else l[i][j]=l[i-1][j];        }    }    for(int i=1;i&lt;=n;i++)for(int j=1;j&lt;=m;j++)        if(a[i][j]==&#39;*&#39;) add(h[i][j],l[i][j]);    for(int i=1;i&lt;=cnt;i++) match[i]=-1;    int output=0;    for(int i=1;i&lt;=cnt;i++){        for(int j=1;j&lt;=cnt;j++) vis[j]=0;        if(find(i))output++;    }    printf(&quot;%d\n&quot;,output);    for(int i=1;i&lt;=cnt;i++) mp[i].clear();    return ;}int main(){    int t;for(scanf(&quot;%d&quot;,&amp;t);t--;) solve();}</code></pre><h1 id="E-HDU-5094-Maze"><a href="#E-HDU-5094-Maze" class="headerlink" title="E HDU 5094 Maze"></a>E HDU 5094 Maze</h1><p>——————————————————————————————————————————<br>给你一个图，</p><hr><p>二进制枚举状态搜索，</p><p><strong> 队友A的,待补 </strong></p><p>———————–Update—————————–</p><p>就是搜索么。<br>我用a[x][y][0~3] 记录每个位置4个方向的们需要那种钥匙开 用a[x][y][4]记录(x,y)这个位置的钥匙是那种，</p><p>因为又9种钥匙， 所以只要用一个9位的二进制数进行枚举就好了</p><p>用vis[x][y][1&lt;&lt;10] 来标记每种状态下走到(x,y)、、</p><p>然后直接搜索就好了</p><p>注意不能走到输出-1；</p><pre><code>#include &lt;bits/stdc++.h&gt;typedef long long int LL;using namespace std;#define abs(x) ((x)&gt;0?(x):-(x))#define rep(a,b,c) for(int a=(b),end=(c);a&lt;=end;a++)const int N   = 2000+7;const int MOD = 1e9+7;/******************************************************/int n,m,q,k;int a[55][55][10];bool vis[55][55][1&lt;&lt;11];int fx[]={0,0,1,-1};int fy[]={1,-1,0,0};struct node {    int x,y,step,s;};int bfs(int x,int y){    queue&lt;node&gt;q;    node tmp,tem;    tmp.x    = x,tmp.y = y;    tmp.step = 0,tmp.s = 0;    q.push(tmp);    vis[1][1][0]=1;    int xx,yy,ss,st;    while(!q.empty()){        tem = q.front();q.pop();        if(tem.x == n&amp;&amp;tem.y == m)            return tem.step;        for(int i=0;i&lt;4;i++){            if( a[tem.x][tem.y][i]==-1) continue;            if((a[tem.x][tem.y][i]&amp;tem.s) != a[tem.x][tem.y][i]) continue;            xx = tem.x + fx[i];            yy = tem.y + fy[i];            ss = (tem.s | a[xx][yy][4]);            st = tem.step + 1;            if(xx&lt;1||xx&gt;n) continue;            if(yy&lt;1||yy&gt;m) continue;            if(vis[xx][yy][ss]) continue;            vis[xx][yy][ss]=1;            tmp.x    = xx;            tmp.y    = yy;            tmp.s    = ss;            tmp.step = st;            q.push(tmp);        }    }    return -1;}int main(){    while(~scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;q)){        memset(vis,0,sizeof(vis));        memset(a  ,0,sizeof(a  ));        scanf(&quot;%d&quot;,&amp;k);        for(int i=1,f,x1,x2,y1,y2,p;i&lt;=k;i++){            scanf(&quot;%d%d%d%d%d&quot;,&amp;x1,&amp;y1,&amp;x2,&amp;y2,&amp;p);            if(p == 0) f=-1;            else       f=1&lt;&lt;(p-1);            for(int j=0;j&lt;4;j++){                if(x1+fx[j]==x2&amp;&amp;y1+fy[j]==y2){                    a[x1][y1][j]|=f;                    break;                }            }            for(int j=0;j&lt;4;j++){                if(x2+fx[j]==x1&amp;&amp;y2+fy[j]==y1){                    a[x2][y2][j]|=f;                    break;                }            }        }        scanf(&quot;%d&quot;,&amp;k);        for(int i=1,x1,y1,p;i&lt;=k;i++){            scanf(&quot;%d%d%d&quot;,&amp;x1,&amp;y1,&amp;p);            a[x1][y1][4]|=1&lt;&lt;(p-1);        }        printf(&quot;%d\n&quot;,bfs(1,1));    }    return 0;}</code></pre><h1 id="F-HDU-5095-Linearization-of-the-kernel-functions-in-SVM"><a href="#F-HDU-5095-Linearization-of-the-kernel-functions-in-SVM" class="headerlink" title="F HDU 5095 Linearization of the kernel functions in SVM"></a>F HDU 5095 Linearization of the kernel functions in SVM</h1><p>——————————————————————————————————————————<br>给你10个系数,让你把10项的多项式的最简形式表示出来,</p><hr><p>小模拟</p><p>注意开始的数是正数的时候没有正号,<br>系数为1 的要省略</p><p>–</p><pre><code>#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long int LL;const int N = 1e5+7;/******************************************************/int a[N];char ch[100]={&#39; &#39;,&#39;p&#39;,&#39;q&#39;,&#39;r&#39;,&#39;u&#39;,&#39;v&#39;,&#39;w&#39;,&#39;x&#39;,&#39;y&#39;,&#39;z&#39;};int n,k;int main(){    int _; scanf(&quot;%d&quot;,&amp;_);    while(_--){        for(int i=1;i&lt;=10;i++) scanf(&quot;%d&quot;,&amp;a[i]);        int i;        for(i=1;i&lt;=10;i++) if(a[i]!=0) break;        int flag=0;        for(;i&lt;10;i++){            if(a[i]==0) continue;            if(a[i]&lt;0) {flag=1;                if(a[i]==-1) printf(&quot;-%c&quot;,ch[i]);                else         printf(&quot;%d%c&quot;,a[i],ch[i]);            }            else {                if(flag) printf(&quot;+&quot;);flag=1;                if(a[i]!=1) printf(&quot;%d%c&quot;,a[i],ch[i]);                else        printf(&quot;%c&quot;,ch[i]);            }        }        if(a[10]!=0) {            if(a[10]&gt;0) {                if(flag) printf(&quot;+&quot;);flag=1;                printf(&quot;%d&quot;,a[10]);            }            else {                printf(&quot;%d&quot;,a[10]),flag=1;            }        }        if(flag == 0) printf(&quot;0&quot;);        puts(&quot;&quot;);    }    return 0;}/***55550 0 0 0 0 0 0 0 0 0-5 -2  5 5 5 5 5 5 5 50 46 3 4 -5 -22 -8 -32 24 272 31 -5 0 0 12 0 0 -49 12-1 -1 -1 0 0 4 0 0 -6 70 0 0 0 0 -5 0 0 0 01 1 1 1 1 1 1 1 1 1-1 -1 -1 -1 -1 -1 -1 -1 -1-1 1 -1 1 -1 1 -1 1 -1 11 -1 1 -1 1 -1 1 -1 1 -1*/</code></pre><h1 id="G-HDU-5096-ACM-Rank"><a href="#G-HDU-5096-ACM-Rank" class="headerlink" title="G HDU 5096 ACM Rank"></a>G HDU 5096 ACM Rank</h1><p>——————————————————————————————————————————</p><p>大模拟,不补.</p><p>–</p><h1 id="H-HDU-5097-Page-Rank"><a href="#H-HDU-5097-Page-Rank" class="headerlink" title="H HDU 5097 Page Rank"></a>H HDU 5097 Page Rank</h1><p>——————————————————————————————————————————<br>待补…</p><hr><h1 id="I-HDU-5098-Smart-Software-Installer"><a href="#I-HDU-5098-Smart-Software-Installer" class="headerlink" title="I HDU 5098 Smart Software Installer"></a>I HDU 5098 Smart Software Installer</h1><p>——————————————————————————————————————————<br>给你一堆程序,后面带’*’好的需要重启之后才能生效,’:’ 后面的是需要安装完这个程序，才能开始安装的程序</p><p>问你最少需要打印多少次</p><hr><p>题目很水，就是题面太长了。没读。。。</p><p>只要注意到要把当前需要重启的程序个数最大化就好了。</p><p>过程就是个拓扑，</p><p>然后就是如何处理这个恶心的读入了。。。</p><pre><code>#include &lt;bits/stdc++.h&gt;typedef long long int LL;using namespace std;const int N   = 1e6+7;const int MOD = 1e9+7;#define pb push_back/*********************************************/int deg[N];bool vis[N];int cnt;int ms[N],len;int ms2[N],len2;string s;char t[N];vector&lt;int &gt;G[N];void add(int u,int v){    G[u].pb(v);    deg[v]++;}map&lt;string ,int &gt;mp;void topo(){    queue&lt;int &gt;q;    while(len) q.push(ms[len--]);    while(!q.empty()){// puts(&quot;++&quot;);        int u = q.front();q.pop();//        printf(&quot;cnt = %d  : %d\n&quot;,cnt,u);        for(int i=0;i&lt;G[u].size();i++){            int to = G[u][i];            deg[to]--;            if(deg[to] == 0){                if(vis[to]) ms[++len] = to;                else q.push(to);//,printf(&quot;%d &lt;--\n&quot;,to);            }        }    }}void solve(){    len = len2 = 0;    for(int i=1;i&lt;=cnt;i++)        if(deg[i]==0){            if(vis[i]) ms2[++len2]=i;            else        ms[++len ]=i;        }//    printf(&quot;&lt;%d,%d&gt;\n&quot;,len,len2);    int ans = 0;    for(;len||len2;){ans++;        topo();        while(len2) ms[++len] = ms2[len2--];    }    printf(&quot;%d\n&quot;,ans-1);    for(int i=1;i&lt;=cnt;i++) G[i].clear(),vis[i]=deg[i]=0;    return ;}void init(){    mp.clear();cnt=0;    int flag;    string id1,id2;    while(getline(cin,s) != NULL){         if(s[0] == &#39;\0&#39;) break;         istringstream sin(s);         sin &gt;&gt; t;         flag = 0;         int len = strlen(t);         for(int i = 0; i &lt; len; ++i)             if(t[i] == &#39;*&#39;) flag = 1;         t[len - 1 - flag] = &#39;\0&#39;;         id1 = t;         if(mp[id1] == 0) mp[id1]= ++cnt;         vis[mp[id1]] = flag;         while(sin &gt;&gt; id2){             if(mp[id2] == 0)                 mp[id2] = ++cnt;             add(mp[id2],mp[id1]);         }    }    return ;}int main(){    int _ = 1,kcase = 0;    cin&gt;&gt;_;    getchar();    getchar();    for(;_--;){        init();//        for(int i=1;i&lt;=cnt;i++){//            printf(&quot;%d: &quot;,i);//            for(int j=0;j&lt;G[i].size();j++){//                printf(&quot; %d-%d*&quot;,G[i][j],deg[G[i][j]]);//            }//            puts(&quot;&quot;);//        }//        for(int i=1;i&lt;=cnt;i++) printf(&quot;deg[%d]=%d\n&quot;,i,deg[i]);        printf(&quot;Case %d: &quot;,++kcase);        solve();    }    return 0;}</code></pre><h1 id="J-HDU-5099-Comparison-of-Android-versions"><a href="#J-HDU-5099-Comparison-of-Android-versions" class="headerlink" title="J HDU 5099 Comparison of Android versions"></a>J HDU 5099 Comparison of Android versions</h1><p>——————————————————————————————————————————</p><p>给你两个字符串,然后按照规则比较下大小.</p><hr><p>我做傻逼了</p><p>队友A的</p><p>题傻逼不补</p><pre><code>#include &lt;bits/stdc++.h&gt;using namespace std;char a[1500];char b[1500];#define mme(i,j) memset(i,j,sizeof(i))void print(int vala ,int valb ){    if(vala&gt;valb)printf(&quot;&gt;&quot;);    else if(vala==valb)printf(&quot;=&quot;);    else printf(&quot;&lt;&quot;);}int opt[3];int main(){    int t;    int kase=0;    scanf(&quot;%d&quot;,&amp;t);    while(t--)    {        mme(opt,0);        scanf(&quot;%s%s&quot;,a+1,b+1);        printf(&quot;Case %d: &quot;,++kase);        if(a[1]==b[1])//0---&gt;=   1----&gt;  -1----&lt;            opt[1]=0;        else if(a[1]&gt;b[1])            opt[1]=1;        else opt[1]=-1;        if(a[2]!=b[2])// bu tong        {            if(a[3]==b[3])            {                if(a[4]==b[4])                {                    if(a[5]==b[5])                        opt[2]=0;                    else{                        if(a[5]&gt;b[5])                            opt[2]=1;                        else                            opt[2]=-1;                    }                }else {                    if(a[4]&gt;b[4])                        opt[2]=1;                    else opt[2]=-1;                }            }else {                if(a[3]&gt;b[3])                    opt[2]=1;                else                    opt[2]=-1;            }        }else {            if(strcmp(a+3,b+3)&gt;0)                opt[2]=1;            else if(strcmp(a+3,b+3)&lt;0)                opt[2]=-1;            else opt[2]=0;        }        if(opt[1]==1)            printf(&quot;&gt; &quot;);        else if(opt[1]==-1)            printf(&quot;&lt; &quot;);        else printf(&quot;= &quot;);        if(opt[2]==1)            printf(&quot;&gt;\n&quot;);        else if(opt[2]==-1)            printf(&quot;&lt;\n&quot;);        else printf(&quot;=\n&quot;);    }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  第八届福建省赛-重现赛 【(6+3)/12】 [待补]</title>
      <link href="/2017/07/22/75687721/"/>
      <url>/2017/07/22/75687721/</url>
      
        <content type="html"><![CDATA[<h1 id="第八届福建省赛-重现赛-【-6-3-12】-待补"><a href="#第八届福建省赛-重现赛-【-6-3-12】-待补" class="headerlink" title="第八届福建省赛-重现赛 【(6+3)/12】 [待补]"></a>第八届福建省赛-重现赛 【(6+3)/12】 [待补]</h1><p>2017年07月22日 19:13:49  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：451</p><hr><p> 博客爬取于<code>2019-04-18 17:15:35</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/75687721" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/75687721</a></p><p>上来A题就崩了 上来习惯性long long 确忘了用I64d wa了4发。。<br>F题 一处爆int 又wa了10发。。。<br>L题 判断 把a[1][3]打成a[1][2]又wa了3发。。。。</p><p>果然我只是个坑队友的坑货，， ，贡献了队伍的全部罚时</p><h1 id="1-Frog"><a href="#1-Frog" class="headerlink" title="1 Frog"></a>1 Frog</h1><p>————————————————————————————————————<br>传统的鸡兔同笼问题。。</p><hr><p>a个脑袋，b条腿</p><p>青蛙个数 = b/2-a；<br>鸡的个数 = a-青蛙个数；</p><p>代码无</p><h1 id="2-Triangles"><a href="#2-Triangles" class="headerlink" title="2 Triangles"></a>2 Triangles</h1><p>————————————————————————————————————<br>给你两个三角形，问你这两个三角形是包含的，还是相交的，还是相离的。</p><hr><p>直接枚举两个三角形,判断一个三角形的三个点 是不是都在另一个三角形里面,如果有就是包含</p><p>然后就看是不是相离的, 如果没有任何一个点在另外的三角形里就是相离,但是要注意六芒星这种情况,所以还要枚举下边 看一看有没有相交的</p><p>然后就是相交了 …</p><hr><pre><code>#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;math.h&gt;#include &lt;iostream&gt;using namespace std;#define LL long long intconst int N = 1e5 + 7;const int MOD = 1e9+7;/**********************************/struct point{    double x,y;};struct trangle{    point p[3];}c[2];double multi(point p1,point p2,point p0){    return fabs((p1.x-p0.x)*(p2.y-p0.y)-(p1.y-p0.y)*(p2.x-p0.x));}double area(point a,point b,point c){    return multi(a,b,c);}int sum;// 判断c1 在不在c2 里bool cantian(trangle c1,trangle c2){    double ac2 =area(c2.p[0],c2.p[1],c2.p[2]);    int t =0 ;    for(int i=0;i&lt;=2;i++)        if(area(c1.p[i],c2.p[0],c2.p[1])+area(c1.p[i],c2.p[1],c2.p[2])+           area(c1.p[i],c2.p[0],c2.p[2]) &gt; ac2);        else sum++,t++;    return t==3;}bool IsIntersected(point s1,point e1,point s2,point e2)//两个线段相交{    return(max(s1.x,e1.x)&gt;=min(s2.x,e2.x))&amp;&amp;           (max(s2.x,e2.x)&gt;=min(s1.x,e1.x))&amp;&amp;           (max(s1.y,e1.y)&gt;=min(s2.y,e2.y))&amp;&amp;           (max(s2.y,e2.y)&gt;=min(s1.y,e1.y))&amp;&amp;           (multi(s1,s2,e1)*multi(s1,e1,e2)&gt;0)&amp;&amp;           (multi(s2,s1,e2)*multi(s2,e2,e1)&gt;0);}bool judge(){    if(IsIntersected(c[1].p[1],c[1].p[2],c[2].p[1],c[2].p[2]))return true;    if(IsIntersected(c[1].p[1],c[1].p[2],c[2].p[2],c[2].p[3]))return true;    if(IsIntersected(c[1].p[1],c[1].p[2],c[2].p[1],c[2].p[3]))return true;    if(IsIntersected(c[1].p[3],c[1].p[2],c[2].p[1],c[2].p[2]))return true;    if(IsIntersected(c[1].p[3],c[1].p[2],c[2].p[2],c[2].p[3]))return true;    if(IsIntersected(c[1].p[3],c[1].p[2],c[2].p[1],c[2].p[3]))return true;    if(IsIntersected(c[1].p[1],c[1].p[3],c[2].p[1],c[2].p[2]))return true;    if(IsIntersected(c[1].p[1],c[1].p[3],c[2].p[2],c[2].p[3]))return true;    if(IsIntersected(c[1].p[1],c[1].p[3],c[2].p[1],c[2].p[3]))return true;    return false;}void solve(){    sum = 0;    if(cantian(c[0],c[1])||cantian(c[1],c[0])){        puts(&quot;contain&quot;);        return ;    }    if(sum&gt;0||judge()){        puts(&quot;intersect&quot;);        return ;    }    puts(&quot;disjoint&quot;);    return ;}int main(){    int _ = 1,kcase = 0;    for(scanf(&quot;%d&quot;,&amp;_);_--;){        for(int i=0;i&lt;=1;i++)for(int j=0;j&lt;=2;j++)            scanf(&quot;%lf%lf&quot;,&amp;c[i].p[j].x,&amp;c[i].p[j].y);        solve();    }    return 0;}</code></pre><h1 id="3-DotA-and-LOL"><a href="#3-DotA-and-LOL" class="headerlink" title="3 DotA and LOL"></a>3 DotA and LOL</h1><p>————————————————————————————————————</p><h1 id="4-Game"><a href="#4-Game" class="headerlink" title="4 Game"></a>4 Game</h1><p>————————————————————————————————————<br>给你两个大数,(不含前导零),<br>两个人轮流操作自己的数,可以除以10(向下取整,没有小数.)或者翻转过去,(翻转之后要去掉前导0).</p><p>当有一时刻两个数相等则A赢,否则B赢,所以A想要将两个数变得相同,B想讲两个数变得不同.</p><p>问你两个人最后谁赢</p><hr><p>考虑到如果B想让两个数不等那么只能是在A中没有B的子串才行,否则A不断的翻转在除以10一定会有一个时刻和B相同,这时候无论B怎么翻转还是除10,最终的一定会<br>有一个时刻相等，</p><p>所以只要用kmp匹配一下A的数是否有B或者翻转的B就行了</p><p>注意的是 B的数 如果翻转就相当去去掉了后面的0，所以在匹配之前除了一下B，使两端都没有0；</p><pre><code>#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;queue&gt;#define maxs 2020202#define mme(i,j) memset(i,j,sizeof(i))using namespace std;char s[1000005],s2[1000005];int nexts[maxs];void getn(){    int len=strlen(s2);    int i=0,j;    j=nexts[0]=-1;    for(i=0;i&lt;len;)    {        if(j==-1 || s2[i]==s2[j])            nexts[++i]=++j;        else            j=nexts[j];    }}bool kmp(){    getn();    int len1=strlen(s),len2=strlen(s2);    int i=0,j=0;    for(i=0;i&lt;len1;)    {        if(j==-1||s[i]==s2[j])        {            i++;            j++;        }        else            j=nexts[j];        if(j&gt;=len2)            return 1;    }    if(j&gt;=len2)        return 1;    return 0;}int main(){    int t;    scanf(&quot;%d&quot;,&amp;t);    while(t--)    {        scanf(&quot;%s%s&quot;,s,s2);        int flag = 1;        for(int i=0;s2[i];i++){            if(s2[i]==&#39;0&#39;) continue;            flag = 0 ;break;        }        int l2 = strlen(s2);        for(int i=l2-1;i&gt;=0;i--){            if(s2[i]==&#39;0&#39;)                s2[i]=&#39;\0&#39;;            else break;        }//        puts(s2);        if(flag||kmp())        {            printf(&quot;Alice\n&quot;);        }        else        {            reverse(s2,s2+strlen(s2));            if(kmp())            {                printf(&quot;Alice\n&quot;);            }            else printf(&quot;Bob\n&quot;);        }    }}</code></pre><h1 id="5-Doctor"><a href="#5-Doctor" class="headerlink" title="5 Doctor"></a>5 Doctor</h1><p>————————————————————————————————————</p><h1 id="6-Change"><a href="#6-Change" class="headerlink" title="6 Change"></a>6 Change</h1><p>————————————————————————————————————<br>有一个根为1的有根树</p><p>然后有两种操作<br>1 v x k : a[v]+=x , a[v’]+=x-k (v’是v的孩子) , a[v”]+=x-2*k (v”是v’的孩子) and so on.<br>2 v : 输出 a[v] mod 1000000007(10^9 + 7).</p><hr><p>考虑单链的时候如何维护-n*k的情况,</p><p>对于⑤来讲  </p><p>①  −  &gt; ②  −  &gt; ③  −  &gt; ④  −  &gt; ⑤  −  4  k  1  −  3  k  1  −  2  k  1  −  1  k<br>1  −  0  k  1</p><p>可以变成这样</p><p>①  −  &gt; ②  −  &gt; ③  −  &gt; ④  −  &gt; ⑤  −  4  k  1  −  3  k  2  −  2  k  3  −  1  k<br>4  −  0  k  5  |  |  +  5  k  1  +  5  k  2  +  5  k  3  +  5  k  4  +  5<br>k  5  +  −  1  k  1  −  2  k  2  −  3  k  3  −  4  k  4  −  5  k  5</p><p>所以我们可以维护两个BIT,一个用来记录  ∑  k  i  另一个记录  ∑  i  ∗  k  +  i<br>然后翻倍相减即可,</p><p>同时在用一个维护  x  i  ,其实和上面的那个放一起就行了，，</p><p>考虑是在树上进行<br>i  对应的就是节点的深度</p><p>在加一个树剖就能做了</p><pre><code>int n;struct edge{    int to,next;}G[N&lt;&lt;1];int head[N],cntG;void add(int u,int v){    G[cntG].to=v,G[cntG].next=head[u],head[u]=cntG++;    G[cntG].to=u,G[cntG].next=head[v],head[v]=cntG++;}LL bit[N][3];#define lowbit(x) (x&amp;-x)void update(int i,int v,int x){    for(;i&amp;&amp;i&lt;=n;i+=lowbit(i)){        bit[i][x]+=v; bit[i][x]%=MOD;    }}LL getSum(int i,int x){    LL ans = 0;    for(;i;i-=lowbit(i))        ans+=bit[i][x];    return ans%=MOD;}int dep[N],fa[N],son[N],sz[N];void dfs(int u,int f,int d){    dep[u]=d,fa[u]=f,son[u]=0,sz[u]=1;    for(int i=head[u],to;i!=-1;i=G[i].next){        to=G[i].to;        if(to == f) continue;        dfs(to,u,d+1);        sz[u]+=sz[to];        if(sz[to]&gt;sz[son[u]]) son[u]=to;    }}int top[N],tree[N],tot;void dfs2(int u,int tp){    tree[u]=++tot;top[u]=tp;    if(son[u]) dfs2(son[u],tp);    else return ;    for(int i=head[u],to;i!=-1;i=G[i].next){        to=G[i].to;        if(to==fa[u]||to==son[u]) continue;        dfs2(to,to);    }}void solve(int x){    int fx=top[x],t=dep[x];    LL sum1 = 0,sum2 = 0,sum3 = 0;    while(fx!=1){        sum1 = (sum1+getSum(tree[x],0)-getSum(tree[fx]-1,0)+MOD)%MOD;        sum2 = (sum2+getSum(tree[x],1)-getSum(tree[fx]-1,1)+MOD)%MOD;        sum3 = (sum3+getSum(tree[x],2)-getSum(tree[fx]-1,2)+MOD)%MOD;        x=fa[fx],fx=top[x];    }    sum1 = (sum1+(getSum(tree[x],0)-getSum(tree[1]-1,0))+MOD)%MOD;    sum2 = (sum2+(getSum(tree[x],1)-getSum(tree[1]-1,1))+MOD)%MOD;    sum3 = (sum3+(getSum(tree[x],2)-getSum(tree[1]-1,2))+MOD)%MOD;    sum1*=t;sum1%=MOD;    sum2-=sum1;sum2=(sum2%MOD+MOD)%MOD;    sum2+=sum3;(sum2%=MOD);    printf(&quot;%I64d\n&quot;,sum2);    return ;}int main(){    int _ = 1,kcase = 0;    for(scanf(&quot;%d&quot;,&amp;_);_--;){        memset(head,-1,sizeof(head));        memset(bit,0,sizeof(bit));        n=read();cntG=0;        for(int i=2,x;i&lt;=n;i++){            x=read();add(i,x);        }        dfs(1,0,1);        tot=0,dfs2(1,1);        int q,op,v,x,k;        for(q=read();q--;){            op=read(),v=read();            if(1 == op){                x=read(),k=read();                update(tree[v],k,0);                update(tree[v],(LL)k*dep[v]%MOD,1);                update(tree[v],x,2);            }            else solve(v);        }    }    return 0;}</code></pre><h1 id="7-YYS"><a href="#7-YYS" class="headerlink" title="7 YYS"></a>7 YYS</h1><p>————————————————————————————————————<br>有n中物品，你一次只能抽取一个物品，得到每个物品的概率是1/n，然后问你凑齐n种物品的期望</p><hr><p>考虑拿到1个物品是的期望是1</p><p>那么拿到第二个物品就是在拿到第一个的基础上再拿到一个没拿过的 ，那么概率就是  (  n  −  1  )  /  n  ,期望就是  n  /  (  n<br>−  1  )</p><p>那么拿到第三个物品就是在拿到第二个的基础上再拿到一个没拿过的 ，那么概率就是  (  n  −  2  )  /  n  ,期望就是  n  /  (  n<br>−  2  )</p><p>。。。</p><p>那么拿到第  n  个物品就是在拿到第  n  −  1  个的基础上再拿到一个没拿过的 ，那么概率就是  (  n  −  2  )  /  n<br>,期望就是  n  /  (  n  −  2  )</p><p>所以结果就是  w  ×  ∑  i  =  1  n  n  i  =  ∑  i  =  1  n  n  !  i</p><p>因为数据有点大 所以上高精度</p><hr><pre><code>#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;math.h&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;#define LL long long intconst int N = 1e5 + 7;const int MOD = 1e9+7;/**********************************/#define MAXN 9999#define MAXSIZE 10#define DLEN 4class BigNum{private:    int a[MAXN];    //可以控制大数的位数    int len;       //大数长度public:    BigNum(){ len = 1;memset(a,0,sizeof(a)); }   //构造函数    BigNum(const int);       //将一个int类型的变量转化为大数    BigNum(const char*);     //将一个字符串类型的变量转化为大数    BigNum(const BigNum &amp;);  //拷贝构造函数    BigNum &amp;operator=(const BigNum &amp;);   //重载赋值运算符，大数之间进行赋值运算    friend istream&amp; operator&gt;&gt;(istream&amp;,  BigNum&amp;);   //重载输入运算符    friend ostream&amp; operator&lt;&lt;(ostream&amp;,  BigNum&amp;);   //重载输出运算符    BigNum operator+(const BigNum &amp;) const;   //重载加法运算符，两个大数之间的相加运算    BigNum operator-(const BigNum &amp;) const;   //重载减法运算符，两个大数之间的相减运算    BigNum operator*(const BigNum &amp;) const;   //重载乘法运算符，两个大数之间的相乘运算    BigNum operator/(const int   &amp;) const;    //重载除法运算符，大数对一个整数进行相除运算    BigNum operator^(const int  &amp;) const;    //大数的n次方运算    int    operator%(const int  &amp;) const;    //大数对一个int类型的变量进行取模运算    bool   operator&gt;(const BigNum &amp; T)const;   //大数和另一个大数的大小比较    bool   operator&lt;(const BigNum &amp; T) const;    bool   operator==(const BigNum &amp; T) const;    bool   operator&gt;(const int &amp; t)const;      //大数和一个int类型的变量的大小比较    bool   operator&lt;(const int &amp;t) const;    bool   operator==(const int &amp;t) const;    void print();       //输出大数};bool BigNum::operator==(const BigNum &amp; T) const {    return !(*this &gt; T) &amp;&amp; !(T &gt; *this);}bool BigNum::operator==(const int &amp;t) const {    BigNum T = BigNum(t);    return *this == T;}bool BigNum::operator&lt;(const BigNum &amp; T) const {    return T &gt; *this;}bool BigNum::operator&lt;(const int &amp;t) const {    return BigNum(t) &gt; *this;}BigNum::BigNum(const int b)     //将一个int类型的变量转化为大数{    int c,d = b;    len = 0;    memset(a,0,sizeof(a));    while(d &gt; MAXN)    {        c = d - (d / (MAXN + 1)) * (MAXN + 1);        d = d / (MAXN + 1);        a[len++] = c;    }    a[len++] = d;}BigNum::BigNum(const char*s)     //将一个字符串类型的变量转化为大数{    int t,k,index,l,i;    memset(a,0,sizeof(a));    l=strlen(s);    len=l/DLEN;    if(l%DLEN)        len++;    index=0;    for(i=l-1;i&gt;=0;i-=DLEN)    {        t=0;        k=i-DLEN+1;        if(k&lt;0)            k=0;        for(int j=k;j&lt;=i;j++)            t=t*10+s[j]-&#39;0&#39;;        a[index++]=t;    }}BigNum::BigNum(const BigNum &amp; T) : len(T.len)  //拷贝构造函数{    int i;    memset(a,0,sizeof(a));    for(i = 0 ; i &lt; len ; i++)        a[i] = T.a[i];}BigNum &amp; BigNum::operator=(const BigNum &amp; n)   //重载赋值运算符，大数之间进行赋值运算{    int i;    len = n.len;    memset(a,0,sizeof(a));    for(i = 0 ; i &lt; len ; i++)        a[i] = n.a[i];    return *this;}istream&amp; operator&gt;&gt;(istream &amp; in,  BigNum &amp; b)   //重载输入运算符{    char ch[MAXSIZE*4];    int i = -1;    in&gt;&gt;ch;    int l=strlen(ch);    int count=0,sum=0;    for(i=l-1;i&gt;=0;)    {        sum = 0;        int t=1;        for(int j=0;j&lt;4&amp;&amp;i&gt;=0;j++,i--,t*=10)        {            sum+=(ch[i]-&#39;0&#39;)*t;        }        b.a[count]=sum;        count++;    }    b.len =count++;    return in;}ostream&amp; operator&lt;&lt;(ostream&amp; out,  BigNum&amp; b)   //重载输出运算符{    int i;    cout &lt;&lt; b.a[b.len - 1];    for(i = b.len - 2 ; i &gt;= 0 ; i--)    {        cout.width(DLEN);        cout.fill(&#39;0&#39;);        cout &lt;&lt; b.a[i];    }    return out;}BigNum BigNum::operator+(const BigNum &amp; T) const   //两个大数之间的相加运算{    BigNum t(*this);    int i,big;      //位数    big = T.len &gt; len ? T.len : len;    for(i = 0 ; i &lt; big ; i++)    {        t.a[i] +=T.a[i];        if(t.a[i] &gt; MAXN)        {            t.a[i + 1]++;            t.a[i] -=MAXN+1;        }    }    if(t.a[big] != 0)        t.len = big + 1;    else        t.len = big;    return t;}BigNum BigNum::operator-(const BigNum &amp; T) const   //两个大数之间的相减运算{    int i,j,big;    bool flag;    BigNum t1,t2;    if(*this&gt;T)    {        t1=*this;        t2=T;        flag=0;    }    else    {        t1=T;        t2=*this;        flag=1;    }    big=t1.len;    for(i = 0 ; i &lt; big ; i++)    {        if(t1.a[i] &lt; t2.a[i])        {            j = i + 1;            while(t1.a[j] == 0)                j++;            t1.a[j--]--;            while(j &gt; i)                t1.a[j--] += MAXN;            t1.a[i] += MAXN + 1 - t2.a[i];        }        else            t1.a[i] -= t2.a[i];    }    t1.len = big;    while(t1.a[t1.len - 1] == 0 &amp;&amp; t1.len &gt; 1)    {        t1.len--;        big--;    }    if(flag)        t1.a[big-1]=0-t1.a[big-1];    return t1;}BigNum BigNum::operator*(const BigNum &amp; T) const   //两个大数之间的相乘运算{    BigNum ret;    int i,j,up;    int temp,temp1;    for(i = 0 ; i &lt; len ; i++)    {        up = 0;        for(j = 0 ; j &lt; T.len ; j++)        {            temp = a[i] * T.a[j] + ret.a[i + j] + up;            if(temp &gt; MAXN)            {                temp1 = temp - temp / (MAXN + 1) * (MAXN + 1);                up = temp / (MAXN + 1);                ret.a[i + j] = temp1;            }            else            {                up = 0;                ret.a[i + j] = temp;            }        }        if(up != 0)            ret.a[i + j] = up;    }    ret.len = i + j;    while(ret.a[ret.len - 1] == 0 &amp;&amp; ret.len &gt; 1)        ret.len--;    return ret;}BigNum BigNum::operator/(const int &amp; b) const   //大数对一个整数进行相除运算{    BigNum ret;    int i,down = 0;    for(i = len - 1 ; i &gt;= 0 ; i--)    {        ret.a[i] = (a[i] + down * (MAXN + 1)) / b;        down = a[i] + down * (MAXN + 1) - ret.a[i] * b;    }    ret.len = len;    while(ret.a[ret.len - 1] == 0 &amp;&amp; ret.len &gt; 1)        ret.len--;    return ret;}int BigNum::operator %(const int &amp; b) const    //大数对一个int类型的变量进行取模运算{    int i,d=0;    for (i = len-1; i&gt;=0; i--)    {        d = ((d * (MAXN+1))% b + a[i])% b;    }    return d;}BigNum BigNum::operator^(const int &amp; n) const    //大数的n次方运算{    BigNum t,ret(1);    int i;    if(n&lt;0)        exit(-1);    if(n==0)        return 1;    if(n==1)        return *this;    int m=n;    while(m&gt;1)    {        t=*this;        for( i=1;i&lt;&lt;1&lt;=m;i&lt;&lt;=1)        {            t=t*t;        }        m-=i;        ret=ret*t;        if(m==1)            ret=ret*(*this);    }    return ret;}bool BigNum::operator&gt;(const BigNum &amp; T) const   //大数和另一个大数的大小比较{    int ln;    if(len &gt; T.len)        return true;    else if(len == T.len)    {        ln = len - 1;        while(a[ln] == T.a[ln] &amp;&amp; ln &gt;= 0)            ln--;        if(ln &gt;= 0 &amp;&amp; a[ln] &gt; T.a[ln])            return true;        else            return false;    }    else        return false;}bool BigNum::operator &gt;(const int &amp; t) const    //大数和一个int类型的变量的大小比较{    BigNum b(t);    return *this&gt;b;}void BigNum::print()    //输出大数{    int i;    printf(&quot;%d&quot;, a[len-1]);    for (int i = len-2; i &gt;= 0; --i) {        printf(&quot;%04d&quot;, a[i]);    }}int main(){    int _ = 1,n;    for(scanf(&quot;%d&quot;,&amp;_);_--;){        scanf(&quot;%d&quot;,&amp;n);        BigNum ans = 0,t = 1;        for(int i=1;i&lt;=n;i++){            t=t*i;        }        for(int i=1;i&lt;=n;i++){            ans = ans + (t/i);        }        ans.print();        puts(&quot;.0&quot;);    }    return 0;}</code></pre><h1 id="8-Cantonese"><a href="#8-Cantonese" class="headerlink" title="8 Cantonese"></a>8 Cantonese</h1><p>————————————————————————————————————</p><h1 id="9-Magic"><a href="#9-Magic" class="headerlink" title="9 Magic"></a>9 Magic</h1><p>————————————————————————————————————<br>给你n个字符串,每个字符串有一个价值,<br>然后有两种操作<br>1 x y 将第x个字符串的价值变成y<br>2 x 问你以第x个字符串做为后缀的且价值小于等于第x个字符串价值的字符串有多少个</p><p>注意一个串是自身的后缀.</p><hr><p>本以为这题另有高论, 后缀??! 后缀数组什么的…</p><p>但是没想到到啊 这个  O  (  n  q  )  都能过….</p><p>首先预处理出每个字符串后缀的hash,<br>然后每次暴力枚举每个字符串判断就好了.</p><hr><pre><code>#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;math.h&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;#define LL long long intconst int N   = 1e5+7;const int MOD = 1e9+7;/**********************************/char s[1111][1111];unsigned long long int  h[1111][1111],t;int  a[1111],len[1111];int main(){    int _ = 1,n,q;    for(scanf(&quot;%d&quot;,&amp;_);_--;){        scanf(&quot;%d&quot;,&amp;n);        for(int i=1;i&lt;=n;i++){            scanf(&quot;%s %d&quot;,s[i],&amp;a[i]);            len[i] = strlen(s[i]);            reverse(s[i],s[i]+len[i]);            h[i][0]=(s[i][0]-&#39;a&#39;),t=29;            for(int j=1;j&lt;len[i];j++){                h[i][j]=h[i][j-1]+(s[i][j]-&#39;a&#39;)*t;                t=t*29;            }        }        int ans ,op,x,y;        scanf(&quot;%d&quot;,&amp;q);        for(int i=1;i&lt;=q;i++){            scanf(&quot;%d%d&quot;,&amp;op,&amp;x);            if(1 == op){                scanf(&quot;%d&quot;,&amp;y);                a[x]=y;            }            else {                ans = 0;                for(int i=1;i&lt;=n;i++){                    if(a[i]&gt;a[x]) continue;                    if(len[i]&lt;len[x]) continue;                    if(h[i][len[x]-1] == h[x][len[x]-1]){                        ans++;                    }                }                printf(&quot;%d\n&quot;,ans);            }        }    }    return 0;}</code></pre><h1 id="10-Trades"><a href="#10-Trades" class="headerlink" title="10 Trades"></a>10 Trades</h1><p>————————————————————————————————————<br>开始你有m钱，有n天，有一个显卡，在每天有不同的价格，你可以在某一天买显卡，或者卖显卡，或者不买不卖，问最后你的钱最多是多少。</p><hr><p>显然要在便宜的时候买，贵的时候卖，</p><p>然后考虑到 对于两个相邻的天，如果前一天的便宜，今天的贵那么就可以在前一天买然后在今天卖掉，这样就能赚钱了，</p><p>然后考虑  c  [  i  −  1  ]  &lt; c  [  i  ]  &lt; c  [  i  +  1  ]  的时候 ，应该在  i  −  1<br>天买,  i  +  1  天卖,那么其实和在  i  −  1  天买,  i  天卖  i  天买,  i  +  1  天卖<br>效果是等价的,所以只要比较两天的价格就好了,,</p><p>如果  c  [  i  −  1  ]  &lt; c  [  i  ]  那么就在  i  −  1  天买,  i  天卖。</p><p>不知道为什么用那个C++的高精度板子，就是过不去，然后用了Java才过。。</p><pre><code>import java.io.*;import java.util.*;import java.math.BigInteger;  public class Main{    public static void main(String args[]) throws Exception {        Scanner cin=new Scanner(System.in);        BigInteger t1;        BigInteger t2;        int t,n,k,cas,mod;        mod = 1000000007;        int[] c = new int[2222];        t = cin.nextInt();        for(cas=1;cas&lt;=t;cas++) {            n = cin.nextInt();            k = cin.nextInt();            BigInteger m = BigInteger.valueOf(k);            int i;            for(i=1;i&lt;=n;i++) c[i]=cin.nextInt();            for(i=2;i&lt;=n;i++)                if(c[i]&gt;c[i-1]){                    t1 = m.remainder(BigInteger.valueOf(c[i-1]));                    t2 = m.divide(BigInteger.valueOf(c[i-1])).multiply(BigInteger.valueOf(c[i]));                    m = t1.add(t2);                }            m = m.remainder(BigInteger.valueOf(mod));            System.out.println(&quot;Case #&quot;+cas+&quot;: &quot;+m);        }    }}</code></pre><h1 id="11-Wand"><a href="#11-Wand" class="headerlink" title="11 Wand"></a>11 Wand</h1><p>————————————————————————————————————<br>有n个人,每个人有一个物品,问你打乱这些物品后至少有K个人还拿到自己的物品的可能数</p><hr><p>考虑错排,</p><p>然后将至少有k个人的k+1个人的….n个人能拿到自己物品的方案数累加就行了,</p><pre><code>#include&lt;stdio.h&gt;#include&lt;string.h&gt;using namespace std;#define LL long long intconst int N = 1e5 + 7;const int MOD = 1e9+7;/**********************************/LL qmod(LL a,LL b) {    LL res = 1ll;    while(b) {        if(b&amp;1) res=res*a%MOD;        b&gt;&gt;=1,a=a*a%MOD;    }    return res;}LL dp[N];LL fac[N],inv[N];void init() {    fac[0]=1;    for(LL i=1; i&lt;N; i++) fac[i]=(fac[i-1]*i)%MOD;    inv[N-1] = qmod(fac[N-1],MOD-2);    for(LL i=N-2; i&gt;=0; i--) inv[i]=(inv[i+1]*(i+1))%MOD;}LL C(int n,int m) {    return fac[n]*inv[m]%MOD*inv[n-m]%MOD;}int main() {    init();    dp[0]=1;    dp[1]=0;    for(LL i=1; i&lt;=10000; i++) {        dp[i]=(i-1)*(dp[i-1]+dp[i-2]);        dp[i]%=MOD;    }    int t;    int n,kk;    scanf(&quot;%d&quot;,&amp;t);    while(t--) {        scanf(&quot;%d%d&quot;,&amp;n,&amp;kk);        LL output=0;        for(int k=kk; k&lt;=n; k++) {            output+=C(n,k)*dp[n-k]%MOD;            output%=MOD;        }        printf(&quot;%I64d\n&quot;,output%MOD);    }    return 0;}</code></pre><h1 id="12-Tic-Tac-Toe"><a href="#12-Tic-Tac-Toe" class="headerlink" title="12 Tic-Tac-Toe"></a>12 Tic-Tac-Toe</h1><p>————————————————————————————————————<br>两个人下井字棋,现在轮到Kim下,问你Kim在下两个子的内能不能赢</p><hr><p>考虑数据范围这么小 直接暴力枚举就好了,</p><p>首先枚举’.’ ,如果Kim下在这里就赢了 那就是Kim win<br>如果不是的话 要判断当前的局面 Kim是不是有大于两个地方能赢,这样才不会被另一个人扳平,</p><p>所以暴力枚举两次就行了</p><pre><code>#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;math.h&gt;using namespace std;#define LL long long intconst int N = 1e5 + 7;const int MOD = 1e9+7;/**********************************/int a[10][10];void display(){    for(int i=1;i&lt;=3;i++){        for(int j=1;j&lt;=3;j++)            printf(&quot;%d &quot;,a[i][j]);        puts(&quot;&quot;);    }    puts(&quot; &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&quot;);}bool judge(int x){//    printf(&quot;%d\n&quot;,x);//    display();    if(x==a[1][1]&amp;&amp;a[1][1]==a[1][2]&amp;&amp;a[1][2]==a[1][3])return true;    if(x==a[2][1]&amp;&amp;a[2][1]==a[2][2]&amp;&amp;a[2][2]==a[2][3])return true;    if(x==a[3][1]&amp;&amp;a[3][1]==a[3][2]&amp;&amp;a[3][2]==a[3][3])return true;    if(x==a[1][1]&amp;&amp;a[1][1]==a[2][1]&amp;&amp;a[2][1]==a[3][1])return true;    if(x==a[1][2]&amp;&amp;a[1][2]==a[2][2]&amp;&amp;a[2][2]==a[3][2])return true;    if(x==a[1][3]&amp;&amp;a[1][3]==a[2][3]&amp;&amp;a[2][3]==a[3][3])return true;    if(x==a[1][1]&amp;&amp;a[1][1]==a[2][2]&amp;&amp;a[2][2]==a[3][3])return true;    if(x==a[1][3]&amp;&amp;a[1][3]==a[2][2]&amp;&amp;a[2][2]==a[3][1])return true;//    puts(&quot;--&quot;);    return false;}bool Kim2(int x){    int flag = 0;    for(int i=1;i&lt;=3;i++){        for(int j=1;j&lt;=3;j++){            if(a[i][j]==0){                a[i][j]=x;                if(judge(x)) flag++;                a[i][j]=0;            }        }    }    return flag&gt;=2;}bool Kim1(int x){    for(int i=1;i&lt;=3;i++){        for(int j=1;j&lt;=3;j++){            if(a[i][j]==0){                a[i][j]=x;                if(judge(x)||Kim2(x))                    return true;                a[i][j]=0;            }        }    }    return false;}char s[10];int main(){    int _ = 1,kcase = 0;    for(scanf(&quot;%d&quot;,&amp;_);_--;){        for(int i=1;i&lt;=3;i++){            for(int j=1;j&lt;=3;j++){                scanf(&quot;%s&quot;,s);                if(s[0]==&#39;.&#39;) a[i][j]=0;                else if(s[0]==&#39;x&#39;) a[i][j]=1;                else a[i][j]=2;            }        }        scanf(&quot;%s&quot;,s);int x;        if(s[0]==&#39;x&#39;)   x=1;        else            x=2;        if(judge(3-x)) puts(&quot;Cannot win!&quot;);        else if(judge(x)||Kim1(x))             puts(&quot;Kim win!&quot;);        else puts(&quot;Cannot win!&quot;);    }    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  BNU Training 2017.07.20 【(2+1+0.233)/11】[待补]</title>
      <link href="/2017/07/20/75578185/"/>
      <url>/2017/07/20/75578185/</url>
      
        <content type="html"><![CDATA[<h1 id="BNU-Training-2017-07-20-【-2-1-0-233-11】-待补"><a href="#BNU-Training-2017-07-20-【-2-1-0-233-11】-待补" class="headerlink" title="BNU Training 2017.07.20 【(2+1+0.233)/11】[待补]"></a>BNU Training 2017.07.20 【(2+1+0.233)/11】[待补]</h1><p>2017年07月20日 21:19:45  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：527</p><hr><p> 博客爬取于<code>2019-04-18 17:15:37</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/75578185" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/75578185</a></p><h1 id="首先膜一发qls"><a href="#首先膜一发qls" class="headerlink" title="首先膜一发qls"></a>首先膜一发qls</h1><p>题目质量很高,,看样子是训练题而不是套题 ,没有特别简单的题目,</p><p>然后再次感到自己菜的一逼</p><h1 id="A-CodeChef-SPCLN-Cleaning-the-Space"><a href="#A-CodeChef-SPCLN-Cleaning-the-Space" class="headerlink" title="A CodeChef SPCLN Cleaning the Space"></a>A CodeChef SPCLN Cleaning the Space</h1><p>——————————————————————————————————————————</p><h1 id="B-CodeChef-PREFIXOR-Prefix-XOR"><a href="#B-CodeChef-PREFIXOR-Prefix-XOR" class="headerlink" title="B CodeChef PREFIXOR Prefix XOR"></a>B CodeChef PREFIXOR Prefix XOR</h1><p>——————————————————————————————————————————</p><h1 id="C-CodeChef-WIQ-Waiting-in-a-Queue"><a href="#C-CodeChef-WIQ-Waiting-in-a-Queue" class="headerlink" title="C CodeChef WIQ Waiting in a Queue"></a>C CodeChef WIQ Waiting in a Queue</h1><p>——————————————————————————————————————————<br>给你一个队列，每个人要做一个事情，他们分别在  b  [  i  ]  时刻准备好，并在轮到他的时候花费  a  [  i  ]  时间完成.<br>每次要花费一分钟检查队头的人准没准备好,如果队头的人准备好了就开始做,做完就离开,否则去队尾.</p><hr><p>这个和 <strong> CF div.2 424 E </strong> 比较像，但是需要多维护这些人的时间什么的。复杂一点</p><hr><p>首先能想到维护一个当前的时刻<br>那么能想到 每次操作 处理一个人，那么这个人一定是接下来的人中第一个准备好的，<br>于是 考虑每次只维护这些能准备好的人，将这些人的序号放入 <strong> set </strong> 中，每次遍历一轮，同时维护当前时刻将能准备好的在加入到 <strong> set </strong><br>中， 计算两个人之间花了多少时间用一个 <strong> 树状数组 </strong> 维护一下即可</p><blockquote><p>设立一个当前时间， 在当前时间下 走过一圈能准备好的 加入set 然后处理这些，<br>因为加入一个元素到set后，当前时间不处理 下一次也一定处理了，所以最多也就被访问两遍<br>总复杂度  O  (  n  log  n  )</p></blockquote><p><strong> set怎么这么强大啊 基本可代替SPLAY啊。 </strong></p><pre><code>#include &lt;bits/stdc++.h&gt;#define xx first#define yy second#define mp make_pair#define pb push_back#define fill( x, y ) memset( x, y, sizeof x )#define copy( x, y ) memcpy( x, y, sizeof x )using namespace std;typedef long long LL;typedef pair &lt; int, int &gt; pa;inline LL read() {    LL sc = 0, f = 1; char ch = getchar();    while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;) {if(ch ==&#39;-&#39;)f=-1;ch=getchar();}    while(ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;) sc=sc*10+ch-&#39;0&#39;,ch=getchar();    return sc * f;}const int MAXN = 1000005;int n, bit[MAXN], lef, cur;LL a[MAXN], b[MAXN], ans[MAXN], tim;set &lt; int &gt; S;pair&lt;LL,int&gt;c[MAXN];inline int lowbit(int x) {return x &amp; -x;}inline void modify(int x, int v) {for(;x&lt;=n;x+=lowbit(x))bit[x]+=v;}inline int query(int x) {int ret = 0;for(;x;x-=lowbit(x))ret+=bit[x];return ret;}inline void upd(){    while(cur&lt;=n&amp;&amp;tim+lef&gt;=c[cur].xx) S.insert( c[ cur++ ].yy );}inline void solve() {    n = lef = read(); tim = 0;cur = 1;    for( int i = 1 ; i &lt;= n ; i++ ) a[i]=read(),bit[i]=0;    for( int i = 1 ; i &lt;= n ; i++ ) b[i]=read()-1,modify(i,1),c[i]=mp(b[i],i);    sort(c+1,c+n+1);//    for(int i=1;i&lt;=n;i++)  printf(&quot;%lld %d\n&quot;,c[i].first,c[i].second);    while(lef){        if(!S.size()&amp;&amp;cur&lt;=n&amp;&amp;tim+lef&lt;=c[cur].xx) tim+=(c[cur].xx-tim)/lef*lef; //轮到下一个准备好的人的时间        upd();        int last = 0; set&lt;int&gt;::iterator it = S.begin();        while( it != S.end() ) {            tim += query( *it ) - query(last);            last = *it;            upd();            if( tim &gt; b[ *it ] ) {                ans[ *it ] = tim += a[ *it ];                upd();                lef--;                it++;                S.erase( last );                modify( last, -1 );            } else it++;        }        tim += query( n ) - query( last );    }    for( int i = 1 ; i &lt;= n ; i++ ) printf( &quot;%lld%c&quot;, ans[ i ], i == n ? &#39;\n&#39; : &#39; &#39; );}int main() {    for( int T = read() ; T ; T-- ) solve();    return 0;}</code></pre><h1 id="D-CodeChef-FOURPTS-Four-Points"><a href="#D-CodeChef-FOURPTS-Four-Points" class="headerlink" title="D CodeChef FOURPTS Four Points"></a>D CodeChef FOURPTS Four Points</h1><p>——————————————————————————————————————————<br>给你四个点,问你有没有一个三角形能经过这四个点,能的话输出YES和任意一个这样的三角形,否则输出NO</p><hr><p><strong> 没写代码,口胡一下 </strong></p><ol><li>首先特判一下有三点共线的情况, 有的话输出, </li><li>判断这四个点构成的四边形是凹的还是凸的,凹的话一定是NO输出 </li><li>如果是凸的一定有,然后找这个三角形,<br>找三角形的办法是先对点排个序,假设(a,b,c,d)是顺时针顺序的,则枚举  a  b  →  和  a  d  →  或  2  a  d  →  找<br>a  b  和  d  c  的交点即可 找到三角形第三个点,而另外两个点是  a  ,  d  还是  b  ,  c  看这两条线哪个长就行.</li></ol><h1 id="E-CodeChef-ANCESTOR-Ancestors-in-Two-Trees"><a href="#E-CodeChef-ANCESTOR-Ancestors-in-Two-Trees" class="headerlink" title="E CodeChef ANCESTOR Ancestors in Two Trees"></a>E CodeChef ANCESTOR Ancestors in Two Trees</h1><p>——————————————————————————————————————————</p><h1 id="F-CodeChef-CHEFPRAD-Chef-and-Pairs"><a href="#F-CodeChef-CHEFPRAD-Chef-and-Pairs" class="headerlink" title="F CodeChef CHEFPRAD Chef and Pairs"></a>F CodeChef CHEFPRAD Chef and Pairs</h1><p>——————————————————————————————————————————<br>有两个序列A,B，在  [  −  2  9  ,  2  9  ]  选择一个数使A数组的每一个元素减去这个数,然后根据  a  b  s  (  a<br>i  −  b  j  )  &lt; =  k  建边,然后求最大二分匹配,问你这个最大二分匹配是多少,</p><hr><p>首先考虑到应该通过一种什么样的方式枚举这些数,然后求这个二分匹配哦,但是光二分匹配的复杂度就已经O(VE)了, 所以这部分一定能优化</p><p>然后考虑到,这是一些序列,而建边的方式又是根据距离,所以这相当于在直线上的匹配,</p><p>然后发现对于数组a中的每个元素,如果要是匹配最大,左边的a一定尽量选左边的b, 对于b同理</p><p>那么我们可以枚举a和b数组,从左向右找,<br>那么分析如果当前  a  b  s  (  a  i  −  b  j  )  &lt; =  k  ,那么  i  +  +  ,  j  +  +<br>,否则的话 就选这两个中靠右的留下,因为靠左的已经不能在和他匹配的了</p><p>所以这部分就可以用  O  (  n  +  m  )  的复杂度处理.</p><p>然后想到如何枚举这些数</p><p>考虑 这个数的选取最好能使一个a[i]和b[j]匹配上，所以可以枚举a[i]-b[j]</p><p>注意的是这两个数能匹配上的点恰好是a[i]-b[j]-e 所以枚举这个就好了</p><p>复杂度为  O  (  n  m  )</p><p>总复杂度  O  (  T  n  m  (  n  +  m  )  )</p><pre><code>#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;algorithm&gt;using namespace std;#define ll long long intll a[1500];ll b[1500];ll dist[450][450];ll temp[450];int n,m;ll e;int Slove(ll x) {    for(int i=1; i&lt;=n; i++)  temp[i]=a[i]-x;    int ans = 0;    for(int i=1,j=1;i&lt;=n&amp;&amp;j&lt;=m;){        if(abs(temp[i]-b[j])&lt;=e) i++,j++,ans++;        else if(temp[i]&lt;b[j]) i++;        else j++;    }//    printf(&quot;%lld %d\n&quot;,x,ans);    return ans;}int main() {    int t;    scanf(&quot;%d&quot;,&amp;t);    while(t--) {        scanf(&quot;%d%d%lld&quot;,&amp;n,&amp;m,&amp;e);        for(int i=1; i&lt;=n; i++)scanf(&quot;%lld&quot;,&amp;a[i]);        sort(a+1,a+1+n);        for(int i=1; i&lt;=m; i++)scanf(&quot;%lld&quot;,&amp;b[i]);        sort(b+1,b+1+m);        for(int i=1; i&lt;=n; i++) {            for(int j=1; j&lt;=m; j++) {                dist[i][j]=(a[i]-b[j]);            }        }        int ans=0;        ans=max(Slove(0),ans);        for(int i=1; i&lt;=n; i++) {            for(int j=1; j&lt;=m; j++) {                ans=max(Slove(dist[i][j]-e),ans);            }        }        printf(&quot;%d\n&quot;,ans);    }}</code></pre><h1 id="G-CodeChef-PLUSMUL-Add-or-Multiply"><a href="#G-CodeChef-PLUSMUL-Add-or-Multiply" class="headerlink" title="G CodeChef PLUSMUL Add or Multiply"></a>G CodeChef PLUSMUL Add or Multiply</h1><p>——————————————————————————————————————————<br>给你一个序列，两个相邻的数之间可以放一个 <strong> 乘号 </strong> 或 <strong> 加号 </strong> ，问你所有可能下 放完符号的序列 运算完的结果总和是多少</p><hr><p>首先考虑每个数的贡献，但是因为有乘法在，容易重复，于是变成求以每个数结尾的 <strong> 单项式 </strong> 对结果的贡献</p><p>于是设<br>f[i] 表示以第i个数结尾的单项的系数 即：  f  [  i  ]  ∗  a  [  i  ]  ∗  2  (  n  −  i  −  1  )<br>为对结果的贡献</p><p>f[i]转移就是  </p><p>f  [  1  ]  =  0  f  [  2  ]  =  a  [  1  ]  f  [  i  ]  =  f  [  i  −  1  ]<br>∗  a  [  i  −  1  ]  +  a  [  i  −  1  ]  ∗  2  i  −  3  ,  i  &gt; =  3</p><p>然后加上每个数作为 <strong> 加数 </strong> 的贡献，</p><blockquote><p>算一下就好了 能发现除了首尾 都是  ×  2  n  −  3  ,  减  1  是  有  n  −  1  的  符  号  ,  去  掉<br>两  边  的  符  号  再  减  2</p></blockquote><p>最后计算结果 看代码把<br>因为是从3开始算得 所以1和2的情况要特判</p><pre><code>#include &lt;bits/stdc++.h&gt;typedef long long int LL;using namespace std;const int N = 100000+7;const int MOD = 1e9+7;LL a[N],f[N],q2[N];LL qq2(int x){    return (x&gt;=0)?q2[x]:1;}int main(){    q2[0]=1;    for(int i=1;i&lt;N;i++) q2[i]=(q2[i-1]*2)%MOD;    int _,n;scanf(&quot;%d&quot;,&amp;_);    while(_--){        scanf(&quot;%d&quot;,&amp;n);        pre[0]=1;a[0]=1;        for(int i=1;i&lt;=n;i++) scanf(&quot;%lld&quot;,&amp;a[i]);        if(n==1) {            printf(&quot;%d\n&quot;,a[1]);            continue;        }        if(n==2){            printf(&quot;%d\n&quot;,a[1]+a[2]+a[1]*a[2]);            continue;        }        LL ans = 0;        f[1]=0,f[2]=a[1];        for(int i=3;i&lt;=n;i++){            f[i]=f[i-1]*a[i-1]%MOD + a[i-1]*q2[i-3]%MOD;            f[i]%=MOD;        }        for(int i=1;i&lt;=n;i++){            ans+=a[i]*q2[n-3]%MOD;ans%=MOD;            ans+=a[i]*f[i]%MOD*qq2(n-i-1)%MOD;ans%=MOD;        }        ans += (a[1]+a[n])*q2[n-1-2]%MOD;ans%=MOD;        printf(&quot;%lld\n&quot;,ans);    }    return 0;}</code></pre><h1 id="H-CodeChef-GQUERY-Game-Revisited"><a href="#H-CodeChef-GQUERY-Game-Revisited" class="headerlink" title="H CodeChef GQUERY Game Revisited"></a>H CodeChef GQUERY Game Revisited</h1><p>——————————————————————————————————————————</p><h1 id="I-CodeChef-MEXDIV-Mex-division"><a href="#I-CodeChef-MEXDIV-Mex-division" class="headerlink" title="I CodeChef MEXDIV Mex division"></a>I CodeChef MEXDIV Mex division</h1><p>——————————————————————————————————————————</p><h1 id="J-CodeChef-ROBOTDAG-Robots-in-a-DAG"><a href="#J-CodeChef-ROBOTDAG-Robots-in-a-DAG" class="headerlink" title="J CodeChef ROBOTDAG Robots in a DAG"></a>J CodeChef ROBOTDAG Robots in a DAG</h1><p>——————————————————————————————————————————</p><h1 id="K-CodeChef-BLACKCOM-Black-Nodes-in-Subgraphs"><a href="#K-CodeChef-BLACKCOM-Black-Nodes-in-Subgraphs" class="headerlink" title="K CodeChef BLACKCOM Black Nodes in Subgraphs"></a>K CodeChef BLACKCOM Black Nodes in Subgraphs</h1><p>——————————————————————————————————————————</p>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  第七届福建省赛 【(5+2)/10】</title>
      <link href="/2017/07/18/75331107/"/>
      <url>/2017/07/18/75331107/</url>
      
        <content type="html"><![CDATA[<h1 id="第七届福建省赛-【-5-2-10】"><a href="#第七届福建省赛-【-5-2-10】" class="headerlink" title="第七届福建省赛 【(5+2)/10】"></a>第七届福建省赛 【(5+2)/10】</h1><p>2017年07月18日 21:46:10  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：522</p><hr><p> 博客爬取于<code>2019-04-18 17:15:38</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/75331107" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/75331107</a></p><p>做的怀疑人生啊 最终5题，其中F和J思路都是对的 但是就是不AC啊</p><p>看来之前高估了自几的代码能力，以为代码能力已经差不多了，，没想到原来代码能力都这么菜。</p><h1 id="2262-Best-Friend-Forever"><a href="#2262-Best-Friend-Forever" class="headerlink" title="2262 Best Friend Forever"></a>2262 Best Friend Forever</h1><p>————————————————————————————————————————————</p><h1 id="2263-Bond"><a href="#2263-Bond" class="headerlink" title="2263 Bond"></a>2263 Bond</h1><p>————————————————————————————————————————————</p><h1 id="2264-Card-Game-First-Edition"><a href="#2264-Card-Game-First-Edition" class="headerlink" title="2264 Card Game (First Edition)"></a>2264 Card Game (First Edition)</h1><p>————————————————————————————————————————————</p><p>每回合两个人轮流在一个序列中任意取一个数，谁的数大谁的1分 ，相等 不得分，问你所有可能下先手得分的期望</p><hr><p>能确定得分的期望 就是任意顺序下总得分除以总的所有可能的轮数</p><p>所有可能的轮数 就是  (  2  n  )  !  因为取数是有顺序的 所以就是全排列</p><p>然后计算先手的总分</p><p>考虑拿先手拿到  a  i  时对结果的贡献.</p><p>那就是  ∑  n  j  =  1  [  a  i  &gt; a  j  ]  ×  (  2  n  −  2  )  !  ×  C  (  n  ,<br>1  )</p><p>后手取的 是  (  a  j  )  固定这两个数 然后一共有  n  轮,这是其中的一轮,所以乘一个  C  (  n  ,  1  )<br>而其他的  2  n  −  2  个数 就又是全排列的</p><p>然后约分下式子就是  ∑  n  i  =  1  ∑  n  j  =  1  [  a  i  &gt; a  j  ]  n  ∗  4  −  2</p><p>计算  ∑  n  j  =  1  [  a  i  &gt; a  j  ]  的时候只要先对a排个序 然后二分就好了</p><p>总复杂度是  O  (  n  log  n  )</p><pre><code>LL a[N];int main(){    int _=read(),kcase=0;    while(_--){        int n=read()*2;        for(int i=1;i&lt;=n;i++) scanf(&quot;%lld&quot;,&amp;a[i]);        sort(a+1,a+n+1);        LL ans = 0;        for(int i=1;i&lt;=n;i++){            int l=1,r=n,mid,tmp=0;            while(l&lt;=r){//puts(&quot;---&quot;);                mid = r+l &gt;&gt; 1;                if(a[mid]&lt;a[i]) tmp = mid,l = mid+1;                else  r = mid-1;            }            ans+=tmp;        }//        printf(&quot;%lld/%lld\n&quot;,ans,(LL)(2*n-2));        double aaa = ans*1.0/(2.0*n-2.0);        printf(&quot;Case %d: %.2f\n&quot;,++kcase,aaa);    }    return 0;}</code></pre><h1 id="2265-Card-Game-Second-Edition"><a href="#2265-Card-Game-Second-Edition" class="headerlink" title="2265 Card Game (Second Edition)"></a>2265 Card Game (Second Edition)</h1><p>————————————————————————————————————————————<br>和上一题一样</p><p>只不过 先手只能那自己的那个序列里面的数 后手同理</p><p>公式为  </p><p>∑  n  i  =  1  ∑  n  j  =  1  [  a  i  &gt; b  j  ]  ×  C  (  n  ,  1  )  ×  (  n<br>−  1  )  !  ×  (  n  −  1  )  !  n  !  ×  n  !  =  ∑  n  i  =  1  ∑  n  j  =<br>1  [  a  i  &gt; b  j  ]  n</p><hr><p>做法和上题一样,只不过计算分子的时候是对b进行二分</p><pre><code>LL a[N],b[N];int main(){    int _=read(),kcase=0;    while(_--){        int n=read();        for(int i=1;i&lt;=n;i++) scanf(&quot;%lld&quot;,&amp;a[i]);        for(int i=1;i&lt;=n;i++) scanf(&quot;%lld&quot;,&amp;b[i]);        sort(b+1,b+n+1);        LL ans = 0;        for(int i=1;i&lt;=n;i++){            int l=1,r=n,mid,tmp=0;            while(l&lt;=r){//puts(&quot;---&quot;);                mid = r+l &gt;&gt; 1;                if(b[mid]&lt;a[i]) tmp = mid,l = mid+1;                else  r = mid-1;            }            ans+=tmp;        }        double aaa = ans*1.0/(1.0*n);        printf(&quot;Case %d: %.2f\n&quot;,++kcase,aaa);    }    return 0;}</code></pre><h1 id="2266-Card-Game-Third-Edition"><a href="#2266-Card-Game-Third-Edition" class="headerlink" title="2266 Card Game (Third Edition)"></a>2266 Card Game (Third Edition)</h1><p>————————————————————————————————————————————<br>队友写的 我不知道这个题 。。。 等会儿 补、、</p><hr><h1 id="2267-The-Bigger-the-Better"><a href="#2267-The-Bigger-the-Better" class="headerlink" title="2267 The Bigger the Better"></a>2267 The Bigger the Better</h1><p>————————————————————————————————————————————<br>给你两个序列， 然你合并成一个字符串，保证新字符串中每个元素在原字符串中的顺序不该变， 使得这个新的字符串的字典序最大。</p><hr><p>想了几个小时的贪心,(虽然有dalao这么做过去了,但是我菜啊 调了很久 还是不行,最终放弃..)</p><p>正解是 <strong> 后缀数组 </strong></p><p>首先能想到对两个序列 进行类似归并的过程，取最大的。<br>但是如果当前一段的数都相同的时候就会判断出错误。</p><p>应该用后缀数组来处理，<br>将这个两个数组前后拼接成一个<br>用后缀数组来处理出Rank[]<br>然后遇到a[la]和b[lb]相同是不知道选哪个的情况<br>就将Rank[la]和Rank[lb]进行比较,哪个大就选哪个, 因为要大的数,所以选择优先级小的</p><p><strong> 附带一点数据, </strong></p><pre><code>//#include &lt;bits/stdc++.h&gt;#include &lt;iostream&gt;#include &lt;string.h&gt;#include &lt;algorithm&gt;#include &lt;stdio.h&gt;typedef long long int LL;using namespace std;const int N   = 2e5+7;const int MOD = 1e9+7;/********************************************/int n,m;const int MAXN=400010;//以下为倍增算法求后缀数组int wa[MAXN],wb[MAXN],wv[MAXN],Ws[MAXN];int cmp(int *r,int a,int b,int l) {    return r[a]==r[b]&amp;&amp;r[a+l]==r[b+l];}/**&lt; 传入参数：str,sa,len+1,ASCII_MAX+1 */void da(const int r[],int sa[],int n,int m) {    int i,j,p,*x=wa,*y=wb,*t;    for(i=0; i&lt;m; i++) Ws[i]=0;    for(i=0; i&lt;n; i++) Ws[x[i]=r[i]]++;//以字符的ascii码为下标    for(i=1; i&lt;m; i++) Ws[i]+=Ws[i-1];    for(i=n-1; i&gt;=0; i--) sa[--Ws[x[i]]]=i;    /*cout&lt;&lt;&quot;SA&quot;&lt;&lt;endl;;    for(int i=0;i&lt;n+1;i++)cout&lt;&lt;sa[i]&lt;&lt;&#39; &#39;;*/    for(j=1,p=1; p&lt;n; j*=2,m=p) {        for(p=0,i=n-j; i&lt;n; i++) y[p++]=i;        for(i=0; i&lt;n; i++) if(sa[i]&gt;=j) y[p++]=sa[i]-j;        for(i=0; i&lt;n; i++) wv[i]=x[y[i]];        for(i=0; i&lt;m; i++) Ws[i]=0;        for(i=0; i&lt;n; i++) Ws[wv[i]]++;        for(i=1; i&lt;m; i++) Ws[i]+=Ws[i-1];        for(i=n-1; i&gt;=0; i--) sa[--Ws[wv[i]]]=y[i];        for(t=x,x=y,y=t,p=1,x[sa[0]]=0,i=1; i&lt;n; i++)            x[sa[i]]=cmp(y,sa[i-1],sa[i],j)?p-1:p++;    }    return;}int sa[MAXN],Rank[MAXN],height[MAXN];//求height数组/**&lt; str,sa,len */void calheight(const char *r,int *sa,int n) {    int i,j,k=0;    for(i=1; i&lt;=n; i++) Rank[sa[i]]=i;    for(i=0; i&lt;n; height[Rank[i++]]=k)        for(k?k--:0,j=sa[Rank[i]-1]; r[i+k]==r[j+k]; k++);    // Unified    for(int i=n; i&gt;=1; --i) ++sa[i],Rank[i]=Rank[i-1];}int a[N*2];int main() {    int _ ,kcase = 0;    scanf(&quot;%d&quot;,&amp;_);    while(_--) {        scanf(&quot;%d%d&quot;,&amp;n,&amp;m);        for(int i=0; i&lt;n; i++) scanf(&quot;%d&quot;,&amp;a[i]);        a[n]=0;        for(int i=0; i&lt;m; i++) scanf(&quot;%d&quot;,&amp;a[i+n+1]);        da(a,sa,n+m+1,101);        for(int i=0;i&lt;n+m+1;i++) Rank[sa[i]]=i;        int la=0,lb=n+1;        printf(&quot;Case %d: &quot;,++kcase);        while(la&lt;n&amp;&amp;lb&lt;n+m+1){            if(a[la]&gt;a[lb])            printf(&quot;%d&quot;,a[la++]);            else if(a[la]&lt;a[lb])       printf(&quot;%d&quot;,a[lb++]);            else if(Rank[la]&gt;Rank[lb]) printf(&quot;%d&quot;,a[la++]);            else                       printf(&quot;%d&quot;,a[lb++]);        }        while(la&lt;n) printf(&quot;%d&quot;,a[la++]);        while(lb&lt;n+m+1) printf(&quot;%d&quot;,a[lb++]);        puts(&quot;&quot;);    }    return 0;}/**444 41 1 9 51 1 9 84 41 1 9 81 1 9 58 75 5 9 8 5 5 9 85 5 9 5 5 9 57 85 5 9 5 5 9 55 5 9 8 5 5 9 88 75 5 9 8 5 5 9 55 5 9 5 5 9 87 85 5 9 5 5 9 85 5 9 8 5 5 9 52 33 23 4 73 23 4 73 23 43 3 23 3 4 74 33 3 4 73 3 26 63 3 4 4 7 93 3 4 4 7 93 31 2 22 1 21 1115 105 6 7 8 91 5 6 7 8 5 6 7 9 94 31 3 2 44 1 33 34 4 34 2 33 34 2 34 4 33 34 4 64 2 63 34 2 64 4 67 77 1 9 1 7 1 97 1 9 1 8 7 17 77 1 1 9 7 1 97 1 9 1 1 8 7----------------------Case 1: 11981195Case 2: 11981195Case 3: 559855985595595Case 4: 559855985595595Case 5: 559855955985595Case 6: 559855955985595Case 7: 34732Case 8: 34732Case 9: 3347332Case 10: 3347332Case 11: 334479334479Case 12: 212212Case 13: 11Case 14: 567891567856799Case 15: 4132413Case 16: 444323Case 17: 444323Case 18: 446426Case 19: 446426Case 20: 77191918717191Case 21: 77191197191187*/</code></pre><h1 id="2268-Cutting-Game"><a href="#2268-Cutting-Game" class="headerlink" title="2268 Cutting Game"></a>2268 Cutting Game</h1><p>————————————————————————————————————————————</p><h1 id="2269-Picking-Game"><a href="#2269-Picking-Game" class="headerlink" title="2269 Picking Game"></a>2269 Picking Game</h1><p>————————————————————————————————————————————</p><h1 id="2270-Two-Triangles"><a href="#2270-Two-Triangles" class="headerlink" title="2270 Two Triangles"></a>2270 Two Triangles</h1><p>————————————————————————————————————————————<br>给你几个点,问你有多少对全等三角形,<br>两个三角形 不能取相同点 ,<br>判定相等的时候可以旋转图形,但是不能翻转</p><p><strong> 注意,  a  全  等  b  和  b  全  等  a  要  算  两  次  </strong></p><hr><p>然后考虑如何判定三角形全等,</p><p>由初中学过的 ,三边相等就行了, 但是题目要求 可以旋转,但是不能翻转</p><p>所以们要对两个图形判定一下,只要  O  (  3  ∗  3  )  固定一个旋转另一个判定就好了, 有一次满足就行,<br>但是要注意 描述这两个三角形的时候要采取同样的顺序,要顺时针都是顺时针,否则都逆时针,</p><p>然后n只有10 ,所以  C  (  10  ,  3  )  =  120  ,  所  以  暴  力  枚  举  两  个  三  角  形  在<br>判  定  是  否  一  样</p><p>所以总复杂度是  O  (  C  (  10  ,  3  )  2  ∗  9  )</p><pre><code>int n,ans;struct point{    int x,y;}p[100];int dis(int p1,int p2){    return (p[p1].x-p[p2].x)*(p[p1].x-p[p2].x)+(p[p1].y-p[p2].y)*(p[p1].y-p[p2].y);}int mul(int p1,int p2,int p0){    return ((p[p1].x-p[p0].x)*(p[p2].y-p[p0].y)-(p[p2].x-p[p0].x)*(p[p1].y-p[p0].y));}int judge(int s1p1,int s1p2,int s1p3,int s2p1,int s2p2,int s2p3){    if(mul(s1p2,s1p3,s1p1)&lt;0) swap(s1p2,s1p3);    if(mul(s2p2,s2p3,s2p1)&lt;0) swap(s2p2,s2p3);    int s1l1 = dis(s1p1,s1p2);    int s1l2 = dis(s1p2,s1p3);    int s1l3 = dis(s1p1,s1p3);    int s2l1 = dis(s2p1,s2p2);    int s2l2 = dis(s2p2,s2p3);    int s2l3 = dis(s2p1,s2p3);    if(s1l1 == s2l1 &amp;&amp;s1l2 == s2l2 &amp;&amp;s1l3 == s2l3 )  return 1;    if(s1l1 == s2l2 &amp;&amp;s1l2 == s2l3 &amp;&amp;s1l3 == s2l1 )  return 1;    if(s1l1 == s2l3 &amp;&amp;s1l2 == s2l1 &amp;&amp;s1l3 == s2l2 )  return 1;    return 0;}double l[4];void solve(int p1,int p2,int p3){    l[1] = sqrt(1.0*dis(p1,p2));    l[2] = sqrt(1.0*dis(p2,p3));    l[3] = sqrt(1.0*dis(p1,p3));    sort(l+1,l+4);    if(l[1]+l[2]&lt;=l[3]+eps&amp;&amp;l[1]+l[2]&gt;=l[3]-eps) return;    for(int i=1;i&lt;=n-2;++i){        if(i==p1||i==p2||i==p3) continue;        for(int j=i+1;j&lt;=n-1;++j){            if(j==p1||j==p2||j==p3) continue;            for(int k=j+1;k&lt;=n;++k){                if(k==p1||k==p2||k==p3) continue;                if(judge(p1,p2,p3,i,j,k)) ans++;            }        }    }}int main(){    int _ = read(),kcase=0;    while(_--){        n=read(); ans = 0;        for(int i=1;i&lt;=n;++i) scanf(&quot;%d%d&quot;,&amp;p[i].x,&amp;p[i].y);        for(int i=1;i&lt;=n-2;++i)            for(int j=i+1;j&lt;=n-1;++j)                for(int k=j+1;k&lt;=n;++k)                    solve(i,j,k);        printf(&quot;Case %d: %d\n&quot;,++kcase,ans);    }    return 0;}</code></pre><h1 id="2271-X"><a href="#2271-X" class="headerlink" title="2271 X"></a>2271 X</h1><p>————————————————————————————————————————————</p><p>给你一个无向图,问你最多去掉多少条边,使得剩下的图中 任意两点间最短路长度不变</p><hr><p>首先题目手没有自环，于是 需要去重边，边取最短的。</p><p>看到n为 100 就想到是floyd</p><p>然后 考虑 floyd 中松弛的过程  </p><p>i  f  (  f  l  o  y  d  [  i  ]  [  j  ]  &gt; =  f  l  o  y  d  [  i  ]  [  k  ]<br>+  f  l  o  y  d  [  k  ]  [  j  ]  )  f  l  o  y  d  [  i  ]  [  j  ]  =  f<br>l  o  y  d  [  i  ]  [  k  ]  +  f  l  o  y  d  [  k  ]  [  j  ]  ;</p><p>那么这个过程中，如果边  m  a  p  [  i  ]  [  j  ]  被松弛了 那么这条边就可以被删掉了,</p><p>注意些细节不要计算重复就好了</p><p><del> 给队友说完这个思路，然后作为我队唯一图论选手的XXX居然没有认同，，最后认同了写了代码 还wa。。。 我也很绝望啊 </del></p><pre><code>int n,m,ans;int mp[111][111];int fd[111][111];int vs[111][111];int main(){    int _ = read(),kcase = 0;    while(_--){        n=read(),m=read(); ans = 0 ;        for(int i=1;i&lt;=n;i++)for(int j=1;j&lt;=n;j++){            fd[i][j]=mp[i][j]=N;vs[i][j]=0;        }        for(int i=1,x,y,w;i&lt;=m;i++){            x=read(),y=read(),w=read();            if(mp[x][y]!=N){                ans++;                if(w&lt;mp[x][y]){                    mp[x][y]=mp[y][x]=w;                    fd[x][y]=fd[y][x]=w;                }                continue;            }            mp[x][y]=mp[y][x]=w;            fd[x][y]=fd[y][x]=w;        }        for(int i=1;i&lt;=n;i++) fd[i][i]=mp[i][i]=0;        for(int k=1;k&lt;=n;k++)for(int i=1;i&lt;=n;i++)for(int j=1;j&lt;=n;j++){            if(fd[i][j]&gt;=fd[i][k]+fd[k][j]){                fd[i][j]=fd[i][k]+fd[k][j];                if(i!=j&amp;&amp;i!=k&amp;&amp;k!=j&amp;&amp;mp[i][j]!=N&amp;&amp;!vs[i][j]){                    ans++;vs[i][j]=vs[j][i]=1;                }            }        }        printf(&quot;Case %d: %d\n&quot;,++kcase,ans);    }    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  SPOJ FTOUR2 - Free tour II [点分治+启发式合并]【分治】</title>
      <link href="/2017/07/18/75270526/"/>
      <url>/2017/07/18/75270526/</url>
      
        <content type="html"><![CDATA[<h1 id="SPOJ-FTOUR2-Free-tour-II-点分治-启发式合并-【分治】"><a href="#SPOJ-FTOUR2-Free-tour-II-点分治-启发式合并-【分治】" class="headerlink" title="SPOJ FTOUR2 - Free tour II [点分治+启发式合并]【分治】"></a>SPOJ FTOUR2 - Free tour II [点分治+启发式合并]【分治】</h1><p>2017年07月18日 09:10:38  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：768</p><hr><p> 博客爬取于<code>2019-04-18 17:15:39</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/75270526" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/75270526</a></p><p>题目链接： <a href="http://www.spoj.com/problems/FTOUR2/" target="_blank" rel="noopener"> http://www.spoj.com/problems/FTOUR2/</a><br>—————————————————————————————————————<br>FTOUR2 - Free tour II<br>no tags<br>After the success of 2nd anniversary (take a look at problem FTOUR for more<br>details), this 3rd year, Travel Agent SPOJ goes on with another discount tour.</p><p>The tour will be held on ICPC island, a miraculous one on the Pacific Ocean.<br>We list N places (indexed from 1 to N) where the visitors can have a trip.<br>Each road connecting them has an interest value, and this value can be<br>negative (if there is nothing interesting to view there). Simply, these N<br>places along with the roads connecting them form a tree structure. We will<br>choose two places as the departure and destination of the tour.</p><p>Since September is the festival season of local inhabitants, some places are<br>extremely crowded (we call them crowded places). Therefore, the organizer of<br>the excursion hopes the tour will visit at most K crowded places (too tiring<br>to visit many of them) and of course, the total number of interesting value<br>should be maximum.</p><p>Briefly, you are given a map of N places, an integer K, and M id numbers of<br>crowded place. Please help us to find the optimal tour. Note that we can visit<br>each place only once (or our customers easily feel bored), also the departure<br>and destination places don’t need to be different.</p><p>Input</p><p>There is exactly one case. First one line, containing 3 integers N K M, with 1<br>&lt;= N &lt;= 200000, 0 &lt;= K &lt;= M, 0 &lt;= M &lt;= N.</p><p>Next M lines, each line includes an id number of a crowded place.</p><p>The last (N - 1) lines describe (N - 1) two-way roads connected N places, form<br>a b i, with a, b is the id of 2 places, and i is its interest value (-10000 &lt;=<br>i &lt;= 10000).</p><p>Output</p><p>Only one number, the maximum total interest value we can obtain.</p><p>Example</p><p>Input:<br>8 2 3<br>3<br>5<br>7<br>1 3 1<br>2 3 10<br>3 4 -2<br>4 5 -1<br>5 7 6<br>5 6 5<br>4 8 3</p><p>Output:<br>12<br>Explanation</p><p>We choose 2 and 6 as the departure and destination place, so the tour will be<br>2 -&gt; 3 -&gt; 4 -&gt; 5 -&gt; 6, total interest value = 10 + (-2) + (-1) + 5 = 12  </p><ul><li>Added some unofficial cases<br>——————————————————————————————————————</li></ul><p>题目大意：<br>给你一棵树，树上的节点有白点有黑点，其中找到一条路径使得在经过的黑色点数 <strong> 不超过K </strong> 的时候 路径长度最大，输出这个最大值</p><hr><h2 id="最好去看论文-gt-戳这里"><a href="#最好去看论文-gt-戳这里" class="headerlink" title="** 最好去看论文===&gt; [ 戳这里"></a>** 最好去看论文===&gt; [ 戳这里</h2><p>](<a href="https://wenku.baidu.com/view/e932a21614791711cc791725.html" target="_blank" rel="noopener">https://wenku.baidu.com/view/e932a21614791711cc791725.html</a>) **</p><p><strong> 注意! 注意! 这里最小值要初始化为0,而不是-INF,可以路径上只有一个点…..wa到死有没有!!! </strong></p><p>还是采用点分治,</p><p>首先 对于每个子树 找 经过根节点的 满足条件 最大值</p><p>可以想到在遍历子树的时候<br>维护一个  m  x  [  i  ]  记录当前节点到根节点经过i个【黑】点时的距离<br>处理出一个前缀最大值 然后就能O(k/2)的计算 当前最大值</p><p>但是问题时如何 避免以根节点儿子为根的子树中的不满足的值</p><p>笨想就是 枚举两个子树 然后维护，但显然这部分复杂度是  O  (  n  2  )  的</p><p>然后就像 其实对一个子树来说 就是要找它和除这个子树外的其他子树的最大值的和</p><p>对于n个子树来说 直接将前i-1的结果个合并,<br>然后就能直接维护第i个子树的答案了</p><p>然后这部分操作  O  (  [  u  ]  .  s  i  z  e  (  )  ∗  k  )</p><p>然后采用优化策略 只有,找到对每个以根节点儿子为根的子树中 经过最多的黑色点的路径中黑色点数为A,由于A大于K的地方对结果无贡献,就不用计算了,<br>这里算一个剪枝.</p><p>然后对前i-1个结果合并的时候 采取启发式合并,先合并小的,在合并大的,这样的话 维护下来  m  x  [  i  ]  中  i<br>的上届会递增,能够优化.</p><p>最后总复杂度就是  O  (  n  log  n  )  [详细复杂度分析请移步国家队论文↑]</p><p>附本题代码<br>——————————————————————————————————————</p><pre><code>#include &lt;bits/stdc++.h&gt;typedef long long int LL;using namespace std;const int N = 200000+7;const int INF = (~(1&lt;&lt;31));inline int read(){    int x=0,f=1;char ch = getchar();    for(;ch&lt;&#39;0&#39;||&#39;9&#39;&lt;ch;ch=getchar()) if(ch==&#39;-&#39;) f=-1;    for(;&#39;0&#39;&lt;=ch&amp;&amp;ch&lt;=&#39;9&#39;;ch=getchar()) x=(x&lt;&lt;3)+(x&lt;&lt;1)+ch-&#39;0&#39;;    return x*f;}/*************************************************************/int n,k,m,ans;bool vis[N];int black[N];struct edge{    int to,next;    int w;}G[N&lt;&lt;1];int head[N],tot;void add(int u,int v,int w=0){    G[tot].w=w,G[tot].to=v,G[tot].next=head[u],head[u]=tot++;}/********重心 begin********/int sz[N],dn[N],siz,zx;void getzx(int u,int fa=0){    sz[u]=1;dn[u]=0;    for(int i=head[u],to;i!=-1;i=G[i].next){        to = G[i].to;        if(to == fa||vis[to]) continue;//puts(&quot;---+++---&quot;);        getzx(to,u);        sz[u]+=sz[to];        dn[u]=max(dn[u],sz[to]);    }    dn[u]=max(dn[u],siz-sz[u]);    if(dn[u]&lt;dn[zx]) zx=u;}/*********重心 end********/int dep[N],dis[N],deep_mx;void getdis(int u,int fa=0){    deep_mx=max(deep_mx,dep[u]);    for(int i=head[u],to;i!=-1;i=G[i].next){        to = G[i].to;        if(vis[to]||to==fa)continue;        dep[to]=dep[u]+black[to];        dis[to]=dis[u]+G[i].w;        getdis(to,u);    }}int tmp[N],mx[N];void getmx(int u,int fa=0){    tmp[dep[u]]=max(tmp[dep[u]],dis[u]);    for(int i=head[u],to;i;i=G[i].next){        to = G[i].to;        if(vis[to]||to==fa)continue;        getmx(to,u);    }}vector&lt;pair&lt;int,int&gt; &gt;v;void solve(int u){    vis[u]=1;if(black[u]) k--; v.clear();    int l=0;    for(int i=head[u],to;i!=-1;i=G[i].next){        to=G[i].to; if(vis[to]) continue;        deep_mx = 0;        dep[to]=black[to];        dis[to]=G[i].w;        getdis(to,u);        v.push_back(make_pair(deep_mx,to));    }    sort(v.begin(),v.end());    for(int i=0,now;i&lt;v.size();i++){        getmx(v[i].second,u);        now = 0;        if(i){            for(int j=v[i].first;j&gt;=0;j--){                while(now+j&lt;k&amp;&amp;now&lt;v[i-1].first)                    now++,mx[now]=max(mx[now],mx[now-1]);                if(now+j&lt;=k) ans=max(ans,mx[now]+tmp[j]);            }        }        if(i==v.size()-1){            for(int j=0;j&lt;=v[i].first;j++){                if(j&lt;=k) ans = max(max(tmp[j],mx[j]),ans);                tmp[j]=mx[j]=0;            }        }        else {            for(int j=0;j&lt;=v[i].first;j++)                mx[j]=max(mx[j],tmp[j]),tmp[j]=0;        }    }    if(black[u])k++;    for(int i=head[u],to;i!=-1;i=G[i].next){        to=G[i].to;        if(vis[to]) continue;        siz=sz[to],zx=0;getzx(to);        solve(zx);    }}int main(){    memset(head,-1,sizeof(head));   zx=0;  tot = 0;    n=read(),k=read(),m=read();    for(int i=1;i&lt;=m;i++) black[read()]=1;    for(int i=1,u,v,w;i&lt;n;i++){        u=read(),v=read(),w=read();        add(u,v,w);add(v,u,w);    }    dn[0]=n;    siz = n; getzx(1);//    printf(&quot;tot = %d zx = %d\n&quot;,tot,zx);//    for(int i=1;i&lt;=n;i++)//        printf(&quot;dn[%d] = %d sz[%d] = %d\n&quot;,i,dn[i],i,sz[i]);    ans = 0; solve(zx);    printf(&quot;%d\n&quot;,ans);    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  POJ 1741 Tree [点分治入门题]【分治】</title>
      <link href="/2017/07/17/75267826/"/>
      <url>/2017/07/17/75267826/</url>
      
        <content type="html"><![CDATA[<h1 id="POJ-1741-Tree-点分治入门题-【分治】"><a href="#POJ-1741-Tree-点分治入门题-【分治】" class="headerlink" title="POJ 1741 Tree [点分治入门题]【分治】"></a>POJ 1741 Tree [点分治入门题]【分治】</h1><p>2017年07月17日 20:37:58  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：298</p><hr><p> 博客爬取于<code>2019-04-18 17:15:40</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/75267826" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/75267826</a></p><p>题目链接: <a href="http://poj.org/problem?id=1741" target="_blank" rel="noopener"> http://poj.org/problem?id=1741 </a><br>——————————————————————————————————————————<br>Tree<br>Time Limit: 1000MS Memory Limit: 30000K<br>Total Submissions: 22808 Accepted: 7542<br>Description</p><p>Give a tree with n vertices,each edge has a length(positive integer less than<br>1001).<br>Define dist(u,v)=The min distance between node u and v.<br>Give an integer k,for every pair (u,v) of vertices is called valid if and only<br>if dist(u,v) not exceed k.<br>Write a program that will count how many pairs which are valid for a given<br>tree.<br>Input</p><p>The input contains several test cases. The first line of each test case<br>contains two integers n, k. (n&lt;=10000) The following n-1 lines each contains<br>three integers u,v,l, which means there is an edge between node u and v of<br>length l.<br>The last test case is followed by two zeros.<br>Output</p><p>For each test case output the answer on a single line.<br>Sample Input</p><p>5 4<br>1 2 3<br>1 3 1<br>1 4 2<br>3 5 1<br>0 0<br>Sample Output</p><p>8</p><p>——————————————————————————————————————————<br>题目大意：<br>给你一棵树，问你两点间距离不超过k的点对个数</p><hr><p><strong> 最好去看论文===&gt; <a href="https://wenku.baidu.com/view/e932a21614791711cc791725.html" target="_blank" rel="noopener"> 戳这里 </a> </strong></p><p>考虑到每颗树上 统计路径经过树根的点对,</p><p>很容易想到 处理一遍子树 记录每个节点到达根节点的距离,<br>然后就变成了</p><blockquote><p>给定一个序列,统计两个数加和不超过k的数对的个数<br>尺取法就能做了</p></blockquote><p>但是注意这里计算之后会有重复的情况</p><p><img src="https://img-blog.csdn.net/20170717203529651?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzMxODQxNzE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>比如当前计算的是根为1 的情况 这个时候如果k比较大 那么还会把&lt;4,6&gt;的情况 给计算上,但是&lt;4,6&gt;的路径是 4-&gt;5-&gt;6</p><p>所以我们还需要减去以1的儿子节点为根的时候的情况</p><p>并不断递归下去找一颗颗子树.</p><p>但是这样下去的话 能发现 不断递归下去的话<br>复杂度依赖于 树的形态<br>如果树是严格平衡的话递归下去的复杂读就是  O  (  log  n  )<br>如果树的形态是一条链的情况 就会变成  O  (  n  )</p><p>于是这里 采取树的重心 作为树根，这样下去的话 能保证 递归下去的深度最低 最终做到复杂度O  (  log  n  )  <strong> [证明请移步国家队论文↑]</strong></p><p>注意: 对于 递归下去的子树 为了保证复杂读 也要再次采用重心为根来做,</p><p>于是最终复杂度就变为  O  (  n  log  2  n  )</p><p>其中一个  log  为分治 向下递归的复杂度<br>另一个  log  为统计的时候 需要保证序列单调的 排序复杂度</p><p>附本题代码<br>——————————————————————————————————————————</p><pre><code>#include &lt;stdio.h&gt;#include &lt;vector&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;string.h&gt;using namespace std;const int N   = 20000+7;/*********************************/int n,k,ans;bool vis[N];int d[N],f[N];struct edge{    int to,next;    int w;}G[N&lt;&lt;1];int head[N],tot;void add(int u,int v,int w=0){    G[tot].w=w,G[tot].to=v,G[tot].next=head[u],head[u]=tot++;}/********重心 begin********/int sz[N],dn[N],siz,zx;void getzx(int u,int fa=0){    sz[u]=1;dn[u]=0;    for(int i=head[u],to;i!=-1;i=G[i].next){        to = G[i].to;        if(to == fa||vis[to]) continue;        getzx(to,u);        sz[u]+=sz[to];        dn[u]=max(dn[u],sz[to]);    }    dn[u]=max(dn[u],siz-sz[u]);    if(dn[u]&lt;dn[zx]) zx=u;}/*********重心 end********//**d[] 为当前节点到当前树根的距离f[] 就是记录当前处理的子树的每个节点的d[]*/void getd(int u,int fa=0){    f[++f[0]] = d[u];    for(int i=head[u],to;i!=-1;i=G[i].next){        to=G[i].to;        if(to==fa||vis[to]) continue;        d[to]=d[u]+G[i].w;        getd(to,u);    }}int cal(int u,int w){    d[u]=w; f[0]=0;int sum = 0;    getd(u); sort(f+1,f+f[0]+1);    for(int l=1,r=f[0];l&lt;r;){        if(f[l]+f[r]&lt;=k){sum+=r-l;l++;}        else r--;    }    return sum;}void solve(int u){    ans+=cal(u,0);    vis[u]=1;    for(int i=head[u],to;i!=-1;i=G[i].next){        to=G[i].to;        if(vis[to]) continue;        ans-=cal(to,G[i].w);        siz=sz[to],zx=0;getzx(to);        solve(zx);    }}int main(){    while(~scanf(&quot;%d%d&quot;,&amp;n,&amp;k)&amp;&amp;(n||k)){        memset(head,-1,sizeof(head));        memset(vis,0,sizeof(vis));        dn[0]=n*10;zx=0;tot=0;        for(int i=1,u,v,w;i&lt;n;i++){            scanf(&quot;%d%d%d&quot;,&amp;u,&amp;v,&amp;w);            add(u,v,w);add(v,u,w);        }        siz = n; getzx(1);        ans = 0;solve(zx);        printf(&quot;%d\n&quot;,ans);    }    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  2017年四川省赛 【(5+2+1)/12】 [待补]</title>
      <link href="/2017/07/16/75208683/"/>
      <url>/2017/07/16/75208683/</url>
      
        <content type="html"><![CDATA[<h1 id="2017年四川省赛-【-5-2-1-12】-待补"><a href="#2017年四川省赛-【-5-2-1-12】-待补" class="headerlink" title="2017年四川省赛 【(5+2+1)/12】 [待补]"></a>2017年四川省赛 【(5+2+1)/12】 [待补]</h1><p>2017年07月16日 18:15:11  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：705</p><hr><p> 博客爬取于<code>2019-04-18 17:15:41</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/75208683" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/75208683</a></p><p>链接： <a href="https://post.icpc-camp.org/d/691-2017" target="_blank" rel="noopener"> https://post.icpc-camp.org/d/691-2017 </a></p><h1 id="A-Simple-Arithmetic"><a href="#A-Simple-Arithmetic" class="headerlink" title="A Simple Arithmetic"></a>A Simple Arithmetic</h1><p>————————————————————————————————————————————————</p><p>签到题<br>注意-2^63 的情况和2^63不能用64位长度的数表示就好了</p><hr><pre><code>#include &lt;bits/stdc++.h&gt;typedef long long int LL;using namespace std;const int N = 200000+7;inline int read() {    int x=0,f=1;    char ch=getchar();    for(; ch&lt;&#39;0&#39;||&#39;9&#39;&lt;ch; ch=getchar())   if(ch==&#39;-&#39;)f=-1;    for(; &#39;0&#39;&lt;=ch&amp;&amp;ch&lt;=&#39;9&#39;; ch=getchar()) x=(x&lt;&lt;3)+(x&lt;&lt;1)+ch-&#39;0&#39;;    return x*f;}/*******************************************************/int main() {    long double a,b;    while(cin&gt;&gt;a&gt;&gt;b) {        if(a == -9223372036854775808.0) {//            puts(&quot;++&quot;);            if(a == b) {                puts(&quot;1&quot;);            } else if(b==-1.0) {                puts(&quot;9223372036854775808&quot;);            } else if(b==1.0) {                puts(&quot;-9223372036854775808&quot;);            } else {                LL ans = floor(a/b);                printf(&quot;%lld\n&quot;,ans);            }            continue;        } else if(b == -9223372036854775808.0) {            if(a&lt;0) puts(&quot;-1&quot;);            else    puts(&quot;0&quot;);            continue;        }        if(a&lt;0&amp;&amp;b&lt;0) a*=-1.0,b*=-1.0;//        cout &lt;&lt; (LL)a &lt;&lt;&quot; &quot;&lt;&lt;  (LL)b &lt;&lt;endl;        LL ans = floor(a/b);        printf(&quot;%lld\n&quot;,ans);    }    return 0;}</code></pre><h1 id="B-Broken-Counter"><a href="#B-Broken-Counter" class="headerlink" title="B Broken Counter"></a>B Broken Counter</h1><p>————————————————————————————————————————————————</p><hr><h1 id="C-Determinant"><a href="#C-Determinant" class="headerlink" title="C Determinant"></a>C Determinant</h1><p>————————————————————————————————————————————————</p><hr><h1 id="D-Dynamic-Graph"><a href="#D-Dynamic-Graph" class="headerlink" title="D Dynamic Graph"></a>D Dynamic Graph</h1><p>————————————————————————————————————————————————<br>给你一个DAG图,每个节点不是白的就是黑的,有q次操作,每次将点x变换颜色.然后输出当前&lt; u,v&gt;有多少对,<br>&lt; u,v&gt;定义为; 当存在一条从u到v的路径使得路径上没有黑色的点是存在.</p><hr><p>考虑到DAG图，所以进行拓扑排序，<br>每次操作完，之后将黑色的点去掉，然后进行拓扑序，在过程中记录能到达每个点的个数，然后一路算过去就行了，然后去个重复采用vis标记,复杂度是  O  (  T<br>q  n  m  )  ,然后妥妥的TLE了,</p><p>最后想到用二进制来优化,每一位对应表示每一个节点,然后进行TOP过程中 <strong> 与 </strong> 一下就行了.</p><p>可以用5个64位整形计算 (这时候注意求1的个数的时候要用lowbit优化)<br>也可以用bitset来计算</p><p>最后复杂度为  O  (  T  q  n  m  /  a  )  ,其中  a  为bitset优化的常数</p><pre><code>#include &lt;bits/stdc++.h&gt;typedef long long int LL;using namespace std;const int N = 1100+7;const int MOD = 1e9+7;inline LL read() {    LL x=0,f=1;    char ch=getchar();    for(; ch&lt;&#39;0&#39;||&#39;9&#39;&lt;ch; ch=getchar())   if(ch==&#39;-&#39;)f=-1;    for(; &#39;0&#39;&lt;=ch&amp;&amp;ch&lt;=&#39;9&#39;; ch=getchar()) x=(x&lt;&lt;3)+(x&lt;&lt;1)+ch-&#39;0&#39;;    return x*f;}/*******************************************************/int n,m,q,ans;vector&lt;int&gt;G[303];int vis[303],c[303],deg[303],temp[303];void TOP() {    bitset&lt;303&gt;mmp[303];    ans = 0;    queue&lt;int&gt;q;    for(int i=1; i&lt;=n; i++) {        if(deg[i]==0) {            q.push(i);        }        temp[i]=deg[i];    }    for(int i=1; i&lt;=n; i++) {        mmp[i][i]=1;    }    while(!q.empty()) {        int u=q.front();        q.pop();        for(int i=0; i&lt;G[u].size(); i++) {            int v=G[u][i];            if(c[v]==0&amp;&amp;c[u]==0) {                mmp[v]=mmp[v]|mmp[u];            }            temp[v]--;            if(temp[v]==0)q.push(v);        }    }    for(int i=1; i&lt;=n; i++) {        if(c[i]==0)            ans+=mmp[i].count()-1;        //   printf(&quot;%d ---%d\n&quot;,c[i],mmp[i].count()-1);    }    printf(&quot;%d\n&quot;,ans);}int main() {    while(~scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;q)) {        memset(c,0,sizeof(c));        memset(deg,0,sizeof(deg));        for(int i=1; i&lt;=n; i++)G[i].clear();        for(int i=1,u,v; i&lt;=m; i++) {            scanf(&quot;%d%d&quot;,&amp;u,&amp;v);            G[u].push_back(v);            deg[v]++;        }        for(int x; q--;) {            scanf(&quot;%d&quot;,&amp;x);            c[x]=1-c[x];            TOP();        }    }    return 0;}</code></pre><h1 id="E-Longest-Increasing-Subsequence"><a href="#E-Longest-Increasing-Subsequence" class="headerlink" title="E Longest Increasing Subsequence"></a>E Longest Increasing Subsequence</h1><p>————————————————————————————————————————————————<br>给你个序列 问你去除每个数之后剩下的数中的结果<br>结果定义为  f  2  1  \xor  f  2  2  \xor  .  .  .  \xor  f  2  n<br>f  (  i  )  为以  a  (  i  )  结尾的lis的长度</p><hr><p>最暴力的想法是求  n  遍  l  i  s  复杂度为  O  (  n  2  log  n  )  ,一定TLE， 然后想如何优化为  O  (<br>n  2  )</p><p>然后想到删除一个数之后对  f  (  i  )  的影响至多减少1, 所以在我们有了原序列的  f  (  i  )  之后 我们就可以  O  (  2<br>n  )  的求每次新的  f  (  i  )</p><p>过程中只要记录 长度为  l  的上升序列当前的最小结尾是谁 ,然后每次看长度为  f  [  i  ]  −  1  的序列的结尾和  a  [  i<br>]  比谁大 就能判断  f  (  i  )  是否减了1</p><hr><pre><code>#include &lt;bits/stdc++.h&gt;typedef long long int LL;using namespace std;const int N = 5000+7;const int MOD = 1e9+7;const int INF = (~(1&lt;&lt;31));inline LL read() {    LL x=0,f=1;    char ch=getchar();    for(; ch&lt;&#39;0&#39;||&#39;9&#39;&lt;ch; ch=getchar())   if(ch==&#39;-&#39;)f=-1;    for(; &#39;0&#39;&lt;=ch&amp;&amp;ch&lt;=&#39;9&#39;; ch=getchar()) x=(x&lt;&lt;3)+(x&lt;&lt;1)+ch-&#39;0&#39;;    return x*f;}/*******************************************************/int n;int a[N],b[N],f[N];int main() {    while(~scanf(&quot;%d&quot;,&amp;n)) {        for(int i=1; i&lt;=n; i++) scanf(&quot;%d&quot;,&amp;a[i]);        for(int i=1; i&lt;=n; i++) {            f[i]=1;            for(int j=1; j&lt;i; j++) if(a[i]&gt;a[j])                    f[i]=max(f[i],f[j]+1);        }        int ans,tmp;        for(int k=1; k&lt;=n; k++) {            for(int i=1; i&lt;=n; i++) b[i] = INF;            ans = 0;            for(int i=1; i&lt;=n; i++) {                if(i==k) continue;                if(b[f[i]-1] &lt; a[i]) tmp = f[i];                else                 tmp = f[i]-1;                ans   ^= (tmp*tmp);                b[tmp] = min(b[tmp],a[i]);            }            printf(&quot;%d%c&quot;,ans,(k==n)?&#39;\n&#39;:&#39; &#39;);        }    }    return 0;}</code></pre><h1 id="F-Simple-Algebra"><a href="#F-Simple-Algebra" class="headerlink" title="F Simple Algebra"></a>F Simple Algebra</h1><p>————————————————————————————————————————————————<br>给你  f  (  x  ,  y  )  =  a  x  2  +  b  x  y  +  c  y  2  ,问你是否永远非负</p><hr><p>考虑到数据范围只有  [  −  10  ,  10  ]  ，于是选择打表，</p><p>判断过程是计算  x  ,  y  ∈  [  −  1000  ,  1000  ]  过程中有没有负的,然后输出  {  0  ,  1  }</p><hr><p>代码太长了 <a href="http://paste.ubuntu.com/25102699/" target="_blank" rel="noopener"> http://paste.ubuntu.com/25102699/ </a></p><h1 id="G-2017"><a href="#G-2017" class="headerlink" title="G 2017"></a>G 2017</h1><p>————————————————————————————————————————————————<br>给你4个数  a  ,  b  ,  c  ,  d  .  0  ≤  a  ≤  b  ≤  10  9  ,  0  ≤  c  ≤  d  ≤<br>10  9<br>问你  ∑  i  =  a  b  ∑  j  =  c  d  [  i  ∗  j  %  2017  =  0  ]</p><hr><p>考虑到2017是素数，满足的情况用坐标系表示的话一定在  x  ,  y  =  2017  k  上 ,所以直接计算就好了</p><hr><pre><code>LL cal(LL a,LL b){    LL ans = (a/2017)*b+(b/2017)*a-(a/2017)*(b/2017);    return ans;}int main(){    LL a,b,c,d;    while(~scanf(&quot;%lld%lld%lld%lld&quot;,&amp;a,&amp;b,&amp;c,&amp;d))        printf(&quot;%lld\n&quot;,cal(b,d)-cal(b,c-1)-cal(a-1,d)+cal(a-1,c-1));    return 0;}</code></pre><h1 id="H-Roads"><a href="#H-Roads" class="headerlink" title="H Roads"></a>H Roads</h1><p>————————————————————————————————————————————————</p><h1 id="I-Strange-Prime"><a href="#I-Strange-Prime" class="headerlink" title="I Strange Prime"></a>I Strange Prime</h1><p>————————————————————————————————————————————————</p><h1 id="J-Skewness"><a href="#J-Skewness" class="headerlink" title="J Skewness"></a>J Skewness</h1><p>————————————————————————————————————————————————</p><p>给你一个n*n的方阵 求每个子矩阵的元素和的三次方的和</p><hr><h1 id="未完待续…"><a href="#未完待续…" class="headerlink" title=" 未完待续… "></a><strong> 未完待续… </strong></h1><p>∑  x  1  =  1  n  ∑  y  1  =  1  n  ∑  x  2  =  x  1  n  ∑  y  2  =  y  1  n<br>(  ∑  i  =  x  1  x  2  ∑  j  =  y  1  y  2  a  i  ,  j  )  3  mod  10  9  ∑<br>x  1  =  1  n  ∑  y  1  =  1  n  ∑  x  2  =  x  1  n  ∑  y  2  =  y  1  n  (<br>f  (  x  2  ,  y  2  )  −  f  (  x  2  ,  y  1  −  1  )  −  f  (  x  1  −  1<br>,  y  2  )  +  f  (  x  1  −  1  ,  y  1  −  1  )  )  3  mod  10  9</p><p>其中  </p><p>(  f  (  x  2  ,  y  2  )  −  f  (  x  2  ,  y  1  −  1  )  −  f  (  x  1  −<br>1  ,  y  2  )  +  f  (  x  1  −  1  ,  y  1  −  1  )  )  3  =  (  a  −  b  −<br>c  +  d  )  3  =  (  a  −  b  −  c  +  d  )  ×  (  a  −  b  −  c  +  d  )<br>×  (  a  −  b  −  c  +  d  )  =  (  a  −  b  −  c  +  d  )  ×  (  a  2  +<br>b  2  +  c  2  +  d  2  −  2  a  b  −  2  a  c  +  2  a  d  +  2  b  c  −<br>2  b  d  −  2  c  d  )  =  (  a  3  −  b  3  −  c  3  +  d  3  +  6  (  b  c<br>d  −  a  c  d  −  a  b  d  +  a  b  c  )  +  3  (  a  b  2  −  a  2  b  −  a<br>2  c  +  a  c  2  +  a  2  d  +  a  d  2  −  b  2  c  −  b  c  2  +  b  2<br>d  −  b  d  2  +  c  2  d  −  c  d  2  )  )</p><p>其中</p><blockquote><p>a  (  a  2  +  b  2  +  c  2  +  d  2  −  2  a  b  −  2  a  c  +  2  a<br>d  +  2  b  c  −  2  b  d  −  2  c  d  )  =  a  3  +  a  b  2  +  a  c  2<br>+  a  d  2  −  2  a  2  b  −  2  a  2  c  +  2  a  2  d  +  2  a  b  c  −<br>2  a  b  d  −  2  a  c  d  −  b  (  a  2  +  b  2  +  c  2  +  d  2  −  2<br>a  b  −  2  a  c  +  2  a  d  +  2  b  c  −  2  b  d  −  2  c  d  )  =  −  a<br>2  b  −  b  3  −  b  c  2  −  b  d  2  +  2  a  b  2  +  2  a  b  c  −  2  a<br>b  d  −  2  b  2  c  +  2  b  2  d  +  2  b  c  d  −  c  (  a  2  +  b  2<br>+  c  2  +  d  2  −  2  a  b  −  2  a  c  +  2  a  d  +  2  b  c  −  2  b<br>d  −  2  c  d  )  =  −  a  2  c  −  b  2  c  −  c  3  −  c  d  2  +  2  a  b<br>c  +  2  a  c  2  −  2  a  c  d  −  2  b  c  2  +  2  b  c  d  +  2  c  2<br>d  d  (  a  2  +  b  2  +  c  2  +  d  2  −  2  a  b  −  2  a  c  +  2  a<br>d  +  2  b  c  −  2  b  d  −  2  c  d  )  =  a  2  d  +  b  2  d  +  c  2<br>d  +  d  3  −  2  a  b  d  −  2  a  c  d  +  2  a  d  2  +  2  b  c  d  −<br>2  b  d  2  −  2  c  d  2</p></blockquote><blockquote></blockquote><blockquote><p>.</p></blockquote><p><strong> </strong> <del> 我TM是有多无聊 会来补这个题，，，MD 不补了 </del></p><p>然后在对于每种情况的求一下对结果的贡献系数</p><p>然后推到一下 ，就需要在预处理出几种前缀和，后缀和，</p><p>然后统计即可 总复杂度是  O  (  n  )  的</p><p>代码没写 <a href="https://www.icpc-camp.org/submissions/4rtbv6xCtpW8Hd" target="_blank" rel="noopener"> 看dalao的吧 </a></p><h1 id="K-2017-Revenge"><a href="#K-2017-Revenge" class="headerlink" title="K 2017 Revenge"></a>K 2017 Revenge</h1><p>————————————————————————————————————————————————</p><p>对于 <strong> 原根 </strong> 理解的十分不到位,只停留到会计算,,,,</p><p>算是强行补题.</p><p>大概了解下 <a href="https://zh.wikipedia.org/wiki/%E5%8E%9F%E6%A0%B9" target="_blank" rel="noopener"> 原根 </a> 在了解些什么是 [ 生成元 ]<br>(<a href="https://zh.wikipedia.org/wiki/%E6%95%B4%E6%95%B0%E6%A8%A1n%E4%B9%98%E6%B3%95%" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/%E6%95%B4%E6%95%B0%E6%A8%A1n%E4%B9%98%E6%B3%95%</a><br>E7%BE%A4) 这题就可以做了</p><p>将乘法转化为加法</p><p><del> 个人理解其实这部分相当去将a<em>x%2017和a</em>y%2017的结果进行了优化,能够方便记录每一位的值 </del></p><p>考虑dp[i][j] 表示到第i个点后取模结果为j的数的个数 然后优化下空间到dp[2017];</p><p>每次转移就是  d  p  [  i  ]  [  j  ∗  x  ]  +  =  d  p  [  i  −  1  ]  [  j  ]  ,<br>d  p  [  i  ]  [  j  ∗  x  ]</p><p>然后因为转化为加法后 能够快速找到值, 又有最后的结果要对  2  取模 能够想到二进制的方法做,</p><p>这里采用了bitset</p><hr><pre><code>int p[N];int n,r;int get(int mod) {    for(int i = 2; ; i++) {        set&lt;int&gt; s;        for(int j = 1, x = 1; j &lt; mod; j++) {            x = (x*i)%mod;            s.insert(x);        }        if(s.size() == mod-1) return i;    }}int main() {    // cout &lt;&lt; get(2017) &lt;&lt; endl;    // 5 为模 2017 的 原根    for(int i = 0, x = 1; i &lt; 2016; i++) {        p[x] = i;        x = (x*5)%2017;    }    while(~scanf(&quot;%d%d&quot;, &amp;n, &amp;r)) {        bitset&lt;2016&gt; f;        f[p[1]] = 1;        for(int i = 0; i &lt; n; i++) {            int x; scanf(&quot;%d&quot;, &amp;x); x = p[x];            f ^= (f&lt;&lt;x) ^ (f&gt;&gt;(2016-x));        }        printf(&quot;%d\n&quot;, (int)f[p[r]]);    }    return 0;}</code></pre><h1 id="L-Nice-Trick"><a href="#L-Nice-Trick" class="headerlink" title="L Nice Trick"></a>L Nice Trick</h1><p>————————————————————————————————————————————————<br>给你一个序列以及  </p><p>s  3  =  ∑  i  ≤  i  &lt; j  &lt; k  ≤  n  a  i  a  j  a  k  =  (  ∑  n  i  =  1  a<br>i  )  3  −  3  (  ∑  n  i  =  1  a  2  i  )  (  ∑  n  i  =  1  a  i  )  +  2<br>(  ∑  n  i  =  1  a  3  i  )  6</p><p>问你  ∑  i  ≤  i  &lt; j  &lt; k  &lt; l  ≤  n  a  i  a  j  a  k  a  l</p><hr><p>有了s3 , 所以可以先求3个数的情况,然后找第4个数,</p><p>然后发现,每次如果第4个数选择  a  [  x  ]  ,那么结果就多了  a  [  x  ]  ×  ∑  i  ≤  i  &lt; j  &lt; k  &lt;<br>x  a  i  a  j  a  k</p><p>所以遍历一遍序列,即固定  a  [  l  ]  同时能求出  ∑  i  =  1  n  a  i  ∑  i  =  1  n  a  2  i<br>∑  i  =  1  n  a  3  i  从而能  O  (  1  )  求出  ∑  i  ≤  i  &lt; j  &lt; k  &lt; l  a  i<br>a  j  a  k</p><hr><pre><code>#include &lt;bits/stdc++.h&gt;typedef long long int LL;using namespace std;const int N = 200000+7;const int MOD = 1e9+7;inline int read() {    int x=0,f=1;    char ch=getchar();    for(; ch&lt;&#39;0&#39;||&#39;9&#39;&lt;ch; ch=getchar())   if(ch==&#39;-&#39;)f=-1;    for(; &#39;0&#39;&lt;=ch&amp;&amp;ch&lt;=&#39;9&#39;; ch=getchar()) x=(x&lt;&lt;3)+(x&lt;&lt;1)+ch-&#39;0&#39;;    return x*f;}/*******************************************************/LL qmod(LL a,LL b){    LL res = 1ll;    while(b){        if(b&amp;1) res=res*a%MOD;        b&gt;&gt;=1,a=a*a%MOD;    }    return res;}int n ;LL inv6 = qmod(6,MOD-2);LL a[N];LL cal(LL a1,LL a2,LL a3){    LL ans = 0;    ans += qmod(a1,3);    ans -= a1*a2%MOD*3%MOD; ans = (ans % MOD + MOD ) %MOD;    ans += a3*2%MOD; ans %= MOD;    return ans*inv6%MOD;}int main(){    while(~scanf(&quot;%d&quot;,&amp;n)){        for(int i=1;i&lt;=n;i++) scanf(&quot;%lld&quot;,&amp;a[i]);        LL a1 = 0,a2 = 0,a3 = 0,ans = 0,tmp = 0;        for(int i=1;i&lt;=n;i++){            if(i&gt;3){                tmp  = a[i]*cal(a1,a2,a3)%MOD;                ans += tmp;                ans %= MOD;            }            a1+=a[i];            a2+=a[i]*a[i]%MOD;            a3+=qmod(a[i],3);            a1%=MOD,a2%=MOD,a3%=MOD;//            printf(&quot; %lld ---&gt;&gt; %lld \n&quot;,tmp,ans);        }        printf(&quot;%lld\n&quot;,ans%MOD);    }    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  “玲珑杯”ACM比赛 Round</title>
      <link href="/2017/07/15/75194944/"/>
      <url>/2017/07/15/75194944/</url>
      
        <content type="html"><![CDATA[<h1 id="“玲珑杯”ACM比赛-Round-18-【4-5】-待补-splay维护256位二进制标记"><a href="#“玲珑杯”ACM比赛-Round-18-【4-5】-待补-splay维护256位二进制标记" class="headerlink" title="“玲珑杯”ACM比赛 Round #18 【4/5】 [待补-splay维护256位二进制标记]"></a>“玲珑杯”ACM比赛 Round #18 【4/5】 [待补-splay维护256位二进制标记]</h1><p>2017年07月15日 23:48:58  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：315</p><hr><p> 博客爬取于<code>2019-04-18 17:15:43</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/75194944" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/75194944</a></p><p>题目链接: <a href="http://www.ifrog.cc/acm/contest/1020" target="_blank" rel="noopener"> http://www.ifrog.cc/acm/contest/1020</a></p><h1 id="1143-计算几何你瞎暴力"><a href="#1143-计算几何你瞎暴力" class="headerlink" title="1143 计算几何你瞎暴力"></a>1143 计算几何你瞎暴力</h1><p>——————————————————————————————————————————<br>观察数据范围，发现点只有11<em>11</em>11个，那么可以记录每种点的个数，然后平方枚举计数即可，</p><p>(话说我当时为什么要写一个树状数组….用数组的话 多么简单….最后处理下前缀和就行了啊)</p><p>–</p><pre><code>#include &lt;bits/stdc++.h&gt;typedef long long int LL;using namespace std;#define abs(x) ((x)&gt;0?(x):-(x))const int N   = 2222+7;const int MOD = 1e9+7;const int INF = (~(1&lt;&lt;31));/*********************************************/int sum[1111];LL zero = 0;void update(int i,LL v){    if(i==0) {zero+=v; return ;}    for(;i&lt;111;i+=(i&amp;-i)) sum[i]+=v;}LL getSum(int i){    LL ans = 0;    for(;i;i-=(i&amp;-i)) ans+=sum[i];    return ans;}LL a[11][11][11];struct node {    int x,y,z;}b[11*11*11*10];int l = 0;void solve(){    for(int i=1;i&lt;=l;i++){        update(0,(a[b[i].x][b[i].y][b[i].z]-1)*a[b[i].x][b[i].y][b[i].z]/2);        for(int j=i+1;j&lt;=l;j++){            update(abs(b[i].x-b[j].x)+abs(b[i].y-b[j].y)+abs(b[i].z-b[j].z),                   a[b[i].x][b[i].y][b[i].z]*a[b[j].x][b[j].y][b[j].z]);        }    }}int main(){    for(int i=0;i&lt;=10;i++)for(int j=0;j&lt;=10;j++)for(int k=0;k&lt;=10;k++)        b[++l].x=i,b[  l].y=j,b[  l].z=k;    int _,n,q;scanf(&quot;%d&quot;,&amp;_);    while(_--){        scanf(&quot;%d%d&quot;,&amp;n,&amp;q);        zero = 0;        memset(sum,0,sizeof(sum));        memset(a,0,sizeof(a));        for(int i=1,x,y,z;i&lt;=n;i++){            scanf(&quot;%d%d%d&quot;,&amp;x,&amp;y,&amp;z);            a[x][y][z]++;        }        solve();        for(int i=1,x;i&lt;=q;i++){            scanf(&quot;%d&quot;,&amp;x);            if(x&gt;50) x=50;            printf(&quot;%lld\n&quot;,getSum(x)+zero);        }    }    return 0;}</code></pre><h1 id="1144-数论你还会快速幂"><a href="#1144-数论你还会快速幂" class="headerlink" title="1144 数论你还会快速幂"></a>1144 数论你还会快速幂</h1><p>——————————————————————————————————————————<br>要注意k为0的情况 所有  i  k  =  0  所以答案就是  n  %  p</p><p>首先有  (  p  +  i  )  k  ≡  (  i  )  k  mod  p</p><p>然后发现存在长度为p的循环节 然后打表找规律发现<br>对于 <strong> 一般 </strong> 情况下一段循环节队结果的贡献是0的<br>如果k为p-1的倍数。则除  [  i  %  p  =  0  ]  时贡献为0 其他情况下贡献是1</p><blockquote><p>由费马小定理可知  a  p  −  1  ≡  1  mod  p  所以这里有  a  k  ≡  1  mod  p</p></blockquote><p>而由于有  0  ≤  n  −  p  ≤  100  所以不成一个循环节的部分暴力就行了.<br>成循环节的部分 分类讨论下即可</p><hr><pre><code>#include &lt;bits/stdc++.h&gt;typedef long long int LL;using namespace std;#define abs(x) ((x)&gt;0?(x):-(x))const int N   = 1e6+7;const int MOD = 1e9+7;const int INF = (~(1&lt;&lt;31));/*********************************************/LL qc(LL a,LL b,LL c){    LL res = 0;    while(b){        if(b&amp;1) res=(res+a)%c;        b&gt;&gt;=1,a=(a+a)%c;    }    return res;}LL qmod(LL a,LL b,LL c) {    LL res = 1ll;    while(b) {        if(b&amp;1) res=qc(res,a,c);        b&gt;&gt;=1,a=qc(a,a,c);    }    return res;}int main() {    LL n,k,p;    int _;    scanf(&quot;%d&quot;,&amp;_);    while(_--) {        scanf(&quot;%lld%lld%lld&quot;,&amp;n,&amp;k,&amp;p);        if(k == 0){            printf(&quot;%lld\n&quot;,n%p);            continue;        }        LL t = n,sum = 0; n %= p;        for(LL i=1; i&lt;=n; i++) {            sum+=qmod(i,k,p);            sum%=p;        }        if( k%(p-1) != 0 ) {            printf(&quot;%lld\n&quot;,sum%p);        } else {            t/=p;            sum += qc( (p-1), t , p);            printf(&quot;%lld\n&quot;,sum%p);  // puts(&quot;--&quot;);        }    }    return 0;}</code></pre><h1 id="1146-图论你先敲完模板"><a href="#1146-图论你先敲完模板" class="headerlink" title="1146 图论你先敲完模板"></a>1146 图论你先敲完模板</h1><p>——————————————————————————————————————————<br>首先考虑暴力做,有一个  O  (  n  2  )  的dp,<br>d  p  [  i  ]  =  m  i  n  {  d  p  [  j  ]  +  2  x  [  i  ]  −  x  [  j  ]<br>∥  j  ∈  [  1  ,  i  )  }  +  a</p><p>但是考虑到  2  x  [  i  ]  −  x  [  j  ]  增长极快，所以我只要向左找至多 60个就行了</p><hr><pre><code>#include &lt;bits/stdc++.h&gt;typedef long long int LL;using namespace std;#define abs(x) ((x)&gt;0?(x):-(x))const int N   = 1e6+7;const int MOD = 1e9+7;const int INF = (~(1&lt;&lt;31));/*********************************************/LL n,a;LL x[N];LL dp[N];int main(){    int _;scanf(&quot;%d&quot;,&amp;_);    while(_--){        scanf(&quot;%lld%lld&quot;,&amp;n,&amp;a);        for(int i=1;i&lt;=n;i++){            scanf(&quot;%lld&quot;,&amp;x[i]);        }        dp[1]=0;        for(int i=2;i&lt;=n;i++){            dp[i]=dp[i-1]+a+(1ll&lt;&lt;(x[i]-x[i-1]));            for(int j=i-1;j;j--){                if(x[i]-x[j]&gt;60) break;                dp[i]=min(dp[i],dp[j]+a+(1ll&lt;&lt;(x[i]-x[j])));            }        }        printf(&quot;%lld\n&quot;,dp[n]);    }    return 0;}</code></pre><h1 id="1147-最后你还是AK了"><a href="#1147-最后你还是AK了" class="headerlink" title="1147 最后你还是AK了"></a>1147 最后你还是AK了</h1><p>——————————————————————————————————————————<br>考虑每条边对结果的贡献,<br>最大化的利用的就是把a,b放到边的左右两边 ,且使最小时最大就行了,这就是这条边贡献的倍数</p><p>就按照边的贡献倍数最大的加最大的c[i] ,次大的加次大的c[i] ….就行了</p><p>可以dfs一边处理 出每条边的贡献倍数,</p><p>然后贪心加过去就好了</p><p>然后注意这个爆栈的问题</p><hr><pre><code>//#pragma comment(linker, &quot;/STACK:102400000,102400000&quot;)#define OPENSTACK#include &lt;bits/stdc++.h&gt;typedef long long int LL;using namespace std;#define abs(x) ((x)&gt;0?(x):-(x))const int N = 111111+7;/*********************************************/int n,k;struct edge{    int to,next,w;}G[N&lt;&lt;1];int head[N],tot;void add(int u,int v,int w){    G[tot].w=w,G[tot].to=v,G[tot].next=head[u],head[u]=tot++;}struct node {    int w,x;}e[N];int l;int dp[N];void dfs(int u,int f=0,int w=0){    dp[u]=1;    for(int i=head[u],to,w;i != -1;i=G[i].next){        to = G[i].to;        w  = G[i].w;        if(to == f) continue ;        dfs(to,u,w);        dp[u]+=dp[to];    }    e[++l].w  =w;    e[  l].x    =min(dp[u],n-dp[u]);}bool cmp(node a,node b){return a.x&gt;b.x;}bool cmp2(int a,int b){return a&gt;b;}int c[N];int main(){    #ifdef OPENSTACK        int size = 64 &lt;&lt; 20; // 64MB        char *p = (char*)malloc(size) + size;        #if (defined _WIN64) or (defined __unix)            __asm__(&quot;movq %0, %%rsp\n&quot; :: &quot;r&quot;(p));        #else            __asm__(&quot;movl %0, %%esp\n&quot; :: &quot;r&quot;(p));        #endif    #endif    int _;scanf(&quot;%d&quot;,&amp;_);    while(_--){        tot = l = 0;memset(head,-1,sizeof(head));        scanf(&quot;%d%d&quot;,&amp;n,&amp;k);        for(int i=2,u,v,w;i&lt;=n;i++){            scanf(&quot;%d%d%d&quot;,&amp;u,&amp;v,&amp;w);            add(u,v,w);            add(v,u,w);        }        for(int i=1;i&lt;=k;i++) scanf(&quot;%d&quot;,&amp;c[i]);        dfs(1);        sort(e+1,e+l+1,cmp);//        for(int i=0;i&lt;=l;i++)      printf(&quot;%d %d\n&quot;,e[i].w,e[i].x);        sort(c+1,c+k+1,cmp2);        for(int i=1;i&lt;=k;i++) e[i].w+=c[i];        LL ans = 0;        for(int i=1;i&lt;l;i++){//            printf(&quot;%d %d\n&quot;,e[i].w,e[i].x);            ans+=1LL*e[i].w*e[i].x;        }        printf(&quot;%lld\n&quot;,ans);    }    #ifdef OPENSTACK        exit(0);    #else        return 0;    #endif}</code></pre><h1 id="1148-数据结构你干瞪眼啊"><a href="#1148-数据结构你干瞪眼啊" class="headerlink" title="1148 数据结构你干瞪眼啊"></a>1148 数据结构你干瞪眼啊</h1><p>——————————————————————————————————————————<br>虽然以我的能力几乎不可能在现场调完这道题,但是还是嘴巴了下</p><blockquote><p>当时考虑了256个颜色就可以用4个64位整形或者长度为256的bitset维护</p></blockquote><blockquote></blockquote><blockquote><p>由于有了区间翻转,所以一定要用splay</p></blockquote><blockquote></blockquote><blockquote><p>对于方阵的处理 可以建立n个splay (后来题解说可以仅简历一个splay,因为每次操作区间都是在一行内的连续区间)</p></blockquote><blockquote></blockquote><blockquote><p>所以对我来说难点就是处理二进制标记上,,不是很好处理啊,,,码力不够啊..</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  Codeforces Round</title>
      <link href="/2017/07/14/75138225/"/>
      <url>/2017/07/14/75138225/</url>
      
        <content type="html"><![CDATA[<h1 id="Codeforces-Round-424-Div-2-【ABCDEF】-补完"><a href="#Codeforces-Round-424-Div-2-【ABCDEF】-补完" class="headerlink" title="Codeforces Round #424 Div. 2 【ABCDEF】[补完]"></a>Codeforces Round #424 Div. 2 【ABCDEF】[补完]</h1><p>2017年07月14日 23:27:34  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：275</p><hr><p> 博客爬取于<code>2019-04-18 17:15:44</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/75138225" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/75138225</a></p><p>好吧 、我也只能做个嘴炮选手了，，，</p><h1 id="A-Unimodal-Array"><a href="#A-Unimodal-Array" class="headerlink" title="A Unimodal Array"></a>A Unimodal Array</h1><p>——————————————————————————————————————<br>日常傻逼题，注意明确题意在写、</p><h1 id="B-Keyboard-Layouts"><a href="#B-Keyboard-Layouts" class="headerlink" title="B Keyboard Layouts"></a>B Keyboard Layouts</h1><p>——————————————————————————————————————<br>有一个加密方式，把26字母分别映射成一个字母，然后给你密文，让你输出原文</p><hr><p>映射一下就好了。注意1~0和大写的情况。、</p><h1 id="C-Jury-Marks"><a href="#C-Jury-Marks" class="headerlink" title="C Jury Marks"></a>C Jury Marks</h1><p>——————————————————————————————————————<br>给你n个评委打分的情况，和其中k次分数，问你初始分数的可能数</p><hr><p>首先处理出打分的前缀和，能知道到第i个人评分后距离初试分数的差值<br>然后排序。从小到小枚举 不同的差值。</p><p>然后从小到大枚举可能分数，做一个类似双指针的东西 ，找分数相匹配的个数 比n大 则有一个初始分数的可能性</p><h1 id="D-Office-Keys"><a href="#D-Office-Keys" class="headerlink" title="D Office Keys"></a>D Office Keys</h1><p>——————————————————————————————————————<br>有n个人，m个keys，目的地p，<br>每个人要拿一个keys到达p，<br>没走1m花费1个单位时间，<br>问所有人到达p的最小时间</p><hr><p>首先考虑这是在直线上，从最左边的人开始枚举，那么为了方便其他人，他所拿的keys一定是尽可能靠左的</p><p>所以二分答案 check就行了</p><h1 id="E-Cards-Sorting"><a href="#E-Cards-Sorting" class="headerlink" title="E Cards Sorting"></a>E Cards Sorting</h1><p>——————————————————————————————————————<br>有n张卡片，成一个队列，每次操作如果队头是队列中最小的就拿出去，否则放到队尾。<br>问等队列为空 操作了多少次</p><hr><p>其实就是个模拟。</p><p>但是直接模拟复杂度是  O  (  n  2  )  的 显然不可取</p><p>然后考虑如何维护。</p><p>首先由于有删除点，首先想到SPLAY维护，将该删除的删除，或者放到意义上的最后。<br>每次找当前意义上对头后面的最近的最小值</p><p>复杂度大概是  O  (  n  log  n  log  n  )  而且实现起来有一定难度，</p><p>然后想每一次删除相当于存在，或者不存在， 想到用BIT维护 即可求意义上的两次删点的操作次数。</p><p>找最小值，看到1e6的范围想到桶排，然后同样大小的 要记录位置，所以开vector数组即可</p><p>维护一个意义上队头，然后二分找那个位置最近。不断维护即可</p><p>复杂度是  O  (  n  log  n  )</p><h1 id="F-Bamboo-Partition"><a href="#F-Bamboo-Partition" class="headerlink" title="F Bamboo Partition"></a>F Bamboo Partition</h1><p>——————————————————————————————————————<br>有n个植物，最开始均为0米。每天长1米。可以认为修剪，且修建后植物不生长，。<br>每隔d天需要人去修剪照看。<br>问你在剪下去的长度和小于k的情况下 d最大为多少</p><hr><p>最先有  k  +  ∑  i  =  1  0  a  i  n  如果大于  m  a  x  {  a  [  x  ]  ∣  ∣  x  ∈<br>[  1  ,  n  ]  }  那么就是d的一种可能性</p><p>其实就是求  [  ∑  i  =  1  n  {  d  ×  ⌈  a  i  d  ⌉  −  a  i  }  &lt; =  k  ]<br>其中d的最大值</p><p>先排序</p><p>考虑暴力的情况，枚举答案是1~a[n] ,然后判定，</p><p>然后想二分，但是发现 不满足单调性，所以不行。</p><p>考虑如何优化这个枚举过程。</p><p>首先考虑这个式子  </p><p>∑  i  =  1  n  {  d  ×  ⌈  a  i  d  ⌉  −  a  i  }  &lt; =  k  ∑  i  =  1  n  d  ×<br>⌈  a  i  d  ⌉  −  ∑  i  =  1  n  a  i  &lt; =  k  d  ×  ∑  i  =  1  n  ⌈  a  i  d<br>⌉  &lt; =  k  +  ∑  i  =  1  n  a  i  d  &lt; =  k  +  ∑  i  =  1  0  a  i  ∑  i<br>=  1  n  ⌈  a  i  d  ⌉</p><p>然后考虑分段枚举d的时候对于  a  i  d  只有  s  q  r  t  种情况, 不知道的话 可以先做做 <a href="https://vjudge.net/problem/HYSBZ-1257" target="_blank" rel="noopener"> 这道题</a> &lt;–戳这里</p><p>于是枚举  d  即可,考虑  d  &lt; =  k  +  ∑  i  =  1  0  a  i  ∑  i  =  1  n  ⌈  a  i  d<br>⌉  这个限制的同时不断维护最大值</p><p>注意d对每个a[i] 分段枚举的时候要满足所有的a[i] ,所以要取最小的.</p><p>复杂度  O  (  n  ×  m  a  x  {  a  [  x  ]  ∣  ∣  x  ∈  [  1  ,  n  ]  }  −  −  −<br>−  −  −  −  −  −  −  −  −  −  −  −  −  √  )</p>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  2011 Heilongjiang collegiate programming contest 【(7+1)/10】 [补完]</title>
      <link href="/2017/07/14/75127871/"/>
      <url>/2017/07/14/75127871/</url>
      
        <content type="html"><![CDATA[<h1 id="2011-Heilongjiang-collegiate-programming-contest-【-7-1-10】-补完"><a href="#2011-Heilongjiang-collegiate-programming-contest-【-7-1-10】-补完" class="headerlink" title="2011 Heilongjiang collegiate programming contest 【(7+1)/10】 [补完]"></a>2011 Heilongjiang collegiate programming contest 【(7+1)/10】 [补完]</h1><p>2017年07月14日 19:00:51  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：304</p><p>个人分类：  <a href="https://blog.csdn.net/qq_33184171/article/category/6362379" target="_blank" rel="noopener"> ===== 各OJ =====</a> <a href="https://blog.csdn.net/qq_33184171/article/category/6822765" target="_blank" rel="noopener"> 套题</a></p><hr><p> 博客爬取于<code>2019-04-18 17:15:46</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/75127871" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/75127871</a></p><p>题目链接:<br>[CDOJ] <a href="https://vjudge.net/contest/170394#overview" target="_blank" rel="noopener"> https://vjudge.net/contest/170394#overview</a><br>[hrbust1395~1402(中文题面哦!) ] <a href="http://acm.hrbust.edu.cn/index.php?m=ProblemSet&amp;a=showProblemVolume" target="_blank" rel="noopener"><br>http://acm.hrbust.edu.cn/index.php?m=ProblemSet&amp;a=showProblemVolume</a></p><hr><p>题目其实很简单,可能由于考试周后第一天训练,状态不对吧,题意都搞不清,,,,</p><p>再加上C题后台数据应该出了问题卡了好久,在hrbustOJ上能AC…..</p><h1 id="A-UESTC-924-Alphabet-Cookies"><a href="#A-UESTC-924-Alphabet-Cookies" class="headerlink" title="A UESTC 924 Alphabet Cookies"></a>A UESTC 924 Alphabet Cookies</h1><p>—————————————————————————————————————————<br>日常傻逼签到题 不解释</p><h1 id="B-UESTC-925-Sequential-game"><a href="#B-UESTC-925-Sequential-game" class="headerlink" title="B UESTC 925 Sequential game"></a>B UESTC 925 Sequential game</h1><p>—————————————————————————————————————————<br>同样傻逼签到题 不解释</p><h1 id="C-UESTC-926-Programming-Contest-Ranking"><a href="#C-UESTC-926-Programming-Contest-Ranking" class="headerlink" title="C UESTC 926 Programming Contest Ranking"></a>C UESTC 926 Programming Contest Ranking</h1><p>—————————————————————————————————————————<br>模拟题,模拟ICPC赛制的rank,<br>与现实规则中,多了一条,一血没有罚时的规则</p><p>模拟即可</p><hr><pre><code>#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 222;/*********************************************/int n,m;struct node {    char name[22];    int ac,total,weight;    bool st[22];    int att[22];}p[N];int blood[N];int aa[N];char s[100];void input(){    vector&lt;int&gt;v[N];    for(int i=1;i&lt;=m;i++) blood[i]=333,aa[i]=0;    for(int i=1;i&lt;=n;i++){        p[i].total=p[i].weight=p[i].ac=0;        scanf(&quot;%s&quot;,p[i].name);        for(int j=1;j&lt;=m;j++){            scanf(&quot;%s&quot;,s);            int l = strlen(s);            if(s[l-1]==&#39;-&#39;) {                p[i].st[j]=0;                continue;            }            int &amp;x = p[i].att[j],flag=0,y=0;            x=0;            for(int k=0;s[k];k++){                if(s[k]==&#39;\\&#39;){                    flag=1;                    continue;                }                if(!flag) x=x*10+s[k]-&#39;0&#39;;                else      y=y*10+s[k]-&#39;0&#39;;            }            p[i].ac++;            p[i].total+=y+x*20-20;            p[i].st[j]=1;            aa[j]++;            if(blood[j]&gt;y){                blood[j]=y;                v[j].clear();                v[j].push_back(i);            }            else if(blood[j]==y){                v[j].push_back(i);            }        }    }    for(int i=1;i&lt;=m;i++)  if(aa[i]) aa[i]=n/aa[i];    for(int i=1;i&lt;=n;i++)        for(int j=1;j&lt;=m;j++)            p[i].weight+=p[i].st[j]*aa[j];    for(int j=1;j&lt;=m;j++){        if(blood[j]==333) continue;        for(int i=0;i&lt;v[j].size();i++)            p[v[j][i]].total-=p[v[j][i]].att[j]*20-20;    }}bool cmp(node a,node b){    if(a.ac==b.ac){        if(a.total==b.total){            if(a.weight==b.weight)                return strcmp(a.name,b.name)&lt;0;            return a.weight&gt;b.weight;        }        return a.total&lt;b.total;    }    return a.ac&gt;b.ac;}int rk[N];int main(){    while(~scanf(&quot;%d%d&quot;,&amp;n,&amp;m)){        input();        sort(p+1,p+n+1,cmp);        rk[1]=1;        for(int i=1;i&lt;=n;i++){            if(i&gt;1){                if(p[i].ac     == p[i-1].ac&amp;&amp;                   p[i].total  == p[i-1].total&amp;&amp;                   p[i].weight == p[i-1].weight){                    rk[i]=rk[i-1];                }                else rk[i]=i;            }            printf(&quot;%*d %*s %*d %*d %*d\n&quot;,3,rk[i],20,p[i].name,2,p[i].ac,6,p[i].total,4,p[i].weight);        }    }    return 0;}</code></pre><h1 id="D-UESTC-927-Dart-game"><a href="#D-UESTC-927-Dart-game" class="headerlink" title="D UESTC 927 Dart game"></a>D UESTC 927 Dart game</h1><p>—————————————————————————————————————————<br>游戏规则很简单，目标是由 1-20 这些区间组成，中心的红点是50分，中心的绿色环是25分，另外两个环一个是分数乘 3 的区域，一个是分数乘 2<br>的区域（如右图）。 每个运动员现在有 N 分数，每个运动员的目标是把自己的分数变为0，而方式是通过每投掷一次飞镖，总分减去投掷所得的分数，且每个运动员要保证<br>最后一次投掷的飞镖要落在分数乘2的区域，也就是 Double Ring区域。谁先把自己的分数降低为0 谁先赢。<br>而你的任务是：<br>给你一个运动员的起始分数，分数为 N，你需要计算出有多少种投掷飞镖的方式能够把分数降到0. 不同的方式意味着：<br>两两方式之间至少有一种方式的某个步骤和另一个不同，如果两个方式可以通过改变其中某种方式相应步骤的顺序来使其和另一个方式相同的话，这两种方式算作一种。<br>例如：N=4， 有四种方式达到 0： 一次（1X2）分， 两次1分加上一次（1X2）分，一次2分加上一次（1X2） 分，两次（1X2） 分。</p><p>由于结果可能很大，你需要对结果模上 2011。</p><hr><p>首先考虑dp[i],表示从0~i的方案数</p><p>那么dp过程中相当于进行完全背包,物品的重量分别是  {  x  |  x  ∈  [  1  ,  20  ]  ,  x  2  ∈  [  1  ,<br>20  ]  ,  x  3  ∈  [  1  ,  20  ]  ,  x  ∈  {  25  ,  50  }  }</p><p>转移过程就是</p><pre><code>dp1[0]=1;    for(int i=0;i&lt;v.size();i++)        for(int j=1;j&lt;N;j++)            if(j-v[i]&gt;=0)  dp1[j]=(dp1[j]+dp1[j-v[i]])%MOD;</code></pre><p>然后要明确,拿分的顺序不影响方案数,所以只要过程中有至少一个2倍的即可</p><p>所以考虑两次dp<br>一次求dp1[],表示所有情况的结果<br>另一次求dp2[],表示去除2倍的结果</p><p>最终结果就是dp1[]-dp2[];</p><hr><pre><code>#include &lt;bits/stdc++.h&gt;typedef long long int LL;using namespace std;const int N   = 1111;const int MOD = 2011;/*********************************************/int dp1[N],dp2[N],ans[N];void init(){    memset(dp1,0,sizeof(dp1));    memset(dp2,0,sizeof(dp2));    vector&lt;int&gt;v;    v.push_back(25),v.push_back(50);    for(int i=1;i&lt;=20;i++){        v.push_back(i);        v.push_back(i*2);        v.push_back(i*3);    }    sort(v.begin(),v.end());    dp1[0]=1;    for(int i=0;i&lt;v.size();i++)        for(int j=1;j&lt;N;j++)            if(j-v[i]&gt;=0)  dp1[j]=(dp1[j]+dp1[j-v[i]])%MOD;    v.clear();    v.push_back(25);    for(int i=1;i&lt;=20;i++){        v.push_back(i);        v.push_back(i*3);    }    sort(v.begin(),v.end());    dp2[0]=1;    for(int i=0;i&lt;v.size();i++)        for(int j=1;j&lt;N;j++)            if(j-v[i]&gt;=0)  dp2[j]=(dp2[j]+dp2[j-v[i]])%MOD;    for(int i=1;i&lt;N;i++) ans[i]=(dp1[i]-dp2[i]+MOD)%MOD;}int main(){    init();int n;    while(~scanf(&quot;%d&quot;,&amp;n)&amp;&amp;n) printf(&quot;%d\n&quot;,ans[n]);    return 0;}</code></pre><h1 id="E-UESTC-928-Similar-Word"><a href="#E-UESTC-928-Similar-Word" class="headerlink" title="E UESTC 928 Similar Word"></a>E UESTC 928 Similar Word</h1><p>—————————————————————————————————————————<br>给你两个字符串,问你循环之后能不能相等,最开始相等不算</p><hr><p>其实就是最小表示法</p><hr><pre><code>#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;iostream&gt;using namespace std;char a[150000];char bb[150000];int n;int minRepresentation(char b[]){    int l=n;    int i = 0, j = 1, k = 0, t;    while(i &lt; l &amp;&amp; j &lt; l &amp;&amp; k &lt; l) {        t = b[(i + k) &gt;= l ? i + k - l : i + k] - b[(j + k) &gt;= l ? j + k - l : j + k];        if(!t) k++;        else{            if(t &gt; 0) i = i + k + 1;            else j = j + k + 1;            if(i == j) ++ j;            k = 0;        }    }    return (i &lt; j ? i : j);}int main(){    while(~scanf(&quot;%s%s&quot;,a,bb))    {        if(strcmp(a,bb)==0)        {            printf(&quot;no\n&quot;);            continue;        }        if(strlen(a)!=strlen(bb))        {            printf(&quot;no\n&quot;);            continue;        }        int flag=0;        n=strlen(a);        int posa=minRepresentation(a);        int posb=minRepresentation(bb);        for(int i=0;i&lt;n;i++)        {            if(a[posa]!=bb[posb])flag=1;            posa++;            posb++;            posa%=n;            posb%=n;        }        if(flag==0)        printf(&quot;yes\n&quot;);        else printf(&quot;no\n&quot;);    }}</code></pre><h1 id="F-UESTC-929-Post-office"><a href="#F-UESTC-929-Post-office" class="headerlink" title="F UESTC 929 Post office"></a>F UESTC 929 Post office</h1><p>—————————————————————————————————————————<br>有n个村庄,有q次询问,每次询问在第i个到第j个村庄找一个位置作为邮局,使得第i个到第j个村庄到邮局的距离和最小,输出这个值</p><hr><p><strong> 好吧,我并没有写代码,所以思路和代码可能有点细微的差别 </strong></p><p>村庄的位置时升序的</p><p>考虑每次查询的i,j</p><p>很容易发现,在第i个和第j个间任选一个位置做邮局对于村庄i,j是一样的<br>那么对于第i+1个和第j-1个同理,<br>….</p><p>所以能够确定的是邮局位置找中间的那个村庄就行了,(偶数个的话中间两个都一样</p><p>然后在计算结果的时候,我们可以先处理一个前缀和,然后能做到O(1)</p><hr><pre><code>#include &lt;bits/stdc++.h&gt;typedef long long int ll;using namespace std;int n;ll sum[150000];ll a[150000];int main(){    while(~scanf(&quot;%d&quot;,&amp;n))    {        for(int i=0;i&lt;n;i++)scanf(&quot;%lld&quot;,&amp;a[i]);        for(int i=0;i&lt;n;i++)        {            if(i==0)sum[i]=a[i];            else sum[i]=sum[i-1]+a[i];        }        int q;        scanf(&quot;%d&quot;,&amp;q);        while(q--)        {            int x,y;            scanf(&quot;%d%d&quot;,&amp;x,&amp;y);            x--;            y--;            if((y-x+1)%2==1)            {                int mid=(x+y)/2;                ll num=(y-x+1)/2;                ll output=a[mid]*num-(sum[mid-1]-sum[x-1]);                output+=(sum[y]-sum[mid])-a[mid]*num;                printf(&quot;%lld\n&quot;,output);            }            else            {                int mid=(x+y)/2;                ll num=(y-x+1)/2-1;                ll output=a[mid]*num-(sum[mid-1]-sum[x-1]);                output+=(sum[y]-sum[mid])-a[mid]*(num+1);                mid=(x+y)/2+1;                num=(y-x+1)/2;                ll output2=a[mid]*num-(sum[mid-1]-sum[x-1]);                output2+=(sum[y]-sum[mid])-a[mid]*(num-1);                printf(&quot;%lld\n&quot;,min(output,output2));            }        }    }}</code></pre><h1 id="G-UESTC-930-Lucky-Boy"><a href="#G-UESTC-930-Lucky-Boy" class="headerlink" title="G UESTC 930 Lucky Boy"></a>G UESTC 930 Lucky Boy</h1><p>—————————————————————————————————————————<br>平面上有n个点,<br>两个人可以拿在同一条直线上的点,<br>能拿3个及以上的点或者最后一个点的人获胜.</p><hr><p>首先考虑如果有3个点以上在一条直线的情况先手必胜,<br>所以特判就好,</p><p>做法是枚举两个点间的斜率,,对于点x,y,z 如果xy的斜率和xz的斜率相等可以了</p><p>剩下的就是普通的情况了,当然两点一定贡献,</p><p>所以剩下的就等价于一个n个石子最多取2个石子的巴士博弈</p><hr><pre><code>#include &lt;bits/stdc++.h&gt;typedef long long int LL;using namespace std;const int N = 10000 +7;map&lt;int,map&lt;int,int&gt; &gt;mmp;int x[N],y[N];int main() {    int n;    while(~scanf(&quot;%d&quot;,&amp;n)) {        for(int i=1; i&lt;=n; i++)           scanf(&quot;%d%d&quot;,&amp;x[i],&amp;y[i]);        int flag = 0,xx,yy,t; // equal;        for(int i=1; i&lt;=n; i++) {            mmp.clear();            for(int j=1; j&lt;=n; j++) {                if(i==j) continue;                if(x[i]==x[j]&amp;&amp;y[i]==y[j]) flag=1;                xx=x[i]-x[j];                yy=y[i]-y[j];                if(xx&lt;0) xx*=-1,yy*=-1;                t=__gcd(xx,yy);                xx/=t,yy/=t;                if(mmp[xx][yy]) flag=1;                mmp[xx][yy]=1;            }        }        if(flag ) {            printf(&quot;a&quot;);        } else {            if(n%(3)==0) printf(&quot;b&quot;);            else         printf(&quot;a&quot;);        }        puts(&quot; is the lucky boy.&quot;);    }    return 0;}</code></pre><h1 id="H-UESTC-931-Car-race-game"><a href="#H-UESTC-931-Car-race-game" class="headerlink" title="H UESTC 931 Car race game"></a>H UESTC 931 Car race game</h1><p>—————————————————————————————————————————<br>XianGe非常喜欢赛车比赛尤其是像达喀尔拉力赛，这种的比赛规模很大，涉及到很多国家的车队的许多车手参赛。XianGe也梦想着自己能举办一个这样大规模的比赛<br>，XianGe幻想着有许多人参赛，那是人山人海啊，不过XianGe只允许最多100000人参加比赛。<br>这么大规模的比赛应该有技术统计，在XianGe的比赛中所有车辆的起始点可能不同，速度当然也会有差异。XianGe想知道比赛中会出现多少次超车（如果两辆车起点<br>相同速度不同也算发生一次超车）。</p><hr><p>首先对x排序,<br>然后x小的如果速度比x大的大就能超车了</p><p>排完序之后用BIT维护一下就好了</p><hr><pre><code>#include &lt;bits/stdc++.h&gt;typedef long long int LL;using namespace std;const int N = 1000000 +7;struct node{    int x,v;}a[N];bool cmp(node a,node b){    if(a.x==b.x) return a.v&lt;b.v;    return a.x&gt;b.x;}int sum[N];#define lowbit(x) (x&amp;-x)void update(int i,int v){    for(;i&lt;N;i+=lowbit(i)) sum[i]+=v;}int getSum(int i){    int ans = 0; for(;i;i-=lowbit(i)) ans+=sum[i];    return ans;}int main(){    int n;    while(~scanf(&quot;%d&quot;,&amp;n)){        memset(sum,0,sizeof(sum));        for(int i=1;i&lt;=n;i++)            scanf(&quot;%d%d&quot;,&amp;a[i].x,&amp;a[i].v);        sort(a+1,a+n+1,cmp);        LL mx = 0;        for(int i=1;i&lt;=n;i++){            mx += getSum(a[i].v-1);            update(a[i].v,1);        }        printf(&quot;%lld\n&quot;,mx);    }    return 0;}</code></pre><h1 id="I-UESTC-932-Jiulianhuan"><a href="#I-UESTC-932-Jiulianhuan" class="headerlink" title="I UESTC 932 Jiulianhuan"></a>I UESTC 932 Jiulianhuan</h1><p>—————————————————————————————————————————<br>相信大家都玩过九连环的游戏 ，九连环的规则是 ：<br>1第一个环可以在任何时候挂到柄上或者从柄上摘下<br>2在任何时候，你只能操作一个环<br>3如果前k-2个环都没有在柄上，并且第k-1个环在柄上，这时如果第k个环在柄上的话，可以把它摘下来，如果它不在柄上，可以把它挂上去</p><p>给定一个数n，n不大于10的8次方，你的任务是输出从柄上摘下n个环需要的最小操作次数，测试数据不超过100组。</p><hr><p>终于理解了九连环怎么玩之后,手动模拟的了一下,<br>发现最后变成<br>0000011<br>1111100(长度为n)<br>的时候需要的次数均是  2  i  −  1  的<br>而接下来需要的操作相当于长度为n-2时的操作,</p><p>所以有了递推式  </p><p>f  [  i  ]  =  f  [  i  −  2  ]  +  2  i  −  1  f  [  1  ]  =  1  f  [  2  ]<br>=  2</p><p>然后构造矩阵就行了<br>[  f  [  i  +  2  ]  f  [  i  +  1  ]  f  [  i  ]  2  i  +  2  ]  ×  ⎡  ⎣<br>⎢  ⎢  ⎢  0  1  0  1  1  0  0  0  0  1  0  0  0  0  0  2  ⎤  ⎦  ⎥  ⎥  ⎥  =  [<br>f  [  i  +  3  ]  f  [  i  +  2  ]  f  [  i  +  1  ]  2  i  +  3  ]</p><hr><pre><code>#include &lt;bits/stdc++.h&gt;typedef long long int LL;using namespace std;const int N = 222;const int MOD = 10007;/*********************************************/const int M = 4;struct Matrix{    LL m[M][M];    void clear0(){        for(int i=0;i&lt;M;i++)            for(int j=0;j&lt;M;j++)                m[i][j]=0;    }    void clearE(){        for(int i=0;i&lt;M;i++)            for(int j=0;j&lt;M;j++)                m[i][j]=(i==j);    }};Matrix operator * (Matrix &amp;a,Matrix &amp;b){    Matrix c;c.clear0();    for(int k=0;k&lt;M;k++)        for(int i=0;i&lt;M;i++)            for(int j=0;j&lt;M;j++)                c.m[i][j]=(c.m[i][j]+a.m[i][k]*b.m[k][j]+MOD)%MOD;    return c;}Matrix operator ^ (Matrix &amp;a,LL b){    Matrix c;c.clearE();    while(b){        if(b&amp;1)  c=c*a;        b&gt;&gt;=1,a=a*a;    }    return c;}int main(){    int n;    while(~scanf(&quot;%d&quot;,&amp;n)){        Matrix a,b;        a.clear0(),b.clear0();        a.m[0][0]=5;        a.m[0][1]=2;        a.m[0][2]=1;        a.m[0][3]=8;        b.m[0][1]=1;        b.m[1][0]=b.m[1][2]=1;        b.m[3][0]=1,b.m[3][3]=2;        b=b^(n-1);        a=a*b;        printf(&quot;%lld\n&quot;,a.m[0][2]);    }    return 0;}</code></pre><h1 id="J-UESTC-933-The-minimum-square-sum"><a href="#J-UESTC-933-The-minimum-square-sum" class="headerlink" title="J UESTC 933 The minimum square sum"></a>J UESTC 933 The minimum square sum</h1><p>—————————————————————————————————————————</p><p>给定你一个质数p (p &lt; 10^8)，请你确定最小的x^2 + y^2 (其中x, y都是正数)，使得x^2 + y^2 = 0 (mod p)</p><hr><p>首先根据p为素数,能想到i*i%p的循环节是p.</p><p>所以说如果选择数的话 一定在这个循环节里面,</p><p>然后能想到  i  ∗  i  +  j  ∗  j  =  p  那么结果就是p 如果找不到 则只能是  p  ∗  p  +  p  ∗  p</p><p>然后想到枚举平方数找存不存在  i  ∗  i  +  j  ∗  j  =  p  ,复杂度为  O  (  s  q  r  t  (  n  )<br>)  1e8差不多能过<br>然后写出了下列代码,就 <strong> TLE </strong> 了</p><pre><code>#include &lt;bits/stdc++.h&gt;typedef long long int LL;using namespace std;int main(){    LL n;    while(~scanf(&quot;%lld&quot;,&amp;n)){        LL mi = n*n+n*n;        for(LL i=1;i*i&lt;n;i++){            LL t = n-i*i;            LL tt = sqrt(t+1.0);            if(t == tt*tt){                mi = n;                break;            }        }        printf(&quot;%lld\n&quot;,mi);    }    return 0;}</code></pre><p>最后贯彻 <strong> “遇事不决先打表” </strong> 这个思想，发现，如果素数形如4*k+3这种，结果就是  p  ∗  p  +  p  ∗  p  否则就是  p</p><hr><pre><code>#include &lt;bits/stdc++.h&gt;typedef long long int LL;using namespace std;int main() {    LL n;    while(~scanf(&quot;%lld&quot;,&amp;n)) {        if(n%4==3) printf(&quot;%lld\n&quot;,n*n*2);        else       printf(&quot;%d\n&quot;,n);    }    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 各OJ </tag>
            
            <tag> 套题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  UVALive - 7344 Numbered Cards [数位dp+状压dp]【动态规划】</title>
      <link href="/2017/07/05/74505041/"/>
      <url>/2017/07/05/74505041/</url>
      
        <content type="html"><![CDATA[<h1 id="UVALive-7344-Numbered-Cards-数位dp-状压dp-【动态规划】"><a href="#UVALive-7344-Numbered-Cards-数位dp-状压dp-【动态规划】" class="headerlink" title="UVALive - 7344 Numbered Cards [数位dp+状压dp]【动态规划】"></a>UVALive - 7344 Numbered Cards [数位dp+状压dp]【动态规划】</h1><p>2017年07月05日 22:42:33  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：322</p><hr><p> 博客爬取于<code>2019-04-18 17:15:47</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/74505041" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/74505041</a></p><p>题目链接: <a href="https://cn.vjudge.net/problem/UVALive-7344" target="_blank" rel="noopener"> https://cn.vjudge.net/problem/UVALive-7344</a><br>——————————————————————————————————————————<br>You have N cards and each has an unique number between 1 and N written on it.<br>In how many<br>ways can you select a non-empty subset of the cards such that the number<br>written on any two of your selected cards don’t have any common digits?<br>For example, when N = 12, {1, 2, 3}, {2, 11}, {3, 4, 5, 6, 7, 8, 9, 12} are<br>some valid selections. But<br>{1, 2, 10}, {2, 5, 12} are not allowed.</p><p>Input<br>The first line of the input contains an integer T  (  T  ≤  15  )  which is<br>the number of test cases. Each of<br>the following T lines denote a test case, containing an integer N  (  1  ≤  N<br>&lt; 10  9  )  .</p><p>Output<br>For each test case, output the case number followed by the number of subsets<br>modulo 1000000007.</p><p>Sample Input<br>2<br>3<br>12</p><p>Sample Output<br>Case 1: 7<br>Case 2: 1151<br>————————————————————————————————————————————<br>题目大意：<br>让你在[1,N]内选择一些数构成一个集合,使得集合中任意两个数没有相同的数字,(但一个数可以由相同的数字比如11.22),问你合法的集合的个数</p><hr><p>首先能确定的是集合中数最多不超过10个，那么可以枚举来</p><p>先选择一个，在选择第二个，保证其两者不没有相同位即可</p><p>显然这个过程是可以进行dp的<br>用长度为10的二进制表示0~9.然后进行转移即可</p><p>设dp[i][j],表示取到第i个数是选择了j(二进制)对应的这些数字</p><p>从而有  d  p  [  i  ]  [  j  ]  =  ∑  d  p  [  i  −  1  ]  [  k  ]  ∗  A  (  表  示<br>k  \xor  j  这  个  状  态  下  的  数  的  个  数  )</p><p>显然有一个O(10<em>1024</em>1024)即可</p><p>但是对于  A  (  表  示  k  \xor  j  这  个  状  态  下  的  数  的  个  数  )  我们应该怎么求呢</p><p>显然是预处理啊 ，<br>通过数位dp进行统计，预处理出每种状态下的数的个数。</p><p>附本题代码<br>————————————————————————————————————————————</p><pre><code>LL dp_nex[15][(1&lt;&lt;12)];int n;int num[12],len;int dp[12][1111];int f[1111];int dfs(int pos,int limit,int na,int &amp;nb){    if(pos&lt;0) return na==nb;    int &amp;t=dp[pos][na];    if(!limit&amp;&amp;t!=-1) return t;    int endi = 9;if(limit) endi=num[pos];    int res = 0;    for(int i=0;i&lt;=endi;i++){        if( (na|i) == 0 )            res+=dfs(pos-1,endi==i&amp;&amp;limit,na,nb);        else if(nb&amp;(1&lt;&lt;i))            res+=dfs(pos-1,endi==i&amp;&amp;limit,na|(1&lt;&lt;i),nb);    }    if(!limit) t=res;    return res;}void solve(int x){    for(len=0;x;x/=10) num[len++]=x%10;    f[0]=f[1]=0;    for(int i=2;i&lt;(1&lt;&lt;10);i++){        memset(dp,-1,sizeof(dp));        f[i]=dfs(len-1,1,0,i);    }}LL qmod(LL a,LL b){    LL res = 1;    while(b){        if(b&amp;1) res=res*a%MOD;        b&gt;&gt;=1;  a  =a  *a%MOD;    }    return res;}int main(){    int t,kcase=0;scanf(&quot;%d&quot;,&amp;t);    while(t--){        int n;        scanf(&quot;%d&quot;,&amp;n);        memset(dp_nex,0,sizeof(dp_nex));        solve(n);        dp_nex[0][0]=1;        int endi=(1&lt;&lt;10);        for(int i=1;i&lt;=10;i++){            for(int j=0;j&lt;endi;j++){                for(int k=0;k&lt;endi;k++){                    if(j==k)continue;                    if(((j&amp;k)==k))                        dp_nex[i][j]=(dp_nex[i][j]+dp_nex[i-1][k]*f[j-k])%MOD;                }            }        }        LL output=0;        for(int i=1;i&lt;=10;i++){            int tmp=1;            for(int j=1;j&lt;=i;j++) tmp*=j;            for(int j=0;j&lt;endi;j++)                output=(output+qmod(tmp,MOD-2)*dp_nex[i][j])%MOD;        }        printf(&quot;Case %d: %lld\n&quot;,++kcase,output);    }    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  HDU 1404 Digital Deletions [SG]【博弈】</title>
      <link href="/2017/07/05/74482641/"/>
      <url>/2017/07/05/74482641/</url>
      
        <content type="html"><![CDATA[<h1 id="HDU-1404-Digital-Deletions-SG-【博弈】"><a href="#HDU-1404-Digital-Deletions-SG-【博弈】" class="headerlink" title="HDU 1404 Digital Deletions [SG]【博弈】"></a>HDU 1404 Digital Deletions [SG]【博弈】</h1><p>2017年07月05日 19:07:23  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：208</p><hr><p> 博客爬取于<code>2019-04-18 17:15:48</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/74482641" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/74482641</a></p><p>题目链接: <a href="http://acm.hdu.edu.cn/showproblem.php?pid=1404" target="_blank" rel="noopener"> http://acm.hdu.edu.cn/showproblem.php?pid=1404</a><br>————————————————————————————————————————————<br>Digital Deletions</p><p>Time Limit: 4000/2000 MS (Java/Others) Memory Limit: 65536/32768 K<br>(Java/Others)<br>Total Submission(s): 2891 Accepted Submission(s): 1052</p><p>Problem Description<br>Digital deletions is a two-player game. The rule of the game is as following.</p><p>Begin by writing down a string of digits (numbers) that’s as long or as short<br>as you like. The digits can be 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 and appear in any<br>combinations that you like. You don’t have to use them all. Here is an<br>example:</p><p><img src="http://acm.hdu.edu.cn/data/images/1404-1.gif" alt="这里写图片描述"></p><p>On a turn a player may either:<br>Change any one of the digits to a value less than the number that it is. (No<br>negative numbers are allowed.) For example, you could change a 5 into a 4, 3,<br>2, 1, or 0.<br>Erase a zero and all the digits to the right of it.</p><p>The player who removes the last digit wins.</p><p>The game that begins with the string of numbers above could proceed like this:<br><img src="http://acm.hdu.edu.cn/data/images/1404-2.gif" alt="这里写图片描述"></p><p>Now, given a initial string, try to determine can the first player win if the<br>two players play optimally both.</p><p>Input<br>The input consists of several test cases. For each case, there is a string in<br>one line.</p><p>The length of string will be in the range of [1,6]. The string contains only<br>digit characters.</p><p>Proceed to the end of file.</p><p>Output<br>Output Yes in a line if the first player can win the game, otherwise output<br>No.</p><p>Sample Input<br>0<br>00<br>1<br>20</p><p>Sample Output<br>Yes<br>Yes<br>No<br>No</p><p>————————————————————————————————————————————<br>题目大意:</p><p>给你一个长度不超过6的有数字组成的字符串,两个人分别操作,最后一次操作的人赢,问先手能不能赢.<br>有两种操作:<br>将任意一个不为0的数字变成小于它的数字<br>将任意一个0开始及其右面的左右数字删除.</p><hr><p>很容易想到要用SG函数来求解，且第一个数字为0的先手必胜</p><p>但是这种时候用mex操作来求解SG函数实在太过麻烦，而且其中对于有前置0的状态很不好表示。</p><p>所以这里求解SG函数的时候用定义来求：<br>SG[]=0 表示必败 SG[]=1 表示必胜</p><blockquote><p>能一步到达必败态的状态一定是必胜态.</p></blockquote><p>所以我们从必败态出发,很容易表示其上一步状态,且不会出现有前置0的情况,</p><p>有SG[1]=0;<br>所以能够确保能够到达所有的状态在[1,1000000)</p><p>附本题代码<br>————————————————————————————————————————————</p><pre><code>int sg[1000001];int h[70],my[111],len;int pow10(int x){    if(x==0) return 1;    if(x==1) return 10;    if(x==2) return 100;    if(x==3) return 1000;    if(x==4) return 10000;    if(x==5) return 100000;}void findsg(int x){    int tem = x;len=0;    for(;tem;tem/=10)      my[len++]=tem%10;    for(int j=0;j&lt;len;j++)        for(int k=1;k+my[j]&lt;10;k++)            sg[x+pow10(j)*k]=1;    int k=1;    for(x*=10;x&lt;1000000;x*=10) {        for(int i=0;i&lt;k;i++) sg[x+i]=1;        k*=10;    }    return ;}void init(){    memset(sg,0,sizeof(sg));    sg[0]=1;    for(int i=1;i&lt;1000000;i++)if(!sg[i])        findsg(i);}char s[10];int main(){    init();    while(~scanf(&quot;%s&quot;,s)){        if(s[0]==&#39;0&#39;) {            puts(&quot;Yes&quot;);            continue;        }        int x=0;        for(int i=0;s[i];i++) x=(x&lt;&lt;3)+(x&lt;&lt;1)+s[i]-&#39;0&#39;;        if(sg[x]) puts(&quot;Yes&quot;);        else      puts(&quot;No&quot;);    }    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  SPOJ - VECTAR1 Matrices with XOR property [FWT]【数学】</title>
      <link href="/2017/07/05/74408116/"/>
      <url>/2017/07/05/74408116/</url>
      
        <content type="html"><![CDATA[<h1 id="SPOJ-VECTAR1-Matrices-with-XOR-property-FWT-【数学】"><a href="#SPOJ-VECTAR1-Matrices-with-XOR-property-FWT-【数学】" class="headerlink" title="SPOJ - VECTAR1 Matrices with XOR property [FWT]【数学】"></a>SPOJ - VECTAR1 Matrices with XOR property [FWT]【数学】</h1><p>2017年07月05日 12:32:49  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：279</p><hr><p> 博客爬取于<code>2019-04-18 17:15:50</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/74408116" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/74408116</a></p><p>题目链接： <a href="http://www.spoj.com/problems/VECTAR1/" target="_blank" rel="noopener"> http://www.spoj.com/problems/VECTAR1/</a><br>——————————————————————————————————————————<br>VECTAR1 - Matrices with XOR property<br>no tags</p><p>Imagine A is a NxM matrix with two basic properties1) Each element in the<br>matrix is distinct and lies in the range of 1&lt;=A[i][j]&lt;=(N _ M)2) For any two<br>cells of the matrix, (i1,j1) and (i2,j2), if (i1^j1) &gt; (i2^j2) then A[i1][j1]</p><blockquote><p>A[i2][j2] ,where 1 ≤ i1,i2 ≤ N1 ≤ j1,j2 ≤ M.Given N and M , you have to<br>calculatethe total number of matrices of size N x M which have both the<br>propertiesmentioned above. Input format:First line contains T, the number of<br>test cases. 2 _ T lines follow with N on the first line and M on the second,<br>representing the number of rows and columns respectively.Output format:Output<br>the total number of such matrices of size N x M. Since, this answer can be<br>large, output it modulo 10^9+7Constraints:1 ≤ N,M,T ≤ 1000SAMPLE INPUT<br>122SAMPLE OUTPUT 4ExplanationThe four possible matrices are:[1 3] | [2 3] | [1<br>4] | [2 4][4 2] | [4 1] | [3 2] | [3 1]<br>Imagine A is a NxM matrix with two basic properties</p></blockquote><ol><li><p>Each element in the matrix is distinct and lies in the range of 1&lt;=A[i][j]&lt;=(N*M) </p></li><li><p>For any two cells of the matrix, (i1,j1) and (i2,j2), if (i1^j1) &gt; (i2^j2) then A[i1][j1] &gt; A[i2][j2] ,where </p></li></ol><p>1 ≤ i1,i2 ≤ N</p><p>1 ≤ j1,j2 ≤ M.</p><p>^ is Bitwise XOR</p><p>Given N and M , you have to calculatethe total number of matrices of size N x<br>M which have both the properties</p><p>mentioned above.</p><p>Input format:</p><p>First line contains T, the number of test cases. 2*T lines follow with N on<br>the first line and M on the second, representing the number of rows and<br>columns respectively.</p><p>Output format:</p><p>Output the total number of such matrices of size N x M. Since, this answer can<br>be large, output it modulo 10^9+7</p><p>Constraints:</p><p>1 ≤ N,M,T ≤ 1000</p><p>SAMPLE INPUT</p><p>1</p><p>2</p><p>2</p><p>SAMPLE OUTPUT</p><p>4</p><p>Explanation</p><p>The four possible matrices are:</p><p>[1 3] | [2 3] | [1 4] | [2 4]</p><p>[4 2] | [4 1] | [3 2] | [3 1]</p><p>——————————————————————————————————————————<br>题目大意:<br>给定规则,问你满足这样的矩阵有多少个<br>规则:<br>i  f  (  i  1  x  o  r  j  1  )  &gt;  (  i  2  x  o  r  j  2  )  t  h  e  n<br>A  [  i  1  ]  [  j  1  ]  &gt;  A  [  i  2  ]  [  j  2  ]  if (i_1 \ xor\<br>j_1) &gt; ( i_2 \ xor\ j_2 )\ \ \ then\ \ \ A[i_1][j_1] &gt; A[i_2][j_2]  i  f<br>(  i  1  ​  x  o  r  j  1  ​  )  &gt; (  i  2  ​  x  o  r  j  2  ​  )  t  h  e  n<br>A  [  i  1  ​  ]  [  j  1  ​  ]  &gt; A  [  i  2  ​  ]  [  j  2  ​  ]</p><hr><p>显然按照  a  [  i  ]  [  j  ]  a[i][j]  a  [  i  ]  [  j  ]  升序排列后对应的  (  i  j  )<br>(i^j)  (  i  j  )  也是升序</p><p>在  (  i  j  )  (i^j)  (  i  j  )  相同的这个集合内,任意排列即可,</p><p>所以问题就是找  (  i  j  )  (i^j)  (  i  j  )  相同的个数,</p><p>很容易想到 <code>FWT</code> ,<br>构造两个向量a,b<br>a=(0,1,1,1,0,0,0,0,) 从第1个(第一个不是第0个)开始n个1<br>b=(0,1,1,1,0,0,0,0,) 从第1个开始m个1</p><p>然后进行FWT即可</p><p>c  [  x  ]  =  ∑  x  =  i  x  o  r  j  a  i  ×  b  j  c[x]= \displaystyle<br>\sum_{x=i\ xor\ j}a_i \times b_j  c  [  x  ]  =  x  =  i  x  o  r  j  ∑  ​  a<br>i  ​  ×  b  j  ​</p><p>上式即是期望结果,</p><p>计算全排列的时候预处理下就能做到O(1)计算</p><p>总复杂度  O  (  T  ×  1024  ×  log  ⁡  (  1024  )  )  O(T\times 1024\times<br>\log{(1024)})  O  (  T  ×  1  0  2  4  ×  lo  g  (  1  0  2  4  )  )</p><p>附本题代码<br>——————————————————————————————————————————</p><pre><code>int n,m,len,a[2222],b[2222];void FWT(int a[],int n){    for(int d=1;d&lt;n;d&lt;&lt;=1)        for(int m=d&lt;&lt;1,i=0;i&lt;n;i+=m)            for(int j=0;j&lt;d;j++){                int x=a[i+j],y=a[i+j+d];                a[i+j]=(x+y)%MOD,a[i+j+d]=(x-y+MOD)%MOD;                //xor:a[i+j]=x+y,a[i+j+d]=(x-y+MOD)%MOD;                //and:a[i+j]=x+y;                //or :a[i+j+d]=x+y;            }}void UFWT(int a[],int n){    const int rev = (MOD+1)&gt;&gt;1;    for(int d=1;d&lt;n;d&lt;&lt;=1)        for(int m=d&lt;&lt;1,i=0;i&lt;n;i+=m)            for(int j=0;j&lt;d;j++){                int x=a[i+j],y=a[i+j+d];                a[i+j]=1LL*(x+y)*rev%MOD,a[i+j+d]=(1LL*(x-y)*rev%MOD+MOD)%MOD;                //xor:a[i+j]=(x+y)/2,a[i+j+d]=(x-y)/2;  inv                //and:a[i+j]=x-y;                //or :a[i+j+d]=y-x;            }}void solve(int a[],int b[],int n){    FWT(a,n);    FWT(b,n);    for(int i=0;i&lt;n;i++) a[i]=1LL*a[i]*b[i]%MOD;    UFWT(a,n);}LL A[2222];int main(){    A[0]=1;    for(int i=1;i&lt;2222;i++) A[i]=A[i-1]*i%MOD;    for(int _=read();_;_--){        n=read(),m=read();        memset(a,0,sizeof(a));        memset(b,0,sizeof(b));        for(int i=1;i&lt;=n;i++) a[i]=1;        for(int i=1;i&lt;=m;i++) b[i]=1;        len = 1024;        solve(a,b,len);        LL ans = 1ll;        for(int i=0;i&lt;len;i++)ans = ans*A[a[i]]%MOD;        printf(&quot;%lld\n&quot;,ans);    }    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  HDU 5534 Partial Tree [完全背包]【动态规划+思维】</title>
      <link href="/2017/07/05/74374144/"/>
      <url>/2017/07/05/74374144/</url>
      
        <content type="html"><![CDATA[<h1 id="HDU-5534-Partial-Tree-完全背包-【动态规划-思维】"><a href="#HDU-5534-Partial-Tree-完全背包-【动态规划-思维】" class="headerlink" title="HDU 5534 Partial Tree [完全背包]【动态规划+思维】"></a>HDU 5534 Partial Tree [完全背包]【动态规划+思维】</h1><p>2017年07月05日 09:31:07  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：405</p><hr><p> 博客爬取于<code>2019-04-18 17:15:51</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/74374144" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/74374144</a></p><p>题目链接： <a href="http://acm.hdu.edu.cn/showproblem.php?pid=5534" target="_blank" rel="noopener"> http://acm.hdu.edu.cn/showproblem.php?pid=5534</a><br>————————————————————————————————————————<br>Partial Tree</p><p>Time Limit: 2000/1000 MS (Java/Others) Memory Limit: 262144/262144 K<br>(Java/Others)<br>Total Submission(s): 1401 Accepted Submission(s): 693</p><p>Problem Description<br>In mathematics, and more specifically in graph theory, a tree is an undirected<br>graph in which any two nodes are connected by exactly one path. In other<br>words, any connected graph without simple cycles is a tree.</p><p>You find a partial tree on the way home. This tree has n nodes but lacks of<br>n−1 edges. You want to complete this tree by adding n−1 edges. There must be<br>exactly one path between any two nodes after adding. As you know, there are<br>nn−2 ways to complete this tree, and you want to make the completed tree as<br>cool as possible. The coolness of a tree is the sum of coolness of its nodes.<br>The coolness of a node is f(d), where f is a predefined function and d is the<br>degree of this node. What’s the maximum coolness of the completed tree?</p><p>Input<br>The first line contains an integer T indicating the total number of test<br>cases.<br>Each test case starts with an integer n in one line,<br>then one line with n−1 integers f(1),f(2),…,f(n−1).</p><p>1≤T≤2015<br>2≤n≤2015<br>0≤f(i)≤10000<br>There are at most 10 test cases with n&gt;100.</p><p>Output<br>For each test case, please output the maximum coolness of the completed tree<br>in one line.</p><p>Sample Input<br>2<br>3<br>2 1<br>4<br>5 1 4</p><p>Sample Output<br>5<br>19<br>————————————————————————————————————————<br>题目大意:<br>有n个节点,让你加n-1条边构建成一棵联通树,使得其权值和最大<br>题目给定节点度数为i的权值为f(i),</p><hr><p>解题思路:</p><p>首先能够确定的是对于整棵树度数和为  2  ∗  (  n  −  1  )  ,<br>如果树联通的话,那么每个节点度数至少为  1  .</p><p>于是问题就变成如何分配  2  ∗  (  n  −  1  )  −  n  ∗  1  =  n  −  2  这几个度数</p><p>可以将这个问题变成在容量为  n  −  2  的背包中不限次数拿取体积为  i  价值为  f  (  i  )  这样一个完全背包问题.</p><p>之后就是因为节点度数至少为  1  了,而在转移的时候至少都是度数为  2  的节点</p><p>那么转移过程应该怎么办?</p><p>这样考虑,如果多了一个度数为  x  的节点,那么同时也就少了一个度数为  1  的节点</p><p>显然在转移的时候先减去  f  [  1  ]  ,最后在结果加回  n  ∗  f  [  1  ]  ,那么就把应该有的度数为  1<br>的节点计算上了.又因为最后这个  n  ∗  f  [  1  ]  是常数,不会影响dp转移的结果</p><p>附本题代码<br>————————————————————————————————————————</p><pre><code>int n;int f[2222];int dp[2222];int main(){    for(int _=read();_;_--){        n=read();        for(int i=1;i&lt;n;i++) f[i]=read(),dp[i]=-1e9; dp[0]=0;        for(int i=1;i&lt;n-1;i++)            for(int j=i;j&lt;=n-2;j++)                dp[j]=max(dp[j],dp[j-i]+f[i+1]-f[1]);        printf(&quot;%d\n&quot;,dp[n-2]+n*f[1]);    }    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  516\. 「LibreOJ β Round</title>
      <link href="/2017/07/04/74356926/"/>
      <url>/2017/07/04/74356926/</url>
      
        <content type="html"><![CDATA[<h1 id="516-「LibreOJ-β-Round-2」DP-一般看规律-set-SPLAY-【STL-数据结构】"><a href="#516-「LibreOJ-β-Round-2」DP-一般看规律-set-SPLAY-【STL-数据结构】" class="headerlink" title="516. 「LibreOJ β Round #2」DP 一般看规律 [set/SPLAY] 【STL/数据结构】"></a>516. 「LibreOJ β Round #2」DP 一般看规律 [set/SPLAY] 【STL/数据结构】</h1><p>2017年07月04日 21:01:07  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：246</p><hr><p> 博客爬取于<code>2019-04-18 17:15:53</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/74356926" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/74356926</a></p><p>题目链接： <a href="https://loj.ac/problem/516" target="_blank" rel="noopener"> https://loj.ac/problem/516 </a><br>——————————————————————————————————————————<br>516. 「LibreOJ β Round #2」DP 一般看规律<br>内存限制：512 MiB<br>时间限制：1000 ms<br>标准输入输出<br>题目类型：传统<br>评测方式：文本比较<br>上传者： nzhtl1477<br>提交<br>提交记录<br>统计<br>测试数据<br>题目描述</p><p>给定一个长度为 n 的序列 a，一共有 m 个操作。<br>每次操作的内容为：给定 x,y，序列中所有 x 会变成 y。</p><p>同时我们有一份代码：</p><pre><code>int ans = 2147483647;for (int i = 1; i &lt;= n; i++) {    for (int j = i + 1; j &lt;= n; j++) {        if (a[i] == a[j])            ans = std::min(ans, j - i);    }}std::cout &lt;&lt; ans &lt;&lt; std::endl;</code></pre><p>请在每次修改后输出代码运行的结果。<br>输入格式<br>第一行两个数，表示 n,m。<br>第二行 n 个数，表示  a  1  ,  a  2  ,  ⋯  ,  a  n  。<br>然后 m 行每行两个数 x 和 y，表示序列中所有 x 会变成 y。<br>输出格式<br>对于每次修改，输出答案。<br>样例<br>样例输入</p><p>5 10<br>2 7 6 3 8<br>6 1<br>7 1<br>1 3<br>5 6<br>1 7<br>9 5<br>1 10<br>7 6<br>7 5<br>3 9<br>样例输出</p><p>2147483647<br>1<br>1<br>1<br>1<br>1<br>1<br>1<br>1<br>1<br>数据范围与提示</p><p>1  ≤  n  ,  m  ≤  100000</p><p>每个出现的数字绝对值在 int 范围内。</p><p>——————————————————————————————————————————</p><p>首先能够明确,两个数的集合合并之后结果一定是越来越小的</p><p>所以就是怎么维护两个数的集合的问题了</p><p>最开始采用 <code>map&lt;int,vector&lt;int&gt; &gt;</code> 来维护</p><p>但是发现虽然最后维护的时候合并过程可以启发式优化<br>但是也需要将这个集合进行进行排序这样复杂度就爆炸了</p><p>然后想到用多颗SPLAY维护这个过程 ,然后码啊码,最后码炸了…</p><p>然后看了下 <strong> 由乃 </strong> 大佬的代码</p><p>发现居然可以用 <code>map&lt;int,set&lt;int&gt; &gt;</code> 进行维护</p><p>由于set本身就是一颗RB-tree了.所以不需要在手写平衡树了啊 .</p><p><strong> 事实证明STL非常强大啊 ,强大到爆啊. </strong></p><p>附本题代码<br>——————————————————————————————————————————</p><pre><code>int n,m,ans=2147483647;map&lt;int,set&lt;int&gt; &gt;pos;inline int read(){    int x=0,f=1;char ch = getchar();    for(;ch&lt;&#39;0&#39;||&#39;9&#39;&lt;ch;ch=getchar())if(ch==&#39;-&#39;) f=-1;    for(;&#39;0&#39;&lt;=ch&amp;&amp;ch&lt;=&#39;9&#39;;ch=getchar())x=(x&lt;&lt;3)+(x&lt;&lt;1)+ch-&#39;0&#39;;    return x*f;}inline void insert(int v,int x){    set&lt;int&gt;::iterator it=pos[v].lower_bound(x);    if(it!=pos[v].end()) ans=min(ans,*it-x);    if(it!=pos[v].begin()) ans=min(ans,x-* --it);    pos[v].insert(x);}int main(){    n=read(),m=read();    for(int i=1;i&lt;=n;i++) insert(read(),i);    while(m--){        int x=read(),y=read();        if(x!=y){            if(pos[x].size()&gt;pos[y].size()) swap(pos[x],pos[y]);            for(set&lt;int&gt;::iterator it=pos[x].begin();it!=pos[x].end();++it) insert(y,*it);            pos[x].clear();        }        printf(&quot;%d\n&quot;,ans);    }    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  「LibreOJ β Round</title>
      <link href="/2017/07/03/74198393/"/>
      <url>/2017/07/03/74198393/</url>
      
        <content type="html"><![CDATA[<h1 id="「LibreOJ-β-Round-2」贪心只能过样例-bitset-【STL】"><a href="#「LibreOJ-β-Round-2」贪心只能过样例-bitset-【STL】" class="headerlink" title="「LibreOJ β Round #2」贪心只能过样例 [bitset]【STL】"></a>「LibreOJ β Round #2」贪心只能过样例 [bitset]【STL】</h1><p>2017年07月03日 14:51:58  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：772</p><hr><p> 博客爬取于<code>2019-04-18 17:15:54</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/74198393" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/74198393</a></p><p>题目链接: <a href="https://loj.ac/problem/515" target="_blank" rel="noopener"> https://loj.ac/problem/515 </a><br>——————————————————————————————————</p><h1 id="515-「LibreOJ-β-Round-2」贪心只能过样例"><a href="#515-「LibreOJ-β-Round-2」贪心只能过样例" class="headerlink" title="515. 「LibreOJ β Round #2」贪心只能过样例"></a>515. 「LibreOJ β Round #2」贪心只能过样例</h1><p>内存限制：256 MiB 时间限制：1000 ms<br>标准输入输出<br>题目类型：传统<br>评测方式：文本比较<br>上传者： nzhtl1477</p><p><strong> 题目描述 </strong></p><p>一共有  n  个数，第  i  个数  x  i  可以取  [  a  i  ,  b  i  ]  中任意值。<br>设  S  =  ∑  x  i  2  ，求  S  种类数。</p><p><strong> 输入格式 </strong><br>第一行一个数  n  。<br>然后  n  行，每行两个数表示  a  i  ,  b  i  。</p><p><strong> 输出格式 </strong><br>输出一行一个数表示答案。<br><strong> 样例 </strong><br>样例输入</p><p>5<br>1 2<br>2 3<br>3 4<br>4 5<br>5 6<br>样例输出</p><p>26<br><strong> 数据范围与提示 </strong><br>1  ≤  n  ,  a  i  ,  b  i  ≤  100<br>——————————————————————————————————<br>其实这个题目很好想,</p><p>显然S的范围在  [  1  ,  10  6  ]  ,</p><p>我们用一个数组标记一下那个位置的值存在,然后就好了</p><p>过程很简但维护一下即可,<br>但是复杂度是  O  (  ∑  n  i  =  1  {  b  i  −  a  i  }  ×  10  6  )</p><p>然后当时采取了用两个栈+一个标记数组维护的想法 应该能去掉很多空状态,</p><p>写了一发但是还是TLE了</p><p>最后听说是用bitset这种东西来维护</p><p><a href="https://www.baidu.com/s?ie=utf-8&amp;f=8&amp;rsv_bp=0&amp;rsv_idx=1&amp;tn=baidu&amp;wd=bitset%20acm&amp;rsv_pq=92c90389000018a8&amp;rsv_t=21019kdauCV9IXGf8qVoMGFqyLhYQWWoVAmLvxLGd%2B%2Bg%2FgHBVM9%2BjEkWr6g&amp;rqlang=cn&amp;rsv_enter=1&amp;rsv_sug3=10&amp;rsv_sug1=9&amp;rsv_sug7=100&amp;rsv_sug2=0&amp;inputT=2050&amp;rsv_sug4=2050&amp;rsv_sug=1" target="_blank" rel="noopener"> bitset </a></p><p>其实就是一个可定义长度的01集合</p><p>经过内部算法优化了时间和空间复杂度</p><p>可以当成一个可变长度的整形来用</p><p>支持整形位运算符</p><hr><p>本题就一样<br>将  x  2  用  1  &lt; &lt; (  x  2  )  来标记</p><p>将  x  2  +  y  2  用  1  &lt; &lt; (  x  2  +  y  2  )  来标记</p><p>很容易证明它的正确性</p><p>附本题代码<br>——————————————————————————————————</p><pre><code>#include &lt;bits/stdc++.h&gt;typedef long long int LL;using namespace std;#define abs(x) ((x)&gt;0?(x):-(x))#define rep(x,a,b) for(int x=(a),end=(b);x&lt;=end;x++)const int N   = 1e4+7;const int MOD = 1e9+7;/*****************************************************************/int n;bitset&lt;1010101&gt;f[2];int main(){    scanf(&quot;%d&quot;,&amp;n);    f[0][0]=1;    for(int i=1,l,r;i&lt;=n;i++){        scanf(&quot;%d%d&quot;,&amp;l,&amp;r);        rep(j,l,r) f[i&amp;1] |= f[!(i&amp;1)] &lt;&lt; (j*j);        f[!(i&amp;1)].reset();    }    printf(&quot;%d\n&quot;,f[(n&amp;1)].count());    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  HDU 5909 Tree Cutting [树形dp+FWT]【动态规划+数学】</title>
      <link href="/2017/07/02/74153824/"/>
      <url>/2017/07/02/74153824/</url>
      
        <content type="html"><![CDATA[<h1 id="HDU-5909-Tree-Cutting-树形dp-FWT-【动态规划-数学】"><a href="#HDU-5909-Tree-Cutting-树形dp-FWT-【动态规划-数学】" class="headerlink" title="HDU 5909 Tree Cutting [树形dp+FWT]【动态规划+数学】"></a>HDU 5909 Tree Cutting [树形dp+FWT]【动态规划+数学】</h1><p>2017年07月02日 19:26:37  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：555</p><hr><p> 博客爬取于<code>2019-04-18 17:15:55</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/74153824" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/74153824</a></p><p>题目链接: <a href="http://acm.hdu.edu.cn/showproblem.php?pid=5909" target="_blank" rel="noopener"> http://acm.hdu.edu.cn/showproblem.php?pid=5909</a><br>——————————————————————————————————————————</p><p>Tree Cutting Accepts: 14 Submissions: 119<br>Time Limit: 4000/2000 MS (Java/Others) Memory Limit: 262144/131072 K<br>(Java/Others)</p><p><strong> 问题描述 </strong></p><p>Byteasar有一棵  n  个点的无根树，节点依次编号为  1  到  n  ，其中节点ii的权值为  v  i  。</p><p>定义一棵树的价值为它所有点的权值的异或和。</p><p>现在对于每个  [  0  ,  m  )  的整数  k  ，请统计有多少  T  的非空连通子树的价值等于  k  。</p><p>一棵树TT的连通子树就是它的一个连通子图，并且这个图也是一棵树。</p><p><strong> 输入描述 </strong></p><p>第一行包含一个正整数  T  (  1  ≤  T  ≤  10  )  ，表示测试数据的组数。</p><p>每组数据的第一行包含两个正整数  n  (  n  ≤  1000  )  和  m  (  1  ≤  m  ≤  2  10  )<br>，分别表示树的大小以及权值的上界。</p><p>第二行包含  n  个整数  v  1  ,  v  2  ,  v  3  ,  .  .  .  ,  v  n  (  0  ≤  v  i  &lt; m<br>)  ，分别表示每个节点的权值。</p><p>接下来  n  −  1  行每行包含两个正整数  a  i  ,  b  i  (  1  ≤  a  i  ,  b  i  ≤  n  )<br>，表示有一条连接  a  i  和  b  i<br>​​ 的无向边。</p><p>输入数据保证  m  是  2  的非负整数幂。</p><p><strong> 输出描述 </strong></p><p>对于每组数据，输出一行  m  个整数，其中第  i  个整数表示价值为  i  的非空连通子树的数目。</p><p>因为答案很大，所以请模  10  9  +  7  后输出。</p><p><strong> 输入样例 </strong><br>2<br>4 4<br>2 0 1 3<br>1 2<br>1 3<br>1 4<br>4 4<br>0 1 3 1<br>1 2<br>1 3<br>1 4</p><p><strong> 输出样例 </strong><br>3 3 2 3<br>2 4 2 3</p><p>——————————————————————————————————————————</p><p>很容易想到树形dp</p><p>设  d  p  [  i  ]  [  j  ]  以第  i  个节点为根的联通子树异或和为  j  的数目.</p><p>转移的过程就是dp[u][i^j]+=dp[u][i]*dp[to][j];</p><p>这部分很好想到,但是复杂度却是  O  (  n  m  2  )  的.</p><p>显然超时</p><p>然后有了一个FWT这种东西, <strong> 快速沃尔什变换 </strong></p><p>和FFT类似,同样是将一个  O  (  n  2  )  的卷积运算转化为  O  (  n  log  n  )  的.</p><p>FWT是</p><p>c  [  x  ]  =  ∑  i  \^  j  =  x  a  [  i  ]  ∗  b  [  j  ]  ,与本题所求相同，套上去就好了</p><p>详细戳这里吧 <a href="http://blog.csdn.net/liangzhaoyang1/article/details/52819835" target="_blank" rel="noopener"> http://blog.csdn.net/liangzhaoyang1/article/details/52819835</a></p><p>附本题代码<br>——————————————————————————————————————————</p><pre><code>#include &lt;bits/stdc++.h&gt;typedef long long int LL;using namespace std;#define abs(x) ((x)&gt;0?(x):-(x))const int N   = 1e3+7;const int MOD = 1e9+7;/*****************************************************************/vector&lt;int&gt;G[N];int w[N],dp[N][(1&lt;&lt;10)+9],ans[(1&lt;&lt;10)+9],tmp[(1&lt;&lt;10)+9];int n,m,len;void FWT(int a[],int n){    for(int d=1;d&lt;n;d&lt;&lt;=1)        for(int m=d&lt;&lt;1,i=0;i&lt;n;i+=m)            for(int j=0;j&lt;d;j++){                int x=a[i+j],y=a[i+j+d];                a[i+j]=(x+y)%MOD,a[i+j+d]=(x-y+MOD)%MOD;                //xor:a[i+j]=x+y,a[i+j+d]=(x-y+MOD)%MOD;                //and:a[i+j]=x+y;                //or :a[i+j+d]=x+y;            }}void UFWT(int a[],int n){    const int rev = (MOD+1)&gt;&gt;1;    for(int d=1;d&lt;n;d&lt;&lt;=1)        for(int m=d&lt;&lt;1,i=0;i&lt;n;i+=m)            for(int j=0;j&lt;d;j++){                int x=a[i+j],y=a[i+j+d];                a[i+j]=1LL*(x+y)*rev%MOD,a[i+j+d]=(1LL*(x-y)*rev%MOD+MOD)%MOD;                //xor:a[i+j]=(x+y)/2,a[i+j+d]=(x-y)/2;  inv                //and:a[i+j]=x-y;                //or :a[i+j+d]=y-x;            }}void solve(int a[],int b[],int n){    FWT(a,n);    FWT(b,n);    for(int i=0;i&lt;n;i++) a[i]=1LL*a[i]*b[i]%MOD;    UFWT(a,n);}void dfs(int u,int f=0){    for(int i=0;i&lt;len;i++) dp[u][i]=0;    dp[u][w[u]]=1;    int gz=G[u].size();    for(int i=0,to;i&lt;gz;i++){        to=G[u][i];        if(to==f) continue;        dfs(to,u);        for(int i=0;i&lt;len;i++) tmp[i]=dp[u][i];        solve(tmp,dp[to],len);        for(int i=0;i&lt;len;i++) dp[u][i]=(dp[u][i]+tmp[i])%MOD;    }    for(int i=0;i&lt;len;i++) ans[i]=(ans[i]+dp[u][i])%MOD;}int main(){    int _;    for(scanf(&quot;%d&quot;,&amp;_);_;_--){        scanf(&quot;%d %d&quot;,&amp;n,&amp;m);        memset(ans,0,sizeof(ans));        for(len=1;len&lt;m;len&lt;&lt;=1);        for(int i=1;i&lt;=n;i++)scanf(&quot;%d&quot;,&amp;w[i]);        for(int i=1,u,v;i&lt;n;i++){            scanf(&quot;%d%d&quot;,&amp;u,&amp;v);            G[u].push_back(v);            G[v].push_back(u);        }        dfs(1);        for(int i=0;i&lt;m-1;i++) printf(&quot;%d &quot;,ans[i]); printf(&quot;%d\n&quot;,ans[m-1]);        for(int i=1;i&lt;=n;i++) G[i].clear();    }    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  Codechef Matrix Transformation 【数学】</title>
      <link href="/2017/06/28/73863598/"/>
      <url>/2017/06/28/73863598/</url>
      
        <content type="html"><![CDATA[<h1 id="Codechef-Matrix-Transformation-【数学】"><a href="#Codechef-Matrix-Transformation-【数学】" class="headerlink" title="Codechef Matrix Transformation 【数学】"></a>Codechef Matrix Transformation 【数学】</h1><p>2017年06月28日 20:14:52  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：236<br>标签：  <a href="https://so.csdn.net/so/search/s.do?q=codechef&amp;t=blog" target="_blank" rel="noopener"> codechef </a> <a href="https://so.csdn.net/so/search/s.do?q=思维&amp;t=blog" target="_blank" rel="noopener"> 思维</a> <a href="https://so.csdn.net/so/search/s.do?q=matrix&amp;t=blog" target="_blank" rel="noopener"> matrix</a></p><p>个人分类：  <a href="https://blog.csdn.net/qq_33184171/article/category/6253262" target="_blank" rel="noopener"> 思维 </a> <a href="https://blog.csdn.net/qq_33184171/article/category/6162724" target="_blank" rel="noopener"> 数学</a> <a href="https://blog.csdn.net/qq_33184171/article/category/6996318" target="_blank" rel="noopener"> codechef</a></p><hr><p> 博客爬取于<code>2019-04-18 17:15:56</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/73863598" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/73863598</a></p><p>题目链接： <a href="https://www.codechef.com/problems/MTRNSFRM" target="_blank" rel="noopener"> https://www.codechef.com/problems/MTRNSFRM</a><br>———————————————————————————————————————————<br>Chef has two n × m matrices A and B. He wants to make them completely<br>identical, to achieve this goal, he can perform the following actions in a<br>single move:</p><p>Choose one of the matrices, either A or B.<br>Choose either one row or one column of the selected matrix.<br>Increment all the numbers in the selected row or column by 1.<br>Now Chef is wondering, what is the minimal number of moves he has to perform<br>in order to make matrices A and B equal? Or is it just impossible?</p><p>Input<br>The first line of the input contains an integer T denoting the number of test<br>cases.</p><p>For each test case, the first line of input contains two integers n and m.</p><p>The following n lines contain m space separated integers each ― the matrix A.</p><p>The next n lines contain m space separated integers each ― the matrix B.</p><p>Warning! The size of the input file can be up to 10 MB!</p><p>Output<br>For each test case, output a single integer ― the minimal number of moves Chef<br>has to perform in order to make matrices A and B equal or -1 if this is not<br>possible.<br>Constraints<br>1 ≤ T ≤ 100<br>1 ≤ n ≤ m ≤ 105<br>1 ≤ n × m ≤ 105<br>Let us denote the sum of n × m over all T testcases by S<br>1 ≤ S ≤ 5 · 105<br>1 ≤ Aij ≤ 109<br>1 ≤ Bij ≤ 109<br>Example<br>Input:<br>3<br>2 2<br>1 1<br>1 1<br>1 2<br>3 4<br>2 2<br>1 9<br>9 1<br>9 1<br>1 9<br>1 4<br>4 5 7 1<br>2 3 4 5</p><p>Output:<br>3<br>-1<br>9<br>Explanation<br>Example case 1. We can transform the matrix A into B in three moves:<br>1 1 -&gt; 1 2 -&gt; 1 2 -&gt; 1 2<br>1 1 -&gt; 1 2 -&gt; 2 3 -&gt; 3 4<br>Example case 2. It is impossible to make these matrices equal using only the<br>allowed moves.<br>Example case 3. We can transform matrix A into 4 5 7 7 in six moves and matrix<br>B into the same 4 5 7 7 in three moves.</p><p>————————————————————————————————————————————<br>题目大意:</p><p>这两个矩阵 每次操作可以选出一个矩阵在它的任意一行或/列上加1,问你最少多少次操作使两矩阵完全一样</p><hr><p>第一点很好想</p><p>将两个矩阵合在一起,生成一个新矩阵, 那么题目就相当于这个新矩阵可以再一行/列上加/减  1  ,最少多少次能变成全0矩阵.</p><p>这样会有两个操作  x  [  i  ]  ,  y  [  i  ]  ,分别代表第i行/列的操作次数</p><p>显然对于新矩阵有  a  [  i  ]  [  j  ]  =  x  [  i  ]  +  y  [  j  ]  ;<br>多以不满足这个条件的就是-1了</p><p><del> 然后想啊？ 怎么搞啊？ 看了看这个数据范围,差分约束？？！ ，好像很牵强啊， 我一个没写过查分约束的还是换个思路吧， </del></p><p>然后考虑，<br>a  [  i  ]  [  j  ]  =  x  [  i  ]  +  y  [  j  ]  ,<br>a  [  k  ]  [  l  ]  =  x  [  k  ]  +  y  [  l  ]  ;<br>那么同时有<br>a  [  i  ]  [  l  ]  =  x  [  i  ]  +  y  [  l  ]  ;<br>a  [  k  ]  [  j  ]  =  x  [  k  ]  +  y  [  j  ]  ;</p><p>易得  a  [  i  ]  [  j  ]  +  a  [  k  ]  [  l  ]  =  =  a  [  i  ]  [  l  ]<br>+  a  [  k  ]  [  j  ]  ;</p><p>但是这样 我们要枚举两个点进行判断么？ no O(n^2)的复杂度是不能接受的</p><p>然后在想</p><p>我们能够发现<br>a  [  i  ]  [  j  ]  +  a  [  k  ]  [  l  ]  =  =  a  [  i  ]  [  l  ]  +  a<br>[  k  ]  [  j  ]  ;<br>a  [  i  ]  [  j  ]  +  a  [  o  ]  [  p  ]  =  =  a  [  i  ]  [  p  ]  +  a<br>[  o  ]  [  j  ]  ;<br>成立</p><p>那么一定有<br>a  [  o  ]  [  p  ]  +  a  [  k  ]  [  l  ]  =  =  a  [  o  ]  [  l  ]  +  a<br>[  k  ]  [  p  ]  ;</p><p>所我们只要固定a[k][l]枚举a[i][j]就好了，</p><p>接下里就是求解了</p><p>答案显然是  ∑  x  [  i  ]  +  ∑  y  [  j  ]</p><p>但是我们求的是最小解。</p><p>这时候我们设  x  [  1  ]  =  t</p><p>易得此时答案是  ∑  a  b  s  (  a  [  i  ]  [  1  ]  −  a  [  1  ]  [  1  ]  −  t  )<br>+  ∑  a  b  s  (  −  a  [  1  ]  [  j  ]  −  t  )</p><p>当t为中间值时最小，证明略</p><hr><p><strong> Codechef为什么这个强势，这只是个 _ EASY _ 难度啊啊啊啊 </strong></p><p>附本题代码<br>————————————————————————————————————————————</p><pre><code>#include &lt;bits/stdc++.h&gt;typedef long long int LL;using namespace std;const int N   = 1e5+7;const int MOD = 1e9+7;#define abs(x) ((x)&gt;0?(x):-(x))inline LL read(){    LL x=0;char ch=getchar();    for(;ch&lt;&#39;0&#39;||&#39;9&#39;&lt;ch;ch=getchar());    for(;&#39;0&#39;&lt;=ch&amp;&amp;ch&lt;=&#39;9&#39;;ch=getchar())x=(x&lt;&lt;3)+(x&lt;&lt;1)+ch-&#39;0&#39;;    return x;}/***************************************************************/vector&lt;int&gt;a[N];int main(){    int _,m,n;    scanf(&quot;%d&quot;,&amp;_);    while(_--){        scanf(&quot;%d%d&quot;,&amp;n,&amp;m);        for(int i=1;i&lt;=n;i++){            a[i].push_back(0);            for(int j=1,x;j&lt;=m;j++){                scanf(&quot;%d&quot;,&amp;x);                a[i].push_back(x);            }        }        for(int i=1;i&lt;=n;i++)            for(int j=1,x;j&lt;=m;j++){                scanf(&quot;%d&quot;,&amp;x);                a[i][j]-=x;            }        bool flag=true;        for(int i=1;i&lt;=n;i++){            for(int j=1;j&lt;=m;j++){                if(a[1][1]+a[i][j]==a[1][j]+a[i][1]) continue;                flag=false;break;            }            if(!flag) break;        }        if(!flag) {            puts(&quot;-1&quot;);        }        else {            vector&lt;int&gt; pts;            for(int i=1;i&lt;=n;i++) pts.push_back(a[i][1]-a[1][1]);            for(int j=1;j&lt;=m;j++) pts.push_back(-a[1][j]);            sort(pts.begin(), pts.end());            int mid = (n+m)/2;            LL ans = 0;            for(int i=0; i&lt;pts.size();i++)                ans += abs(pts[mid]-pts[i]);            printf(&quot;%lld\n&quot;, ans);        }        for(int i=1;i&lt;=n;i++) a[i].clear();    }    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
            <tag> 思维 </tag>
            
            <tag> matrix </tag>
            
            <tag> codechef </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  Codeforces Round</title>
      <link href="/2017/06/28/73825637/"/>
      <url>/2017/06/28/73825637/</url>
      
        <content type="html"><![CDATA[<h1 id="Codeforces-Round-421-Div-2"><a href="#Codeforces-Round-421-Div-2" class="headerlink" title="Codeforces Round #421 (Div. 2)"></a>Codeforces Round #421 (Div. 2)</h1><p>2017年06月28日 03:17:32  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：517</p><hr><p> 博客爬取于<code>2019-04-18 17:15:57</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/73825637" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/73825637</a></p><p>第一次完全凭自己水平进了d2 前50(最后居然变成了36…hhh), 然后因为我没做的C题数据出锅而unrated…..</p><p>不开心啊….</p><h1 id="A-Mister-B-and-Book-Reading"><a href="#A-Mister-B-and-Book-Reading" class="headerlink" title="A [ Mister B and Book Reading"></a>A [ Mister B and Book Reading</h1><p>](<a href="http://codeforces.com/contest/820/problem/A" target="_blank" rel="noopener">http://codeforces.com/contest/820/problem/A</a>)</p><p>————————————————————————————————————————————<br>日常简单模拟题</p><pre><code>int main(){    int c,v0,v1,a,l;    scanf(&quot;%d%d%d%d%d&quot;,&amp;c,&amp;v0,&amp;v1,&amp;a,&amp;l);    int p=0,ans=0,flag=0;    while(p&lt;c){        ans++;        if(flag) p-=l;        flag=1;        p+=v0;        v0+=a;        v0=min(v0,v1);    }    printf(&quot;%d\n&quot;,ans);    return 0;}</code></pre><h1 id="B-Mister-B-and-Angle-in-Polygon"><a href="#B-Mister-B-and-Angle-in-Polygon" class="headerlink" title="B [ Mister B and Angle in Polygon"></a>B [ Mister B and Angle in Polygon</h1><p>](<a href="http://codeforces.com/contest/820/problem/B" target="_blank" rel="noopener">http://codeforces.com/contest/820/problem/B</a>)</p><p>————————————————————————————————————————————<br>给你一个正n变形,和一个角度a</p><p>让你找三个点,使得这三个点构成的角,与a相减的绝对值最小</p><hr><p>首先我们可以知道多边形的顶点是共圆的,所以以一个点为顶点的时候,其他边的圆周角大小相等,所以固定两个点也就是一个边,枚举另一个点即可</p><p>由于数据范围小,O(n) 维护即可,,如果大了点的话 需要三分求解</p><pre><code>int n;double a;int main(){    scanf(&quot;%d&quot;,&amp;n);    scanf(&quot;%lf&quot;,&amp;a);    double b=(n-2)*180/n,mi=411;    int ans = 1;    for(int i=1;i&lt;=n-2;i++){         if(abs(180.0/n*i-a)&lt;mi){            mi=abs(180.0/n*i-a);            ans=i;        }    }    printf(&quot;%d %d %d\n&quot;,n,n-1,ans);    return 0;}</code></pre><h1 id="C-Mister-B-and-Boring-Game"><a href="#C-Mister-B-and-Boring-Game" class="headerlink" title="C  Mister B and Boring Game "></a>C <a href="http://codeforces.com/contest/820/problem/C" target="_blank" rel="noopener"> Mister B and Boring Game </a></h1><p>————————————————————————————————————————————</p><p><strong> 题目问题比较大啊 正解最后都没有明确。 不补了 </strong></p><h1 id="D-Mister-B-and-PR-Shifts"><a href="#D-Mister-B-and-PR-Shifts" class="headerlink" title="D  Mister B and PR Shifts "></a>D <a href="http://codeforces.com/contest/820/problem/D" target="_blank" rel="noopener"> Mister B and PR Shifts </a></h1><p>————————————————————————————————————————————<br>给你一个长度为n的序列<br>可以旋转n次,<br>问你</p><p>∑  i  =  1  n  ∣  ∣  p  [  i  ]  −  i  ∣  ∣</p><p>的值最小的时候是多少 需要旋转几次  </p><p>k  =  0  :  s  h  i  f  t  p  1  ,  p  2  ,  .  .  .  p  n  ,  k  =  1  :  s<br>h  i  f  t  p  n  ,  p  1  ,  .  .  .  p  n  −  1  ,  .  .  .  ,  k  =  n  −<br>1  :  s  h  i  f  t  p  2  ,  p  3  ,  .  .  .  p  n  ,  p  −  1.</p><hr><p>其实很简单，<br>我们可以观察到每次旋转，除了最后一个数之外，其他的数需要减去的值都+1了<br>那么就是  p  [  i  ]  −  i  为非正值得数贡献+1,正数的数贡献坚毅</p><p>p  [  i  ]  −  i  相当于变成  p  [  i  ]  −  (  i  +  1  )  ,那也就是  (  p  [  i  ]<br>−  1  )  −  i</p><p>那么我们可以先算出初始的  ∑  n  i  =  1  ∣  ∣  p  [  i  ]  −  i  ∣  ∣  结果,然后每次按照上述规则计算即可,</p><p>方法是用一个数组h[j]记录  p  [  i  ]  −  i  为j的数有多少个</p><p>对于  p  [  i  ]  −  1  的情况 其实就用一个变量维护一个零线 就可以了</p><p>处理下前缀和即可,</p><p>由于序列最后一个值要特殊处理,所有会有修改,所以采用BIT进行维护</p><p>在每次旋转中维护答案即可</p><p>总复杂度:  O  (  n  log  n  )</p><p>——–Update——</p><p>刚才又想了想 发现这个过程根本不需要BIT，直接数组，零线外加两个变量就行了，是能做到O(1)的。</p><p>附本题代码<br>————————————————————————————————————</p><pre><code>#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long int LL;#define abs(x) ((x)&gt;0?(x):-(x))const int N = 2e6+10;/******************************************************/int z[N],f[N],p[N],n;int sum[N*4];#define lowbit(x) (x&amp;-x)void update(int i,int v){for(;i&lt;n*4;i+=lowbit(i)) sum[i]+=v;}int getsum(int i){int ans=0; for(;i;i-=lowbit(i)) ans+=sum[i]; return ans;}int main(){    memset(sum,0,sizeof(sum));    scanf(&quot;%d&quot;,&amp;n);    LL tmp=0,tem=0;int ans = 0,dd=n;    for(int i=1;i&lt;=n;i++){        scanf(&quot;%d&quot;,&amp;p[i]);        tmp+=abs(p[i]-i);        update(p[i]-i+n,1);    }    tem=tmp;    for(int i=2;i&lt;=n;i++){        tem-=abs(p[n-i+2]-n);        tem+=abs(p[n-i+2]-1);        update(p[n-i+2]-(n-i+2)+n,-1);        int t=getsum(dd);        tem+=t;        tem-=n-1-t;        dd++;        update(p[n-i+2]-1+dd,1);        if(tem&lt;tmp){            tmp=tem;            ans=i-1;        }    }    printf(&quot;%lld %d\n&quot;,tmp,ans);    return 0;}</code></pre><h1 id="E-Mister-B-and-Beacons-on-Field"><a href="#E-Mister-B-and-Beacons-on-Field" class="headerlink" title="E [ Mister B and Beacons on Field"></a>E [ Mister B and Beacons on Field</h1><p>](<a href="http://codeforces.com/contest/820/problem/E" target="_blank" rel="noopener">http://codeforces.com/contest/820/problem/E</a>)</p><p>————————————————————————————————————————————</p>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  [HAOI2008] 排名系统 &amp; [ZJOI2006] GameZ游戏排名系统 [SPLAY]【数据结构】</title>
      <link href="/2017/06/28/73825606/"/>
      <url>/2017/06/28/73825606/</url>
      
        <content type="html"><![CDATA[<h1 id="HAOI2008-排名系统-amp-ZJOI2006-GameZ游戏排名系统-SPLAY-【数据结构】"><a href="#HAOI2008-排名系统-amp-ZJOI2006-GameZ游戏排名系统-SPLAY-【数据结构】" class="headerlink" title="[HAOI2008] 排名系统 &amp; [ZJOI2006] GameZ游戏排名系统 [SPLAY]【数据结构】"></a>[HAOI2008] 排名系统 &amp; [ZJOI2006] GameZ游戏排名系统 [SPLAY]【数据结构】</h1><p>2017年06月28日 02:52:41  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：303</p><hr><p> 博客爬取于<code>2019-04-18 17:15:59</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/73825606" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/73825606</a></p><p>题目链接: <a href="http://codevs.cn/problem/1985/" target="_blank" rel="noopener"> http://codevs.cn/problem/1985/ </a><br>————————————————————————————————————————<br>题目描述 Description<br>[HAOI2008] 排名系统 &amp; [ZJOI2006] GameZ游戏排名系统：</p><p>GameZ为他们最新推出的游戏开通了一个网站。世界各地的玩家都可以将自己的游戏得分上传到网站上。这样就可以看到自己在世界上的排名。得分越高，排名就越靠前。当<br>两个玩家的名次相同时，先上传记录者优先。由于新游戏的火爆，网站服务器已经难堪重负。为此GameZ雇用了你来帮他们重新开发一套新的核心。 排名系统通常要应付三<br>种请求：上传一条新的得分记录、查询某个玩家的当前排名以及返回某个区段内的排名记录。当某个玩家上传自己最新的得分记录时，他原有的得分记录会被删除。为了减轻服务<br>器负担，在返回某个区段内的排名记录时，最多返回10条记录。</p><p>输入描述 Input Description<br>第一行是一个整数n（n&gt;=10）表示请求总数目。<br>接下来n行每行包含了一个请求。请求的具体格式如下：<br>+Name Score 上传最新得分记录。Name表示玩家名字，由大写英文字母组成，不超过10个字符。Score为不超过无符号32位整型表示范围的非负整数。<br>?Name 查询玩家排名。该玩家的得分记录必定已经在前面上传。<br>?Index 返回自第Index名开始的最多10名玩家名字。Index必定合法，即不小于1，也不大于当前有记录的玩家总数。<br>输入数据大小不超过2M。<br>NOTE：用C++的fstream读大规模数据的效率较低。</p><p>输出描述 Output Description<br>对于每条查询请求，输出相应结果。对于?Name格式的请求，应输出一个整数表示该玩家当前的排名。对于?Index格式的请求，应在一行中依次输出从第Index名<br>开始的最多10名玩家姓名，用一个空格分隔。</p><p>样例输入 Sample Input<br>20<br>+ADAM 1000000<br>+BOB 1000000<br>+TOM 2000000<br>+CATHY 10000000<br>?TOM<br>?1<br>+DAM 100000<br>+BOB 1200000<br>+ADAM 900000<br>+FRANK 12340000<br>+LEO 9000000<br>+KAINE 9000000<br>+GRACE 8000000<br>+WALT 9000000<br>+SANDY 8000000<br>+MICK 9000000<br>+JACK 7320000<br>?2<br>?5<br>?KAINE</p><p>样例输出 Sample Output<br>2<br>CATHY TOM ADAM BOB<br>CATHY LEO KAINE WALT MICK GRACE SANDY JACK TOM BOB<br>WALT MICK GRACE SANDY JACK TOM BOB ADAM DAM</p><p>数据范围及提示 Data Size &amp; Hint<br>【样例解释】<br>20<br>+ADAM 1000000 加入ADAM的得分记录<br>+BOB 1000000 加入BOB的得分记录<br>+TOM 2000000 加入TOM的得分记录<br>+CATHY 10000000 加入CATHY的得分记录<br>?TOM 输出TOM目前排名<br>?1 目前有记录的玩家总数为4，因此应输出第1名到第4名。<br>+DAM 100000 加入DAM的得分记录<br>+BOB 1200000 更新BOB的得分记录<br>+ADAM 900000 更新ADAM的得分记录（即使比原来的差）<br>+FRANK 12340000 加入FRANK的得分记录<br>+LEO 9000000 加入LEO的得分记录<br>+KAINE 9000000 加入KAINE的得分记录<br>+GRACE 8000000 加入GRACE的得分记录<br>+WALT 9000000 加入WALT的得分记录<br>+SANDY 8000000 加入SANDY的得分记录<br>+MICK 9000000 加入MICK的得分记录<br>+JACK 7320000 加入JACK的得分记录<br>?2 目前有记录的玩家总数为12，因此应输出第2名到第11名。<br>?5 输出第5名到第13名。<br>?KAINE 输出KAINE的排名</p><p>【数据范围】<br>20%数据满足N&lt;=100<br>100%数据满足N&lt;=250000<br>————————————————————————————————————————</p><p>首先这题考虑到玩家需要加分 ，那么就会产生一个新的排名，可以确定<br>这是一个SPLAY</p><p>因为排名是分数大的在前,所以是降序.我们可以在树上挂 <strong> 负值 </strong></p><p>那么考虑 怎么能在二叉排序树中找某个人的名字，？</p><p>这题光输入就很麻烦啊</p><p>名字 用一个map 映射成一个值就好了<br>考虑到先出现的在前 所以给这个值放大 然后+i就好了<br>然后在用这个值映射回名字即可,</p><p>一共两个map</p><p>其实还是很简单的 记录下分数 然后就找就行了</p><p>附本题代码<br>————————————————————————————————————————</p><pre><code>#include &lt;bits/stdc++.h&gt;typedef long long int LL ;using namespace std;const int N   = 300000+7;const LL INF = 1000000000000000000LL;/******************************************************/int n;string ss,s;map&lt;string,LL&gt;mmp;map&lt;LL,string&gt;mmp2;int ch[N][2];  //ch[][0] lson ch[][1] rsonint f[N];      //fatherint sz[N];     //sizeLL val[N];    //value of node_iint cnt[N];    // counts of the node_iint root;      //root of splay-treeint tot;       //tot,total,is the number of node of treevoid pushup(int x){    if(x)sz[x]=sz[ch[x][0]]+sz[ch[x][1]]+cnt[x];}void rotate(int x,int k){   // k = 0 左旋， k = 1 右旋    int y=f[x];int z=f[y];    ch[y][!k]=ch[x][k];if(ch[x][k])f[ch[x][k]]=y;    f[x]=z;if(z)ch[z][ch[z][1]==y]=x;    f[y]=x;ch[x][k]=y;    pushup(y),pushup(x);}void splay(int x,int goal){    for(int y=f[x];f[x]!=goal;y=f[x])        rotate(x,(ch[y][0]==x));    if(goal==0) root=x;}void newnode(int rt,LL v,int fa){    f[rt]=fa;val[rt]=v,sz[rt]=cnt[rt]=1;    ch[rt][0]=ch[rt][1]=0;}void delnode(int &amp;rt){ //其实是为内存回收做准备的  回头再完善    f[rt]=val[rt]=sz[rt]=cnt[rt]=0;    ch[rt][0]=ch[rt][1]=rt=0;}/***************************以下是DEBUG***************************/void Traversal(int rt){    if(!rt) return;    Traversal(ch[rt][0]);    printf(&quot;%d f[]=%d sz[]=%d lson=%d rson=%d val[]=%lld\n&quot;,rt,f[rt],sz[rt],ch[rt][0],ch[rt][1],val[rt]);    Traversal(ch[rt][1]);}void debug(){    printf(&quot;ROOT = %d &lt;---\n&quot;,root);    Traversal(root);}/**************************以下是前置操作**************************///以x为根的子树 的极值点  0 极小 1 极大int extreme(int x,int k){    while(ch[x][k])x=ch[x][k];splay(x,0);    return x;}//以x为根的子树 第k个数的位置int kth(int x,int k){    if(sz[ch[x][0]]+1&lt;=k&amp;&amp;k&lt;=sz[ch[x][0]]+cnt[x]) return x;    else if(ch[x][0]&amp;&amp;sz[ch[x][0]]&gt;=k) return kth(ch[x][0],k);    else return kth(ch[x][1],k-sz[ch[x][0]]-cnt[x]);}int search(int rt,LL x){        if(ch[rt][0]&amp;&amp;val[rt]&gt;x) return search(ch[rt][0],x);    else if(ch[rt][1]&amp;&amp;val[rt]&lt;x)return search(ch[rt][1],x);    else return rt;}/***************************以下是正经操作*************************///前驱int prec(LL x){    int k=search(root,x);    splay(k,0);//debug();    if(val[k]&lt;x) return k;    return extreme(ch[k][0],1);}//后继int sufc(LL x){    int k=search(root,x);    splay(k,0);//debug();    if(val[k]&gt;x) return k;    return extreme(ch[k][1],0);}int rk(LL x){    int k=search(root,x);    splay(k,0);    return sz[ch[root][0]]+1;}//按照二叉排序树性质插入xvoid _insert(LL x){    int p=prec(x),s=sufc(x);    splay(p,0);splay(s,p);    newnode(++tot,x,ch[root][1]);    ch[ch[root][1]][0]=tot;    for(int z=ch[root][1];z;z=f[z])pushup(z);    splay(tot,0);}void _delete(LL x){    int p=prec(x),s=sufc(x);    splay(p,0);splay(s,p);    ch[ch[root][1]][0]=0;    delnode(ch[ch[root][1]][0]);    for(int yy=s;yy;yy=f[yy]) pushup(yy);}LL mystack[100],len;void dfs(int rt){    if(!rt) return ;    dfs(ch[rt][0]);    mystack[++len]=val[rt];    dfs(ch[rt][1]);}void solve(int x){    int y=kth(root,x-1);    int z=kth(root,min(x+10,sz[root]));    splay(y,0),splay(z,y);    len=0;    dfs(ch[ch[root][1]][0]);    for(int i=1;i&lt;len;i++)        cout&lt;&lt;mmp2[mystack[i]]&lt;&lt;&quot; &quot;;    cout&lt;&lt;mmp2[mystack[len]]&lt;&lt;endl;}int main(){    mmp.clear();mmp2.clear();    cin&gt;&gt;n;    tot=0,root=1;    newnode(++tot,-INF,0),newnode(++tot,INF,root);    ch[root][1]=tot;    for(int i=1,sc;i&lt;=n;i++){//debug();        cin&gt;&gt;s;        ss=&quot;&quot;;        for(int i=1;i&lt;s.size();i++) ss+=s[i];        if(s[0]==&#39;+&#39;){            cin&gt;&gt;sc;            if(mmp[ss]!=0) _delete(mmp[ss]);            mmp[ss]=(LL)sc*-1000000+i;            mmp2[mmp[ss]]=ss;            _insert(mmp[ss]);        }        else {            if(&#39;0&#39;&lt;=ss[0]&amp;&amp;ss[0]&lt;=&#39;9&#39;){                sc=0;                for(int j=0;j&lt;ss.size();j++) sc=(sc&lt;&lt;3)+(sc&lt;&lt;1)+ss[j]-&#39;0&#39;;                solve(sc+1);            }            else{                cout&lt;&lt;rk(mmp[ss])-1&lt;&lt;endl;            }        }    }    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  Codeforces Round</title>
      <link href="/2017/06/27/73822126/"/>
      <url>/2017/06/27/73822126/</url>
      
        <content type="html"><![CDATA[<h1 id="Codeforces-Round-420-Div-2"><a href="#Codeforces-Round-420-Div-2" class="headerlink" title="Codeforces Round #420 (Div. 2)"></a>Codeforces Round #420 (Div. 2)</h1><p>2017年06月27日 19:07:39  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：182</p><p>个人分类：  <a href="https://blog.csdn.net/qq_33184171/article/category/6235560" target="_blank" rel="noopener"> codeforces</a> <a href="https://blog.csdn.net/qq_33184171/article/category/6822765" target="_blank" rel="noopener"> 套题</a></p><hr><p> 博客爬取于<code>2019-04-18 17:16:00</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/73822126" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/73822126</a></p><h1 id="A-Okabe-and-Future-Gadget-Laboratory"><a href="#A-Okabe-and-Future-Gadget-Laboratory" class="headerlink" title="A [ Okabe and Future Gadget Laboratory"></a>A [ Okabe and Future Gadget Laboratory</h1><p>](<a href="http://codeforces.com/contest/821/problem/A" target="_blank" rel="noopener">http://codeforces.com/contest/821/problem/A</a>)</p><p>——————————————————————————————————————————</p><p>简单SB题，<br>问你矩阵中所有大于  1  的数能否用所在行的一个数加上所在列的一个数表示 ,如果都能就YES,否则NO</p><pre><code>int n;int a[55][55];bool solve(int x,int y){    for(int i=1;i&lt;=n;i++){        for(int j=1;j&lt;=n;j++){            if(a[x][y]==a[x][i]+a[j][y]) return true;        }    }    return false;}int main(){    scanf(&quot;%d&quot;,&amp;n);    for(int i=1;i&lt;=n;i++){        for(int j=1;j&lt;=n;j++){            scanf(&quot;%d&quot;,&amp;a[i][j]);        }    }    int flag=1;    for(int i=1;i&lt;=n;i++){        for(int j=1;j&lt;=n;j++){            if(a[i][j]==1)continue;            if(solve(i,j))continue;            flag=false;break;        }        if(!flag) break;    }    if(flag) puts(&quot;Yes&quot;);    else     puts(&quot;No&quot;);    return 0;}</code></pre><h1 id="B-Okabe-and-Banana-Trees"><a href="#B-Okabe-and-Banana-Trees" class="headerlink" title="B  Okabe and Banana Trees "></a>B <a href="http://codeforces.com/contest/821/problem/B" target="_blank" rel="noopener"> Okabe and Banana Trees </a></h1><p>——————————————————————————————————————————</p><p>还是SB题,暴力找  O  (  m  ×  b  )  都不会超时</p><p>但是显然答案一定在线下方第一个点,</p><p>而直到每个点后的答案是能O(1)计算的</p><p>所以  O  (  b  )  维护  (  1  +  x  )  ∗  x  /  2  ∗  (  y  +  1  )  +  (  1<br>+  y  )  ∗  (  y  )  /  2  ∗  (  x  +  1  )  的最小值即可</p><pre><code>int main(){    LL m,b,ans=0;    scanf(&quot;%lld%lld&quot;,&amp;m,&amp;b);    for(LL y=0,x;y&lt;=b;y++){        x=(b-y)*m;        ans = max(ans,(1+x)*x/2*(y+1)+(1+y)*(y)/2*(x+1));    }    printf(&quot;%lld\n&quot;,ans);    return 0;}</code></pre><h1 id="C-Okabe-and-Boxes"><a href="#C-Okabe-and-Boxes" class="headerlink" title="C  Okabe and Boxes "></a>C <a href="http://codeforces.com/contest/821/problem/C" target="_blank" rel="noopener"> Okabe and Boxes </a></h1><p>——————————————————————————————————————————</p><p>让你维护一个栈,你可以将栈里面的元素重新排列,现在问你至少重新排列多少回 能让出栈的顺序为升序</p><hr><p>就是在维护这个栈的操作,<br>进栈的时候一样</p><p>出站的时候看栈顶是不是预期的那个数,是的话就重新排列下即可</p><p>而这里的重新排列 可以用清空栈来代替</p><pre><code>char s[22];int mystack[N],len;int a[N],la,cnt,ans;const int INF = 3e6;int main(){    int n;len=la=cnt=ans=0;    scanf(&quot;%d&quot;,&amp;n);    for(int i=1,x;i&lt;=n*2;i++){        scanf(&quot;%s&quot;,s);        if(s[0]==&#39;a&#39;){            scanf(&quot;%d&quot;,&amp;x);            mystack[++len]=x;        }        else {            cnt++;            if(len&amp;&amp;mystack[len]==cnt) len--;            else if(len) ans++,len=0;        }    }    printf(&quot;%d\n&quot;,ans);    return 0;}</code></pre><h1 id="D-Okabe-and-City"><a href="#D-Okabe-and-City" class="headerlink" title="D  Okabe and City "></a>D <a href="http://codeforces.com/contest/821/problem/D" target="_blank" rel="noopener"> Okabe and City </a></h1><p>——————————————————————————————————————————</p><p>N*M的二维矩阵,有K个位置时初始就是亮着的,一个人要走在当时亮着的格子从(1,1)到(n,m)<br>站在最初是亮着位置可以花费1来让某一行或某一列全变量,<br>问你最小花费</p><hr><p>同时只能点亮某一行或某一列,那么一定是在最初两者的位置临近的两个行/两个列和本身所在的行/列,</p><p>再加上格子相邻的地方</p><p>按照这两种规则进行建图计算最短路就行了,</p><pre><code>struct node {    int to,next,w;}G[N];int head[N],cnt,tot;void add(int u,int v,int w){    G[cnt].w=w,G[cnt].to=v,G[cnt].next=head[u],head[u]=cnt++;}int d[N],vis[N];void SPFA(int s,int t,int n){    const int INF = (~(1&lt;&lt;31))&gt;&gt;1;    for(int i=0;i&lt;=n;i++) d[i]=INF,vis[i]=0;    queue&lt;int &gt;q;    q.push(s);d[s]=0,vis[s]=1;    while(!q.empty()){        int u=q.front();q.pop();        vis[u]=0;        for(int i=head[u],to,w;i!=-1;i=G[i].next){            to=G[i].to;            w =G[i].w;            if(d[to]&gt;d[u]+w){                d[to]=d[u]+w;                if(vis[to])continue;                vis[to]=1;q.push(to);            }        }    }    if(d[t]==INF) puts(&quot;-1&quot;);    else printf(&quot;%d\n&quot;,d[t]);}int n,m,k;int x[11111],y[11111];int a[11111],b[11111];int main(){    memset(head,-1,sizeof (head));    scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;k);    cnt=0,tot=k;    for(int i=1;i&lt;=n;i++) x[i]=++tot;    for(int j=1;j&lt;=m;j++) y[j]=++tot;    int flag=0,s=0,t=0;    for(int i=1;i&lt;=k;i++){        scanf(&quot;%d%d&quot;,&amp;a[i],&amp;b[i]);    }    for(int i=1;i&lt;=k;i++){        add(i,x[a[i]],1),add(x[a[i]],i,0);        if(x[a[i]-1]) add(i,x[a[i]-1],1),add(x[a[i]-1],i,0);        if(x[a[i]+1]) add(i,x[a[i]+1],1),add(x[a[i]+1],i,0);        add(i,y[b[i]],1),add(y[b[i]],i,0);        if(y[b[i]-1]) add(i,y[b[i]-1],1),add(y[b[i]-1],i,0);        if(y[b[i]+1]) add(i,y[b[i]+1],1),add(y[b[i]+1],i,0);        for(int j=1;j&lt;i;j++) if(abs(a[i]-a[j])+abs(b[i]-b[j])&lt;=1) add(i,j,0),add(j,i,0);        if(a[i]==1&amp;&amp;b[i]==1) s=i;        if(a[i]==n&amp;&amp;b[i]==m) t=i;    }    if(!t)  t=++tot;    add(x[n],t,0);    add(y[m],t,0);    SPFA(s,t,tot);    return 0;}1</code></pre><h1 id="E-Okabe-and-El-Psy-Kongroo"><a href="#E-Okabe-and-El-Psy-Kongroo" class="headerlink" title="E  Okabe and El Psy Kongroo "></a>E <a href="http://codeforces.com/contest/821/problem/E" target="_blank" rel="noopener"> Okabe and El Psy Kongroo </a></h1><p>——————————————————————————————————————————</p><p>有n条线段,线段平行于x坐标,<br>每次只能走在线段下方,从(x,y)能走到(x+1,y+1)(x+1,y)(x+1,y-1)这三个位置,问你最后到(k,0)的方案数,</p><hr><p>简单的矩阵快速幂</p><p>只与必须在线段下方的限制,我们可以再计算之前将不合格的点清0即可</p><p>注意I64 要不然会GG</p><pre><code>#include &lt;bits/stdc++.h&gt;typedef long long int LL;using namespace std;const int N   = 3e6+7;const int MOD = 1e9+7;#define abs(x) ((x)&gt;0?(x):-(x))inline LL read(){    LL x=0;char ch=getchar();    for(;ch&lt;&#39;0&#39;||&#39;9&#39;&lt;ch;ch=getchar());    for(;&#39;0&#39;&lt;=ch&amp;&amp;ch&lt;=&#39;9&#39;;ch=getchar())x=(x&lt;&lt;3)+(x&lt;&lt;1)+ch-&#39;0&#39;;    return x;}/***************************************************************/const int M = 20;struct Matrix{    LL m[M][M];    void clearO(){        for(int i=0; i&lt;M; i++)            for(int j=0; j&lt;M; j++)                m[i][j]= 0;    }    void clearE(){        for(int i=0; i&lt;M; i++)            for(int j=0; j&lt;M; j++)                m[i][j]= (i==j);    }    void display(){        for(int i=0; i&lt;M; i++){            for(int j=0; j&lt;M; j++)                printf(&quot;%d &quot;,m[i][j]);            puts(&quot;&quot;);        }    }};Matrix operator * (Matrix &amp;a,Matrix &amp;b){    Matrix c;c.clearO();    for(int k=0; k&lt;M; k++)        for(int i=0; i&lt;M; i++){            if(a.m[i][k] &lt;= 0)  continue;            for(int j=0; j&lt;M; j++){                if(b.m[k][j] &lt;= 0)    continue;                c.m[i][j]=(c.m[i][j]+a.m[i][k]*b.m[k][j]+MOD)%MOD;            }        }    return c;}Matrix operator ^ (Matrix &amp;a,LL b){    Matrix c;c.clearE();    while(b){        if(b&amp;1) c= c * a ;        b &gt;&gt;= 1;        a = a * a ;    }    return c;}int n;LL k;LL a[111],b[111];int c[111];int main(){    scanf(&quot;%d%lld&quot;,&amp;n,&amp;k);    for(int i=1;i&lt;=n;i++) scanf(&quot;%lld%lld%d&quot;,&amp;a[i],&amp;b[i],&amp;c[i]);    b[n]=k;    Matrix aa,bb;    aa.clearO();aa.m[0][0]=1;    for(int i=1;i&lt;=n;i++){        bb.clearO();        for(int j=0;j&lt;=15;j++){            if(j-1&gt;=0)    bb.m[j][j-1]=1;                          bb.m[j][j  ]=1;            if(j+1&lt;=15)   bb.m[j][j+1]=1;        }//        bb.display();        for(int j=0;j&lt;=15;j++){            for(int k=0;k&lt;=15;k++){                if(j&lt;=c[i]&amp;&amp;k&lt;=c[i]) continue;                aa.m[j][k]=bb.m[j][k]=0;            }        }        bb=bb^(b[i]-a[i]);        aa=aa*bb;    }    printf(&quot;%lld\n&quot;,aa.m[0][0]);    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> codeforces </tag>
            
            <tag> 套题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  hihoCoder挑战赛29</title>
      <link href="/2017/06/27/73798177/"/>
      <url>/2017/06/27/73798177/</url>
      
        <content type="html"><![CDATA[<h1 id="hihoCoder挑战赛29"><a href="#hihoCoder挑战赛29" class="headerlink" title="hihoCoder挑战赛29"></a>hihoCoder挑战赛29</h1><p>2017年06月27日 14:51:27  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：214</p><p>个人分类：  <a href="https://blog.csdn.net/qq_33184171/article/category/6822765" target="_blank" rel="noopener"> 套题 </a></p><hr><p> 博客爬取于<code>2019-04-18 17:16:01</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/73798177" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/73798177</a></p><h2 id="先附上官方题解：-https-media-hihocoder-com-contests-challenge29-sol-pdf"><a href="#先附上官方题解：-https-media-hihocoder-com-contests-challenge29-sol-pdf" class="headerlink" title="先附上官方题解： [ https://media.hihocoder.com/contests/challenge29/sol.pdf"></a>先附上官方题解： [ <a href="https://media.hihocoder.com/contests/challenge29/sol.pdf" target="_blank" rel="noopener">https://media.hihocoder.com/contests/challenge29/sol.pdf</a></h2><p>](<a href="https://media.hihocoder.com/contests/challenge29/sol.pdf" target="_blank" rel="noopener">https://media.hihocoder.com/contests/challenge29/sol.pdf</a>)</p><h2 id="—————————————————————————–"><a href="#—————————————————————————–" class="headerlink" title="—————————————————————————–"></a>—————————————————————————–</h2><p><strong> 啊啊啊啊啊啊啊啊啊啊啊啊 ，再次感觉到了自己有多弱！！！！！ </strong></p><h1 id="1526-序列的值"><a href="#1526-序列的值" class="headerlink" title="1526 : 序列的值"></a>1526 : 序列的值</h1><p>时间限制:20000ms<br>单点时限:1000ms<br>内存限制:256MB<br>描述<br>给定一个长度为 n 的序列 a[1..n]，定义函数 f(b[1..m]) 的值为在 [0,m-1] 内满足如下条件的 i 的数目：</p><p>b 中前 i 个数异或起来的值小于 b 中前 i +1个数异或起来的值。</p><p>对于 a[1..n] 的每个子序列 b[1..m]，求f(b[1..m])之和。</p><p>输入<br>第一行一个正整数 n。</p><p>接下来一共有 n 行。第 i+1 行包含一个非负整数 a[i]。</p><p>1 ≤ n ≤ 105</p><p>0 ≤ a[i] &lt; 231</p><p>输出<br>输出答案对 998244353 取模后的值。</p><p>样例输入<br>2<br>1<br>2<br>样例输出<br>4</p><hr><p>首先考虑a &lt; a^b的情况, 显然需要a中二进制的0位在b中对应位是1且是b的最高位, <a href="http://blog.csdn.net/qq_33184171/article/details/51183322" target="_blank" rel="noopener"> 不懂可以戳这里</a></p><p>然后就是需要对每个数 求贡献,</p><p>也就是找每个数 前面所构成在这个数最高位为0的异或和的个数,</p><p>可以设一个dp[31][0/1] 代表每一位位0/1的个数</p><p>转移就是  </p><p>i  f  (  对  应  的  数  第  i  位  为  1  )  d  p  [  i  ]  [  0  ]  =  d  p  [  i<br>]  [  0  ]  (  不  异  或  上  这  个  数  )  +  d  p  [  i  ]  [  1  ]  (  异  或  上<br>这  个  数  )  d  p  [  i  ]  [  1  ]  =  d  p  [  i  ]  [  1  ]  (  不  异  或  上<br>这  个  数  )  +  d  p  [  i  ]  [  0  ]  (  异  或  上  这  个  数  )  i  f  (  对  应<br>的  数  第  i  位  为  0  )  d  p  [  i  ]  [  0  ]  =  d  p  [  i  ]  [  0  ]  (<br>不  异  或  上  这  个  数  )  +  d  p  [  i  ]  [  0  ]  (  异  或  上  这  个  数  )  d<br>p  [  i  ]  [  1  ]  =  d  p  [  i  ]  [  1  ]  (  不  异  或  上  这  个  数  )  +<br>d  p  [  i  ]  [  1  ]  (  异  或  上  这  个  数  )</p><p>以上</p><h2 id="附本题代码"><a href="#附本题代码" class="headerlink" title="附本题代码"></a>附本题代码</h2><pre><code>int a[N],n;LL dp[40][2],m[N];int main(){    scanf(&quot;%d&quot;,&amp;n);    for(int i=1;i&lt;=n;i++)scanf(&quot;%d&quot;,&amp;a[i]);    LL ans=0;    for(int i=0;i&lt;=30;i++) dp[i][0]=1;    m[n]=1;    for(int i=n-1;i;i--) m[i]=m[i+1]*2%MOD;    for(int i=1,bt;i&lt;=n;i++){        bt=0;        for(int j=30;j&gt;=0;j--)if(a[i]&amp;(1&lt;&lt;j)){bt=j;break;}        ans=(ans+dp[bt][0]*m[i])%MOD;        for(int j=0;j&lt;=30;j++){            int zero,one;            if(a[i]&amp;(1&lt;&lt;j)){                zero = (dp[j][0]+dp[j][1]  )%MOD;                one  = (dp[j][0]+dp[j][1]  )%MOD;            }            else {                zero = (dp[j][0]+dp[j][0]  )%MOD;                one  = (dp[j][1]+dp[j][1]  )%MOD;            }            dp[j][0]=zero,dp[j][1]=one;        }    }    printf(&quot;%lld\n&quot;,ans%MOD);    return 0;}</code></pre><h1 id="1527-快速乘法"><a href="#1527-快速乘法" class="headerlink" title="1527 : 快速乘法"></a>1527 : 快速乘法</h1><p>时间限制:20000ms<br>单点时限:1000ms<br>内存限制:256MB<br>描述<br>在写代码时，我们经常要用到类似 x × a 这样的语句( a<br>是常数)。众所周知，计算机进行乘法运算是非常慢的，所以我们需要用一些加法、减法和左移的组合来实现乘一个常数这个操作。具体来讲， 我们要把 x × a<br>替换成：  (  x  &lt; &lt; a  0  )  o  p  1  (  x  &lt; &lt; a  1  )  o  p  2  (  x  &lt; &lt; a  2<br>)  .  .  .  o  p  n  (  x  &lt; &lt; a  n  )  这样的形式，其中  o  p  i  是+或者-。</p><p>举个例子：x × 15 = (x&lt;&lt;4) - (x&lt;&lt;0)。</p><p>在本题中，假设左移（包括左移0）和加法、减法所需要的时间都是一个单位的时间，上述的例子所需要的时间是3。</p><p>现在给定常数 a 的二进制形式，求实现 x × a 最少需要多少单位的时间。</p><p>输入<br>一个01串，表示 a 的二进制形式，从左到右分别是从高位到低位。</p><p>0 &lt; 01串的长度之和 ≤ 10^6。</p><p>a &gt; 0。</p><p>输出<br>输出一个数，表示最小需要多少单位的时间可以实现 x × a。</p><p>样例输入<br>1111<br>样例输出<br>3</p><p>————————————————————————————————————————<br>是个二分拆幂 <a href="http://www.cnblogs.com/atyuwen/archive/2012/08/04/pow2_partition.html" target="_blank" rel="noopener"> http://www.cnblogs.com/atyuwen/archive/2012/08/04/pow2_partition.html</a></p><p>附本题代码<br>————————————————————————————————————————</p><pre><code>#include &lt;bits/stdc++.h&gt;typedef long long int LL;using namespace std;const int N = 3e6+7;/*************************************************/char a[N];int main(){a[0]=&#39;-&#39;;    scanf(&quot;%s&quot;,a+1);    int la = strlen(a+1);    int l=1,r=la;    while(l&lt;=la&amp;&amp;a[l]==&#39;0&#39;) l++;    while(r&amp;&amp;a[r]==&#39;0&#39;) r--;    if(a[r]==&#39;-&#39;) return 0*puts(&quot;0&quot;);    int u=1,d=1;    for(int i=r-1;i&gt;=l;i--){        if(a[i]==&#39;1&#39;) u=min(u,d)+1;        else          d=min(u,d)+1;    }    printf(&quot;%d\n&quot;,u*2-1);    return 0;}</code></pre><h1 id="1528-投篮比赛"><a href="#1528-投篮比赛" class="headerlink" title="1528 : 投篮比赛"></a>1528 : 投篮比赛</h1><p>时间限制:40000ms<br>单点时限:2000ms<br>内存限制:256MB<br>描述<br>有 n 个小朋友在投篮，他们的赛制是这样的：对于每轮，每个人投一颗球，没投进的就淘汰掉，无法参加下轮。特别地，如果所有人都没投进，那就没有人被淘汰。他们将一<br>轮轮比下去直到最后只剩1个人。</p><p>现在已知每个小朋友投进的概率是 p，求期望几轮结束比赛。</p><p>输入<br>第一行三个整数 n, x, y。</p><p>题目中的 p = x / y。</p><p>1 ≤ n ≤ 105</p><p>1 ≤ x &lt; y &lt; 998244353</p><p>输出<br>输出答案对 998244353 取模后的值。</p><p>分数取模的方法： <a href="https://math.stackexchange.com/questions/586595/finding-modular-of-a-fraction" target="_blank" rel="noopener"> https://math.stackexchange.com/questions/586595/finding-modular-<br>of-a-fraction </a></p><p>样例输入<br>2 1 2<br>样例输出<br>2<br>——————————————————————————————————</p><p><strong> 不会 </strong></p><p>——————————————————————————————————</p><h1 id="1529-不上升序列"><a href="#1529-不上升序列" class="headerlink" title="1529 : 不上升序列"></a>1529 : 不上升序列</h1><p>时间限制:40000ms<br>单点时限:2000ms<br>内存限制:256MB<br>描述<br>给定一个长度为 n 的非负整数序列 a[1..n]。</p><p>你每次可以花费 1 的代价给某个 a[i] 加1或者减1。</p><p>求最少需要多少代价能将这个序列变成一个不上升序列。</p><p>输入<br>第一行一个正整数 n。</p><p>接下来 n 行每行一个非负整数，第 i 行表示 a[i]。</p><p>1 ≤ n ≤ 500000</p><p>0 &lt; a[i] ≤ 10^9</p><p>输出<br>一个非负整数，表示答案。</p><p>样例解释<br>[5,3,4,5] -&gt; [5,4,4,4]</p><p>样例输入<br>4<br>5<br>3<br>4<br>5<br>样例输出<br>2</p><p>——————————————————————————————————————————<br>首先这题有个结论, 最后得到的序列中的每一个元素都在原序列中</p><p>首先考虑  O  (  n  2  )  的dp</p><p>有了这个结论,我们可以直接dp</p><p>把  a  i  变成第k大的那个序列所需要的最小花费就行了</p><p>但是这题数据范围明显需要  O  (  n  log  n  )</p><p>可以用左偏树降到  O  (  n  log  n  )  ,然后就上了个左偏树的模板</p><p>附本题代码<br>——————————————————————————————————————————</p><pre><code>#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;cstdlib&gt;using namespace std;typedef long long int LL;const LL maxn = 500000 + 10;#define B printf(&quot;BUG\n&quot;);LL a[maxn];LL ans[maxn];class Node {public :    LL v;    LL h;    Node * ch[2];    Node(LL v) : v(v) { ch[0] = ch[1] = NULL; h = 0; }};class Seg {public :    LL n;    Node * rt;    Seg(Node * rt, LL n) : rt(rt), n(n) {}};class Leftist {public :    stack&lt;Seg *&gt;S;    Node * merge(Node * t1, Node * t2) {        if(t1 == NULL) return t2;        else if(t2 == NULL) return t1;        if(t1-&gt;v &lt; t2-&gt;v) swap(t1, t2);        if(t1-&gt;ch[1] == NULL) {            t1-&gt;ch[1] = t2;            if(t1-&gt;ch[0] == NULL) { swap(t1-&gt;ch[0], t1-&gt;ch[1]); t1-&gt;h = 0; }            else {                if(t1-&gt;ch[0]-&gt;h &lt; t1-&gt;ch[1]-&gt;h) swap(t1-&gt;ch[0], t1-&gt;ch[1]);                t1-&gt;h = t1-&gt;ch[1]-&gt;h + 1;            }        }        else {            t1-&gt;ch[1] = merge(t1-&gt;ch[1], t2);            if(t1-&gt;ch[0] == NULL) { swap(t1-&gt;ch[0], t1-&gt;ch[1]); t1-&gt;h = 0; }            else {                if(t1-&gt;ch[0]-&gt;h &lt; t1-&gt;ch[1]-&gt;h) swap(t1-&gt;ch[0], t1-&gt;ch[1]);                t1-&gt;h = t1-&gt;ch[1]-&gt;h + 1;            }        }        return t1;    }    void solve(LL x) {        LL num = 1;        Node * t1 = new Node(x);        while(!S.empty()) {            Seg * s2 = S.top();            if(t1-&gt;v &lt; s2-&gt;rt-&gt;v) {                LL flag = false;                if(num % 2 &amp;&amp; s2-&gt;n % 2) flag = true;                t1 = merge(t1, s2-&gt;rt);                num += s2-&gt;n;                if(flag) {                    Node * tmp = t1;                    t1 = merge(t1-&gt;ch[0], t1-&gt;ch[1]);                    delete tmp;                }                S.pop();                delete s2;            }            else break;        }        Seg * s2 = new Seg(t1, num);        S.push(s2);    }    void removetree(Node * rt) {        if(rt-&gt;ch[0] == NULL &amp;&amp; rt-&gt;ch[1] == NULL) {            delete rt;            rt = NULL;            return ;        }        if(rt-&gt;ch[0]) removetree(rt-&gt;ch[0]);        if(rt-&gt;ch[1]) removetree(rt-&gt;ch[1]);        delete rt;        rt = NULL;    }    void remove() {        while(!S.empty()) {            removetree(S.top()-&gt;rt);            delete S.top();            S.pop();        }    }};int main() {    LL n;    while(scanf(&quot;%lld&quot;, &amp;n) != EOF) {        Leftist lt;        for( LL i=0; i&lt;n; i++ ) {            scanf(&quot;%lld&quot;, &amp;a[i]);            lt.solve(a[i]);        }        LL k = 0;        while(!lt.S.empty()) {            Seg * f = lt.S.top(); lt.S.pop();            for( LL i=0; i&lt;f-&gt;n; i++ ) {                ans[k++] = f-&gt;rt-&gt;v;            }        }        LL res = 0;        for( LL i=k-1; i&gt;=0; i-- ) res += abs(ans[i] - a[n-i-1]);        lt.remove();        Leftist lt2;        for( LL i=0; i&lt;n/2; i++ ) swap(a[i], a[n-i-1]);        for( LL i=0; i&lt;n; i++ ) lt2.solve(a[i]);        k = 0;        while(!lt2.S.empty()) {            Seg * f = lt2.S.top(); lt2.S.pop();            for( LL i=0; i&lt;f-&gt;n; i++ ) {                ans[k++] = f-&gt;rt-&gt;v;            }        }        LL res2 = 0;        for( LL i=k-1; i&gt;=0; i-- ) res2 += abs(ans[i] - a[n-i-1]);        lt2.remove();        printf(&quot;%lld\n&quot;,res2);    }    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 套题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  Codeforces 557D - Vitaly and Cycle [二分图染色]【图论】</title>
      <link href="/2017/06/21/73556860/"/>
      <url>/2017/06/21/73556860/</url>
      
        <content type="html"><![CDATA[<h1 id="Codeforces-557D-Vitaly-and-Cycle-二分图染色-【图论】"><a href="#Codeforces-557D-Vitaly-and-Cycle-二分图染色-【图论】" class="headerlink" title="Codeforces 557D - Vitaly and Cycle [二分图染色]【图论】"></a>Codeforces 557D - Vitaly and Cycle [二分图染色]【图论】</h1><p>2017年06月21日 23:51:59  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：196</p><p>个人分类：  <a href="https://blog.csdn.net/qq_33184171/article/category/6235560" target="_blank" rel="noopener"> codeforces</a> <a href="https://blog.csdn.net/qq_33184171/article/category/6188704" target="_blank" rel="noopener"> ===== 图论 =====</a> <a href="https://blog.csdn.net/qq_33184171/article/category/6253262" target="_blank" rel="noopener"> 思维</a></p><hr><p> 博客爬取于<code>2019-04-18 17:16:03</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/73556860" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/73556860</a></p><p>题目链接: <a href="http://codeforces.com/problemset/problem/557/D" target="_blank" rel="noopener"> http://codeforces.com/problemset/problem/557/D</a><br>——————————————————————————————————————<br>D. Vitaly and Cycle<br>time limit per test1 second<br>memory limit per test256 megabytes<br>inputstandard input<br>outputstandard output<br>After Vitaly was expelled from the university, he became interested in the<br>graph theory.</p><p>Vitaly especially liked the cycles of an odd length in which each vertex<br>occurs at most once.</p><p>Vitaly was wondering how to solve the following problem. You are given an<br>undirected graph consisting of n vertices and m edges, not necessarily<br>connected, without parallel edges and loops. You need to find t — the minimum<br>number of edges that must be added to the given graph in order to form a<br>simple cycle of an odd length, consisting of more than one vertex. Moreover,<br>he must find w — the number of ways to add t edges in order to form a cycle of<br>an odd length (consisting of more than one vertex). It is prohibited to add<br>loops or parallel edges.</p><p>Two ways to add edges to the graph are considered equal if they have the same<br>sets of added edges.</p><p>Since Vitaly does not study at the university, he asked you to help him with<br>this task.</p><p>Input<br>The first line of the input contains two integers n and m ( — the number of<br>vertices in the graph and the number of edges in the graph.</p><p>Next m lines contain the descriptions of the edges of the graph, one edge per<br>line. Each edge is given by a pair of integers ai, bi (1 ≤ ai, bi ≤ n) — the<br>vertices that are connected by the i-th edge. All numbers in the lines are<br>separated by a single space.</p><p>It is guaranteed that the given graph doesn’t contain any loops and parallel<br>edges. The graph isn’t necessarily connected.</p><p>Output<br>Print in the first line of the output two space-separated integers t and w —<br>the minimum number of edges that should be added to the graph to form a simple<br>cycle of an odd length consisting of more than one vertex where each vertex<br>occurs at most once, and the number of ways to do this.</p><p>Examples<br>input<br>4 4<br>1 2<br>1 3<br>4 2<br>4 3<br>output<br>1 2<br>input<br>3 3<br>1 2<br>2 3<br>3 1<br>output<br>0 1<br>input<br>3 0<br>output<br>3 1<br>Note<br>The simple cycle is a cycle that doesn’t contain any vertex twice.<br>——————————————————————————————————————<br>题目大意：<br>就是现在一个N个节点，M条边的无向图，问你最少添加多少条边，能找到一个奇圈，添加的方法有多少个</p><p>解题思路：</p><p>判断奇圈偶圈，很容易想到二分图染色，那么通过二分图染色，就能确定很多信息了，</p><p>首先能确定的是最多也就添加3条边， 3条边就能将三个点变成一个奇圈了，</p><p>那么添加边就是要变成一个3个节点的奇圈</p><blockquote><p>那么就分这四种情况讨论</p></blockquote><blockquote></blockquote><blockquote><p>1.添加0条边<br>就是原图中有奇圈了， 通过染色判断，方案数就是1了<br>2.添加1条边<br>只需添加一条边的时候就是一个点a连向点b,c. 这时候将b,c连上就好了<br>这种情况需要在一侧的多个节点都能和另一边的节点直接或间接连上才行,<br>所以我用了一个并查集维护联通性,然后统计个数<br>3.添加2条边<br>如果一个节点至多被一条边连着,<br>那么想要构成奇圈,就要将边的两个端点连上另外的一个一个节点构成奇圈<br>方案数就是  m  ∗  (  n  −  2  )<br>4.添加3条边<br>只有一条边都没有的时候才要添加三条边,<br>方案数就是在n个点取3个节点的方案数</p></blockquote><p>分类讨论即可</p><p>附本题代码<br>——————————————————————————————————————</p><pre><code>#include &lt;bits/stdc++.h&gt;typedef long long int LL;using namespace std;const int N = 1e5+7;/************************************/int k,n,m;int pre[N];int findi(int x){    int r=x;    while(r!=pre[r])r=pre[r];    for(int i=x,j;r!=i;){        j=pre[i];        pre[i]=r;        i=j;    }    return r;}void join(int x,int y){    int fx=findi(x),fy=findi(y);    pre[fx]=fy;}vector&lt;int &gt;G[N];int col[N];//二分图染色  用来判断是不是二分图int color(int s){    queue&lt;int&gt;q;int ans =0 ;    q.push(s);col[s]=1;    while(!q.empty()){        int u = q.front();q.pop();        int gz=G[u].size();        for(int i=0,to;i&lt;gz;i++){            to=G[u][i];            if(col[to]==0){                col[to]=3-col[u];                q.push(to);            }            else if(col[to]==col[u])                ans++;        }    }    return ans&gt;&gt;1;}void init(){    for(int i=0;i&lt;=n;i++) G[i].clear(),col[i]=0,pre[i]=i;}void add(int u,int v){    G[u].push_back(v);    G[v].push_back(u); //无向图才需要}int x[N],y[N];int main(){    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);    init();    for(int i=1,u,v;i&lt;=m;i++){        scanf(&quot;%d%d&quot;,&amp;u,&amp;v);        add(u,v);join(u,v);    }    if(m==0) return 0*printf(&quot;3 %lld\n&quot;,(LL)n*(n-1)*(n-2)/6);    int flag=0;    for(int i=1;i&lt;=n;i++)        if(col[i]==0) flag+=color(i);    if(flag) return 0*puts(&quot;0 1&quot;);    LL ans = 0;    flag=0;    for(int i=1;i&lt;=n;i++){        if(G[i].size()&gt;1) flag=1;        if(col[i]==1)ans+=x[findi(i)]++;        else         ans+=y[findi(i)]++;    }    if(flag) printf(&quot;1 %lld\n&quot;,ans);    else     printf(&quot;2 %lld\n&quot;,(LL)m*(n-2));    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图论 </tag>
            
            <tag> 思维 </tag>
            
            <tag> codeforces </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  伸展树(SPLAY)个人总结+模板 [平衡树]【数据结构】【模板】</title>
      <link href="/2017/06/21/73549164/"/>
      <url>/2017/06/21/73549164/</url>
      
        <content type="html"><![CDATA[<h1 id="伸展树-SPLAY-个人总结-模板-平衡树-【数据结构】【模板】"><a href="#伸展树-SPLAY-个人总结-模板-平衡树-【数据结构】【模板】" class="headerlink" title="伸展树(SPLAY)个人总结+模板 [平衡树]【数据结构】【模板】"></a>伸展树(SPLAY)个人总结+模板 [平衡树]【数据结构】【模板】</h1><p>置顶  2017年06月21日 14:52:43  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a><br>阅读数：1311</p><hr><p> 博客爬取于<code>2019-04-18 17:15:08</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/73549164" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/73549164</a></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近3个月内，无论是现场赛还线上赛中SPLAY出现的概率大的惊人啊啊啊！！！<br>然而不会的我就GG了，同时发现大家都会SPLAY，，，，然后就学习了一波。</p><hr><p>开始怎么学都学不懂，直到看到一句话</p><blockquote><p>想学好splay,只要把伸展和旋转操作弄懂,就好了.<br>(而这两个想要学会就是需要自己画图自己理解了)</p></blockquote><p>于是茅塞顿开,有了本文,<br>本文重点是SPLAY维护序列的操作,而非SPLAY本身,这部分会说的比较粗略,二叉树的部分更不会有说明,</p><p><strong> 菜(sha3)逼我也只是初学,如果有描述不当甚至错误的地方,欢迎指正 </strong></p><hr><h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>伸展树（Splay Tree），也叫分裂树，是一种二叉排序树，它能在O(log n)内完成插入、查找和删除操作。</p><p>同其他平衡树一样,都是在二叉排序树的基础上进行操作的,但不同于AVL需要记录平衡信息,也没有红黑树实现上的难度.是一种综合考量下很适合应用于信息学竞赛的平衡<br>树.</p><p>对于一个基本的SPLAY 我这样定义</p><pre><code>int ch[N][2];  //ch[][0] 表示左儿子 ch[][1] 表示右儿子int f[N];      //节点的父亲节点int sz[N];     //当前节点给所在的子树的节点个数int val[N];    //当前节点表示的值int cnt[N];    //当前节点所表示的值的个数int root;      //记录根节点的int tot;       //计算树中节点个数</code></pre><p>构建的过程也就和普通二叉树一样了,递归下去即可</p><pre><code>void newnode(int rt,int v,int fa){    f[rt]=fa;    val[rt]=v;sz[rt]=1;    ch[rt][0]=ch[rt][1]=0;}void delnode(int rt){    f[rt]=sz[rt]=val[rt]=0;    ch[rt][0]=ch[rt][1]=0;}void build(int &amp;rt,int l,int r,int fa){    if(l&gt;r) return ;    int m = r+l &gt;&gt; 1;    rt=m; newnode(rt,val[rt],fa);cnt[rt]=1;    build(ch[rt][0],l,m-1,rt);    build(ch[rt][1],m+1,r,rt);    pushup(rt);}void init(int n){    root=0;    f[0]=sz[0]=ch[0][0]=ch[0][1]=rev[0]=0;    build(root,1,n,0);    pushup(root);}</code></pre><h1 id="旋转"><a href="#旋转" class="headerlink" title="旋转"></a>旋转</h1><p>对于一颗二叉排序树,根据序列的信息很容易找到某一个值,只要不断的向下搜索下去即可,复杂度是 <strong> O(树高) </strong> ,<br>但是二叉树最坏的情况下是会退化成一个单链的,这是后查找的复杂度就是 <strong> O(n) </strong> 了,非常不可取</p><p>而在SPLAY中控制树保持平衡需要的就是 <strong> 旋转操作 </strong> ,是树保持平衡,这样复杂度就变成了 <strong> 均摊 </strong> O  (  log  n  )  的了</p><h3 id="单旋-左旋-zag-amp-右旋-zig"><a href="#单旋-左旋-zag-amp-右旋-zig" class="headerlink" title="单旋: 左旋(zag)&amp;右旋(zig)"></a>单旋: 左旋(zag)&amp;右旋(zig)</h3><p><img src="http://dl2.iteye.com/upload/attachment/0019/1324/03e3d39d-3664-3341-9e1f-0c3eb3082bf3.jpg" alt></p><h3 id="双旋"><a href="#双旋" class="headerlink" title="双旋:"></a>双旋:</h3><p>通过树的旋转来自我调整来保持平衡,就是基于这两个操作 <strong> 左旋(zag)&amp;右旋(zig) </strong> ,还有其延伸出的操作<br><img src="http://www.myexception.cn/img/2015/08/12/094945901.png" alt><br><img src="http://www.myexception.cn/img/2015/08/12/094945902.png" alt></p><p>下面来实现下旋转操作</p><blockquote><p>总之就是对每次旋转节点间关系信息发生改变的位置调整好就行<br>需要点耐心,不要调错</p></blockquote><pre><code>void rotate(int x,int k){   // k = 0 左旋， k = 1 右旋    int y=f[x];int z=f[y];    pushdown(y),pushdown(x);    ch[y][!k]=ch[x][k];if(ch[x][k])f[ch[x][k]]=y;    f[x]=z;if(z)ch[z][ch[z][1]==y]=x;    f[y]=x;ch[x][k]=y;    pushup(y),pushup(x);}</code></pre><h1 id="伸展"><a href="#伸展" class="headerlink" title="伸展"></a>伸展</h1><p>经过多次旋转,将节点位置坐出调整的操作就是伸展了</p><p>来举个栗子，对于一个退化为单链的树进行旋转<br><img src="http://images2015.cnblogs.com/blog/1130316/201703/1130316-20170322210134174-1328823653.png" alt><br><img src="http://images2015.cnblogs.com/blog/1130316/201703/1130316-20170322210202830-1131794868.png" alt></p><p>双旋的写法，比较稳定</p><pre><code>void splay(int x,int goal){//将x旋转到goal的下面      while(f[x] != goal){          if(f[f[x]] == goal) rotate(x , ch[f[x]][0] == x);          else   {              int y=f[x],z=f[y];              int K = (ch[z][0]==y);              if(ch[y][K] == x) rotate(x,!K),rotate(x,K);              else rotate(y,K),rotate(x,K);          }      }      pushup(x);      if(goal==0) root=x;  }  </code></pre><p><del> 而我发现zig-zag这种两个旋转合在一起的操作,其实是两遍单旋,所以只要每次都向上单旋就行了, </del></p><pre><code>单旋容易被卡 不懂 百度伸展树单双旋的比较void splay(int x,int goal){  //将x调整为goal的儿子,(如果要调整到根goal就是0)    for(int y=f[x];f[x]!=goal;y=f[x])        rotate(x,(ch[y][0]==x)); //(ch[y][0]==x)计算是左旋还是右旋,看x是左右儿子哪一个区分开了    if(goal==0) root=x;}</code></pre><h1 id="各种操作"><a href="#各种操作" class="headerlink" title="各种操作"></a>各种操作</h1><blockquote><p><strong> 对于SPALY能够做到的操作以【BZOJ3224 普通平衡树】为引,以 【BZOJ 1895 &amp; POJ 3580 supermemo<br>】做补充,如果不完全,后期会补上 </strong></p></blockquote><h2 id="一些基本操作"><a href="#一些基本操作" class="headerlink" title="一些基本操作"></a>一些基本操作</h2><h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><blockquote><p>查找部分和普通的二叉查找树一模一样,只要遍历下去即可</p></blockquote><pre><code>int search(int rt,int x){        if(ch[rt][0]&amp;&amp;val[rt]&gt;x) return search(ch[rt][0],x);    else if(ch[rt][1]&amp;&amp;val[rt]&lt;x)return search(ch[rt][1],x);    else return rt;}</code></pre><h3 id="极值-amp-前驱-后继"><a href="#极值-amp-前驱-后继" class="headerlink" title="极值 &amp; 前驱,后继"></a>极值 &amp; 前驱,后继</h3><p>前驱:小于x的最大的数<br>后继:大于x的最小的数</p><blockquote><p>先找到x所在的节点,然后在左右子树,找最右左的节点即可</p></blockquote><pre><code>//以x为根的子树 的极值点  0 极小 1 极大int extreme(int x,int k){    while(ch[x][k])x=ch[x][k];splay(x,0);    return x;}</code></pre><h3 id="第K个数"><a href="#第K个数" class="headerlink" title="第K个数"></a>第K个数</h3><p>第k个数,通过记录的sz[],很容易得到每个节点是第几个,不断的在树上二分就行,</p><pre><code>//以x为根的子树 第k个数的位置int kth(int x,int k){    if(sz[ch[x][0]]+1==k&amp;&amp;k&lt;=sz[ch[x][0]]+cnt[x]) return x;    else if(sz[ch[x][0]]&gt;=k) return kth(ch[x][0],k);    else return kth(ch[x][1],k-sz[ch[x][0]]-cnt[x]);}</code></pre><h2 id="一些正经的操作"><a href="#一些正经的操作" class="headerlink" title="一些正经的操作"></a>一些正经的操作</h2><h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><blockquote><p>假如要插入的点已经存在了,那么cnt++就行了,<br>假如要插入的点在x<br>那么让x-1做为树根,x+1伸展到根节点下面,那么x+1的左儿子就是空出来的 加个值就好了</p></blockquote><pre><code>void _insert(int x){    int y=search(root,x),k=-1;    if(val[y]==x){        cnt[y]++;        sz[y]++;        for(int yy=y;yy;yy=f[yy]) pushup(yy);    }    else {        int p=prec(x),s=sufc(x);        splay(p,0);splay(s,p);        newnode(++tot,x,ch[root][1]);        ch[ch[root][1]][0]=tot;        for(int z=ch[root][1];z;z=f[z])pushup(z);    }    if(k==-1) splay(y,0);else splay(tot,0);}</code></pre><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><blockquote><p>和删除一样,就是反过来了而已,<br>首先这个值如果不存在,那就直接return即可<br>如果这个值大于1,那就cnt–即可<br>如果这个值所在的节点的儿子节点有空的,那么就把需要提上去的儿子节点提上去即可<br>如果这个值所在的节点的儿子节点都存在,那么就把这个节点的前驱提到根节点,后继提到根节点的下面,那样的话删除ch[ch[root][1]][0]就行了</p></blockquote><pre><code>void _delete(int x){    int y=search(root,x);    if(val[y]!=x) return;    if(cnt[y]&gt;1){        cnt[y]--;        sz[y]--;        for(int yy=y;yy;yy=f[yy]) pushup(yy);    }    else if(ch[y][0]==0||ch[y][1]==0){        int z=f[y];        ch[z][ch[z][1]==y]=ch[y][ch[y][0]==0];        f[ch[y][ch[y][0]==0]]=z;delnode(y);        for(int yy=z;yy;yy=f[yy]) pushup(yy);    }    else {        int p=prec(x),s=sufc(x);        splay(p,0);splay(s,p);        ch[ch[root][1]][0]=0;        delnode(ch[ch[root][1]][0]);        for(int yy=s;yy;yy=f[yy]) pushup(yy);    }}</code></pre><h3 id="区间加"><a href="#区间加" class="headerlink" title="区间加"></a>区间加</h3><blockquote><p>区间操作</p></blockquote><blockquote></blockquote><blockquote><p>对于区间[l,r]<br>那么让l-1做为树根,r+1伸展到根节点下面,那么r+1的左儿子就是这个区间<br>打上lazy_tag就行了</p></blockquote><blockquote></blockquote><blockquote><p>但为了更好的处理[1,n]这个区间 加上个0和n+1这两个节点</p></blockquote><pre><code>//区间加void add(int l,int r,int v){    int x=kth(root,l-1),y=kth(root,r+1);    splay(x,0);splay(y,x);    update_add(ch[y][0],v);}</code></pre><h3 id="区间翻转"><a href="#区间翻转" class="headerlink" title="区间翻转"></a>区间翻转</h3><blockquote><p>同样在一个二叉树中 翻转也就是让每个节点的两个儿子交换一下顺序就好了,, 打个标记 就行了,</p></blockquote><pre><code>//区间翻转void reversal(int l,int r){    int x=kth(root,l-1),y=kth(root,r+1);    splay(x,0);splay(y,x);    update_rev(ch[y][0]);}</code></pre><h3 id="区间交换"><a href="#区间交换" class="headerlink" title="区间交换"></a>区间交换</h3><blockquote><p>所以我们可以将后一个区间处理到一个子树上,然后放到l−1,l 这两个节点之间,就好了,先减掉,然后在加上去就好了</p></blockquote><pre><code>//区间交换void exchange(int l1,int r1,int l2,int r2){    int x=kth(root,l2-1),y=kth(root,r2+1);    splay(x,0),splay(y,x);    int tmp_right = ch[y][0]; ch[y][0]=0;    x=kth(root,l1-1),y=kth(root,l1);    splay(x,0),splay(y,x);    ch[y][0] = tmp_right;    f[tmp_right]=y;}</code></pre><h3 id="合并"><a href="#合并" class="headerlink" title="合并"></a>合并</h3><p>合并是指两颗SPLAY进行合并,<br>要求这两颗树没有交错的部分,(可能没有这个限制,但是我不会,)</p><p>首先处理好一个树A加入到B中,那么在B中腾出一个空节点来代替A树需要的段，然后把A树的树根放到呢个腾出的空节点位置就行了，</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>SPLAY操作非常灵活多变,一定要理解SPLAY然后去使用,不要只会套板子就结束了,</p><p>有几点特别要注意的地方<br>1.插入/删除节点的时候注意父节点要修改<br>2.sz[]维护不要出错<br>3. ……</p><h2 id="——————————————————————————"><a href="#——————————————————————————" class="headerlink" title="——————————————————————————-"></a>——————————————————————————-</h2><p>附上整体代码-md贴上来太卡了,去题解里看吧<br><strong> 注：这两个板子没有用双旋，用的单旋。。 </strong></p><p><a href="http://blog.csdn.net/qq_33184171/article/details/73518838" target="_blank" rel="noopener"> 维护序列的 </a><br><a href="http://blog.csdn.net/qq_33184171/article/details/70304674" target="_blank" rel="noopener"> 维护一堆数的 </a></p>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  BZOJ 1895 &amp; POJ 3580 supermemo [SPLAY]【数据结构】</title>
      <link href="/2017/06/20/73518838/"/>
      <url>/2017/06/20/73518838/</url>
      
        <content type="html"><![CDATA[<h1 id="BZOJ-1895-amp-POJ-3580-supermemo-SPLAY-【数据结构】"><a href="#BZOJ-1895-amp-POJ-3580-supermemo-SPLAY-【数据结构】" class="headerlink" title="BZOJ 1895 &amp; POJ 3580 supermemo [SPLAY]【数据结构】"></a>BZOJ 1895 &amp; POJ 3580 supermemo [SPLAY]【数据结构】</h1><p>2017年06月20日 20:43:37  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：497</p><p>个人分类：  <a href="https://blog.csdn.net/qq_33184171/article/category/6362428" target="_blank" rel="noopener"> ==== 数据结构 ====</a> <a href="https://blog.csdn.net/qq_33184171/article/category/6114215" target="_blank" rel="noopener"> POJ</a></p><hr><p> 博客爬取于<code>2019-04-18 17:16:04</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/73518838" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/73518838</a></p><p>题目链接： <a href="http://poj.org/problem?id=3580" target="_blank" rel="noopener"> http://poj.org/problem?id=3580 </a><br>——————————————————————————————————————————<br>SuperMemo<br>Time Limit: 5000MS Memory Limit: 65536K<br>Total Submissions: 15846 Accepted: 4992<br>Case Time Limit: 2000MS<br>Description</p><p>Your friend, Jackson is invited to a TV show called SuperMemo in which the<br>participant is told to play a memorizing game. At first, the host tells the<br>participant a sequence of numbers, {A1, A2, … An}. Then the host performs a<br>series of operations and queries on the sequence which consists:</p><p>ADD x y D: Add D to each number in sub-sequence {Ax … Ay}. For example,<br>performing “ADD 2 4 1” on {1, 2, 3, 4, 5} results in {1, 3, 4, 5, 5}<br>REVERSE x y: reverse the sub-sequence {Ax … Ay}. For example, performing<br>“REVERSE 2 4” on {1, 2, 3, 4, 5} results in {1, 4, 3, 2, 5}<br>REVOLVE x y T: rotate sub-sequence {Ax … Ay} T times. For example, performing<br>“REVOLVE 2 4 2” on {1, 2, 3, 4, 5} results in {1, 3, 4, 2, 5}<br>INSERT x P: insert P after Ax. For example, performing “INSERT 2 4” on {1, 2,<br>3, 4, 5} results in {1, 2, 4, 3, 4, 5}<br>DELETE x: delete Ax. For example, performing “DELETE 2” on {1, 2, 3, 4, 5}<br>results in {1, 3, 4, 5}<br>MIN x y: query the participant what is the minimum number in sub-sequence {Ax<br>… Ay}. For example, the correct answer to “MIN 2 4” on {1, 2, 3, 4, 5} is 2<br>To make the show more interesting, the participant is granted a chance to turn<br>to someone else that means when Jackson feels difficult in answering a query<br>he may call you for help. You task is to watch the TV show and write a program<br>giving the correct answer to each query in order to assist Jackson whenever he<br>calls.</p><p>Input</p><p>The first line contains n (n ≤ 100000).</p><p>The following n lines describe the sequence.</p><p>Then follows M (M ≤ 100000), the numbers of operations and queries.</p><p>The following M lines describe the operations and queries.</p><p>Output</p><p>For each “MIN” query, output the correct answer.</p><p>Sample Input</p><p>5<br>1<br>2<br>3<br>4<br>5<br>2<br>ADD 2 4 1<br>MIN 4 5<br>Sample Output</p><p>5</p><p>——————————————————————————————————————————</p><p>题意：<br>给出一个数字序列，有6种操作：</p><p>（1） ADD x y d： 第x个数到第y个数加d 。</p><p>（2） REVERSE x y ： 将区间[x,y]中的数翻转 。</p><p>（3） REVOLVE x y t ：将区间[x,y]旋转t次，如1 2 3 4 5 旋转2次后就变成4 5 1 2 3 。</p><p>（4） INSERT x p ：在第x个数后面插入p 。</p><p>（5）DELETE x ：删除第x个数 。</p><p>（6） MIN x y ： 查询区间[x,y]中的最小值 。</p><hr><p>本来不想写来着 但想到 好多天没有更新博客了，加上这题还是挺好玩儿的，还是应该更新一波吧。</p><p>就是区间加，翻转，剪切，询问最值。点插入，删除。这几个操作</p><p>有翻转了 所以用SPLAY来维护一下</p><p>区间加 区间最小值就不说了 和普通的二叉搜索树一模一样.</p><p><strong> 点插入 删除 </strong></p><blockquote><p>假如要插入的点在x<br>那么让x-1做为树根,x+1伸展到根节点下面,那么x+1的左儿子就是空出来的 加个值就好了<br>删除发过来一样的</p></blockquote><p><strong> 区间操作 </strong></p><blockquote><p>对于区间[l,r]<br>那么让l-1做为树根,r+1伸展到根节点下面,那么r+1的左儿子就是这个区间</p></blockquote><blockquote></blockquote><blockquote><p>但为了更好的处理[1,n]这个区间 加上个0和n+1这两个节点</p></blockquote><p><strong> 翻转 </strong></p><blockquote><p>同样在一个二叉树中 翻转也就是让每个节点的两个儿子交换一下顺序就好了,, 打个标记 就行了,</p></blockquote><p><strong> 旋转 </strong></p><blockquote><p>其实旋转说白了就是将这个区间分成两段然后交换一下子,</p></blockquote><blockquote></blockquote><blockquote><p>所以我们可以将后一个区间处理到一个子树上,然后放到  l  −  1  ,  l  这两个节点之间,就好了,先减掉,然后在加上去就好了</p></blockquote><p><strong> 注: 个人的SPLAY模板正在建设,这个的代码比较杂乱,见谅. </strong></p><p>附本题代码<br>——————————————————————————————————————————</p><pre><code>//#include &lt;bits/stdc++.h&gt;#include &lt;stdio.h&gt;typedef long long int LL;const int N = 200000+7;inline int read(){    int x=0,f=1;char ch=getchar();    for(;ch&lt;&#39;0&#39;||&#39;9&#39;&lt;ch;ch=getchar())   if(ch==&#39;-&#39;)f=-1;    for(;&#39;0&#39;&lt;=ch&amp;&amp;ch&lt;=&#39;9&#39;;ch=getchar()) x=(x&lt;&lt;3)+(x&lt;&lt;1)+ch-&#39;0&#39;;    return x*f;}/*******************************************************//*************SPLAY-tree************/int n,m;int ch[N][2];  //ch[][0] lson ch[][1] rsonint f[N];      //fatherint sz[N];     //sizeint val[N];    //value of node_iint lazy[N];   //lazy-tagint mi[N];     //min of son-tree : root of iint rev[N];    //tag of revearint root;      //root of splay-treeint tot;       //tot,total,is the number of node of treevoid myswap(int &amp;x,int &amp;y){    x^=y,y^=x,x^=y;}int min(int x,int y){    return (x&lt;y)?x:y;}void update_rev(int x){    if(!x) return ;    myswap(ch[x][0],ch[x][1]);    rev[x]^=1;}void update_add(int x,int v){    if(x) lazy[x]+=v,val[x]+=v,mi[x]+=v;}void pushdown(int x){    if(!x) return ;    if(lazy[x]){        update_add(ch[x][0],lazy[x]);        update_add(ch[x][1],lazy[x]);        lazy[x]=0;    }    if(rev[x]){        update_rev(ch[x][0]);        update_rev(ch[x][1]);        rev[x]=0;    }}void pushup(int x){    if(!x)return ;    sz[x]=1,mi[x]=val[x];    if(ch[x][0])sz[x]+=sz[ch[x][0]],mi[x]=min(mi[x],mi[ch[x][0]]);    if(ch[x][1])sz[x]+=sz[ch[x][1]],mi[x]=min(mi[x],mi[ch[x][1]]);}void rotate(int x,int k){   // k = 0 左旋， k = 1 右旋    int y=f[x];int z=f[y];    pushdown(y),pushdown(x);    ch[y][!k]=ch[x][k];if(ch[x][k])f[ch[x][k]]=y;    f[x]=z;if(z)ch[z][ch[z][1]==y]=x;    f[y]=x;ch[x][k]=y;    pushup(y),pushup(x);}/***这样的SPLAY 不好么？ 相比分6种旋转的 zig-zag*/void splay(int x,int goal){    for(int y=f[x];f[x]!=goal;y=f[x])        rotate(x,(ch[y][0]==x));    if(goal==0) root=x;}void newnode(int rt,int v,int fa){//    printf(&quot;%d &lt;---\n&quot;,rt);    f[rt]=fa;    mi[rt]=val[rt]=v;sz[rt]=1;    ch[rt][0]=ch[rt][1]=rev[rt]=lazy[rt]=0;}void delnode(int rt){    f[rt]=mi[rt]=val[rt]=sz[rt]=0;    ch[rt][0]=ch[rt][1]=rev[rt]=lazy[rt]=0;}void build(int &amp;rt,int l,int r,int fa){    if(l&gt;r) return ;    int m = r+l &gt;&gt; 1;    rt=m; newnode(rt,val[rt],fa);    build(ch[rt][0],l,m-1,rt);    build(ch[rt][1],m+1,r,rt);    pushup(rt);}void init(int n){    root=0;    f[0]=sz[0]=ch[0][0]=ch[0][1]=rev[0]=0;    build(root,1,n,0);    pushup(root);}/***************************以下是DEBUG***************************/void Traversal(int rt){    if(!rt) return;    pushdown(ch[rt][0]);Traversal(ch[rt][0]);    printf(&quot;%d f[]=%d sz[]=%d lson=%d rson=%d val[]=%d mi[]=%d \n&quot;,rt,f[rt],sz[rt],ch[rt][0],ch[rt][1],val[rt],mi[rt]);    pushdown(ch[rt][1]);Traversal(ch[rt][1]);    pushup(rt);}void debug(){    printf(&quot;ROOT = %d &lt;---\n&quot;,root);    pushdown(root);    Traversal(root);}/**************************以下是前置操作**************************///以x为根的子树 的最左节点int x_left(int x){    for(pushdown(x);ch[x][0];pushdown(x)) x=ch[x][0];    return x;}//以x为根的子树 的最右节点int x_right(int x){    for(pushdown(x);ch[x][1];pushdown(x)) x=ch[x][1];    return x;}//以x为根的子树 第k个数的位置int kth(int x,int k){    pushdown(x);    if(sz[ch[x][0]]+1 == k) return x;    else if(sz[ch[x][0]]&gt;=k) return kth(ch[x][0],k);    else return kth(ch[x][1],k-sz[ch[x][0]]-1);}/***************************以下是正经操作**************************//***    如果有区间为[1,n]情况不好处理，    所以我们可以 多添加一个head，一个tail    这样的话区间[1,n]就是tail的左儿子了,*///区间交换void exchange(int l1,int r1,int l2,int r2){    int x=kth(root,l2-1),y=kth(root,r2+1);    splay(x,0),splay(y,x);    int tmp_right = ch[y][0]; ch[y][0]=0;    x=kth(root,l1-1),y=kth(root,l1);    splay(x,0),splay(y,x);    ch[y][0] = tmp_right;    f[tmp_right]=y;}//区间翻转void reversal(int l,int r){    int x=kth(root,l-1),y=kth(root,r+1);    splay(x,0);splay(y,x);    update_rev(ch[y][0]);}//区间加void add(int l,int r,int v){    int x=kth(root,l-1),y=kth(root,r+1);    splay(x,0);splay(y,x);    update_add(ch[y][0],v);}//按照二叉排序树性质插入xvoid _insert(int x){    /**    其实我们也可以 将插入后临街的两个节点 a x b    将a伸展到根 b伸展到 根下    那么b的左儿子一定没有，插进去就行了，    */}//在第k个数后插入值为x的节点void _insert(int k,int x){    int r=kth(root,k),rr=kth(root,k+1);    splay(r,0),splay(rr,r);//    puts(&quot;begin insert &lt;-------------------&quot;);//    printf(&quot;%d %d %d\n&quot;,r,rr,tot);//    debug();//    puts(&quot;end   insert &lt;-------------------&quot;);    newnode(++tot,x,rr);ch[rr][0]=tot;    for(r=rr;r;r=f[r])pushdown(r),pushup(r);    splay(rr,0);}//删除第k个数void _delete(int k){    splay(kth(root,k-1),0);    splay(kth(root,k+1),root);    delnode(ch[ch[root][1]][0]);    ch[ch[root][1]][0]=0;    pushup(ch[root][1]);    pushup(root);}//int get_max(int l,int r){//    int x=kth(root,l-1),y=kth(root,r+1);//    splay(x,0);splay(y,x);//    return mx[ch[y][0]];//}int get_min(int l,int r){    int x=kth(root,l-1),y=kth(root,r+1);    splay(x,0);splay(y,x);    return mi[ch[y][0]];}/*****************************************************/char s[12];int main(){    scanf(&quot;%d&quot;,&amp;n);    val[1]=val[n+2]=1000000000;    for(int i=1+1;i&lt;=n+1;i++) val[i]=read();    tot=n+2;init(n+2);    scanf(&quot;%d&quot;,&amp;m);    for(int i=1,d,l,r,v;i&lt;=m;i++){        scanf(&quot;%s&quot;,s);        if(s[0]==&#39;A&#39;){ //ADD            scanf(&quot;%d%d%d&quot;,&amp;l,&amp;r,&amp;d);            add(l+1,r+1,d);        }        else if(s[0]==&#39;I&#39;){ //INSERT            scanf(&quot;%d%d&quot;,&amp;l,&amp;d);            _insert(l+1,d);        }        else if(s[0]==&#39;M&#39;){ //MIN            scanf(&quot;%d%d&quot;,&amp;l,&amp;r);            printf(&quot;%d\n&quot;,get_min(l+1,r+1));        }        else if(s[0]==&#39;D&#39;){ //DELETE            scanf(&quot;%d&quot;,&amp;l);            _delete(l+1);        }        else if(s[3]==&#39;E&#39;){ //REVERSE            scanf(&quot;%d%d&quot;,&amp;l,&amp;r);            reversal(l+1,r+1);        }        else { //REVOLVE            scanf(&quot;%d%d%d&quot;,&amp;l,&amp;r,&amp;d);            d=(d%(r-l+1)+r-l+1)%(r-l+1);            if(d) exchange(l +1,r-d +1,r-d+1 +1,r +1);        }//            debug();    }//        debug();    return 0;}/****51 2 3 4 56ADD 1 3 1INSERT 3 3DELETE 4MIN 1 5MIN 2 5REVOLVE 1 5 2101 2 3 4 5 6 7 8 9 1015ADD 4 8 3MIN 5 7MIN 7 10REVERSE 2 5MIN 2 6MIN 2 3INSERT 3 4MIN 3 4MIN 5 10DELETE 6MIN 3 5MIN 4 4REVOLVE 3 6 7MIN 5 8MIN 7 10//*/</code></pre>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> POJ </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  51nod 1296 有限制的排列 【动态规划】</title>
      <link href="/2017/06/14/73246276/"/>
      <url>/2017/06/14/73246276/</url>
      
        <content type="html"><![CDATA[<h1 id="51nod-1296-有限制的排列-【动态规划】"><a href="#51nod-1296-有限制的排列-【动态规划】" class="headerlink" title="51nod 1296 有限制的排列 【动态规划】"></a>51nod 1296 有限制的排列 【动态规划】</h1><p>2017年06月14日 16:21:10  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：250</p><hr><p> 博客爬取于<code>2019-04-18 17:16:05</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/73246276" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/73246276</a></p><p>题目链接： <a href="http://www.51nod.com/onlineJudge/questionCode.html#!problemId=1296" target="_blank" rel="noopener"> http://www.51nod.com/onlineJudge/questionCode.html#!problemId=1296</a><br>———————————————————————————————————————————<br>1296 有限制的排列<br>题目来源： HackerRank<br>基准时间限制：1 秒 空间限制：131072 KB 分值: 80 难度：5级算法题 收藏 关注<br>计算整数集合{1,2,3,4, …. N }满足下列条件的的排列个数:</p><p>在位置a1, a2, …, aK小于其邻居（编号从0开始）。<br>在位置b1, b2, …, bL大于其邻居。</p><p>输出符合条件的排列数量Mod 1000000007的结果。例如：N = 4，a = {1}, b = {2}，符合条件的排列为：</p><p>2 1 4 3<br>3 2 4 1<br>4 2 3 1<br>3 1 4 2<br>4 1 3 2<br>Input<br>第1行：3个数N, K, L，分别表示数组的长度，限制a的长度，限制b的长度(1 &lt;= N &lt;= 5000, 1 &lt;= K, L &lt;= N)。<br>第2 - K + 1行：每行一个数，对应限制a的位置(1 &lt;= ai &lt;= N - 2)<br>第K + 2 - K + L + 1行：每行一个数，对应限制b的位置(1 &lt;= bi &lt;= N - 2)<br>Output<br>输出符合条件的排列数量Mod 1000000007的结果。<br>Input示例<br>4 1 1<br>1<br>2<br>Output示例<br>5<br>———————————————————————————————————————————</p><p>解题思路:</p><p>首先要知道的是排列的生成,,<br>对于一个长度为x的排列,在x+1的位置插入一个元素a,那么就是将原排列中所有大于等于a的数加1，</p><p>对于本题来说，看到N的范围就知道是个O(n^2)的dp， <del> 但是dp废，，， </del></p><p>首先对每个位置标上状态,state[i]代表第i个位置和前一个位置的大小关系,</p><p>还是设dp[i][j]为第i个位置放j的情况数,</p><p>那么根据状态的不同转移,  </p><p>d  p  [  i  ]  [  j  ]  =  ∑  a  =  1  i  −  1  d  p  [  i  −  1  ]  [  a  ]<br>,  (  s  t  a  t  e  [  i  ]  =  =  0  )  d  p  [  i  ]  [  j  ]  =  ∑  a  =<br>i  −  1  j  −  1  d  p  [  i  −  1  ]  [  a  ]  ,  (  s  t  a  t  e  [  i  ]<br>=  =  1  )  d  p  [  i  ]  [  j  ]  =  ∑  a  =  1  j  −  1  d  p  [  i  −  1<br>]  [  a  ]  ,  (  s  t  a  t  e  [  i  ]  =  =  2  )</p><p>对于求和的过程用一个前缀和优化一下复杂度就能降一维,然后就会发现,转移所需要的信息就是前缀和的信息,所以dp数组也只需要一维就好了,</p><p>附本题代码<br>————————————————————————————————————————————</p><pre><code>int N,K,L;int state[5555];int sum[5555];int dp[5555];int main(){    scanf(&quot;%d%d%d&quot;, &amp;N, &amp;K, &amp;L);    int a;    for (int i=0;i&lt;K;i++){        scanf(&quot;%d&quot;,&amp;a);        state[++a]=1;        state[a+1]=2;    }    for (int i=0;i&lt;L;i++){        scanf(&quot;%d&quot;,&amp;a);        state[++a]=2;        state[a+1]=1;    }    sum[0]=0;    dp[1]=sum[1]=1;    for(int i=2;i&lt;=N;i++){        for(int j=1;j&lt;=i;j++){            if(state[i]==0) dp[j]=sum[i-1];            if(state[i]==1) dp[j]=((sum[i-1]-sum[j-1])%MOD+MOD)%MOD;            if(state[i]==2) dp[j]=sum[j-1];        }        for(int j=1;j&lt;=N;j++) sum[j]=(sum[j-1]+dp[j])%MOD;    }    printf(&quot;%d\n&quot;,sum[N]);    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  51nod 1076 2条不相交的路径 [双联通]【图论】</title>
      <link href="/2017/06/09/72971158/"/>
      <url>/2017/06/09/72971158/</url>
      
        <content type="html"><![CDATA[<h1 id="51nod-1076-2条不相交的路径-双联通-【图论】"><a href="#51nod-1076-2条不相交的路径-双联通-【图论】" class="headerlink" title="51nod 1076 2条不相交的路径 [双联通]【图论】"></a>51nod 1076 2条不相交的路径 [双联通]【图论】</h1><p>2017年06月09日 20:47:42  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：309<br>标签：  <a href="https://so.csdn.net/so/search/s.do?q=算法&amp;t=blog" target="_blank" rel="noopener"> 算法 </a> <a href="https://so.csdn.net/so/search/s.do?q=联通&amp;t=blog" target="_blank" rel="noopener"> 联通</a></p><p>个人分类：  <a href="https://blog.csdn.net/qq_33184171/article/category/6676637" target="_blank" rel="noopener"> 51nod </a> <a href="https://blog.csdn.net/qq_33184171/article/category/6188704" target="_blank" rel="noopener"><br>===== 图论 ===== </a></p><hr><p> 博客爬取于<code>2019-04-18 17:16:06</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/72971158" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/72971158</a></p><p>题目链接: <a href="http://www.51nod.com/onlineJudge/questionCode.html#!problemId=1076" target="_blank" rel="noopener"> http://www.51nod.com/onlineJudge/questionCode.html#!problemId=1076</a><br>———————————————————————————————————————————<br>1076 2条不相交的路径<br>基准时间限制：1 秒 空间限制：131072 KB 分值: 40 难度：4级算法题<br>给出一个无向图G的顶点V和边E。进行Q次查询，查询从G的某个顶点V[s]到另一个顶点V[t]，是否存在2条不相交的路径。（两条路径不经过相同的边）<br>（注，无向图中不存在重边，也就是说确定起点和终点，他们之间最多只有1条路）<br>Input<br>第1行：2个数M N，中间用空格分开，M是顶点的数量，N是边的数量。（2 &lt;= M &lt;= 25000, 1 &lt;= N &lt;= 50000)<br>第2 - N + 1行，每行2个数，中间用空格分隔，分别是N条边的起点和终点的编号。例如2<br>4表示起点为2，终点为4，由于是无向图，所以从4到2也是可行的路径。<br>第N + 2行，一个数Q，表示后面将进行Q次查询。(1 &lt;= Q &lt;= 50000)<br>第N + 3 - N + 2 + Q行，每行2个数s, t，中间用空格分隔，表示查询的起点和终点。<br>Output<br>共Q行，如果从s到t存在2条不相交的路径则输出Yes，否则输出No。<br>Input示例<br>4 4<br>1 2<br>2 3<br>1 3<br>1 4<br>5<br>1 2<br>2 3<br>3 1<br>2 4<br>1 4<br>Output示例<br>Yes<br>Yes<br>Yes<br>No<br>No<br>———————————————————————————————————————————</p><p>题目问的是 两个点有没有两条不想交的路径,其实就是这两个节点在不在同一个双联通分量里面 如果在就是 否则不是</p><p>所以最后就是求双联通了,</p><p>双联通用tarjan即可,其实和强连通类似,</p><p>只不过对与low 要与所有的儿子进行比较,剩下的就和强连通一模一样了,其实就是一回事儿</p><p>附本题代码<br>———————————————————————————————————————————</p><pre><code>#include&lt;bits/stdc++.h&gt;typedef long long int LL;using namespace std;const int N   = 25000+7;const int MOD = 1e9+7;const int INF = (~(1&lt;&lt;31))&gt;&gt;1;#define abs(x) ((x)&gt;0?(x):-(x))/****************************************************/vector&lt;int&gt;G[N];int dfn[N],low[N],vis[N],color[N],cnt,tot;int mystack[N],len;void tarjan(int u,int f){    dfn[u]=low[u]=++cnt;    vis[u]=1;mystack[++len]=u;    int gz=G[u].size();    for(int i=0,to;i&lt;gz;i++){        to=G[u][i];        if(to==f) continue;        if(vis[to]==0)tarjan(to,u);        low[u]=min(low[u],low[to]);    }    if(low[u]==dfn[u]){        ++tot;        do{            color[mystack[len]]=tot;            vis[mystack[len]]=2;        }while(mystack[len--]!=u);    }}int n,m;int main(){    tot=cnt=len=0;    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);    for(int i=1,u,v;i&lt;=m;i++){        scanf(&quot;%d%d&quot;,&amp;u,&amp;v);        G[u].push_back(v);        G[v].push_back(u);    }    for(int i=1;i&lt;=n;i++) if(vis[i]==0) tarjan(i,0);//    for(int i=1;i&lt;=n;i++)printf(&quot;%d &quot;,color[i]);puts(&quot;&quot;);    int q,u,v;scanf(&quot;%d&quot;,&amp;q);    while(q--){        scanf(&quot;%d%d&quot;,&amp;u,&amp;v);        if(color[u]==color[v])            puts(&quot;Yes&quot;);        else puts(&quot;No&quot;);    }    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图论 </tag>
            
            <tag> 算法 </tag>
            
            <tag> 联通 </tag>
            
            <tag> 51nod </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  HDU 5934 Bomb [强连通+点基]【图论】</title>
      <link href="/2017/06/09/72956798/"/>
      <url>/2017/06/09/72956798/</url>
      
        <content type="html"><![CDATA[<h1 id="HDU-5934-Bomb-强连通-点基-【图论】"><a href="#HDU-5934-Bomb-强连通-点基-【图论】" class="headerlink" title="HDU 5934 Bomb [强连通+点基]【图论】"></a>HDU 5934 Bomb [强连通+点基]【图论】</h1><p>2017年06月09日 13:48:43  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：252</p><hr><p> 博客爬取于<code>2019-04-18 17:16:07</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/72956798" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/72956798</a></p><p>题目链接： <a href="http://acm.hdu.edu.cn/showproblem.php?pid=5934" target="_blank" rel="noopener"> http://acm.hdu.edu.cn/showproblem.php?pid=5934</a><br>————————————————————————————————————————<br>Bomb</p><p>Time Limit: 2000/1000 MS (Java/Others) Memory Limit: 65536/32768 K<br>(Java/Others)<br>Total Submission(s): 1160 Accepted Submission(s): 392</p><p>Problem Description<br>There are N bombs needing exploding.</p><p>Each bomb has three attributes: exploding radius ri, position (xi,yi) and<br>lighting-cost ci which means you need to pay ci cost making it explode.</p><p>If a un-lighting bomb is in or on the border the exploding area of another<br>exploding one, the un-lighting bomb also will explode.</p><p>Now you know the attributes of all bombs, please use the minimum cost to<br>explode all bombs.</p><p>Input<br>First line contains an integer T, which indicates the number of test cases.</p><p>Every test case begins with an integers N, which indicates the numbers of<br>bombs.</p><p>In the following N lines, the ith line contains four intergers xi, yi, ri and<br>ci, indicating the coordinate of ith bomb is (xi,yi), exploding radius is ri<br>and lighting-cost is ci.</p><p>Limits<br>- 1≤T≤20<br>- 1≤N≤1000<br>- −108≤xi,yi,ri≤108<br>- 1≤ci≤104</p><p>Output<br>For every test case, you should output ‘Case #x: y’, where x indicates the<br>case number and counts from 1 and y is the minimum cost.</p><p>Sample Input<br>1<br>5<br>0 0 1 5<br>1 1 1 6<br>0 1 1 7<br>3 0 2 10<br>5 0 1 4</p><p>Sample Output<br>Case #1: 15</p><p>Source<br>2016年中国大学生程序设计竞赛（杭州）</p><p>————————————————————————————————————————<br>题目大意：<br>在一个直角坐标系上给你n个炸弹，这些炸弹可以被点燃引爆，或者被其他炸弹给连带。 点燃每个炸弹有一个花费，问引爆所有炸弹最少需要多少个。</p><p>解题思路：<br>首先根据能不能被连带引爆的关系建立有向图。</p><p>然后发现，只要有入度就一定能被其他节点引爆，没有入度就必须被点燃。</p><p>那么就将没有入度的点点燃加起来即可，</p><p>但是注意可能出现这样的情况，如果成环了， 那么一定要选择一个点，</p><p>所以我们可以缩点，然后新点的花费就是所有节点的花费中最小的。</p><p>缩点后后再统计没有入度花费总和即可</p><p>附本题代码<br>————————————————————————————————————————</p><pre><code>#include&lt;bits/stdc++.h&gt;typedef long long int LL;using namespace std;const int N   = 2333+7;const int MOD = 1e9+7;const int INF = (~(1&lt;&lt;31))&gt;&gt;1;#define abs(x) ((x)&gt;0?(x):-(x))/****************************************************/int x[N],y[N],r[N],c[N];int dfn[N],low[N],color[N];int vis[N],cnt,tot;int cost[N],deg[N];int mystack[N],len;vector&lt;int&gt;G[N];void dfs(int u){    dfn[u]=low[u]=++cnt;    vis[u]=1;    mystack[++len]=u;    int gz=G[u].size();    for(int i=0,to;i&lt;gz;i++){        to=G[u][i];        if(vis[to]==0)dfs(to);        if(vis[to]==1)low[u]=min(low[u],low[to]);    }    if(dfn[u]==low[u]){        ++tot;        do{            cost[tot]=min(cost[tot],c[mystack[len]]);            color[mystack[len]]=tot;            vis[mystack[len]]=2;        }while(mystack[len--]!=u);    }}LL dis(LL x){return x*x;}bool judge(int i,int j){    return dis(x[i]-x[j])+dis(y[i]-y[j])&lt;=dis(r[i]);}int n;int main(){    int _,kcase=0;scanf(&quot;%d&quot;,&amp;_);    while(_--){        tot=cnt=len=0;        scanf(&quot;%d&quot;,&amp;n);        for(int i=1;i&lt;=n;i++) scanf(&quot;%d%d%d%d&quot;,&amp;x[i],&amp;y[i],&amp;r[i],&amp;c[i]);        for(int i=1;i&lt;=n;i++){cost[i]=INF,deg[i]=vis[i]=0;            for(int j=1;j&lt;=n;j++){                if(i==j) continue;                if(judge(i,j))G[i].push_back(j);            }        }        for(int i=1;i&lt;=n;i++) if(vis[i]==0) dfs(i);        for(int i=1;i&lt;=n;i++){            int gz=G[i].size();            for(int j=0,to;j&lt;gz;j++){                to=G[i][j];                if(color[i]!=color[to])                    deg[color[to]]++;            }        }        int ans=0;        for(int i=1;i&lt;=tot;i++)            if(deg[i]==0) ans+=cost[i];        printf(&quot;Case #%d: %d\n&quot;,++kcase,ans);        for(int i=1;i&lt;=n;i++) G[i].clear();    }    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  计蒜之道 2016复赛A 百度地图的实时路况 [floyd+分治]【图论】</title>
      <link href="/2017/06/09/72953925/"/>
      <url>/2017/06/09/72953925/</url>
      
        <content type="html"><![CDATA[<h1 id="计蒜之道-2016复赛A-百度地图的实时路况-floyd-分治-【图论】"><a href="#计蒜之道-2016复赛A-百度地图的实时路况-floyd-分治-【图论】" class="headerlink" title="计蒜之道 2016复赛A 百度地图的实时路况 [floyd+分治]【图论】"></a>计蒜之道 2016复赛A 百度地图的实时路况 [floyd+分治]【图论】</h1><p>2017年06月09日 09:58:13  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：358</p><hr><p> 博客爬取于<code>2019-04-18 17:16:08</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/72953925" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/72953925</a></p><p>题目链接： <a href="https://nanti.jisuanke.com/t/11217" target="_blank" rel="noopener"> https://nanti.jisuanke.com/t/11217</a><br>——————————————————————————————————————————</p><p>百度地图的实时路况功能相当强大，能方便出行的人们避开拥堵路段。一个地区的交通便捷程度就决定了该地区的拥堵情况。假设一个地区有 nn 个观测点，编号从 11<br>到 nn。定义 d(u,v,w)d(u,v,w) 为从 uu 号点出发，严格不经过 vv 号点，最终到达 ww<br>号点的最短路径长度，如果不存在这样的路径，d(u,v,w)d(u,v,w) 的值为 -1−1。</p><p>那么这个地区的交通便捷程度 PP 为：</p><p>P  =  ∑  1  ≤  x  ,  y  ,  z  ≤  n  ,  x  ≠  y  ,  y  ≠  z  d  (  x  ,  y  ,<br>z  )</p><p>现在我们知道了该地区的 nn 个点，以及若干条有向边，求该地区的交通便捷程度 PP。</p><p>输入格式</p><p>第一行输入一个正整数  n  (  4  ≤  n  ≤  300  )  ，表示该地区的点数。</p><p>接下来输入 n 行，每行输入 n 个整数。第 i行第 j 个数  G  i  ,  j  (  −  1  ≤  G  i  ,  j  ≤  10000<br>;  G  i  ,  i  =  0  )  表示从 i 号点到 j 号的有向路径长度。如果这个数为 −1，则表示不存在从 ii 号点出发到 jj<br>号点的路径。</p><p>输出格式</p><p>输出一个整数，表示这个地区的交通便捷程度。</p><p>样例输入</p><p>4<br>0 1 -1 -1<br>-1 0 1 -1<br>-1 -1 0 1<br>1 -1 -1 0<br>样例输出</p><p>4<br>——————————————————————————————————————————</p><p>正常做法是枚举每个点之后对其他点进行floyd，这样的话复杂度是  O  (  n  4  )  显然会TLE</p><p>然后想有没有其他优秀的图论东西能够快速的解决，发现没有，</p><p>最后我们采取的是分治的思路；</p><p>每次分为两段递归分治下去，将另一半所在的点给其他点进行松弛，也就是floyd的过程</p><p>然后这题的总复杂度度就能在  O  (  n  3  log  n  )  的时间复杂下解决了</p><p>附本题代码<br>——————————————————————————————————————————</p><pre><code>#include&lt;bits/stdc++.h&gt;typedef long long int LL;using namespace std;const int N   = 333+7;const int MOD = 1e9+7;const int INF = (~(1&lt;&lt;31))&gt;&gt;1;#define abs(x) ((x)&gt;0?(x):-(x))/****************************************************/int n;int m[N][N];int dp[20][N][N];LL ans;void solve(int d,int l,int r){    if(l==r){        for(int i=1;i&lt;=n;i++)            for(int j=1;j&lt;=n;j++)if(j!=l&amp;&amp;i!=l)                if(dp[d][i][j]==INF) ans+=-1;                else                 ans+=dp[d][i][j];        return ;    }    int m = r+l &gt;&gt; 1;    for(int i=1;i&lt;=n;i++)        for(int j=1;j&lt;=n;j++)            dp[d+1][i][j]=dp[d][i][j];    for(int k=m+1;k&lt;=r;k++)        for(int i=1;i&lt;=n;i++)            for(int j=1;j&lt;=n;j++)                if(dp[d+1][i][j]&gt;dp[d+1][i][k]+dp[d+1][k][j])                    dp[d+1][i][j]=dp[d+1][i][k]+dp[d+1][k][j];    solve(d+1,l,m);    for(int i=1;i&lt;=n;i++)        for(int j=1;j&lt;=n;j++)            dp[d+1][i][j]=dp[d][i][j];    for(int k=l;k&lt;=m;k++)        for(int i=1;i&lt;=n;i++)            for(int j=1;j&lt;=n;j++)                if(dp[d+1][i][j]&gt;dp[d+1][i][k]+dp[d+1][k][j])                    dp[d+1][i][j]=dp[d+1][i][k]+dp[d+1][k][j];    solve(d+1,m+1,r);}int main(){    scanf(&quot;%d&quot;,&amp;n);ans=0;    for(int i=1;i&lt;=n;i++){        for(int j=1;j&lt;=n;j++){            scanf(&quot;%d&quot;,&amp;dp[1][i][j]);            if(dp[1][i][j]==-1) dp[1][i][j]=INF;        }    }    solve(1,1,n);    printf(&quot;%lld\n&quot;,ans);    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  POJ 3460 Father Christmas flymouse [强连通缩点+最长路]【图论】</title>
      <link href="/2017/06/08/72934503/"/>
      <url>/2017/06/08/72934503/</url>
      
        <content type="html"><![CDATA[<h1 id="POJ-3460-Father-Christmas-flymouse-强连通缩点-最长路-【图论】"><a href="#POJ-3460-Father-Christmas-flymouse-强连通缩点-最长路-【图论】" class="headerlink" title="POJ 3460 Father Christmas flymouse [强连通缩点+最长路]【图论】"></a>POJ 3460 Father Christmas flymouse [强连通缩点+最长路]【图论】</h1><p>2017年06月08日 20:15:31  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：177</p><p>个人分类：  <a href="https://blog.csdn.net/qq_33184171/article/category/6114215" target="_blank" rel="noopener"> POJ </a> <a href="https://blog.csdn.net/qq_33184171/article/category/6188704" target="_blank" rel="noopener"><br>===== 图论 ===== </a></p><hr><p> 博客爬取于<code>2019-04-18 17:16:09</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/72934503" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/72934503</a></p><p>题目链接： <a href="http://poj.org/problem?id=3160" target="_blank" rel="noopener"> http://poj.org/problem?id=3160 </a><br>————————————————————————————————————————<br>Father Christmas flymouse<br>Time Limit: 1000MS Memory Limit: 131072K<br>Total Submissions: 3483 Accepted: 1187<br>Description</p><p>After retirement as contestant from WHU ACM Team, flymouse volunteered to do<br>the odds and ends such as cleaning out the computer lab for training as<br>extension of his contribution to the team. When Christmas came, flymouse<br>played Father Christmas to give gifts to the team members. The team members<br>lived in distinct rooms in different buildings on the campus. To save vigor,<br>flymouse decided to choose only one of those rooms as the place to start his<br>journey and follow directed paths to visit one room after another and give out<br>gifts en passant until he could reach no more unvisited rooms.</p><p>During the days on the team, flymouse left different impressions on his<br>teammates at the time. Some of them, like LiZhiXu, with whom flymouse shared a<br>lot of candies, would surely sing flymouse’s deeds of generosity, while the<br>others, like snoopy, would never let flymouse off for his idleness. flymouse<br>was able to use some kind of comfort index to quantitize whether better or<br>worse he would feel after hearing the words from the gift recipients (positive<br>for better and negative for worse). When arriving at a room, he chould choose<br>to enter and give out a gift and hear the words from the recipient, or bypass<br>the room in silence. He could arrive at a room more than once but never enter<br>it a second time. He wanted to maximize the the sum of comfort indices<br>accumulated along his journey.</p><p>Input</p><p>The input contains several test cases. Each test cases start with two integers<br>N and M not exceeding 30 000 and 150 000 respectively on the first line,<br>meaning that there were N team members living in N distinct rooms and M direct<br>paths. On the next N lines there are N integers, one on each line, the i-th of<br>which gives the comfort index of the words of the team member in the i-th<br>room. Then follow M lines, each containing two integers i and j indicating a<br>directed path from the i-th room to the j-th one. Process to end of file.</p><p>Output</p><p>For each test case, output one line with only the maximized sum of accumulated<br>comfort indices.</p><p>Sample Input</p><p>2 2<br>14<br>21<br>0 1<br>1 0<br>Sample Output</p><p>35<br>Hint</p><p>32-bit signed integer type is capable of doing all arithmetic.<br>————————————————————————————————————————</p><p>题目大意：<br>就是给你N个点，M条有向边，每个点一个权值，走过这个点可以取走这个价值，也可以留下，让你找一条路使得能获得的权值最大。</p><p>解题思路；<br>首先这个权值最大 很好处理，权值为正就取，负的就不取，为了方便，将负值全部变为0；</p><p>然后考虑到可能存在有向环，所以要缩点做，</p><p>缩点后从新建图，然后建一个超级源点，跑最长路就好了</p><p>最长路用SPFA即可</p><p>附本题代码<br>————————————————————————————————————————</p><pre><code>#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;typedef long long int LL;using namespace std;const int N   = 5555+7;const int MOD = 1e9+7;const int INF = (~(1&lt;&lt;31))&gt;&gt;1;//const double Pi = acos(-1.0);#define abs(x) ((x)&gt;0?(x):-(x))/****************************************************/vector&lt;int&gt;G[N];vector&lt;pair&lt;int,int&gt; &gt;G2[N];int low[N],dfn[N],w[N],d[N];int vis[N],val[N];int color[N],cnt,tot;int mystack[N],len;void dfs(int u){vis[u]=1;    dfn[u]=low[u]=++cnt;    mystack[++len]=u;    int gz=G[u].size();    for(int to,i=0;i&lt;gz;i++){        to=G[u][i];        if(vis[to]==0) dfs(to);        if(vis[to]==1) low[u]=min(low[u],low[to]);    }    if(dfn[u]==low[u]){        ++tot;        do{            val[tot]+=w[mystack[len]];            color[mystack[len]]=tot;            vis[mystack[len]]=2;        }while(mystack[len--]!=u);    }}int n,m;int main(){    while(~scanf(&quot;%d%d&quot;,&amp;n,&amp;m)){        cnt=tot=len=0;        for(int i=1;i&lt;=n;i++){            scanf(&quot;%d&quot;,&amp;w[i]);            if(w[i]&lt;0) w[i]=0;        }        for(int i=1,u,v;i&lt;=m;i++){            scanf(&quot;%d%d&quot;,&amp;u,&amp;v);            G[u+1].push_back(v+1);        }        for(int i=1;i&lt;=n;i++)if(vis[i]==0)dfs(i);        for(int i=1;i&lt;=tot;i++) G2[0].push_back(make_pair(val[i],i));        for(int i=1,gz;i&lt;=n;i++){vis[i]=0,d[i]=0;            gz=G[i].size();            for(int j=0,to;j&lt;gz;j++){                to=G[i][j];                if(color[i]!=color[to])                    G2[color[i]].push_back(make_pair(val[color[to]],color[to]));            }        }        queue&lt;int&gt; q;        q.push(0);        d[0]=0;vis[0]=1;        while(!q.empty()){            int u=q.front();q.pop();            vis[u]=0;            int gz=G2[u].size();            for(int i=0,to;i&lt;gz;i++){                to=G2[u][i].second;                if(d[to]&lt;d[u]+G2[u][i].first){                    d[to]=d[u]+G2[u][i].first;                    if(vis[to]==1)continue;                    vis[to]=1; q.push(to);                }            }        }        int ans = 0;        for(int i=1;i&lt;=tot;i++)ans=max(ans,d[i]);        printf(&quot;%d\n&quot;,ans);        for(int i=0;i&lt;=n;i++) G[i].clear(),vis[i]=color[i]=val[i]=0;        for(int i=0;i&lt;=n;i++) G2[i].clear();    }    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> POJ </tag>
            
            <tag> 图论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  hdu 5636 &amp;&amp;bestcoder</title>
      <link href="/2017/06/06/72886742/"/>
      <url>/2017/06/06/72886742/</url>
      
        <content type="html"><![CDATA[<h1 id="hdu-5636-amp-amp-bestcoder-74-1002-Shortest-Path-floyd-松弛-【图论-思维】"><a href="#hdu-5636-amp-amp-bestcoder-74-1002-Shortest-Path-floyd-松弛-【图论-思维】" class="headerlink" title="hdu 5636 &amp;&amp;bestcoder #74 1002 Shortest Path [floyd+松弛]【图论+思维】"></a>hdu 5636 &amp;&amp;bestcoder #74 1002 Shortest Path [floyd+松弛]【图论+思维】</h1><p>2017年06月06日 19:38:38  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：228</p><p>个人分类：  <a href="https://blog.csdn.net/qq_33184171/article/category/6253262" target="_blank" rel="noopener"> 思维 </a> <a href="https://blog.csdn.net/qq_33184171/article/category/6132246" target="_blank" rel="noopener"><br>bestcoder </a> <a href="https://blog.csdn.net/qq_33184171/article/category/6117382" target="_blank" rel="noopener"> hdu</a> <a href="https://blog.csdn.net/qq_33184171/article/category/6188704" target="_blank" rel="noopener"> ===== 图论 =====</a></p><hr><p> 博客爬取于<code>2019-04-18 17:16:10</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/72886742" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/72886742</a></p><p>题目链接: <a href="http://acm.hdu.edu.cn/showproblem.php?pid=5636" target="_blank" rel="noopener"> http://acm.hdu.edu.cn/showproblem.php?pid=5636</a><br>——————————————————————————————————————————</p><p>Shortest Path</p><p>Accepts: 40</p><p>Submissions: 610<br>Time Limit: 4000/2000 MS (Java/Others)</p><p>Memory Limit: 131072/131072 K (Java/Others)<br>问题描述<br>有一条长度为n的链. 节点ii和i+1之间有长度为1的边. 现在又新加了3条边, 每条边长度都是1. 给出m个询问, 每次询问两点之间的最短路.<br>输入描述<br>输入包含多组数据. 第一行有一个整数T, 表示测试数据的组数. 对于每组数据:</p><p>第一行包含2个整数n和m  (  1  ≤  n  ,  m  ≤  10  5  )  表示节点的数目和询问数目. 接下来一行包含66个有空格分开的整数<br>a  1  ,  b  1  ,  a  2  ,  b  2  ,  a  3  ,  b  3  (  1  ≤  a  1  ,  a  2  ,<br>a  3  ,  b  1  ,  b  2  ,  b  3  ≤  n  )  表示新加的三条边为  (  a  1  ,  b  1  )  ,  (<br>a  2  ,  b  2  )  ,  (  a  3  ,  b  3  )  . 接下来mm行, 每行包含两个整数  s  i  和  t  i  (<br>1  ≤  s  i  ,  t  i  ≤  n  )  , 表示一组询问.</p><p>所有数据中mm的和不超过10^6106.<br>输出描述<br>对于每组数据, 输出一个整数  S  =  (  ∑  i  =  1  m  i  ⋅  z  i  )  mod  (  10  9  +  7  )<br>, 其中z_izi表示第ii组询问的答案.<br>输入样例<br>1<br>10 2<br>2 4 5 7 8 10<br>1 5<br>3 1<br>输出样例<br>7</p><p>——————————————————————————————————————————<br>首先对于给了N个节点求最短路 一定不能直接做了,</p><p>发现他加的三条边与查询的边一共就8个点,那么每次对这8个点写folyd不就好了,O(8<em>8</em>8)然而写了一发TLE</p><p>然后想这样怎么能在优化呢?</p><p>想到给定的那6个点是固定的,那么多次求就浪费了</p><p>然后考虑,让我查询的就一条边,那么其实也就是6<em>6条边对这条边松弛,那么复杂度就是O(6</em>6),</p><p>附本题代码<br>——————————————————————————————————————————</p><pre><code>#include &lt;bits/stdc++.h&gt;typedef long long int LL;using namespace std;#define abs(x) (((x)&gt;0)?(x):-(x))const int N   = 1e5+10;const int MOD = 1e9+7;const int INF = 11111;/******************************************/int a[10],n,m;int b[11][11];int main(){    int _;scanf(&quot;%d&quot;,&amp;_);    while(_--){        scanf(&quot;%d%d&quot;,&amp;n,&amp;m);        for(int i=1;i&lt;=6;i++)scanf(&quot;%d&quot;,&amp;a[i]);        LL ans=0;        for(int i=1;i&lt;=6;i++)            for(int j=1;j&lt;=6;j++)                b[i][j]=abs(a[i]-a[j]);        b[1][2]=b[3][4]=b[5][6]=1;        b[2][1]=b[4][3]=b[6][5]=1;        for(int k=1;k&lt;=6;k++)            for(int i=1;i&lt;=6;i++)                for(int j=1;j&lt;=6;j++)                    if(b[i][j]&gt;b[i][k]+b[k][j])                        b[i][j]=b[i][k]+b[k][j];        for(LL o=1;o&lt;=m;o++){            scanf(&quot;%d%d&quot;,&amp;a[7],&amp;a[8]);            int dis=abs(a[7]-a[8]);            for(int i=1;i&lt;=6;i++)                for(int j=1;j&lt;=6;j++){                    int t=abs(a[i]-a[7])+b[i][j]+abs(a[j]-a[8]);                    if(t&lt;dis) dis=t;                }            ans+=o*dis;            ans%=MOD;        }        printf(&quot;%lld\n&quot;,ans);    }    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hdu </tag>
            
            <tag> bestcoder </tag>
            
            <tag> 图论 </tag>
            
            <tag> 思维 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  北信科1011 K. paulzhou和方程 [组合数学+差分序列]【数学】</title>
      <link href="/2017/06/06/72877015/"/>
      <url>/2017/06/06/72877015/</url>
      
        <content type="html"><![CDATA[<h1 id="北信科1011-K-paulzhou和方程-组合数学-差分序列-【数学】"><a href="#北信科1011-K-paulzhou和方程-组合数学-差分序列-【数学】" class="headerlink" title="北信科1011 K. paulzhou和方程 [组合数学+差分序列]【数学】"></a>北信科1011 K. paulzhou和方程 [组合数学+差分序列]【数学】</h1><p>2017年06月06日 12:41:52  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：530</p><hr><p> 博客爬取于<code>2019-04-18 17:16:11</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/72877015" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/72877015</a></p><p>题目链接: <a href="http://acm.hdu.edu.cn/diy/contest_showproblem.php?cid=31989&amp;pid=1011" target="_blank" rel="noopener"> http://acm.hdu.edu.cn/diy/contest_showproblem.php?cid=31989&amp;pid=1011</a><br>———————————————————————————————————————————<br>K. paulzhou和方程</p><p>Time Limit : 3000/1000ms (Java/Other) Memory Limit : 65535/102400K<br>(Java/Other)<br>Total Submission(s) : 28 Accepted Submission(s) : 7<br>Font: Times New Roman | Verdana | Georgia<br>Font Size: ← →<br>Problem Description<br>众所周知，paulzhou的数学不太好。现在他有一个问题，希望你帮他解答：<br>给定一元n次方程  f  x  =  c  0  +  c  1  ∗  x  +  c  2  ˙  x  2  +  .  .  .  +  c<br>n  ˙  x  n<br>定义  f  i  的前k项和  </p><p>s  k  ∑  i  =  0  k  −  1  f  i</p><p>现给出n、n+1个各项的系数  c  i  以及k，求  s  k  %  10007</p><p>其中<br>Input<br>第1行输入T(1≤T≤10)，代表有T组数据。<br>紧接着每3行分别为n，各项系数，k，输入数据均为正整数。<br>Output<br>每组测试数据输出一行，输出  f  x  的前k-1项和</p><p>s  k  ∑  i  =  0  k  −  1  f  i</p><p>并对10007取模。<br>Sample Input<br>1<br>4<br>1 -2 3 1 0<br>3<br>Sample Output<br>21<br>Author<br>Kirai<br>———————————————————————————————————————————</p><p>这题用到了差分序列 详情见《组合数学(原书第5版)》翻译版 P169</p><p>查分序列:<br>设有一个序列  h  0  ,  h  1  ,  h  2  ,  ,  ,  ,  h  n<br>它的一阶差分序列是  </p><p>△  h  i  =  h  i  +  1  −  h  i</p><p>对应二阶差分序列为  </p><p>△  2  h  i  =  △  h  i  +  1  −  △  h  i</p><p>由此得到差分表(看起来很难看啊 意思意思就行了)  </p><p>h  0  h  1  h  2  h  3  .  .  .  .  .  △  h  0  △  h  1  △  h  2  .  .  .  .<br>.  .  .  .</p><p>根据性质能够得到(证明看书吧..)</p><p>h  x  =  ∑  i  =  0  n  C  (  x  ,  i  )  ∗  △  i  h  i</p><p>∑  i  =  0  n  ∑  j  =  0  k  −  1  C  (  j  ,  i  )  ∗  △  i  h  0</p><p>由  </p><p>∑  i  =  0  n  C  (  m  ,  i  )  =  C  (  n  +  1  ,  m  +  1  )</p><p>故  </p><p>∑  i  =  0  n  ∑  j  =  0  k  −  1  C  (  j  ,  i  )  ∗  △  i  h  0  =  ∑  i<br>=  0  n  C  (  k  ,  i  +  1  )  ∗  △  i  h  0</p><p><strong> 注：取模的时候最好都（x%MOD+MOD）%MOD </strong></p><p>附本题代码<br>———————————————————————————————————————————</p><pre><code>#include &lt;bits/stdc++.h&gt;typedef long long int LL;using namespace std;#define abs(x) (((x)&gt;0)?(x):-(x))const LL N = 1e5+10;const LL M = 10007;/******************************************/LL n,a[N],h[N],b[N];LL k;LL fac[M],inv[M];LL qmod(LL a,LL b){    LL res=1;    while(b){        if(b&amp;1) res=res*a%M;        b&gt;&gt;=1,a=a*a%M;    }    return res;}void init(){    fac[0]=1;    for(LL i=1;i&lt;M;i++) fac[i]=fac[i-1]*i%M;    inv[M-1]=qmod(fac[M-1],M-2);    for(LL i=M-2;i&gt;=0;i--) inv[i]=inv[i+1]*(i+1)%M;}LL C(LL n,LL m){    return fac[n]*inv[m]%M*inv[n-m]%M;}LL Combination(LL n, LL m){    if(n&lt;m) return 0;    if(n&lt;M&amp;&amp;m&lt;M) return C(n,m);    return Combination(n/M,m/M)*Combination(n%M,m%M)%M;}int main(){    init();    LL _;scanf(&quot;%lld&quot;,&amp;_);    while(_--){        scanf(&quot;%lld&quot;,&amp;n);        for(LL i=0;i&lt;=n;i++) scanf(&quot;%lld&quot;,&amp;a[i]),a[i]=a[i]%M;        scanf(&quot;%lld&quot;,&amp;k);        for(LL i=0,j,x;i&lt;=n;i++){            for(h[i]=j=0,x=1;j&lt;=n;j++){                h[i]=(h[i]+a[j]*x%M)%M;                h[i]=(h[i]%M+M)%M;x=x*i%M;            }        }        b[0]=h[0];        for(LL i=1;i&lt;=n;i++){            for(LL j=0;j&lt;=n-i;j++)                h[j]=(h[j+1]-h[j]+M)%M;            b[i]=h[0];        }        LL ans = 0;        for(LL i=0;i&lt;=n;i++){            ans = ans + b[i]*Combination(k,i+1)%M;            ans = (ans%M+M)%M;        }        printf(&quot;%lld\n&quot;,ans);    }    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  2016东北赛 &amp;&amp; hdu 5927 Auxiliary Set [dfs序+BIT]【数据结构】</title>
      <link href="/2017/06/05/72868717/"/>
      <url>/2017/06/05/72868717/</url>
      
        <content type="html"><![CDATA[<h1 id="2016东北赛-amp-amp-hdu-5927-Auxiliary-Set-dfs序-BIT-【数据结构】"><a href="#2016东北赛-amp-amp-hdu-5927-Auxiliary-Set-dfs序-BIT-【数据结构】" class="headerlink" title="2016东北赛 &amp;&amp; hdu 5927 Auxiliary Set [dfs序+BIT]【数据结构】"></a>2016东北赛 &amp;&amp; hdu 5927 Auxiliary Set [dfs序+BIT]【数据结构】</h1><p>2017年06月05日 16:38:47  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：283</p><p>个人分类：  <a href="https://blog.csdn.net/qq_33184171/article/category/6117382" target="_blank" rel="noopener"> hdu </a> <a href="https://blog.csdn.net/qq_33184171/article/category/6362428" target="_blank" rel="noopener"><br>==== 数据结构 ==== </a></p><hr><p> 博客爬取于<code>2019-04-18 17:16:12</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/72868717" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/72868717</a></p><p>题目链接： <a href="http://acm.hdu.edu.cn/showproblem.php?pid=5927" target="_blank" rel="noopener"> http://acm.hdu.edu.cn/showproblem.php?pid=5927</a><br>————————————————————————————————————————————<br>Auxiliary Set</p><p>Time Limit: 9000/4500 MS (Java/Others) Memory Limit: 65536/65536 K<br>(Java/Others)<br>Total Submission(s): 1525 Accepted Submission(s): 460</p><p>Problem Description<br>Given a rooted tree with n vertices, some of the vertices are important.</p><p>An auxiliary set is a set containing vertices satisfying at least one of the<br>two conditions：</p><p>∙It is an important vertex<br>∙It is the least common ancestor of two different important vertices.</p><p>You are given a tree with n vertices (1 is the root) and q queries.</p><p>Each query is a set of nodes which indicates the unimportant vertices in the<br>tree. Answer the size (i.e. number of vertices) of the auxiliary set for each<br>query.</p><p>Input<br>The first line contains only one integer T (T≤1000), which indicates the<br>number of test cases.</p><p>For each test case, the first line contains two integers n (1≤n≤100000), q<br>(0≤q≤100000).</p><p>In the following n -1 lines, the i-th line contains two integers<br>ui,vi(1≤ui,vi≤n) indicating there is an edge between uii and vi in the tree.</p><p>In the next q lines, the i-th line first comes with an integer mi(1≤mi≤100000)<br>indicating the number of vertices in the query set.Then comes with mi<br>different integers, indicating the nodes in the query set.</p><p>It is guaranteed that ∑qi=1mi≤100000.</p><p>It is also guaranteed that the number of test cases in which n≥1000 or<br>∑qi=1mi≥1000 is no more than 10.</p><p>Output<br>For each test case, first output one line “Case #x:”, where x is the case<br>number (starting from 1).</p><p>Then q lines follow, i-th line contains an integer indicating the size of the<br>auxiliary set for each query.</p><p>Sample Input<br>1<br>6 3<br>6 4<br>2 5<br>5 4<br>1 5<br>5 3<br>3 1 2 3<br>1 5<br>3 3 1 4</p><p>Sample Output<br>Case #1:<br>3<br>6<br>3<br>Hint</p><p><img src="http://acm.hdu.edu.cn/data/images/C729-1006-1.jpg" alt="这里写图片描述"></p><p>For the query {1，2, 3}:<br>•node 4, 5, 6 are important nodes For the query {5}：<br>•node 1，2, 3, 4, 6 are important nodes<br>•node 5 is the lea of node 4 and node 3 For the query {3, 1，4}:<br>• node 2, 5, 6 are important nodes</p><p>————————————————————————————————————————————<br>题意:</p><p>是有一颗有n个节点以  1  位根的树,有q次查询,每次查询给定一个集合,集合外的点是 <strong> 重要点 </strong> ,集合内的点是 <strong> 非重要点 </strong> ,如果<br><strong> 非重要点 </strong> 是两个 <strong> 重要点 </strong> 的LCA,那么这个 <strong> 非重要点 </strong> 会变成 <strong> 重要点 </strong> ,问你重要点的个数.</p><p>解题思路:</p><p>开始看数据范围非常大,以为要O(M)查询,后来看哪个乱七八糟的数据范围,感觉带个log啥的,再加上剪剪枝也能做做看,..</p><p>首先对于一次查询,我们要知道了 <strong> 非重要点 </strong> 的个数m,那么集合外的 <strong> 重要点 </strong> 就是n-m</p><p>对于集合里面的重要点我们可以枚举,存在至少有两个节点在一个 <strong> 非重要点 </strong> 的不同儿子节点为根的子树上,那么这个 <strong> 非重要点 </strong> 就是两个 <strong><br>重要点 </strong> 的LCA,就要++.;</p><p>那么考虑,会不会有 <strong> 非重要点 </strong> 是 <strong> 非重要点 </strong> 变成的 <strong> 重要点 </strong> 的LCA才计算的呢?,这种情况怎么处理,<br>其实很好想,如果 <strong> 非重要点 </strong> 变成 <strong> 重要点 </strong> ,那么这个 <strong> 非重要点 </strong> 的树一定有最开始就是 <strong> 重要点 </strong><br>的节点,所以忽略这个情况就行了.</p><p>那么就是找节点子树中有没有 <strong> 重要点 </strong> 了,对于子树问题,想到 <strong> _ dfs序 _ </strong> ,并用一个数组标记这个点是不是 <strong> 重要点 </strong><br>,也就是看子树所包括的连续序列有没有被标记的,维护一个 <strong> _ BIT _ </strong> ,就能log计算了</p><p>然后注意一个剪枝,就是有两个儿子节点的树上有 <strong> 重要点 </strong> ,就可以break了.</p><p>附本题代码<br>————————————————————————————————————————————</p><p>​    </p><pre><code>#include &lt;bits/stdc++.h&gt;typedef long long int LL;using namespace std;const int MOD = 10007;const int N   = 100000+7;#define abs(x)  ((x)&gt;0?(x):-(x))int read(){    int x=0;char ch = getchar();    while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;) ch = getchar();    while(&#39;0&#39;&lt;=ch&amp;&amp;ch&lt;=&#39;9&#39;) {x=(x&lt;&lt;3)+(x&lt;&lt;1)+ch-&#39;0&#39;;ch=getchar();}    return x;}/*******************************/vector&lt;int&gt;G[N];int n,m,q;int a[N],L[N],R[N],fa[N],cnt;void dfs(int u,int f){    L[u]=++cnt;fa[u]=f;    int gz=G[u].size();    for(int i=0,to;i&lt;gz;i++){        to=G[u][i];        if(to==f) continue;        dfs(to,u);    }    R[u]=cnt;}int sum[N];#define lowbit(x) (x&amp;-x)void update(int i,int v){for(;i&lt;=n;i+=lowbit(i))sum[i]+=v;}int getSum(int i){int ans=0;for(;i;i-=lowbit(i))ans+=sum[i];return ans;}int main(){    int _=read(),kcase=0;    while(_--){cnt=0;        n=read(),q=read();        update(1,1);        for(int i=2,u,v;i&lt;=n;i++){update(i,1);            u=read(),v=read();            G[u].push_back(v);            G[v].push_back(u);        }        dfs(1,0);        int ans;printf(&quot;Case #%d:\n&quot;,++kcase);        while(q--){            m=read();ans=n-m;            for(int i=1;i&lt;=m;i++) a[i]=read(),update(L[a[i]],0);            for(int i=1;i&lt;=m;i++){                int gz=G[a[i]].size(),tot=0;                for(int j=0,to;j&lt;gz;j++){                    to=G[a[i]][j];                    if(to==fa[a[i]])continue;                    if(getSum(R[to])-getSum(L[to]-1) &gt; 0)tot++;                }                if(tot&gt;=2) ans++;            }            printf(&quot;%d\n&quot;,ans);            for(int i=1;i&lt;=m;i++) update(L[a[i]],1);        }        for(int i=1;i&lt;=n;i++)G[i].clear();    }    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hdu </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  SUDT 3926 bLue的二叉树 [KMP or hash]【思维】</title>
      <link href="/2017/06/05/72863523/"/>
      <url>/2017/06/05/72863523/</url>
      
        <content type="html"><![CDATA[<h1 id="SUDT-3926-bLue的二叉树-KMP-or-hash-【思维】"><a href="#SUDT-3926-bLue的二叉树-KMP-or-hash-【思维】" class="headerlink" title="SUDT 3926 bLue的二叉树 [KMP or hash]【思维】"></a>SUDT 3926 bLue的二叉树 [KMP or hash]【思维】</h1><p>2017年06月05日 01:35:52  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：303</p><hr><p> 博客爬取于<code>2019-04-18 17:16:13</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/72863523" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/72863523</a></p><p>题目链接: <a href="http://acm.sdut.edu.cn/onlinejudge2/index.php/Home/Contest/contestproblem/cid/2176/pid/3926.html" target="_blank" rel="noopener"> http://acm.sdut.edu.cn/onlinejudge2/index.php/Home/Contest/contestprob<br>lem/cid/2176/pid/3926.html </a><br>——————————————————————————————————————<br>bLue的二叉树<br>Time Limit: 3000MS Memory Limit: 65536KB<br>Submit Statistic<br>Problem Description</p><p>Keke 是一个喜爱种树的人，他对各种树都有很深的研究。<br>MLE 听说 bLue 种了一些新品种的树，就想邀请 Keke 去围观一下。<br>PBH 在暗中把这一切尽收眼底，作为资深植树行家，他虽不屑，但也决定和他们一起去看一看。<br>于是，大家便一起到了 bLue 家去看树。<br>bLue 有两棵二叉树，分别有 n 和 m 个节点，编号分别为 1-n 和 1-m，每个节点都有一个权值，bLue<br>想知道第一棵树的所有子树中与第二棵树完全相同的个数(不考虑节点编号)。<br>Input</p><p>输入数据有多组，组数不超过 150，到 EOF 结束。<br>每组第一行有两个整数 n (0 &lt; n &lt;= 1e5)和 m (0 &lt; m &lt;= 1e5)，表示第一棵树和第二棵树的节点个数；<br>接下来 n 行，表示第一棵树：第 i (0 &lt; i &lt;= n) 行有 3 个整数，w[i] (0 &lt; w[i] &lt;= 10), lc[i], rc[i]<br>(0 &lt; lc[i], rc[i] &lt;= n)，分别表示节点 i 的权值，该节点的左孩子编号和右孩子编号，若某个孩子不存在，则为 0<br>(数据保证每棵树都是合法的有根二叉树)；<br>接下来 m 行，表示第二棵树：格式同第一棵树；<br>保证：树的最大深度不会超过 10000。数据量比较大，请用 scanf 读入！<br>Output</p><p>对于每组数据，输出一行一个整数 num，表示第一棵树的所有子树中与第二棵树完全相同的个数。<br>Example Input</p><p>7 4<br>1 6 3<br>2 0 4<br>1 7 0<br>3 0 0<br>1 2 1<br>2 0 0<br>2 0 0<br>2 0 0<br>1 4 0<br>1 1 2<br>2 0 0<br>3 3<br>1 0 0<br>2 1 3<br>3 0 0<br>1 0 3<br>2 1 0<br>3 0 0<br>Example Output</p><p>1<br>0<br>Hint</p><p>Author</p><p>不得不放弃、<br>——————————————————————————————————————<br>首先确定的是严格确定 二叉树的左子树和左子树对 上右子树和右子树对上才行</p><p>对于子树问题考虑dfs序<br>对于一个dfs序,区间内的东西都是子树的,那么对于两个完全一样的子树.遍历出来的区间也是一模一样的.</p><p>但是为了避免有多个子树遍出结果一样的,我们只需把空节点当作一个不一样的权值加入到树中,这样既能确保区间序列一样,同时又不会冲突.</p><p>最后对两个dfs序KMP即能求解</p><hr><p>其实这题是能够hash做的 ，最开始我也在想hash的方法，但是想不到怎么处理左右儿子的左/右儿子到底在那，所以不太行，，==<br>现在想到对dfs序后他的位置l的x^l的系数 感觉很可行啊 ，同时也要做dfs==！ 其实还是字符串hash了，，，，，</p><p>附本题 <strong> 两份KMP+hash </strong> 代码<br>——————————————————————————————————————</p><pre><code>#include &lt;bits/stdc++.h&gt;typedef long long int LL;using namespace std;#define abs(x) (((x)&gt;0)?(x):-(x))const int N    = 1e5+10;const int MOD  = 1e9+7;int sum;LL read(){    LL x=0;char ch=getchar();    while(&#39;0&#39;&gt;ch||ch&gt;&#39;9&#39;) ch=getchar();    while(&#39;0&#39;&lt;=ch&amp;&amp;ch&lt;=&#39;9&#39;){x=(x&lt;&lt;3)+(x&lt;&lt;1)+ch-&#39;0&#39;;sum++;ch=getchar();}    return x;}/******************************************/int n,m;int a[N][3],b[N][3],c[N&lt;&lt;1],d[N&lt;&lt;1],lc,ld;void dfs1(int rt){    c[lc++]=a[rt][0];//printf(&quot;%d &quot;,a[rt][0]);    if(rt==0) return;    dfs1(a[rt][1]);    dfs1(a[rt][2]);}void dfs2(int rt){    d[ld++]=b[rt][0];//printf(&quot;%d &quot;,b[rt][0]);    if(rt==0) return;    dfs2(b[rt][1]);    dfs2(b[rt][2]);}int Next[N&lt;&lt;1];//Next[i] 表示从[0~i]中最长公共前缀的长.void get_next(int *s,int len){    for(int i=0,j=-1;i&lt;=len;++i,++j){        Next[i]=j;        while(j&gt;=0&amp;&amp;s[i]!=s[j]) j = Next[j];    }//    for(int i=0;i&lt;=len;i++) printf(&quot;%d%c&quot;,Next[i],(i==len)?&#39;\n&#39;:&#39; &#39;);}//在串s上找szint KMP (int *s,int len,int *sz,int l){    int i=0,j=0,cnt=0;    while(i&lt;len/*&amp;&amp;j&lt;l*/){        if(s[i]==sz[j])  i++,j++;        else{            if(0==j)  i++;            else      j=Next[j];        }        if(j==l) cnt++;    }//   return (j==l)?(i-l+1):-1; //找第一次出现的位置    return cnt; //找出现的个数}bool visa[N],visb[N];int main(){    while(~scanf(&quot;%d%d&quot;,&amp;n,&amp;m)){        lc=ld=0;        for(int i=1;i&lt;=n;i++)  a[i][0]=read(),a[i][1]=read(),a[i][2]=read(),visa[a[i][1]]=visa[a[i][2]]=1;        for(int i=1;i&lt;=m;i++)  b[i][0]=read(),b[i][1]=read(),b[i][2]=read(),visb[b[i][1]]=visb[b[i][2]]=1;        for(int i=1;i&lt;=n;i++)  if(visa[i]==0){dfs1(i);break;}//puts(&quot;&quot;);        for(int i=1;i&lt;=m;i++)  if(visb[i]==0){dfs2(i);break;}//puts(&quot;&quot;);        get_next(d,ld);        printf(&quot;%d\n&quot;,KMP(c,lc,d,ld));        for(int i=1;i&lt;=n;i++) visa[i]=0;        for(int i=1;i&lt;=m;i++) visb[i]=0;    }    return 0;}/***************************************************User name: tabrisResult: AcceptedTake time: 872msTake Memory: 596KBSubmit time: 2017-06-05 00:39:32****************************************************/#include &lt;bits/stdc++.h&gt;typedef unsigned long long int LL;using namespace std;#define abs(x) (((x)&gt;0)?(x):-(x))const int N    = 1e5+10;const int MOD  = 1e9+7;int sum;LL read(){    LL x=0;char ch=getchar();    while(&#39;0&#39;&gt;ch||ch&gt;&#39;9&#39;) ch=getchar();    while(&#39;0&#39;&lt;=ch&amp;&amp;ch&lt;=&#39;9&#39;){x=(x&lt;&lt;3)+(x&lt;&lt;1)+ch-&#39;0&#39;;sum++;ch=getchar();}    return x;}/******************************************/int n,m,ans,lc,ld;int a[N][3],b[N][3];//,lb[N],rb[N];LL c[N&lt;&lt;1],x,h,tota,totb;void dfs1(int rt){    ++lc;    c[lc]=a[rt][0]*x;x*=h;    if(rt==0) return;    dfs1(a[rt][1]);    dfs1(a[rt][2]);}void dfs2(int rt){    ++ld;    totb+=b[rt][0]*x;x*=h;    if(rt==0) return;    dfs2(b[rt][1]);    dfs2(b[rt][2]);}bool visa[N],visb[N];int main(){    a[0][0]=b[0][0]=101;h=27;c[0]=0;    while(~scanf(&quot;%d%d&quot;,&amp;n,&amp;m)){        lc=ld=0;ans=0;tota=totb=0;        for(int i=1;i&lt;=n;i++)  a[i][0]=read(),a[i][1]=read(),a[i][2]=read(),visa[a[i][1]]=visa[a[i][2]]=1;        for(int i=1;i&lt;=m;i++)  b[i][0]=read(),b[i][1]=read(),b[i][2]=read(),visb[b[i][1]]=visb[b[i][2]]=1;        x=1;for(int i=1;i&lt;=n;i++)  if(visa[i]==0){dfs1(i);break;}//puts(&quot;&quot;);        x=1;for(int i=1;i&lt;=m;i++)  if(visb[i]==0){dfs2(i);break;}//puts(&quot;&quot;);        for(int i=1;i&lt;ld;i++) tota+=c[i];        for(int i=ld;i&lt;=lc;i++){            tota-=c[i-ld],tota+=c[i];            if(tota==totb) ans++;            totb*=h;        }        printf(&quot;%d\n&quot;,ans);        for(int i=1;i&lt;=n;i++) visa[i]=0;        for(int i=1;i&lt;=m;i++) visb[i]=0;    }    return 0;}/***************************************************User name: tabrisResult: AcceptedTake time: 884msTake Memory: 2244KBSubmit time: 2017-06-05 01:34:54****************************************************/</code></pre>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  2017年第0届浙江工业大学之江学院程序设计竞赛决赛 [(6+1+6)/13]【补题报告】</title>
      <link href="/2017/06/03/72849801/"/>
      <url>/2017/06/03/72849801/</url>
      
        <content type="html"><![CDATA[<h1 id="2017年第0届浙江工业大学之江学院程序设计竞赛决赛-6-1-6-13-【补题报告】"><a href="#2017年第0届浙江工业大学之江学院程序设计竞赛决赛-6-1-6-13-【补题报告】" class="headerlink" title="2017年第0届浙江工业大学之江学院程序设计竞赛决赛 [(6+1+6)/13]【补题报告】"></a>2017年第0届浙江工业大学之江学院程序设计竞赛决赛 [(6+1+6)/13]【补题报告】</h1><p>2017年06月03日 03:07:10  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：369</p><hr><p> 博客爬取于<code>2019-04-18 17:16:14</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/72849801" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/72849801</a></p><p>端午几天没有碰键盘，开场A题就炸了。<br>现场的时候只AC了6个，最后2个小时M由于题目描述有问题，后台有非法数据，wa了两个小时，心态爆炸，怀疑人生，GG（其实是能AC的代码）</p><p>后面有几个水题都没有看到，比如这个C，还有很好想的E。。</p><p>题目质量真心好啊，给举办方大大的赞啊。。<br>同时学到了好多东西，以前lca只会树剖，现在会写倍增了，又学会了可持久化01字典树。和树重构。 美滋滋啊。</p><p>话说同步赛大家玩的都很开心，但是。。。额。心疼现场玩家。</p><p>———————fen·ge·xian——————————-</p><p>据说每题单开一贴能增加阅读体验</p><h1 id="1481-Problem-A-qwb与支教"><a href="#1481-Problem-A-qwb与支教" class="headerlink" title="[ 1481 Problem A qwb与支教"></a>[ 1481 Problem A qwb与支教</h1><p>](<a href="http://blog.csdn.net/qq_33184171/article/details/72849484" target="_blank" rel="noopener">http://blog.csdn.net/qq_33184171/article/details/72849484</a>)</p><h1 id="1477-Problem-B-qwb与矩阵"><a href="#1477-Problem-B-qwb与矩阵" class="headerlink" title="[ 1477 Problem B qwb与矩阵"></a>[ 1477 Problem B qwb与矩阵</h1><p>](<a href="http://blog.csdn.net/qq_33184171/article/details/72849513" target="_blank" rel="noopener">http://blog.csdn.net/qq_33184171/article/details/72849513</a>)</p><h1 id="1479-Problem-C-勤劳的ACgirls"><a href="#1479-Problem-C-勤劳的ACgirls" class="headerlink" title="[ 1479 Problem C 勤劳的ACgirls"></a>[ 1479 Problem C 勤劳的ACgirls</h1><p>](<a href="http://blog.csdn.net/qq_33184171/article/details/72849551" target="_blank" rel="noopener">http://blog.csdn.net/qq_33184171/article/details/72849551</a>)</p><h1 id="1480-Problem-D-qwb与神奇的序列"><a href="#1480-Problem-D-qwb与神奇的序列" class="headerlink" title="[ 1480 Problem D qwb与神奇的序列"></a>[ 1480 Problem D qwb与神奇的序列</h1><p>](<a href="http://blog.csdn.net/qq_33184171/article/details/72849656" target="_blank" rel="noopener">http://blog.csdn.net/qq_33184171/article/details/72849656</a>)</p><h1 id="1483-Problem-E-qwb和李主席"><a href="#1483-Problem-E-qwb和李主席" class="headerlink" title="[ 1483 Problem E qwb和李主席"></a>[ 1483 Problem E qwb和李主席</h1><p>](<a href="http://blog.csdn.net/qq_33184171/article/details/72849660" target="_blank" rel="noopener">http://blog.csdn.net/qq_33184171/article/details/72849660</a>)</p><h1 id="1485-Problem-F-qwb-has-a-lot-of-Coins"><a href="#1485-Problem-F-qwb-has-a-lot-of-Coins" class="headerlink" title="[ 1485 Problem F qwb has a lot of Coins"></a>[ 1485 Problem F qwb has a lot of Coins</h1><p>](<a href="http://blog.csdn.net/qq_33184171/article/details/72849663" target="_blank" rel="noopener">http://blog.csdn.net/qq_33184171/article/details/72849663</a>)</p><h1 id="1487-Problem-G-qwb去面试"><a href="#1487-Problem-G-qwb去面试" class="headerlink" title="[ 1487 Problem G qwb去面试"></a>[ 1487 Problem G qwb去面试</h1><p>](<a href="http://blog.csdn.net/qq_33184171/article/details/72849668" target="_blank" rel="noopener">http://blog.csdn.net/qq_33184171/article/details/72849668</a>)</p><h1 id="1490-Problem-H-qwb与学姐"><a href="#1490-Problem-H-qwb与学姐" class="headerlink" title="[ 1490 Problem H qwb与学姐"></a>[ 1490 Problem H qwb与学姐</h1><p>](<a href="http://blog.csdn.net/qq_33184171/article/details/72849743" target="_blank" rel="noopener">http://blog.csdn.net/qq_33184171/article/details/72849743</a>)</p><h1 id="1492-Problem-I-qwb-VS-去污棒"><a href="#1492-Problem-I-qwb-VS-去污棒" class="headerlink" title="[ 1492 Problem I qwb VS 去污棒"></a>[ 1492 Problem I qwb VS 去污棒</h1><p>](<a href="http://blog.csdn.net/qq_33184171/article/details/72849787" target="_blank" rel="noopener">http://blog.csdn.net/qq_33184171/article/details/72849787</a>)</p><h1 id="1488-Problem-J-qwb又偷懒了"><a href="#1488-Problem-J-qwb又偷懒了" class="headerlink" title="[ 1488 Problem J qwb又偷懒了"></a>[ 1488 Problem J qwb又偷懒了</h1><p>](<a href="http://blog.csdn.net/qq_33184171/article/details/72849792" target="_blank" rel="noopener">http://blog.csdn.net/qq_33184171/article/details/72849792</a>)</p><h1 id="1482-Problem-K-qwb与小数"><a href="#1482-Problem-K-qwb与小数" class="headerlink" title="[ 1482 Problem K qwb与小数"></a>[ 1482 Problem K qwb与小数</h1><p>](<a href="http://blog.csdn.net/qq_33184171/article/details/72849793" target="_blank" rel="noopener">http://blog.csdn.net/qq_33184171/article/details/72849793</a>)</p><h1 id="1475-Problem-L-qwb与整数对"><a href="#1475-Problem-L-qwb与整数对" class="headerlink" title="[ 1475 Problem L qwb与整数对"></a>[ 1475 Problem L qwb与整数对</h1><p>](<a href="http://blog.csdn.net/qq_33184171/article/details/72849794" target="_blank" rel="noopener">http://blog.csdn.net/qq_33184171/article/details/72849794</a>)</p><h1 id="1486-Problem-M-qwb与二叉树"><a href="#1486-Problem-M-qwb与二叉树" class="headerlink" title="[ 1486 Problem M qwb与二叉树"></a>[ 1486 Problem M qwb与二叉树</h1><p>](<a href="http://blog.csdn.net/qq_33184171/article/details/72849797" target="_blank" rel="noopener">http://blog.csdn.net/qq_33184171/article/details/72849797</a>)</p>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  2017年第0届浙江工业大学之江学院程序设计竞赛决赛 M qwb与二叉树 [记忆化dp]【动态规划】</title>
      <link href="/2017/06/03/72849797/"/>
      <url>/2017/06/03/72849797/</url>
      
        <content type="html"><![CDATA[<h1 id="2017年第0届浙江工业大学之江学院程序设计竞赛决赛-M-qwb与二叉树-记忆化dp-【动态规划】"><a href="#2017年第0届浙江工业大学之江学院程序设计竞赛决赛-M-qwb与二叉树-记忆化dp-【动态规划】" class="headerlink" title="2017年第0届浙江工业大学之江学院程序设计竞赛决赛 M: qwb与二叉树 [记忆化dp]【动态规划】"></a>2017年第0届浙江工业大学之江学院程序设计竞赛决赛 M: qwb与二叉树 [记忆化dp]【动态规划】</h1><p>2017年06月03日 03:04:48  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：444</p><hr><p> 博客爬取于<code>2019-04-18 17:16:16</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/72849797" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/72849797</a></p><p>题目链接： <a href="http://115.231.222.240:8081/JudgeOnline/problem.php?cid=1005&amp;pid=12" target="_blank" rel="noopener"> http://115.231.222.240:8081/JudgeOnline/problem.php?cid=1005&amp;pid=12</a><br>——————————————————————————————————————————<br>Problem M: qwb与二叉树<br>Time Limit: 1 Sec Memory Limit: 128 MB<br>Submit: 159 Solved: 35<br>[Submit][Status][Web Board]<br>Description<br>某一天，qwb正在上数据结构课。老师在讲台上面讲着二叉树，qwb在下面发着呆。<br>突然qwb想到一个问题：对于一棵n个无编号节点，m个叶子的有根二叉树，有多少种形态呐？你能告诉他吗？</p><p>Input<br>多组输入，处理到文件结束,大约有104组数据。<br>每一组输入一行，两个正整数n,m(0≤m≤n≤50),意义如题目所述。</p><p>Output<br>每一行输出一个数，表示相应询问的答案,由于答案可能很大，请将答案对109+7取模后输出。</p><p>Sample Input<br>4 2<br>10 5<br>Sample Output<br>6<br>252<br>HINT</p><p>样例1的6种形态:</p><p><img src="http://115.231.222.240:8081/JudgeOnline/upload/image/20170525/20170525135945_50358.png" alt="这里写图片描述"><br>——————————————————————————————————————————<br>心态爆炸的一道题,现场后2hours wa到死… 其实是题目描述错了1~50 但后台数据是0~50,后来修改了</p><p>题目而言是好题目,<br>设dp[i][j]是i个节点j个叶子的树的种类</p><p>那么转移就是以当前点为根,左右子树方案数的乘积,</p><p>d  p  [  n  ]  [  m  ]  =  ∑  i  ∑  j  d  p  [  i  ]  [  j  ]  ∗  d  p  [  n<br>−  1  −  i  ]  [  m  −  j  ]</p><p>我开始采取记忆化的方式，然后处理答案要交表，然后发现时间比较快 交完就wa，补题的时候发现数据范围描述有误。。。</p><p>但其实如果我输出不是dp[n][m]，而直接dfs(n,m)也就诶问题了，，，也算长个记性。。。</p><p>附本题代码<br>——————————————————————————————————————————</p><p>​    </p><pre><code>#include &lt;bits/stdc++.h&gt;typedef long long int LL;using namespace std;#define abs(x) (((x)&gt;0)?(x):-(x))const int N = 1000000+10;const int MOD  = 1e9+7;/******************************************/LL dp[555][555];LL dfs(int x,int y){    if(dp[x][y]!=-1) return dp[x][y];    if(x&lt;y*2-1||x&lt;=0||y&lt;=0)      return dp[x][y]=0ll;    int xx=x-1,yy=y;    LL res = 0;    res=(2ll*dfs(xx,yy))%MOD;    for(int i=0;i&lt;xx;i++)        for(int j=1;j&lt;yy;j++)            res=(res+(1ll*dfs(i,j)*dfs(xx-i,yy-j))%MOD)%MOD;    return dp[x][y]=res;}int main(){    memset(dp,-1,sizeof(dp));    dp[1][1]=1;//    for(int i=1;i&lt;=50;i++){//        printf(&quot;{&quot;);//        for(int j=1;j&lt;50;j++)  printf(&quot;%9lld,&quot;,dp[i][j]);//        printf(&quot;%9lld},\n&quot;,dp[i][50]);//    }    int n,m;    while(~scanf(&quot;%d%d&quot;,&amp;n,&amp;m)) {//        if(n&lt;1||n&gt;100||m&lt;1||m&gt;100) while(true);        printf(&quot;%lld\n&quot;,dfs(n,m));    }    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  2017年第0届浙江工业大学之江学院程序设计竞赛决赛 L qwb与整数对 [离线]【思维】</title>
      <link href="/2017/06/03/72849794/"/>
      <url>/2017/06/03/72849794/</url>
      
        <content type="html"><![CDATA[<h1 id="2017年第0届浙江工业大学之江学院程序设计竞赛决赛-L-qwb与整数对-离线-【思维】"><a href="#2017年第0届浙江工业大学之江学院程序设计竞赛决赛-L-qwb与整数对-离线-【思维】" class="headerlink" title="2017年第0届浙江工业大学之江学院程序设计竞赛决赛 L: qwb与整数对 [离线]【思维】"></a>2017年第0届浙江工业大学之江学院程序设计竞赛决赛 L: qwb与整数对 [离线]【思维】</h1><p>2017年06月03日 02:55:21  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：632</p><hr><p> 博客爬取于<code>2019-04-18 17:16:17</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/72849794" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/72849794</a></p><p>题目链接: <a href="http://115.231.222.240:8081/JudgeOnline/problem.php?cid=1005&amp;pid=11" target="_blank" rel="noopener"> http://115.231.222.240:8081/JudgeOnline/problem.php?cid=1005&amp;pid=11</a><br>——————————————————————————————————————————<br>Problem L: qwb与整数对<br>Time Limit: 1 Sec Memory Limit: 128 MB<br>Submit: 171 Solved: 18<br>[Submit][Status][Web Board]<br>Description<br>qwb又遇到了一道数学难题，你能帮助他吗？</p><p>给出两个整数n和m，请统计满足0＜a＜b＜n并且使得 (a2+b2+m)/(ab) 的结果是整数的整数对(a,b)的个数。</p><p>Input<br>本题包含多组测试例 。当测试例数据是n=m=0时，表示输入结束。（测试例数量&lt;6000）</p><p>每个测试例一行，是两个整数n和m。输入保证0≤n≤1000，-20000&lt; m&lt; 20000。</p><p>Output<br>对每个测试例，输出测试例的编号（Case X:Y） 以及满足上述要求的整数对(a,b)的个数，输出格式如样例输出所示。</p><p>Sample Input<br>10 1<br>20 3<br>30 4<br>0 0<br>Sample Output<br>Case 1: 2<br>Case 2: 4<br>Case 3: 5<br>——————————————————————————————————————————</p><p>在线的复杂度实在不科学</p><p>看dalao离线做了,我也做了下</p><p>离线之后n^2枚举到每个位置计算贡献的时候类似筛法只要找(i*j)的倍数就好了</p><p>然后记下这个时候的值询问,满足n的情况就ans++</p><p>感觉没有代码直观啊.</p><p>附本题代码<br>——————————————————————————————————————————</p><p>​    </p><pre><code>#include &lt;bits/stdc++.h&gt;typedef long long int LL;using namespace std;int n[6666],m[6666],ans[6666];vector&lt;int&gt;vc[44444];int main(){    for(int i=1;~scanf(&quot;%d%d&quot;,&amp;n[i],&amp;m[i])&amp;&amp;(n[i]||m[i]);i++){        vc[m[i]+20000].push_back(i);    }    for(int i=1;i&lt;=1000;i++){        for(int j=i+1;j&lt;=1000;j++){            int x=(i*j)-(i*i+j*j)%(i*j);            for(int k=x;k&lt;=20000;k+=i*j){                int vcz=vc[k+20000].size();                for(int u=0;u&lt;vcz;u++){                    if(n[vc[k+20000][u]]&gt;j)                        ans[vc[k+20000][u]]++;                }            }            for(int k=x-i*j;k&gt;=-20000;k-=i*j){                int vcz=vc[k+20000].size();                for(int u=0;u&lt;vcz;u++){                    if(n[vc[k+20000][u]]&gt;j)                        ans[vc[k+20000][u]]++;                }            }        }    }    for(int i=1;(n[i]||m[i]);i++)  printf(&quot;Case %d: %d\n&quot;,i,ans[i]);    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  2017年第0届浙江工业大学之江学院程序设计竞赛决赛 K qwb与小数 [快速幂]【思维】</title>
      <link href="/2017/06/03/72849793/"/>
      <url>/2017/06/03/72849793/</url>
      
        <content type="html"><![CDATA[<h1 id="2017年第0届浙江工业大学之江学院程序设计竞赛决赛-K-qwb与小数-快速幂-【思维】"><a href="#2017年第0届浙江工业大学之江学院程序设计竞赛决赛-K-qwb与小数-快速幂-【思维】" class="headerlink" title="2017年第0届浙江工业大学之江学院程序设计竞赛决赛 K: qwb与小数 [快速幂]【思维】"></a>2017年第0届浙江工业大学之江学院程序设计竞赛决赛 K: qwb与小数 [快速幂]【思维】</h1><p>2017年06月03日 02:50:11  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：356</p><hr><p> 博客爬取于<code>2019-04-18 17:16:18</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/72849793" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/72849793</a></p><p>题目链接： <a href="http://115.231.222.240:8081/JudgeOnline/problem.php?cid=1005&amp;pid=10" target="_blank" rel="noopener"> http://115.231.222.240:8081/JudgeOnline/problem.php?cid=1005&amp;pid=10</a><br>——————————————————————————————————————————<br>Problem K: qwb与小数<br>Time Limit: 1 Sec Memory Limit: 128 MB<br>Submit: 382 Solved: 71<br>[Submit][Status][Web Board]<br>Description<br>qwb遇到了一个问题：将分数a/b化为小数后，小数点后第n位的数字是多少？</p><p>做了那么多题，我已经不指望你能够帮上他了。。。</p><p>Input<br>多组测试数据，处理到文件结束。（测试数据&lt;=100000组）</p><p>每组测试例包含三个整数a，b，n，相邻两个数之间用单个空格隔开，其中0 &lt;= a &lt;1e9，0 &lt; b &lt; 1e9，1 &lt;= n &lt; 1e9。</p><p>Output<br>对于每组数据，输出a/b的第n位数，占一行。<br>Sample Input<br>1 2 1<br>1 2 2<br>Sample Output<br>5<br>0<br>HINT<br>——————————————————————————————————————————</p><p>在dalao们的帮助下，会了</p><p>a<em>10^(n-1)%b</em>10/b;<br>a<em>10^(n-1)%b前面留在其他位的都不影响结果<br>最后</em>10/b也就是我们要的结果了</p><p>其实没后面一位就是a*10/b 做了n次而已</p><p>附本题代码<br>——————————————————————————————————————————</p><p>​    </p><pre><code>#include&lt;bits/stdc++.h&gt;typedef long long int LL;using namespace std;const int N = 8000000+7;//const int MOD = 1e9+7;const double Pi = acos(-1.0);int read(){    int x=0,f=1;char ch= getchar();    while(&#39;0&#39;&gt;ch||ch&gt;&#39;9&#39;){if(ch==&#39;-&#39;)f=-1;ch=getchar();}    while(&#39;0&#39;&lt;=ch&amp;&amp;ch&lt;=&#39;9&#39;){x=(x&lt;&lt;3)+(x&lt;&lt;1)+ch-&#39;0&#39;;ch=getchar();}    return x*f;}/******************************/LL MOD,x,n;LL qmod(LL a,LL b){    LL res = 1ll;    while(b){        if(b&amp;1) res=res*a%MOD;        b&gt;&gt;=1,a=a*a%MOD;    }    return res;}int main(){    while(~scanf(&quot;%lld%lld%lld&quot;,&amp;x,&amp;MOD,&amp;n)){        printf(&quot;%lld\n&quot;,(x%MOD*qmod(10,n-1))%MOD*10/MOD);    }    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  2017年第0届浙江工业大学之江学院程序设计竞赛决赛 J qwb又偷懒了 [BIT]【数据结构】</title>
      <link href="/2017/06/03/72849792/"/>
      <url>/2017/06/03/72849792/</url>
      
        <content type="html"><![CDATA[<h1 id="2017年第0届浙江工业大学之江学院程序设计竞赛决赛-J-qwb又偷懒了-BIT-【数据结构】"><a href="#2017年第0届浙江工业大学之江学院程序设计竞赛决赛-J-qwb又偷懒了-BIT-【数据结构】" class="headerlink" title="2017年第0届浙江工业大学之江学院程序设计竞赛决赛 J: qwb又偷懒了 [BIT]【数据结构】"></a>2017年第0届浙江工业大学之江学院程序设计竞赛决赛 J: qwb又偷懒了 [BIT]【数据结构】</h1><p>2017年06月03日 02:44:15  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：554</p><hr><p> 博客爬取于<code>2019-04-18 17:16:19</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/72849792" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/72849792</a></p><p>题目链接： <a href="http://115.231.222.240:8081/JudgeOnline/problem.php?cid=1005&amp;pid=9" target="_blank" rel="noopener"> http://115.231.222.240:8081/JudgeOnline/problem.php?cid=1005&amp;pid=9</a><br>——————————————————————————————————————————<br>Problem J: qwb又偷懒了<br>Time Limit: 1 Sec Memory Limit: 128 MB<br>Submit: 599 Solved: 93<br>[Submit][Status][Web Board]<br>Description<br>qwb最近在做一个群众收入统计。ta非常懒，以至于忘记了今天领导要来视察。所以急忙催下属去做统计。<br>在接下来长度为n的时间里,每个单位时间都有事情发生,可能会发下以下两种事件：</p><p>1)下属递交了一份调查报告，由于太匆忙，上面只有一个整数x，代表一个居民的收入。<br>2)领导来视察了，领导会来询问，收入在区间[l,r]内的居民的平均收入，qwb需要给出回答。</p><p>qwb非常讨厌小数，所以qwb上报时都会省略小数部分。如果上报时统计的人数为0，qwb就暴露了他偷懒的事情，他就会zhizhiwuwu。<br>Input<br>多组测试数据，处理到文件末尾。</p><p>每组测试数据的第一行为一个正整数n(0&lt;=100000),确保所有的n的和不超过300000</p><p>接下来n行，<br>当第一个数为0时，代表操作1，后面跟着一个整数x(0&lt;=x&lt;=1000000)，意义如题目所述。<br>当第一个数为1时，代表操作2，后面跟着两个整数l，r(0&lt;=l&lt;=r&lt;=1000000)，意义如题目描述。</p><p>Output<br>对于每一个领导的询问，给出一个回答，如果统计区间的人数为零，则输出”zhizhiwuwu”。（不带引号）<br>每个测试例之后输出一个空行。<br>Sample Input<br>3<br>0 1<br>0 3<br>1 1 3<br>2<br>0 1<br>1 2 2<br>Sample Output<br>2</p><p>zhizhiwuwu</p><p>HINT</p><p>输入输出包含大规模数据,建议使用scanf,printf.</p><p>样例1中，收入为1的居民有一个，收入为3的居民有1个，所以收入在1-3范围内的居民有2个，总收入是4，4/2=2<br>——————————————————————————————————————————</p><p>BIT入门级别 没啥说的<br>数据范围小，直接两个BIT就好<br>其实1个就够了，另一个主要是记录0的个数，，，我也没注意这里wa了一发</p><p>附本题代码<br>——————————————————————————————————————————</p><p>​    </p><pre><code>#include &lt;bits/stdc++.h&gt;typedef long long int LL;using namespace std;#define abs(x) (((x)&gt;0)?(x):-(x))const int N = 1000000+10;const int MOD  = 1e9+7;/******************************************/LL sum[N][2];#define lowbit(x) (x&amp;-x)void update(int i,int v){for(i++;i&lt;N;i+=lowbit(i))sum[i][0]+=v,sum[i][1]+=1;}LL getSum(int i){LL ans=0;for(i++;i;i-=lowbit(i))ans+=sum[i][0];return ans;}LL getCnt(int i){LL ans=0;for(i++;i;i-=lowbit(i))ans+=sum[i][1];return ans;}LL n,op,l,r,x;int main(){    while(~scanf(&quot;%lld&quot;,&amp;n)){        memset(sum,0,sizeof(sum));        for(int i=1;i&lt;=n;i++){            scanf(&quot;%lld&quot;,&amp;op);            if(op){                scanf(&quot;%lld%lld&quot;,&amp;l,&amp;r);                LL cnt = getCnt(r)-getCnt(l-1);                LL ans = getSum(r)-getSum(l-1);//                cout&lt;&lt;ans&lt;&lt;&#39; &#39;&lt;&lt;cnt&lt;&lt;endl;                if(cnt==0) puts(&quot;zhizhiwuwu&quot;);                else       printf(&quot;%lld\n&quot;,ans/cnt);            }            else {                scanf(&quot;%lld&quot;,&amp;x);                update(x,x);            }        }        puts(&quot;&quot;);    }    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  2017年第0届浙江工业大学之江学院程序设计竞赛决赛 I qwb VS 去污棒 [可持久化01字典树]【数据结构】</title>
      <link href="/2017/06/03/72849787/"/>
      <url>/2017/06/03/72849787/</url>
      
        <content type="html"><![CDATA[<h1 id="2017年第0届浙江工业大学之江学院程序设计竞赛决赛-I-qwb-VS-去污棒-可持久化01字典树-【数据结构】"><a href="#2017年第0届浙江工业大学之江学院程序设计竞赛决赛-I-qwb-VS-去污棒-可持久化01字典树-【数据结构】" class="headerlink" title="2017年第0届浙江工业大学之江学院程序设计竞赛决赛 I: qwb VS 去污棒 [可持久化01字典树]【数据结构】"></a>2017年第0届浙江工业大学之江学院程序设计竞赛决赛 I: qwb VS 去污棒 [可持久化01字典树]【数据结构】</h1><p>2017年06月03日 02:41:12  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：955<br>标签：  <a href="https://so.csdn.net/so/search/s.do?q=数据结构&amp;t=blog" target="_blank" rel="noopener"> 数据结构 </a></p><p>个人分类：  <a href="https://blog.csdn.net/qq_33184171/article/category/6362428" target="_blank" rel="noopener"> ==== 数据结构 ====</a></p><hr><p> 博客爬取于<code>2019-04-18 17:16:20</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/72849787" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/72849787</a></p><p>题目链接： <a href="http://115.231.222.240:8081/JudgeOnline/problem.php?cid=1005&amp;pid=8" target="_blank" rel="noopener"> http://115.231.222.240:8081/JudgeOnline/problem.php?cid=1005&amp;pid=8</a><br>——————————————————————————————————————————<br>Problem I: qwb VS 去污棒<br>Time Limit: 2 Sec Memory Limit: 256 MB<br>Submit: 74 Solved: 26<br>[Submit][Status][Web Board]<br>Description<br>qwb表白学姐失败后，郁郁寡欢，整天坐在太阳底下赏月。在外人看来，他每天自言自语，其实他在和自己的影子“去污棒”聊天。<br>去污棒和qwb互相出题考验对方，去污棒问了qwb这样一个问题：<br>现已知一个有n个正整数的序列a[1],a[2]…a[n],接下来有m个操作<br>操作一共有两种：</p><p>1.在序列末尾添加一个数x。</p><p>2.查询suf[p] xor x的最大值，其中xor是异或 ,l&lt;=p&lt;=r，<br>suf[t]表示从t开始的后缀的异或和，即suf[t]=a[t] xor a[t+1] xor …xor a[len]，len为序列长度。</p><p>Input<br>第一行一个整数T(&lt;=5)，表示一共有T组数据。</p><p>每组数据第一行两个整数n(&lt;=200000),m(&lt;=200000)，意义如上所述。</p><p>随后一行有n个数，表示初始序列。<br>随后m行，每行表示一个操作。<br>操作有两种，1： x 表示在末尾添加一个x，2： l r x表示查询suf[p] xor x的最大值，其中l&lt;= p &lt;= r，<br>所有数及x不超过224 且保证所有操作合法。<br>Output<br>每组测试数据的第一行输出”Case x:”，x为数据组数的标号，从1开始。</p><p>接下来，对每个操作2输出一行答案。</p><p>Sample Input<br>1<br>5 5<br>1 2 3 4 5<br>2 1 3 4<br>1 10<br>1 7<br>2 4 4 5<br>2 1 5 19<br>Sample Output<br>Case 1:<br>6<br>9<br>31<br>——————————————————————————————————————————</p><p>以下是边做题时边写的</p><blockquote><p>可持久化Trie 离线，维护后缀异或和 然后在区间上进行查找<br>其实通过消去率能将suffix变成前缀，不对么</p></blockquote><blockquote></blockquote><blockquote><p>yes</p></blockquote><blockquote></blockquote><blockquote><p>假如序列长度为 n</p></blockquote><blockquote></blockquote><blockquote><p>那么prexor[n]^prexor[k] = suf[k+1]; 所以在线就好了；</p></blockquote><blockquote></blockquote><blockquote><p>可持久化01字典树，那就用一个可持久化线段树来实现，怎么搞呢。</p></blockquote><blockquote></blockquote><blockquote><p>算了还是先改了别人的吧。。。</p></blockquote><p>异或最大值就想到了01trie</p><p>但是限制区间所以要可持久化</p><p>可持久化01字典树可以借鉴主席树来写,</p><p>但是我这个最后被卡常了,加了读入挂才AC</p><p>附本题代码<br>——————————————————————————————————————————</p><p>​    </p><pre><code>#include &lt;bits/stdc++.h&gt;typedef long long int LL;using namespace std;#define abs(x) (((x)&gt;0)?(x):-(x))const int N = 400000+10;const int MOD  = 1e8;int read(){    int x=0;char ch = getchar();    while(&#39;0&#39;&gt;ch||ch&gt;&#39;9&#39;)ch=getchar();    while(&#39;0&#39;&lt;=ch&amp;&amp;ch&lt;=&#39;9&#39;){x=(x&lt;&lt;3)+(x&lt;&lt;1)+ch-&#39;0&#39;;ch=getchar();}    return x;}/**********************************/int trie[N*40][2],sz[N*40],rt[N];int n,m,cnt,sum;char s[10];int update(int pre,int i,int x){    int now=++cnt;    if(0==i){        trie[now][0]=trie[now][1]=0;        sz[now]=sz[pre]+1;        return now;    }    int bt=((x&gt;&gt;(i-1))&amp;1);    trie[now][1-bt]=trie[pre][1-bt];    trie[now][bt]=update(trie[pre][bt],i-1,x);    sz[now]=sz[trie[now][0]]+sz[trie[now][1]];    return now;}int query(int rt1,int rt2,int i,int x){    if (i==0) return 0;    int bt=((x&gt;&gt;(i-1))&amp;1);    if (sz[trie[rt2][1-bt]]-sz[trie[rt1][1-bt]])        return (1&lt;&lt;(i-1))+query(trie[rt1][1-bt],trie[rt2][1-bt],i-1,x);    else        return query(trie[rt1][bt],trie[rt2][bt],i-1,x);}int main(){    int _=read(),kcase=0;    while(_--){        n=read(),m=read();        rt[0]=trie[0][0]=trie[0][1]=sz[0]=sum=0;        rt[0]=update(rt[0],25,0);        for (int i=1;i&lt;=n;i++){            sum^=read();            rt[i]=update(rt[i-1],25,sum);        }        printf(&quot;Case %d:\n&quot;,++kcase);        while (m--){            int l,r;            scanf(&quot;%s&quot;,s+1);            if (s[1]==&#39;1&#39;){                sum^=read();                n++;rt[n]=update(rt[n-1],25,sum);            }            else{                l=read()-1,r=read()-1;                printf(&quot;%d\n&quot;,query(rt[l-1],rt[r],25,sum^read()));            }        }    }    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  2017年第0届浙江工业大学之江学院程序设计竞赛决赛 H qwb与学姐 [MST+LCA]【数据结构】</title>
      <link href="/2017/06/03/72849743/"/>
      <url>/2017/06/03/72849743/</url>
      
        <content type="html"><![CDATA[<h1 id="2017年第0届浙江工业大学之江学院程序设计竞赛决赛-H-qwb与学姐-MST-LCA-【数据结构】"><a href="#2017年第0届浙江工业大学之江学院程序设计竞赛决赛-H-qwb与学姐-MST-LCA-【数据结构】" class="headerlink" title="2017年第0届浙江工业大学之江学院程序设计竞赛决赛 H: qwb与学姐 [MST+LCA]【数据结构】"></a>2017年第0届浙江工业大学之江学院程序设计竞赛决赛 H: qwb与学姐 [MST+LCA]【数据结构】</h1><p>2017年06月03日 02:36:00  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：606</p><hr><p> 博客爬取于<code>2019-04-18 17:16:21</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/72849743" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/72849743</a></p><p>题目链接： <a href="http://115.231.222.240:8081/JudgeOnline/problem.php?cid=1005&amp;pid=7" target="_blank" rel="noopener"> http://115.231.222.240:8081/JudgeOnline/problem.php?cid=1005&amp;pid=7</a><br>——————————————————————————————————————————<br>Problem H: qwb与学姐<br>Time Limit: 1 Sec Memory Limit: 128 MB<br>Submit: 113 Solved: 44<br>[Submit][Status][Web Board]<br>Description<br>qwb打算向学姐表白，可是学姐已经受够了他的骚扰，于是出了一个题想难住他:<br>已知一幅n个点m条边的无向图,定义路径的值为这条路径上最短的边的长度，<br>现在有 k个询问，<br>询问从A点到B点的所有路径的值的最大值。<br>qwb听完这个问题很绝望啊,聪明的你能帮帮他吗?<br>Input<br>一组数据。<br>第一行三个整数n，m，k (1&lt;=N&lt;=50000,m&lt;=200000,k&lt;=100000)。<br>第2..m+1行：三个正整数：X, Y, and D (1 &lt;= X &lt;=N; 1 &lt;= Y &lt;= N,1&lt;=D&lt;=215)<br>表示X与Y之间有一条长度为D的边。<br>第m+2..m+k+1行： 每行两个整数A B(1&lt;=A,B&lt;=n且A≠B)，意义如题目描述。<br>保证图连通。<br>Output<br>对于每个询问输出一行，一共k行，每行输出A点到B点的所有路径的值的最大值。<br>Sample Input<br>4 5 3<br>1 2 6<br>1 3 8<br>2 3 4<br>2 4 5<br>3 4 7<br>2 3<br>1 4<br>3 4<br>Sample Output<br>6<br>7<br>7<br>——————————————————————————————————————————</p><p>他要找所有路径的最大值,那么我只需要留校路径最大的那个就好了</p><p>这里有一个贪心策略,就是最大生成树,<br>这样能保证,两点间在图上其他的路径的值都小于最大生成树的</p><p>然后问题就是如何求两点间路径最小值了</p><p>最开始写了个树剖,发现由于是边权在维护的时候lca位置不好维护<br>于是GG,在提示下学习了倍增求lca</p><p>知识点不介绍了,</p><p>因为同样是变成了点权<br>我们只需要求路径最小的时候变成两个路径的最小值,非别是(u,x(fa[x]=lca)),(v,y(fa[y]=lca))</p><p>这样下来就好办多了,找到lca之后维护最小值就好了</p><p>附本题代码<br>——————————————————————————————————————————</p><p>​    </p><pre><code>#include&lt;bits/stdc++.h&gt;typedef long long int LL;using namespace std;const int N = 50000+7;const int MOD = 1e9+7;const int INF = (~(1&lt;&lt;31));const double Pi = acos(-1.0);int read(){    int x=0,f=1;char ch= getchar();    while(&#39;0&#39;&gt;ch||ch&gt;&#39;9&#39;){if(ch==&#39;-&#39;)f=-1;ch=getchar();}    while(&#39;0&#39;&lt;=ch&amp;&amp;ch&lt;=&#39;9&#39;){x=(x&lt;&lt;3)+(x&lt;&lt;1)+ch-&#39;0&#39;;ch=getchar();}    return x*f;}/*****************************/int n,m,k;vector&lt;pair&lt;int,int&gt; &gt;G[N];void add(int u,int v,int w){    G[u].push_back(make_pair(v,w));    G[v].push_back(make_pair(u,w));}struct node {    int u,v,w;}e[N*4];bool cmp(node a,node b){    return a.w&gt;b.w;}/*****************************/int pre[N];int findi(int x){    int r=x;    while(r!=pre[r])r=pre[r];    int i=x,j;    while(i!=r){        j=pre[i];        pre[i]=r;        i=j;    }    return r;}void join(int x,int y){    int fx=findi(x),fy=findi(y);    pre[fx]=fy;}void MST(){    for(int i=1,sum=0;i&lt;=m&amp;&amp;sum&lt;n-1;i++){        if(findi(e[i].u)==findi(e[i].v)) continue;        join(e[i].u,e[i].v);        add(e[i].u,e[i].v,e[i].w);        sum++;    }}/*****************************/int fa[N][20],dep[N],mi[N][20];void dfs(int u,int f,int d){    fa[u][0]=f;dep[u]=d;    for(int i=1;i&lt;20;i++)        fa[u][i]=fa[fa[u][i-1]][i-1],mi[u][i]=min(mi[u][i-1],mi[fa[u][i-1]][i-1]);    int gz=G[u].size();    for(int i=0,to;i&lt;gz;i++){        to=G[u][i].first;        if(to==f)continue;        mi[to][0]=G[u][i].second;        dfs(to,u,d+1);    }}void solve(int u,int v){    if(dep[u]&lt;dep[v]) swap(u,v);    int lca=-1,tu=u,tv=v;    for(int i=19;i&gt;=0;i--)        if(dep[fa[u][i]]&gt;=dep[v])            u=fa[u][i];    if(u==v) lca=v;// return v;    else{        for(int i=19;i&gt;=0;i--){            if(fa[u][i]==fa[v][i]) continue;            u=fa[u][i];            v=fa[v][i];        }        lca = fa[v][0];//return fa[v][0];    }//    cout&lt;&lt;lca&lt;&lt;&quot;  &quot;;    int miu=INF,miv=INF;    for(int i=19;i&gt;=0;i--){        if(dep[fa[tu][i]]&gt;=dep[lca])            miu=min(miu,mi[tu][i]),tu=fa[tu][i];        if(dep[fa[tv][i]]&gt;=dep[lca])            miv=min(miv,mi[tv][i]),tv=fa[tv][i];    }    //miu=min(miu,mi[tu][0]),miv=min(miv,mi[tv][0]);    printf(&quot;%d\n&quot;,min(miu,miv));}/*****************************/void init(){    for(int i=1;i&lt;=n;i++) pre[i]=i;    memset(mi,0x7f,sizeof(mi));}int main(){    while(~scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;k)){        init();        for(int i=1;i&lt;=m;i++)    scanf(&quot;%d%d%d&quot;,&amp;e[i].u,&amp;e[i].v,&amp;e[i].w);        sort(e+1,e+m+1,cmp);        MST();        dfs(1,0,1);//        for(int i=1;i&lt;=n;i++){//            printf(&quot;%d: &quot;,i);//            for(int j=0;j&lt;20;j++)//                printf(&quot;%d &quot;,mi[i][j]);//            puts(&quot;&quot;);//        }        for(int u,v;k--;){            scanf(&quot;%d%d&quot;,&amp;u,&amp;v);            solve(u,v);        }    }    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  2017年第0届浙江工业大学之江学院程序设计竞赛决赛 G qwb去面试 [找规律]【思维】</title>
      <link href="/2017/06/03/72849668/"/>
      <url>/2017/06/03/72849668/</url>
      
        <content type="html"><![CDATA[<h1 id="2017年第0届浙江工业大学之江学院程序设计竞赛决赛-G-qwb去面试-找规律-【思维】"><a href="#2017年第0届浙江工业大学之江学院程序设计竞赛决赛-G-qwb去面试-找规律-【思维】" class="headerlink" title="2017年第0届浙江工业大学之江学院程序设计竞赛决赛 G: qwb去面试 [找规律]【思维】"></a>2017年第0届浙江工业大学之江学院程序设计竞赛决赛 G: qwb去面试 [找规律]【思维】</h1><p>2017年06月03日 02:27:50  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：550</p><p>个人分类：  <a href="https://blog.csdn.net/qq_33184171/article/category/6253262" target="_blank" rel="noopener"> 思维 </a></p><hr><p> 博客爬取于<code>2019-04-18 17:16:22</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/72849668" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/72849668</a></p><p>题目链接： <a href="http://115.231.222.240:8081/JudgeOnline/problem.php?cid=1005&amp;pid=6" target="_blank" rel="noopener"> http://115.231.222.240:8081/JudgeOnline/problem.php?cid=1005&amp;pid=6</a><br>——————————————————————————————————————————<br>Problem G: qwb去面试<br>Time Limit: 1 Sec Memory Limit: 128 MB<br>Submit: 1627 Solved: 260<br>[Submit][Status][Web Board]<br>Description<br>某一天，qwb去WCfun面试，面试官问了他一个问题：把一个正整数n拆分成若干个正整数的和，请求出这些数乘积的最大值。<br>qwb比较猥琐，借故上厕所偷偷上网求助，聪明的你能帮助他吗?<br>Input<br>第一行为一个正整数T.(T&lt;=100000)<br>接下来T行，每行一个正整数n(n&lt;=1e9)，意义如题目所述。<br>Output<br>每一行输出一个整数，表示乘积的最大值，由于答案可能很大，请将答案对109+7取模后输出。<br>Sample Input<br>2<br>2<br>5<br>Sample Output<br>2<br>6<br>HINT<br>2=2<br>5=2+3<br>——————————————————————————————————————————</p><p>一定是素数的成绩会最大</p><p>最开始以为要素因子展开，然后发现，不对，<br>2<em>2</em>2&lt;3*3<br>然后就发现了是尽可能的拆成3<br>余1就将一个变成4<br>余2就在乘2</p><p>应该有严谨的证明之类的吧，但是我不会。</p><p>附本题代码<br>——————————————————————————————————————————</p><p>​    </p><pre><code>#include &lt;bits/stdc++.h&gt;typedef long long int LL;using namespace std;#define abs(x) (((x)&gt;0)?(x):-(x))const int N = 3000+10;const int MOD  = 1e9+7;/******************************************/LL qmod(LL a,LL b){    LL res = 1;    while(b){        if(b&amp;1) res=res*a%MOD;        b&gt;&gt;=1,a=a*a%MOD;    }    return res;}int main(){    qmod(3,0);    int _;    LL x,y,n;    scanf(&quot;%d&quot;,&amp;_);    while(_--){        scanf(&quot;%lld&quot;,&amp;n);        if(n&lt;5){            printf(&quot;%d\n&quot;,n);            continue;        }        x=n/3;        y=n%3;        if(y==1) x--,y=4;        if(y==0) y=1;        printf(&quot;%lld\n&quot;,qmod(3,x)*y%MOD);    }    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 思维 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  2017年第0届浙江工业大学之江学院程序设计竞赛决赛 F qwb has a lot of Coins [nim]【博弈】</title>
      <link href="/2017/06/03/72849663/"/>
      <url>/2017/06/03/72849663/</url>
      
        <content type="html"><![CDATA[<h1 id="2017年第0届浙江工业大学之江学院程序设计竞赛决赛-F-qwb-has-a-lot-of-Coins-nim-【博弈】"><a href="#2017年第0届浙江工业大学之江学院程序设计竞赛决赛-F-qwb-has-a-lot-of-Coins-nim-【博弈】" class="headerlink" title="2017年第0届浙江工业大学之江学院程序设计竞赛决赛 F: qwb has a lot of Coins [nim]【博弈】"></a>2017年第0届浙江工业大学之江学院程序设计竞赛决赛 F: qwb has a lot of Coins [nim]【博弈】</h1><p>2017年06月03日 02:22:20  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：371</p><hr><p> 博客爬取于<code>2019-04-18 17:16:24</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/72849663" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/72849663</a></p><p>题目链接： <a href="http://115.231.222.240:8081/JudgeOnline/problem.php?cid=1005&amp;pid=5" target="_blank" rel="noopener"> http://115.231.222.240:8081/JudgeOnline/problem.php?cid=1005&amp;pid=5</a><br>——————————————————————————————————————————<br>Problem F: qwb has a lot of Coins<br>Time Limit: 1 Sec Memory Limit: 128 MB<br>Submit: 699 Solved: 220<br>[Submit][Status][Web Board]<br>Description<br>qwb has a lot of coins. One day, he decides to play a game with his friend<br>using these coins. He first puts some of his coins into M piles, each of which<br>is composed of Ni (1&lt;=i&lt;=M) coins. Then, the two players play the coin game in<br>turns. Every step, one can remove one or more coins from only one pile. The<br>winner is the one who removes the last coin.<br>Then comes the question: How many different ways the first player can do that<br>will ensure him win the game?<br>Input<br>Input contains multiple test cases till the end of file. Each test case starts<br>with a number M (1 &lt;= M&lt;= 1000) meaning the number of piles. The next line<br>contains M integers Ni (1 &lt;= Ni &lt;= 1e9, 1 &lt;= i&lt;= M) indicating the number of<br>coins in pile i.<br>Output<br>For each case, put the method count in one line.<br>If the first player can win the game, the method count is the number of<br>different ways that he can do to ensure him win the game, otherwise zero.<br>Sample Input<br>3<br>1 2 3<br>1<br>1<br>Sample Output<br>0<br>1<br>——————————————————————————————————————————<br>题意：就是问你Nim游戏先手第一步能赢的方案数</p><hr><p>显然就是然你模拟下Nim游戏呗，如果第一步选当前堆能赢就++，</p><p>能赢就是这个堆的石子个数大于其他堆得石子个数异或和</p><p>简单nim游戏不解释</p><p>虽然给了1000，但是这题是可以预处理前后缀异或和达到O(n)的</p><p>附本题代码<br>——————————————————————————————————————————</p><p>​    </p><pre><code>#include &lt;bits/stdc++.h&gt;typedef long long int LL;using namespace std;#define abs(x) (((x)&gt;0)?(x):-(x))const int N = 3000+10;const int MOD  = 1e8;/******************************************/int n;int a[1111];int pre[1111],suf[1111];int main(){    while(~scanf(&quot;%d&quot;,&amp;n)){        pre[0]=suf[n+1]=0;        for(int i=1;i&lt;=n;i++){            scanf(&quot;%d&quot;,&amp;a[i]);            pre[i]=pre[i-1]^a[i];        }        for(int i=n;i;i--)            suf[i]=suf[i+1]^a[i];        int cnt=0;        for(int i=1;i&lt;=n;i++){//            printf(&quot;%d : %d %d\n&quot;,i,a[i],(pre[i-1]^suf[i+1]));            if(a[i]&gt;(pre[i-1]^suf[i+1])) cnt++;        }        printf(&quot;%d\n&quot;,cnt);    }    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  2017年第0届浙江工业大学之江学院程序设计竞赛决赛 E qwb和李主席 [折半枚举二分]【思维?套路！】</title>
      <link href="/2017/06/03/72849660/"/>
      <url>/2017/06/03/72849660/</url>
      
        <content type="html"><![CDATA[<h1 id="2017年第0届浙江工业大学之江学院程序设计竞赛决赛-E-qwb和李主席-折半枚举二分-【思维-套路！】"><a href="#2017年第0届浙江工业大学之江学院程序设计竞赛决赛-E-qwb和李主席-折半枚举二分-【思维-套路！】" class="headerlink" title="2017年第0届浙江工业大学之江学院程序设计竞赛决赛 E: qwb和李主席 [折半枚举二分]【思维?套路！】"></a>2017年第0届浙江工业大学之江学院程序设计竞赛决赛 E: qwb和李主席 [折半枚举二分]【思维?套路！】</h1><p>2017年06月03日 02:17:40  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：1036</p><hr><p> 博客爬取于<code>2019-04-18 17:16:25</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/72849660" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/72849660</a></p><p>题目链接： <a href="http://115.231.222.240:8081/JudgeOnline/problem.php?cid=1005&amp;pid=4" target="_blank" rel="noopener"> http://115.231.222.240:8081/JudgeOnline/problem.php?cid=1005&amp;pid=4</a><br>——————————————————————————————————————————<br>Problem E: qwb和李主席<br>Time Limit: 4 Sec Memory Limit: 128 MB<br>Submit: 391 Solved: 39<br>[Submit][Status][Web Board]<br>Description<br>qwb和李主席打算平分一堆宝藏，他们想确保分配公平，可惜他们都太懒了，你能帮助他们嘛？<br>Input<br>输入包含多组测试数据，处理到文件结束。</p><p>每组测试数据的第一行是一个正整数N(0 &lt;= N &lt;=36 )表示物品的总个数.。</p><p>接下来输入N个浮点数(最多精确到分)，表示每个物品的价值V（0&lt; V&lt;=1e9）。</p><p>Output<br>对于每组测试数据，输出能够使qwb和李主席各自所得到的物品的总价值之差的最小值（精确到分），每组测试数据输出占一行。</p><p>Sample Input<br>3 0.01 0.1 1<br>2 1 1<br>Sample Output<br>0.89<br>0.00<br>——————————————————————————————————————————</p><p>n=36，如果直接枚举的话超时</p><p>然后先到分成两部分进行枚举，先枚举出一部分的所有可能结果，然后枚举另一部分在这个部分二分找最优就好</p><p>找的时候要找加和最靠近total/2的，然后维护最小值就好了</p><p>讲道理说如果*100用整形处理比较美滋滋，但是wa到死，改成double直接ac。。。。</p><p>附本题代码<br>——————————————————————————————————————————</p><p>​    </p><pre><code>#include &lt;bits/stdc++.h&gt;typedef long long int LL;using namespace std;#define abs(x) (((x)&gt;0)?(x):-(x))const int N = 1000000+10;const int MOD = 1e9+7;const double INF = 1e18;/******************************************/double x[111];double a[111],b[111],c[(1&lt;&lt;20)+1];double tot,tmp,ans;int la,lb,lc;int n;double BS(){    int l=1,r=lc,mid,res=-1;    while(l&lt;=r){        mid = r+l &gt;&gt; 1;        if(c[mid]+tmp&gt;=tot/2.0)            res=mid,r=mid-1;        else l=mid+1;    }    if(res==-1) res=r;    return min(abs(tot-c[res]*2-tmp*2),abs(tot-c[res-1]*2-tmp*2));}int main(){    c[0]=INF;    while(~scanf(&quot;%d&quot;,&amp;n)){        la=lb=lc=tot=0.0,ans=INF;        for(int i=1;i&lt;=n;i++) scanf(&quot;%lf&quot;,&amp;x[i]);        for(int i=1;i&lt;=n;i++){            tot+=x[i];            if(i*2&lt;=n) a[la++]=x[i];            else       b[lb++]=x[i];        }        for(int i=0,j;i&lt;(1&lt;&lt;la);i++)            for(c[++lc]=0.0,j=0;j&lt;la;j++)                if(i&amp;(1&lt;&lt;j)) c[lc]+=a[j];        sort(c+1,c+lc+1);        for(int i=0,j;i&lt;(1&lt;&lt;lb);i++){            for(tmp=0.0,j=0;j&lt;lb;j++)                if(i&amp;(1&lt;&lt;j)) tmp+=b[j];            ans=min(ans,BS());        }        if(ans==0.0) ans=0.0;        printf(&quot;%.2f\n&quot;,ans);//        printf(&quot;%lld.%02lld\n&quot;,ans/100,ans%100);    }    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  2017年第0届浙江工业大学之江学院程序设计竞赛决赛 D qwb与神奇的序列 [矩阵]【数学】</title>
      <link href="/2017/06/03/72849656/"/>
      <url>/2017/06/03/72849656/</url>
      
        <content type="html"><![CDATA[<h1 id="2017年第0届浙江工业大学之江学院程序设计竞赛决赛-D-qwb与神奇的序列-矩阵-【数学】"><a href="#2017年第0届浙江工业大学之江学院程序设计竞赛决赛-D-qwb与神奇的序列-矩阵-【数学】" class="headerlink" title="2017年第0届浙江工业大学之江学院程序设计竞赛决赛 D: qwb与神奇的序列 [矩阵]【数学】"></a>2017年第0届浙江工业大学之江学院程序设计竞赛决赛 D: qwb与神奇的序列 [矩阵]【数学】</h1><p>2017年06月03日 02:12:15  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：699</p><hr><p> 博客爬取于<code>2019-04-18 17:16:26</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/72849656" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/72849656</a></p><p>题目链接： <a href="http://115.231.222.240:8081/JudgeOnline/problem.php?cid=1003&amp;pid=3" target="_blank" rel="noopener"> http://115.231.222.240:8081/JudgeOnline/problem.php?cid=1003&amp;pid=3</a><br>——————————————————————————————————————————<br>Problem D: qwb与神奇的序列<br>Time Limit: 1 Sec Memory Limit: 128 MB<br>Submit: 1107 Solved: 163<br>[Submit][Status][Web Board]<br>Description<br>qwb又遇到了一道题目：</p><p>有一个序列，初始时只有两个数x和y，之后每次操作时，在原序列的任意两个相邻数之间插入这两个数的和，得到新序列。举例说明：</p><p>初始：1 2<br>操作1次：1 3 2<br>操作2次：1 4 3 5 2<br>……<br>请问在操作n次之后，得到的序列的所有数之和是多少？<br>Input<br>多组测试数据，处理到文件结束（测试例数量&lt;=50000）。</p><p>输入为一行三个整数x，y，n，相邻两个数之间用单个空格隔开。（0 &lt;= x &lt;= 1e10, 0 &lt;= y &lt;= 1e10, 1 &lt; n &lt;= 1e10）。</p><p>Output<br>对于每个测试例，输出一个整数，占一行，即最终序列中所有数之和。<br>如果和超过1e8，则输出低8位。（前导0不输出，直接理解成%1e8）<br>Sample Input<br>1 2 2<br>Sample Output<br>15<br>——————————————————————————————————————————</p><p>先不管x，y的值是什么看看每次x，y对结果贡献多少？<br>定义（n，m）其中n为x的贡献，m为y的贡献 答案就是n<em>x+m</em>y</p><p>次数  fac  tot</p><p>0</p><p>(1,0)(0,1)</p><p>(1,1)</p><p>1</p><p>(1,0)(1,1)(0,1)</p><p>(2,2)</p><p>2</p><p>(1,0)(2,1)(1,1)(1,2)(0,1)</p><p>(5,5)</p><p>3</p><p>(1,0)(3,1)(2,1)(3,2)(1,1)(2,3)(1,2)(1,3)(0,1)</p><p>(14,14)</p><p>然后推出第3列的递推式  </p><p>a  i  =  a  i  −  1  ∗  3  −  1</p><p>由此构造矩阵  </p><p>[  a  i  a  i  +  1  ]  ×  [  3  1  0  1  ]  =  [  a  i  +  1  a  i  +  2<br>]</p><p>附本题代码<br>——————————————————————————————————————————</p><p>​    </p><pre><code>#include &lt;bits/stdc++.h&gt;typedef long long int LL;using namespace std;#define abs(x) (((x)&gt;0)?(x):-(x))const int N = 3000+10;const int MOD  = 1e8;const int M = 2;struct Matrix {    LL m[M][M];    void clear0(){        for(int i=0;i&lt;M;i++)            for(int j=0;j&lt;M;j++)                m[i][j]=0;    }    void clear1(){        for(int i=0;i&lt;M;i++)            for(int j=0;j&lt;M;j++)                m[i][j]=(i==j);    }    void display(){        for(int i=0;i&lt;M;i++){            for(int j=0;j&lt;M;j++)                printf(&quot;%lld &quot;,m[i][j]);            puts(&quot;&quot;);        }        puts(&quot;------&quot;);    }};Matrix operator * (Matrix &amp;a, Matrix &amp;b){    Matrix c;c.clear0();    for(int k=0;k&lt;M;k++)        for(int i=0;i&lt;M;i++)            for(int j=0;j&lt;M;j++)                c.m[i][j]=(c.m[i][j]+a.m[i][k]*b.m[k][j]+MOD)%MOD;    return c;}Matrix operator ^(Matrix &amp;a,LL b){    Matrix c;c.clear1();    while(b){        if(b&amp;1) c=c*a;        b&gt;&gt;=1,a=a*a;    }    return c;}Matrix a,b;LL x,y,n;void solve(){    a.clear0();b.clear0();    a.m[0][0]=1,a.m[0][1]=-1;    b.m[0][0]=3,b.m[0][1]=0;    b.m[1][0]=1,b.m[1][1]=1;    b=b^(n);    a=a*b;    printf(&quot;%lld\n&quot;,a.m[0][0]*(x+y)%MOD);}int main(){    while(~scanf(&quot;%lld%lld%lld&quot;,&amp;x,&amp;y,&amp;n))     solve();    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  2017年第0届浙江工业大学之江学院程序设计竞赛决赛 C 勤劳的ACgirls</title>
      <link href="/2017/06/03/72849551/"/>
      <url>/2017/06/03/72849551/</url>
      
        <content type="html"><![CDATA[<h1 id="2017年第0届浙江工业大学之江学院程序设计竞赛决赛-C-勤劳的ACgirls"><a href="#2017年第0届浙江工业大学之江学院程序设计竞赛决赛-C-勤劳的ACgirls" class="headerlink" title="2017年第0届浙江工业大学之江学院程序设计竞赛决赛 C: 勤劳的ACgirls"></a>2017年第0届浙江工业大学之江学院程序设计竞赛决赛 C: 勤劳的ACgirls</h1><p>2017年06月03日 01:51:32  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：531</p><hr><p> 博客爬取于<code>2019-04-18 17:16:27</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/72849551" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/72849551</a></p><p>题目链接: <a href="http://115.231.222.240:8081/JudgeOnline/problem.php?cid=1005&amp;pid=2" target="_blank" rel="noopener"> http://115.231.222.240:8081/JudgeOnline/problem.php?cid=1005&amp;pid=2</a><br>——————————————————————————————————————————<br>g输出请用%lld 参赛请加qq群160384471获取最新消息<br>Problem C: 勤劳的ACgirls<br>Time Limit: 1 Sec Memory Limit: 128 MB<br>Submit: 100 Solved: 39<br>[Submit][Status][Web Board]<br>Description<br>zjc的ACgirls队的队员最近比较忙，为了能够取得更好的比赛成绩，他们制定了一个m天a掉n题的计划，a掉一题可以是这m天的任何时候。<br>为了表示对acmer事业的热爱，队长wc要求每天必须至少要ac掉k题，这m天每天ac掉的题数可以用一个m元组表示。<br>设不同的m元组一共有c个，请问c的末尾有多少个0？（如果c是0，输出0）<br>Input<br>多组测试数据，处理到文件结束。（测试例数量&lt;=160000）</p><p>输入的每一行是一个测试例，分别是m、n和k（0&lt;=m,n,k&lt;=1e9），含义如前所述。</p><p>Output<br>每组测试例中m元组的数量的末尾0的个数，占一行。<br>Sample Input<br>3 11 0<br>3 11 1<br>999 99999 4<br>Sample Output<br>0<br>0<br>5<br>——————————————————————————————————————————</p><p>就是将n-m*k个题放到m天做，</p><p>就是简单的组合么,</p><p>在n+m-1个东西选m-1个 (-1的意思是挡板，将n个题分成m天)</p><p>结果就是</p><p>n  =  n  −  m  ∗  k  C  (  n  +  m  −  1  ,  m  −  1  )  =  (  n  +  m  −  1<br>)  !  (  n  )  !  ×  (  m  −  1  )  !</p><p>分别计算  (  n  +  m  −  1  )  !  ,  (  n  )  !  ,  (  m  −  1  )  !  中2,5的个数就好了</p><p>附本题代码<br>——————————————————————————————————————————</p><p>​    </p><pre><code>#include &lt;bits/stdc++.h&gt;typedef long long int LL;using namespace std;LL solve(LL x,int y){    LL sum = 0;    while(x){        x/=y;        sum+=x;    }    return sum;}LL n,m,k;int main(){    while(~scanf(&quot;%lld%lld%lld&quot;,&amp;m,&amp;n,&amp;k)){        n=n-m*k;        if(n&lt;=0) puts(&quot;0&quot;);        else{            LL sum =solve(n+m-1,5)-solve(n,5)-solve(m-1,5);            LL sum2=solve(n+m-1,2)-solve(n,2)-solve(m-1,2);            sum=min(sum,sum2);            sum=max(0ll,sum);            printf(&quot;%lld\n&quot;,sum);        }    }    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  2017年第0届浙江工业大学之江学院程序设计竞赛决赛 B qwb与矩阵</title>
      <link href="/2017/06/03/72849513/"/>
      <url>/2017/06/03/72849513/</url>
      
        <content type="html"><![CDATA[<h1 id="2017年第0届浙江工业大学之江学院程序设计竞赛决赛-B-qwb与矩阵"><a href="#2017年第0届浙江工业大学之江学院程序设计竞赛决赛-B-qwb与矩阵" class="headerlink" title="2017年第0届浙江工业大学之江学院程序设计竞赛决赛 B: qwb与矩阵"></a>2017年第0届浙江工业大学之江学院程序设计竞赛决赛 B: qwb与矩阵</h1><p>2017年06月03日 01:43:28  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：635</p><hr><p> 博客爬取于<code>2019-04-18 17:16:28</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/72849513" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/72849513</a></p><p>题目链接: <a href="http://115.231.222.240:8081/JudgeOnline/problem.php?cid=1005&amp;pid=1" target="_blank" rel="noopener"> http://115.231.222.240:8081/JudgeOnline/problem.php?cid=1005&amp;pid=1</a><br>———————————————————————————————————————<br>Problem B: qwb与矩阵<br>Time Limit: 2 Sec Memory Limit: 128 MB<br>Submit: 1030 Solved: 189<br>[Submit][Status][Web Board]<br>Description<br>做完了辣么多的数学题，qwb好好睡了一觉。但是他做了一个梦：</p><p>有一个n*m的矩阵，qwb在这个矩阵的左上角(1,1)，终点在右下角(n,m)。</p><p>每个格子中有小钱钱，也可能没有，还有可能是要交过路费的，并且行走方向必须是靠近终点的方向。<br>往下走一次只能走一格，往右走一次可以走一格也可以走到当前列数的倍数格。<br>比如当前格子是（x,y），那么可以移动到(x+1,y),(x,y+1)或者(x,y*k),其中k&gt;1。<br>qwb希望找到一种走法，使得到达右下角时他能够有最多的小钱钱。</p><p>你能帮助他吗？</p><p>Input<br>第一行是测试例数量 T （T&lt;=100），接下来是T组测试数据。<br>每组测试数据的第一行是两个整数n,m，分别表示行数和列数(1&lt;=n&lt;=20,1&lt;=m&lt;=10000)；<br>接下去给你一个n*m的矩阵，每个格子里有一个数字 k （-100&lt;=k&lt;=100）代表小钱钱的数量。 ∑nm&lt;=3,000,000</p><p>Output<br>每组数据一行，输出L先生能够获得小钱钱的最大值(可能为负数)。<br>Sample Input<br>1<br>3 8<br>9 10 10 10 10 -10 10 10<br>10 -11 -1 0 2 11 10 -20<br>-11 -11 10 11 2 10 -10 -10<br>Sample Output<br>52<br>HINT<br>————————————————————————————————————————</p><p>很明显的dp<br>dp[i][j]为到(i,j)位置时的最大值.</p><p>转移方程大家都会,但是如果暴力可能会超时</p><p>所以在考虑走倍数的时候采用类似筛法的方法转移就好了</p><p>附本题代码<br>————————————————————————————————————————</p><p>​    </p><pre><code>#include &lt;bits/stdc++.h&gt;typedef long long int LL;using namespace std;inline int read(){    int x=0,f=1;char ch=getchar();    while(&#39;0&#39;&gt;ch||ch&gt;&#39;9&#39;) {if(ch==&#39;-&#39;)f=-1;ch=getchar();}    while(&#39;0&#39;&lt;=ch&amp;&amp;ch&lt;=&#39;9&#39;){x=(x&lt;&lt;3)+(x&lt;&lt;1)+ch-&#39;0&#39;;ch=getchar();}    return x*f;}/**************************************/int n,m;int a[22][11111];int dp[22][11111];int main(){    int _=read();    while(_--){        n=read(),m=read();        for(int i=1;i&lt;=n;i++)            for(int j=1;j&lt;=m;j++)                a[i][j]=read(),dp[i][j]=-2000000000;        dp[1][1]=a[1][1];        for(int i=1;i&lt;=n;i++)            for(int j=1;j&lt;=m;j++){                if(i&gt;1)dp[i][j]=max(dp[i][j],dp[i-1][j]+a[i][j]);                if(j&gt;1)dp[i][j]=max(dp[i][j],dp[i][j-1]+a[i][j]);                for(int k=j+j;k&lt;=m;k+=j)                    dp[i][k]=max(dp[i][k],dp[i][j]+a[i][k]);            }        printf(&quot;%d\n&quot;,dp[n][m]);    }    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  2017年第0届浙江工业大学之江学院程序设计竞赛决赛 A qwb与支教 [容斥]【数学】</title>
      <link href="/2017/06/03/72849484/"/>
      <url>/2017/06/03/72849484/</url>
      
        <content type="html"><![CDATA[<h1 id="2017年第0届浙江工业大学之江学院程序设计竞赛决赛-A-qwb与支教-容斥-【数学】"><a href="#2017年第0届浙江工业大学之江学院程序设计竞赛决赛-A-qwb与支教-容斥-【数学】" class="headerlink" title="2017年第0届浙江工业大学之江学院程序设计竞赛决赛 A: qwb与支教 [容斥]【数学】"></a>2017年第0届浙江工业大学之江学院程序设计竞赛决赛 A: qwb与支教 [容斥]【数学】</h1><p>2017年06月03日 01:36:38  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：1015</p><hr><p> 博客爬取于<code>2019-04-18 17:16:29</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/72849484" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/72849484</a></p><p>题目链接: <a href="http://115.231.222.240:8081/JudgeOnline/problem.php?cid=1005&amp;pid=0" target="_blank" rel="noopener"> http://115.231.222.240:8081/JudgeOnline/problem.php?cid=1005&amp;pid=0</a></p><p>————————————————————————————————————————<br>Problem A: qwb与支教<br>Time Limit: 1 Sec Memory Limit: 128 MB<br>Submit: 1457 Solved: 268<br>[Submit][Status][Web Board]<br>Description<br>qwb同时也是是之江学院的志愿者，暑期要前往周边地区支教，为了提高小学生的数学水平。她把小学生排成一排，从左至右从1开始依次往上报数。</p><p>玩完一轮后，他发现这个游戏太简单了。于是他选了3个不同的数x,y,z；从1依次往上开始报数，遇到x的倍数、y的倍数或z的倍数就跳过。如果x=2,y=3,z=<br>5；第一名小学生报1，第2名得跳过2、3、4、5、6，报7；第3名得跳过8、9、10，报11。</p><p>那么问题来了，请你来计算，第N名学生报的数字是多少？</p><p>Input<br>多组测试数据，处理到文件结束。（测试数据数量&lt;=8000）</p><p>每个测试例一行，每行有四个整数x,y,z,N。（ 2≤x,y,z≤107,1≤N≤1017）。</p><p>Output<br>对于每个测试例，输出第N名学生所报的数字，每个报数占一行。<br>Sample Input<br>2 3 5 2<br>6 2 4 10000<br>Sample Output<br>7<br>19999</p><p>————————————————————————————————————————</p><p>学过容斥的人应该都会,不会的话坐下hdu 1796</p><p>a  n  s  =  n  l  c  m  {  一  个  元  素  }  −  n  l  c  m  {  两  个  元  素  }  +<br>n  l  c  m  {  三  个  元  素  }  −  .  .  .  .  n  l  c  m  {  所  有  元  素  }</p><p>附本题代码<br>——————————————————————————</p><p>​    </p><pre><code>#include &lt;bits/stdc++.h&gt;typedef long long int LL;using namespace std;/**************************************/LL lcm(LL a,LL b){    return a/__gcd(a,b)*b;}LL x,y,z,N;LL cal(LL k){    LL sum = k;    sum-=k/x+k/y+k/z;    sum+=k/lcm(x,y)+k/lcm(y,z)+k/lcm(x,z);    sum-=k/lcm(x,lcm(y,z));  //baojingdu//    cout&lt;&lt;&quot;sum = &quot;&lt;&lt;sum&lt;&lt;endl;    return sum;}int main(){    while(~scanf(&quot;%lld%lld%lld%lld&quot;,&amp;x,&amp;y,&amp;z,&amp;N)){        LL l=1,r=(~(1ll&lt;&lt;63))&gt;&gt;1,mid,ans=1;        while(l&lt;=r){            mid = r+l &gt;&gt; 1;            if(cal(mid)&gt;=N) ans=mid,r=mid-1;            else l=mid+1;        }        printf(&quot;%lld\n&quot;,ans);    }    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  2017中国大学生程序设计竞赛 - 女生专场 个人训练总结【(7+1)/10】</title>
      <link href="/2017/05/28/72793781/"/>
      <url>/2017/05/28/72793781/</url>
      
        <content type="html"><![CDATA[<h1 id="2017中国大学生程序设计竞赛-女生专场-个人训练总结【-7-1-10】"><a href="#2017中国大学生程序设计竞赛-女生专场-个人训练总结【-7-1-10】" class="headerlink" title="2017中国大学生程序设计竞赛 - 女生专场 个人训练总结【(7+1)/10】"></a>2017中国大学生程序设计竞赛 - 女生专场 个人训练总结【(7+1)/10】</h1><p>2017年05月28日 17:03:47  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：2424</p><hr><p> 博客爬取于<code>2019-04-18 17:16:30</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/72793781" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/72793781</a></p><p>hdu的题目，我挂到了VJ上<br>VJ链接: <a href="https://cn.vjudge.net/contest/165580#overview" target="_blank" rel="noopener"> https://cn.vjudge.net/contest/165580#overview</a><br>hdoj链接: <a href="http://acm.hdu.edu.cn/search.php?field=problem&amp;key=2017%D6%D0%B9%FA%B4%F3%D1%A7%C9%FA%B3%CC%D0%F2%C9%E8%BC%C6%BE%BA%C8%FC+-+%C5%AE%C9%FA%D7%A8%B3%A1&amp;source=1&amp;searchmode=source" target="_blank" rel="noopener"> 太长了 戳这里就好了 </a></p><p><img src="https://img-blog.csdn.net/20170528162022308?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzMxODQxNzE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>给妹子们出的题目，貌似没有那么凶。。但是渣渣也仅会7道题。。。</p><p>没有队友搅屎，个人切题的感觉还不错。。 也是把会的题都做了。。</p><p>这个Ｄ　虽然出的人数比较多一点，但我就是不会，没有办法，　、、、</p><p>知识广度不够，刷题太少了。</p><h1 id="A-HDU-6023-Automatic-Judge"><a href="#A-HDU-6023-Automatic-Judge" class="headerlink" title="A HDU 6023 Automatic Judge"></a>A HDU 6023 Automatic Judge</h1><p>————————————————————————————————————————<br>就是有n道题，m次提交，ICPC赛制，让你计算最终的成绩(题数+分数)</p><hr><p>附本题代码<br>——————————————————————</p><pre><code>#include &lt;bits/stdc++.h&gt;typedef long long int LL;using namespace std;#define abs(x) (((x)&gt;0)?(x):-(x))const int N = 65535+10;int n,m,a,b,c;char s[100];map&lt;int ,int &gt;mt,ma;int main(){    int _;    scanf(&quot;%d&quot;,&amp;_);    while(_--){mt.clear(),ma.clear();        scanf(&quot;%d%d&quot;,&amp;n,&amp;m);        int totac=0,tottime=0;        for(int i=1;i&lt;=m;i++){            scanf(&quot;%d %d:%d %s&quot;,&amp;a,&amp;b,&amp;c,s);            mt[a]+=20;            if(s[0]==&#39;A&#39;){                if(ma[a]==0){                    totac++;                    tottime+=mt[a]-20+b*60+c;                }                ma[a]=1;            }        }        printf(&quot;%d %d\n&quot;,totac,tottime);    }    return 0;}</code></pre><h1 id="B-HDU-6024-Building-Shops"><a href="#B-HDU-6024-Building-Shops" class="headerlink" title="B HDU 6024 Building Shops"></a>B HDU 6024 Building Shops</h1><p>————————————————————————————————————————<br>在直线上是有n(&lt;=3k)的屋子,每个屋子可以花费  C  i  建一个商店,或者去左边最近的去买花费是距离的差， 问你现在n个屋子的最小花费。</p><hr><p>看到n的范围很明显的  O  (  n  2  )  左右的解法，</p><p>然后想到在按照x升序排列后 dp</p><p>设dp[i][0/1] 表示第i个屋子建商店不建商店的最小花费</p><p>转移就是  </p><p>d  p  [  i  ]  [  1  ]  =  c  [  i  ]  +  m  i  n  (  d  p  [  i  −  1  ]  [<br>1  ]  ,  d  p  [  i  −  1  ]  [  0  ]  )  d  p  [  i  ]  [  0  ]  =  m  i  n<br>{  d  p  [  j  ]  [  1  ]  +  ∑  k  =  j  +  1  i  (  x  [  k  ]  −  x  [  i<br>]  )  ∣  ∣  j  ∈  [  1  ,  i  )  }</p><p>附本题代码<br>——————————————————————</p><pre><code>#include &lt;bits/stdc++.h&gt;typedef long long int LL;using namespace std;#define abs(x) (((x)&gt;0)?(x):-(x))const int N = 3000+10;const int MOD  = 1e9+7;int n,m,k;struct node {    LL x,c;}a[N];LL dp[N][2];bool cmp(node A,node B){    return A.x&lt;B.x;}LL sum[N];int main(){    while(~scanf(&quot;%d&quot;,&amp;n)){        for(int i=1;i&lt;=n;i++)  scanf(&quot;%lld%lld&quot;,&amp;a[i].x,&amp;a[i].c);        sort(a+1,a+n+1,cmp);        sum[0]=0;        for(int i=1;i&lt;=n;i++)sum[i]=sum[i-1]+a[i].x;        dp[1][1] = a[1].c;        dp[2][1] = a[1].c+a[2].c;        dp[2][0] = a[1].c+a[2].x-a[1].x;        for(int i=3;i&lt;=n;i++){            dp[i][1]=a[i].c+min(dp[i-1][1],dp[i-1][0]);            dp[i][0]=dp[1][1]+(sum[i]-sum[1]-a[1].x*(i-1));            for(int j=2;j&lt;i;j++){                dp[i][0]=min(dp[i][0],dp[j][1]+(sum[i]-sum[j]-a[j].x*(i-j)));            }        }//        for(int i=1;i&lt;=n;i++) printf(&quot;%lld &quot;,sum[i]); puts(&quot;&quot;);//        for(int i=1;i&lt;=n;i++) printf(&quot;%lld &quot;,dp[i][1]); puts(&quot;&quot;);//        for(int i=1;i&lt;=n;i++) printf(&quot;%lld &quot;,dp[i][0]); puts(&quot;&quot;);        printf(&quot;%lld\n&quot;,min(dp[n][1],dp[n][0]));    }    return 0;}</code></pre><h1 id="C-HDU-6025-Coprime-Sequence"><a href="#C-HDU-6025-Coprime-Sequence" class="headerlink" title="C HDU 6025 Coprime Sequence"></a>C HDU 6025 Coprime Sequence</h1><p>————————————————————————————————————————<br>给你一个序列,任选一个元素去掉,使得剩下的元素gcd值最大,问你gcd的最大值是多少</p><hr><p>因为要去掉一个,很容易想到预处理前缀gcd和后缀gcd,然后O(n)枚举去掉的元素即可,同事维护结果的最大值</p><p>附本题代码<br>——————————————————————</p><pre><code>#include &lt;bits/stdc++.h&gt;typedef long long int LL;using namespace std;#define abs(x) (((x)&gt;0)?(x):-(x))const int N = 100000+10;const int MOD  = 1e9+7;int n,m,k;int a[N],pre[N],suf[N];int main(){    int _;    scanf(&quot;%d&quot;,&amp;_);    while(_--){        scanf(&quot;%d&quot;,&amp;n);        for(int i=1;i&lt;=n;i++){            scanf(&quot;%d&quot;,&amp;a[i]);        }        pre[1]=a[1],suf[n]=a[n];        for(int i=2;i&lt;=n;i++){            pre[i]=__gcd(pre[i-1],a[i]);        }        for(int i=n-1;i;i--){            suf[i]=__gcd(suf[i+1],a[i]);        }//        for(int i=1;i&lt;=n;i++) printf(&quot;%d &quot;,pre[i]);puts(&quot;&quot;);//        for(int i=1;i&lt;=n;i++) printf(&quot;%d &quot;,suf[i]);puts(&quot;&quot;);        int mx = max(suf[2],pre[n-1]);        for(int i=2;i&lt;n;i++){            mx = max(mx,__gcd(suf[i+1],pre[i-1]));        }        printf(&quot;%d\n&quot;,mx);    }    return 0;}</code></pre><h1 id="D-HDU-6026-Deleting-Edges"><a href="#D-HDU-6026-Deleting-Edges" class="headerlink" title="D HDU 6026 Deleting Edges"></a>D HDU 6026 Deleting Edges</h1><p>————————————————————————————————————————<br>打给就是给你一个完全图,然后问你满足每个点到0节点的距离都是原图上的最小距离的生成树的个数</p><hr><p>不会、、</p><p>————————Update—————————–</p><p>首先处理出来 两点间最短路,用floyd即可</p><p>然后考虑枚举每一条边,如果这条边</p><pre><code>#include &lt;bits/stdc++.h&gt;typedef long long int LL;using namespace std;const int N   = 2e5+7;const int MOD = 1e9+7;/****************************************************/int n;char a[55][55];int b[55][55];int dis[55][55];LL ans[55];int main(){    while(~scanf(&quot;%d&quot;,&amp;n)){        memset(ans,0,sizeof(ans));        for(int i=1;i&lt;=n;i++)scanf(&quot;%s&quot;,a[i]+1);        for(int i=1;i&lt;=n;i++){            for(int j=1;j&lt;=n;j++){                b[i][j]=dis[i][j]=a[i][j]-&#39;0&#39;;                if(b[i][j]==0) b[i][j]=dis[i][j]=1000000000;            }            b[i][i]=dis[i][i]=0;        }//        for(int i=1;i&lt;=n;i++){//            for(int j=1;j&lt;=n;j++)//                printf(&quot;%d &quot;,dis[i][j]);//            puts(&quot;&quot;);//        }        for(int k=1;k&lt;=n;k++)            for(int i=1;i&lt;=n;i++)                for(int j=1;j&lt;=n;j++)                    if(dis[i][j]&gt;dis[i][k]+dis[k][j])                        dis[i][j]=dis[i][k]+dis[k][j];//        for(int i=1;i&lt;=n;i++){//            for(int j=1;j&lt;=n;j++)//                printf(&quot;%d &quot;,dis[i][j]);//            puts(&quot;&quot;);//        }        for(int i=1;i&lt;=n;i++)            for(int j=1;j&lt;=n;j++)                if(i!=j&amp;&amp;dis[1][i]+b[i][j]==dis[1][j])                    ans[j]++;        LL res = 1;        for(int j=1;j&lt;=n;j++)            if(ans[j]&gt;0)  res=res*ans[j]%MOD;        printf(&quot;%I64d\n&quot;,res);    }    return 0;}</code></pre><h1 id="E-HDU-6027-Easy-Summation"><a href="#E-HDU-6027-Easy-Summation" class="headerlink" title="E HDU 6027 Easy Summation"></a>E HDU 6027 Easy Summation</h1><p>————————————————————————————————————————<br>让你计算  </p><p>∑  i  =  1  n  i  k</p><hr><p>因位数据范围较小,只要快速幂计算  i  k  就好了,如果数据特别大的话 需要矩阵乘法做</p><p>附本题代码<br>——————————————————————</p><pre><code>#include &lt;bits/stdc++.h&gt;typedef long long int LL;using namespace std;#define abs(x) (((x)&gt;0)?(x):-(x))const int N = 65535+10;const int MOD  = 1e9+7;int n,m,k;LL qmod(LL a,LL b){    LL res = 1ll;    while(b){        if(b&amp;1) res=res*a%MOD;        b&gt;&gt;=1,a=a*a%MOD;    }    return res;}int main(){    int _;    while(~scanf(&quot;%d&quot;,&amp;m)){        for(int i=1;i&lt;=m;i++){            scanf(&quot;%d%d&quot;,&amp;n,&amp;k);            LL ans = 0;            for(int j=1;j&lt;=n;j++){                ans+=qmod(j,k);                if(ans&gt;MOD) ans-=MOD;            }            printf(&quot;%lld\n&quot;,ans);        }    }    return 0;}</code></pre><p>＃F HDU 6028 Forgiveness<br>————————————————————————————————————————</p><p>没读题,不会,没人出啊.</p><h1 id="G-HDU-6029-Graph-Theory"><a href="#G-HDU-6029-Graph-Theory" class="headerlink" title="G HDU 6029 Graph Theory"></a>G HDU 6029 Graph Theory</h1><p>————————————————————————————————————————<br>按照规则有一个图,然你在这个图上找一个完美匹配<br>规则如下:<br>1 将这个点u和标号小于u的点连一个边,<br>2 没有操作.</p><hr><p>其实很简单,我们只要顺序遍历下来,如果是1的时候,前面有一个节点没有匹配,那就和当前点匹配上,</p><p>最后所有节点都匹配上yes否则no</p><p>附本题代码<br>——————————————————————</p><pre><code>#include &lt;bits/stdc++.h&gt;typedef long long int LL;using namespace std;#define abs(x) (((x)&gt;0)?(x):-(x))const int N = 3000+10;const int MOD  = 1e9+7;int n,m,k;int main(){    int _;    scanf(&quot;%d&quot;,&amp;_);    while(_--){        scanf(&quot;%d&quot;,&amp;n);        int flag = 0,x;        int sum = 1;        for(int i=2;i&lt;=n;i++){            scanf(&quot;%d&quot;,&amp;x);            sum++;            if(x==1&amp;&amp;sum&gt;=2) sum-=2;        }        if(sum==0) puts(&quot;Yes&quot;);        else     puts(&quot;No&quot;);    }    return 0;}</code></pre><h1 id="H-HDU-6030-Happy-Necklace"><a href="#H-HDU-6030-Happy-Necklace" class="headerlink" title="H HDU 6030 Happy Necklace"></a>H HDU 6030 Happy Necklace</h1><p>————————————————————————————————————————<br>现在有n这么长的手链,你有红色的,蓝色的石子,保证在连续奇数的区间内红色石子数不小于蓝色石子数,问方案数</p><hr><p>首先对于 <code>保证在连续奇数的区间内红色石子数不小于蓝色石子数,</code> ,很容易发现只要满足不存在<br>‘蓝蓝’,’蓝红蓝’,这两种子串就好了,</p><p>然后应该就能构造了,但是我这智商够早不出来啊,,</p><p>于是贯彻 <code>遇事不决先打表</code> 的宗旨,</p><p>x  2  3  4  5  6  …  n</p><p>ans(x)</p><p>3</p><p>4</p><p>6</p><p>9</p><p>13</p><p>…</p><p>ans(i-1)+ans(i-3)</p><p>然后构造矩阵就好了  </p><p>[  a  n  s  (  i  +  2  )  a  n  s  (  i  +  1  )  a  n  s  (  i  )  ]  ×  ⎡<br>⎣  ⎢  1  0  1  1  0  0  0  1  0  ⎤  ⎦  ⎥  =  [  a  n  s  (  i  +  3  )  a  n<br>s  (  i  +  2  )  a  n  s  (  i  +  1  )  ]</p><p>附本题代码<br>————————————</p><pre><code>#include &lt;bits/stdc++.h&gt;typedef long long int LL;using namespace std;#define abs(x) (((x)&gt;0)?(x):-(x))const int N = 3000+10;const int MOD  = 1e9+7;int n,m,k;const int M = 3;struct Matrix {    LL m[M][M];    void clear0(){        for(int i=0;i&lt;M;i++)            for(int j=0;j&lt;M;j++)                m[i][j]=0;    }    void clear1(){        for(int i=0;i&lt;M;i++)            for(int j=0;j&lt;M;j++)                m[i][j]=(i==j);    }    void display(){        for(int i=0;i&lt;M;i++){            for(int j=0;j&lt;M;j++)                printf(&quot;%lld &quot;,m[i][j]);            puts(&quot;&quot;);        }        puts(&quot;------&quot;);    }};Matrix operator * (Matrix &amp;a, Matrix &amp;b){    Matrix c;c.clear0();    for(int k=0;k&lt;M;k++)        for(int i=0;i&lt;M;i++)            for(int j=0;j&lt;M;j++)                c.m[i][j]=(c.m[i][j]+a.m[i][k]*b.m[k][j]+MOD)%MOD;    return c;}Matrix operator ^(Matrix &amp;a,LL b){    Matrix c;c.clear1();    while(b){        if(b&amp;1) c=c*a;        b&gt;&gt;=1,a=a*a;    }    return c;}Matrix a,b;void solve(LL x){    a.clear0();b.clear0();    a.m[0][0]=6,a.m[0][1]=4,a.m[0][2]=3;    b.m[0][0]=1,b.m[0][1]=1,b.m[0][2]=0;    b.m[1][0]=0,b.m[1][1]=0,b.m[1][2]=1;    b.m[2][0]=1,b.m[2][1]=0,b.m[2][2]=0;//    b.display();    b=b^(x-2);//    b.display();    a=a*b;//    a.display();    printf(&quot;%lld\n&quot;,a.m[0][2]);}int main(){    int _;LL x;    scanf(&quot;%d&quot;,&amp;_);    while(_--){        scanf(&quot;%lld&quot;,&amp;x);        solve(x);    }    return 0;}</code></pre><h1 id="I-HDU-6031-Innumerable-Ancestors"><a href="#I-HDU-6031-Innumerable-Ancestors" class="headerlink" title="I HDU 6031 Innumerable Ancestors"></a>I HDU 6031 Innumerable Ancestors</h1><p>————————————————————————————————————————<br>这题是有一棵节点个数为n树，有m次查询，<br>查询是有两个集合，在集合中分别选出一个元素，求其LCA，问LCA的深度最大是多少</p><hr><p>解题思路：</p><p>注意数据范围  ∑  k  =  100000  ,那么就从这里着手么,<br>显然分别枚举一定不行,所以可以枚举一个集合,对另一个集合,我们可以先进行处理<br>大概就是进行一个dfs序,然后出现的节点我们就标记一下,这样我就能知道,当前集合的每个节点的子树有没有另一个集合的节点了,</p><p>找的时候我们将一个节点不断向上找其父节点,如果这个父节点的子树有另一个集合的元素,那么LCA就是这个父节点</p><p>然后注意几个剪枝就好了,</p><p>1,采取启发式搜索的思路,将集合内元素及其祖宗节点个数多的标记上去,对另一个小的查找<br>2,深度小于当前维护的最大值得父节点直接退出就好了,<br>3,可以先维护下这两个集合内相同元素的深度的最大值,</p><p>附本题代码<br>——————————————————————————————————</p><pre><code>#include &lt;bits/stdc++.h&gt;typedef long long int LL;using namespace std;#define abs(x) (((x)&gt;0)?(x):-(x))const int N = 100000+10;const int MOD  = 1e9+7;int read(){    int x=0;char ch = getchar();    while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;) ch = getchar();    while(&#39;0&#39;&lt;=ch&amp;&amp;ch&lt;=&#39;9&#39;) {x=(x&lt;&lt;3)+(x&lt;&lt;1)+ch-&#39;0&#39;;ch=getchar();}    return x;}/************************************************************/int n,m,k;int sum[N];#define lowbit(x) (x&amp;-x)void update(int i,int v){for(;i&lt;=n;i+=lowbit(i))sum[i]+=v;}int getSum(int i){int ans=0;for(;i;i-=lowbit(i))ans+=sum[i];return ans;}vector&lt;int &gt;G[N];int L[N],R[N],fa[N],dep[N],cnt,a[N],b[N],mx,h[N];void dfs(int u,int f,int d){    dep[u]=d,fa[u]=f;L[u]=++cnt;    int gz=G[u].size();    for(int to,i=0;i&lt;gz;i++){        to = G[u][i];        if(to==f) continue;        dfs(to,u,d+1);    }    R[u]=cnt;}void  solve(int x){    for(int f=x;f;f=fa[f]){        if(dep[f]&lt;=mx) return ;        if(getSum(R[f])-getSum(L[f]-1)&gt;0)            mx = max(mx,dep[f]);    }}int main(){    while(~scanf(&quot;%d%d&quot;,&amp;n,&amp;m)){        for(int i=1,u,v;i&lt;n;i++){//            scanf(&quot;%d%d&quot;,&amp;u,&amp;v);            u=read(),v=read();            G[u].push_back(v);            G[v].push_back(u);        }        cnt=0,dfs(1,0,1);        int x;LL ta,tb;        for(int i=1;i&lt;=m;i++){            mx=0;ta=tb=0;            a[0]=read();            for(int j=1;j&lt;=a[0];j++){                a[j]=read();ta+=dep[a[j]];                h[a[j]]=1;            }            b[0]=read();            for(int j=1;j&lt;=b[0];j++){                b[j]=read();tb+=dep[b[j]];                if(h[b[j]]) mx=max(mx,dep[b[j]]);            }            if(tb&lt;ta){                for(int j=1;j&lt;=a[0];j++)   update(L[a[j]],1);                for(int j=1;j&lt;=b[0];j++)                    if(dep[b[j]]&gt;mx) solve(b[j]);                for(int j=1;j&lt;=a[0];j++)   update(L[a[j]],-1);            }            else {                for(int j=1;j&lt;=b[0];j++)   update(L[b[j]],1);                for(int j=1;j&lt;=a[0];j++)                    if(dep[a[j]]&gt;mx) solve(a[j]);                for(int j=1;j&lt;=b[0];j++)   update(L[b[j]],-1);            }            printf(&quot;%d\n&quot;,mx);            for(int j=1;j&lt;=a[0];j++) h[a[j]]=0;        }        for(int i=1;i&lt;=n;i++) G[i].clear();    }    return 0;}</code></pre><h1 id="J-HDU-6032-Judicious-Strategy"><a href="#J-HDU-6032-Judicious-Strategy" class="headerlink" title="J HDU 6032 Judicious Strategy"></a>J HDU 6032 Judicious Strategy</h1><p>————————————————————————————————————————————————————</p>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  2017西安邀请赛总结</title>
      <link href="/2017/05/26/72775704/"/>
      <url>/2017/05/26/72775704/</url>
      
        <content type="html"><![CDATA[<h1 id="2017西安邀请赛总结"><a href="#2017西安邀请赛总结" class="headerlink" title="2017西安邀请赛总结"></a>2017西安邀请赛总结</h1><p>2017年05月26日 23:11:56  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：955</p><hr><p> 博客爬取于<code>2019-04-18 17:16:31</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/72775704" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/72775704</a></p><p>我记得前几天就传上来了的呀。。。</p><hr><p>邀请赛总结 ，<br>前几天玩的太浪了，还包了一次宿。休息就跟不上了，正式赛时候脑子一直蒙蒙的。而且之前想前一天去安排下战术，然而热身发挥的比较稳，再加上酒店问题比较大，换房间什<br>么的浪费很长时间就没有去安排战术，正式赛只做的4题，铜牌第6.。</p><p>发挥的很差，全场题总是不出。。</p><p>其实A题正解我早早就推出来了，但是对1，0的可能居然是相同的抱有疑问。。我做的时候不敢相信最后居然能变成一个式子，，认为一定是我想错了，，自以为这种题套路很<br>明显，枚举A矩阵1的个数然后统计答案就好了，，，就还在那么写了，最终GG，，最后交的几发，有一发是等价正解的，但是1的个数为0的特判，指数我少加了个m。。所<br>以依旧时WA。</p><p>想一想， 最后100min如果和mengxiang000全力去做K，或者叫他俩帮我我看看A。而不是我和mengxiang000各自开一题，叫My_stage<br>做数据hack这种打发，哪怕只是和他俩随便一个人交流下我A题的做法，至少能再出一题的。。<br>当时3个人脑子都抽了么，为什么最后的那么长时间内没有任何交流呢？？！！作为队长 我很失败啊。。。。。</p><hr><p>自身缺陷很严重，硬实力的缺陷还需要时间学习来弥补。但能做出的水题不能在现场作出，这问题实在太大了，<br>一是赛中与队友交流很少。<br>二是个人做题时一直是要将每个结果证明出来才敢写，不敢去猜。这也对于算是一大弊病吧，，，。</p><hr><p>队伍配合急需加强，以后比赛还是要有战术分配的。<br>多刷题，多看论文（切掉例题），</p>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  华中农业大学第五届程序设计大赛 【10/12】个人训练总结</title>
      <link href="/2017/05/26/72775494/"/>
      <url>/2017/05/26/72775494/</url>
      
        <content type="html"><![CDATA[<h1 id="华中农业大学第五届程序设计大赛-【10-12】个人训练总结"><a href="#华中农业大学第五届程序设计大赛-【10-12】个人训练总结" class="headerlink" title="华中农业大学第五届程序设计大赛 【10/12】个人训练总结"></a>华中农业大学第五届程序设计大赛 【10/12】个人训练总结</h1><p>2017年05月26日 22:57:22  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：639</p><hr><p> 博客爬取于<code>2019-04-18 17:16:32</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/72775494" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/72775494</a></p><p>题目比较好，就是描述有的时候很不清晰，还有不带数据范围的。。。</p><p>10个题写了1天？！ 好菜啊。。。。<br>但是发觉阅读能力见长啊，。。可能还是题目比较简单吧，，，</p><p>至今不会搞死小圆啊 。。。 回头去学习一波。。</p><p><del> 明天补题。 </del></p><hr><p>听说每题单开一贴能增加阅读体验？ 难道不是访问量++？？！</p><p>题目比较简单【10/12】</p><p><a href="http://blog.csdn.net/qq_33184171/article/details/72773556" target="_blank" rel="noopener"> Problem A Little Red Riding Hood</a><br><a href="http://blog.csdn.net/qq_33184171/article/details/72773595" target="_blank" rel="noopener"> Problem B Choosy in Food</a><br><a href="http://blog.csdn.net/qq_33184171/article/details/72773662" target="_blank" rel="noopener"> Problem C Friends</a><br><a href="http://blog.csdn.net/qq_33184171/article/details/72773724" target="_blank" rel="noopener"> Problem D GCD </a><br><a href="http://blog.csdn.net/qq_33184171/article/details/72773799" target="_blank" rel="noopener"> Problem E One Stroke</a><br><a href="http://blog.csdn.net/qq_33184171/article/details/72773828" target="_blank" rel="noopener"> Problem F Escape from the Darkness</a><br><a href="http://blog.csdn.net/qq_33184171/article/details/72773915" target="_blank" rel="noopener"> Problem G Sequence Number</a><br><a href="http://blog.csdn.net/qq_33184171/article/details/72773955" target="_blank" rel="noopener"> Problem H MathematicalGame</a><br><a href="http://blog.csdn.net/qq_33184171/article/details/72773996" target="_blank" rel="noopener"> Problem I Candies</a><br><a href="http://blog.csdn.net/qq_33184171/article/details/72774870" target="_blank" rel="noopener"> Problem J Color Circle</a><br><a href="http://blog.csdn.net/qq_33184171/article/details/72775216" target="_blank" rel="noopener"> Problem K Deadline</a><br>Problem L Happiness<br>傻逼签到题，实在不想单开一贴，计算AB的数目就好了。</p>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  华中农业大学第五届程序设计大赛 K Deadline []【思维】</title>
      <link href="/2017/05/26/72775216/"/>
      <url>/2017/05/26/72775216/</url>
      
        <content type="html"><![CDATA[<h1 id="华中农业大学第五届程序设计大赛-K-Deadline-【思维】"><a href="#华中农业大学第五届程序设计大赛-K-Deadline-【思维】" class="headerlink" title="华中农业大学第五届程序设计大赛 K Deadline []【思维】"></a>华中农业大学第五届程序设计大赛 K Deadline []【思维】</h1><p>2017年05月26日 22:49:23  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：249</p><hr><p> 博客爬取于<code>2019-04-18 17:16:33</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/72775216" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/72775216</a></p><p>题目连接: <a href="http://acm.hzau.edu.cn/problem.php?id=1209" target="_blank" rel="noopener"> http://acm.hzau.edu.cn/problem.php?id=1209</a></p><p>——————————————————————————<br>1209: Deadline<br>Time Limit: 2 Sec Memory Limit: 1280 MB<br>Submit: 1195 Solved: 139<br>[Submit][Status][Web Board]<br>Description<br>There are N bugs to be repaired and some engineers whose abilities are roughly<br>equal. And an engineer can repair a bug per day. Each bug has a deadline A[i].</p><p>Question: How many engineers can repair all bugs before those deadlines at<br>least?</p><p>1&lt;=n&lt;= 1e6. 1&lt;=a[i] &lt;=1e9</p><p>Input<br>There are multiply test cases.</p><p>In each case, the first line is an integer N , indicates the number of bugs.<br>The next line is n integers indicates the deadlines of those bugs.</p><p>Output<br>There are one number indicates the answer to the question in a line for each<br>case.</p><p>Sample Input<br>4<br>1 2 3 4<br>Sample Output<br>1</p><p>————————————————————————————<br>题目大意：<br>就是有n个bug，每个bug有一个ddl，问你最少需要多少人才能在保证在每个bug的ddl之前修好所有bug。</p><p>解题思路：</p><p>其实很好想，枚举ddl，计算这个ddl内有多少个bug需要解决，除一下向上取整就是当前所需要的最少人数，维护最大值就行了，</p><p>附本题代码<br>————————————————————————————</p><pre><code>#include &lt;bits/stdc++.h&gt;typedef long long int LL;using namespace std;const int N   = 2e6+7;//const int INF = (~(1&lt;&lt;31));int read(){    int x=0,f=1;char ch = getchar();    while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;) ch = getchar();    while(&#39;0&#39;&lt;=ch&amp;&amp;ch&lt;=&#39;9&#39;){x=(x&lt;&lt;3)+(x&lt;&lt;1)+ch-&#39;0&#39;;ch = getchar();}    return x;}/*******************************************/int a[N];int n;int main(){//printf(&quot;%d\n&quot;,INF);    while(~scanf(&quot;%d&quot;,&amp;n)){        for(int i=1;i&lt;=n;i++)    a[i]=read();        sort(a+1,a+n+1);        int mx = 1;        for(int i=1;i&lt;=n;i++)            mx = (mx&gt;((i+a[i]-1)/a[i]))?mx:((i+a[i]-1)/a[i]);        printf(&quot;%d\n&quot;,mx);    }    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  华中农业大学第五届程序设计大赛 J Color Circle</title>
      <link href="/2017/05/26/72774870/"/>
      <url>/2017/05/26/72774870/</url>
      
        <content type="html"><![CDATA[<h1 id="华中农业大学第五届程序设计大赛-J-Color-Circle"><a href="#华中农业大学第五届程序设计大赛-J-Color-Circle" class="headerlink" title="华中农业大学第五届程序设计大赛 J Color Circle"></a>华中农业大学第五届程序设计大赛 J Color Circle</h1><p>2017年05月26日 22:41:01  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：288</p><hr><p> 博客爬取于<code>2019-04-18 17:16:34</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/72774870" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/72774870</a></p><p>题目连接： <a href="http://acm.hzau.edu.cn/problem.php?id=1208" target="_blank" rel="noopener"> http://acm.hzau.edu.cn/problem.php?id=1208</a><br>——————————————————————<br>1208: Color Circle<br>Time Limit: 1 Sec Memory Limit: 1280 MB<br>Submit: 344 Solved: 104<br>[Submit][Status][Web Board]<br>Description<br>There are colorful flowers in the parterre in front of the door of college and<br>form many beautiful patterns. Now, you want to find a circle consist of<br>flowers with same color. What should be done ?</p><p>Assuming the flowers arranged as matrix in parterre, indicated by a N*M<br>matrix. Every point in the matrix indicates the color of a flower. We use the<br>same uppercase letter to represent the same kind of color. We think a sequence<br>of points d1, d2, … dk makes up a circle while:</p><ol><li><p>Every point is different. </p></li><li><p>k &gt;= 4 </p></li><li><p>All points belong to the same color. </p></li><li><p>For 1 &lt;= i &lt;= k-1, di is adjacent to di+1 and dk is adjacent to d1. ( Point x is adjacent to Point y while they have the common edge). </p></li></ol><p>N, M &lt;= 50. Judge if there is a circle in the given matrix.</p><p>Input<br>There are multiply test cases.</p><p>In each case, the first line are two integers n and m, the 2nd ~ n+1th lines<br>is the given n*m matrix. Input m characters in per line.</p><p>Output<br>Output your answer as “Yes” or ”No” in one line for each case.</p><p>Sample Input<br>3 3<br>AAA<br>ABA<br>AAA<br>Sample Output<br>Yes</p><p>————————————————————————————<br>题目大意：</p><p>问你能不能找到一个由一种颜色构成的圈<br>有求，<br>1.至少有4个点<br>2.所有点首尾相接构成一个圈<br>3.颜色相同<br>4.点是不同的</p><p>解题思路：</p><p>由于图很小，所以暴力搜就好了，</p><p>附本题代码<br>——————————————————————————</p><pre><code>#include &lt;bits/stdc++.h&gt;typedef long long int LL;using namespace std;const int N   = 2e5+7;//const int INF = (~(1&lt;&lt;31));int read(){    int x=0,f=1;char ch = getchar();    while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;) ch = getchar();    while(&#39;0&#39;&lt;=ch&amp;&amp;ch&lt;=&#39;9&#39;){x=(x&lt;&lt;3)+(x&lt;&lt;1)+ch-&#39;0&#39;;ch = getchar();}    return x;}/*******************************************/char a[111][111];int vis[111][111];int n,m;bool flag,flag2;int fx[]={0,0,1,-1};int fy[]={1,-1,0,0};void dfs(int x,int y,int dep){    if(flag) return ;    int xx,yy;    for(int i=0;i&lt;4;i++){        xx=x+fx[i];        yy=y+fy[i];        if(xx&lt;1||xx&gt;n||yy&lt;1||yy&gt;m)  continue;        if(a[xx][yy]!=a[x][y]) continue;        if(vis[xx][yy]&amp;&amp;dep-vis[xx][yy]+1&gt;=4) {flag = true;return ;}        else if(!vis[xx][yy]) {            vis[xx][yy]=dep;            dfs(xx,yy,dep+1);            vis[xx][yy]=0;        }    }}int main(){    while(~scanf(&quot;%d%d&quot;,&amp;n,&amp;m)){memset(vis,0,sizeof(vis));        for(int i=1;i&lt;=n;i++)     scanf(&quot;%s&quot;,a[i]+1);        flag = flag2 = false;        for(int i=1;i&lt;=n&amp;&amp;!flag2;i++)            for(int j=1;j&lt;=m&amp;&amp;!flag2;j++){                dfs(i,j,1);                if(flag) flag2=true;            }        if(flag2) puts(&quot;Yes&quot;);        else      puts(&quot;No&quot;);    }    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  华中农业大学第五届程序设计大赛 I Candies [线段树]【数据结构】</title>
      <link href="/2017/05/26/72773996/"/>
      <url>/2017/05/26/72773996/</url>
      
        <content type="html"><![CDATA[<h1 id="华中农业大学第五届程序设计大赛-I-Candies-线段树-【数据结构】"><a href="#华中农业大学第五届程序设计大赛-I-Candies-线段树-【数据结构】" class="headerlink" title="华中农业大学第五届程序设计大赛 I Candies [线段树]【数据结构】"></a>华中农业大学第五届程序设计大赛 I Candies [线段树]【数据结构】</h1><p>2017年05月26日 22:03:13  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：280</p><hr><p> 博客爬取于<code>2019-04-18 17:16:35</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/72773996" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/72773996</a></p><p>题目链接: <a href="http://acm.hzau.edu.cn/problem.php?id=1207" target="_blank" rel="noopener"> http://acm.hzau.edu.cn/problem.php?id=1207</a><br>——————————————————————————————————————<br>1207: Candies<br>Time Limit: 2 Sec Memory Limit: 1280 MB<br>Submit: 249 Solved: 39<br>[Submit][Status][Web Board]<br>Description<br>Xiao Ming likes those N candies he collects very much. There are two kinds of<br>candies, A and B. One day, Xiao Ming puts his candies in a row and plays<br>games. And he can replace the Lth candy to the Rth candy with the same kind of<br>candies. Now, he wonder that if he eats the Lth candy to Rth candy, he can eat<br>how many B candy continuously at most. For each Xiao Ming’s query, give the<br>number of the B candy he can eat continuously at most.</p><p>Input<br>In the first line, there is an integer T, indicates the number of test cases.</p><p>For each case, there are two integers N and M in the first line, indicate the<br>number of candies and the time of Xiao Ming’s operations.</p><p>The second line is a N-length string consist of character A and B, indicates<br>the row of candies Xiao Ming put.</p><p>The next M line is Xiao Ming’s operations. There are two kind of operations:</p><ol><li><p>1 L R v, indicate Xiao Ming replaces the Lth candy to the Rth candy with A candies (v==1) or B candies ( v == 2 ). </p></li><li><p>2 L R, indicate Xiao Ming wonder that there are how many continuous B candies between the Lth candy to the Rth candy most. </p></li></ol><p>Output<br>In each case, the first line is “Case #k: “, k indicates the case number.</p><p>For each query, output the number of the most continuous B candies.</p><p>Sample Input<br>1<br>5 3<br>ABABB<br>2 1 3<br>1 2 3 2<br>2 1 3<br>Sample Output<br>Case #1:<br>1<br>2</p><p>————————————————————————————————————————————<br>题目大意：<br>给你一个序列，分别代表AB两种果实，</p><p>有两种操作，<br>1 将区间l，r 全变为（A或B）中操作<br>2 问你区间l，r 中连续的B最长是多长</p><p>解题思路：<br>线段树维护就好了</p><p>因为要有维护两个区间并的情况，所以要维护<br>sum 当前区间内连续的B的长度<br>ls 当前左边界开始向右连续B的长度<br>rs 当前右边界开始向左连续B的长度<br>lazy 懒标记</p><p>然后注意下维护的细节就好</p><p>Ps： 本来自己写了份代码，但是写到最后query的时候发现，合并时需要的信息得需要一个结构体来存诸，然而我写的时数组的。。。。。心态爆炸。。<br>最后厚颜无耻的贴了代码。。。</p><p>附本题代码<br>————————————————————————————————</p><pre><code>#include &lt;bits/stdc++.h&gt;  using namespace std;  const int maxn = 1e6 + 7;  struct node{      int l, r, lazy, len;      int lb, mb, rb;      void Set_B(int key){ // 对区间内的 lb, mb, rb 进行更改          if(key == 1) lb = mb = rb = 0;          else lb = mb = rb = len;      }  } tree[maxn&lt;&lt;2];  char z[maxn];  int Find_max(int s1, int s2, int s3){      if(s2 &gt; s1) s1 = s2;      if(s3 &gt; s1) s1 = s3;      return s1;  }  void Push_up(int key){ // 向上更新, 区间合并      int lson = key&lt;&lt;1, rson = key&lt;&lt;1|1;      tree[key].lb = tree[lson].lb;      tree[key].rb = tree[rson].rb;      if(tree[lson].lb == tree[lson].len) tree[key].lb += tree[rson].lb;      if(tree[rson].rb == tree[rson].len) tree[key].rb += tree[lson].rb;      tree[key].mb = max(tree[lson].rb + tree[rson].lb, max(tree[lson].mb, tree[rson].mb));  }  void Push_down(int key){ // 向下更新      if(tree[key].lazy != 0){          int lson = key&lt;&lt;1, rson = key&lt;&lt;1|1;          tree[lson].lazy = tree[rson].lazy = tree[key].lazy;          tree[lson].Set_B(tree[key].lazy);          tree[rson].Set_B(tree[key].lazy);          tree[key].lazy = 0;      }  }  void Buildtree(int l, int r, int key){ // 建树      tree[key].l = l;      tree[key].r = r;      tree[key].len = r - l + 1;      tree[key].lazy = 0;      if(l == r){          if(z[l] == &#39;A&#39;) tree[key].Set_B(1);          else tree[key].Set_B(2);          return;      }      int mid = (l + r) &gt;&gt; 1;      Buildtree(l, mid, key&lt;&lt;1);      Buildtree(mid+1, r, key&lt;&lt;1|1);      Push_up(key);  }  void Update(int l, int r, int key, int w){ // 更新      if(l &lt;= tree[key].l &amp;&amp; tree[key].r &lt;= r){          tree[key].lazy = w;          tree[key].Set_B(w);          return;      }      Push_down(key);      int mid = (tree[key].l + tree[key].r) &gt;&gt; 1;      if(l &lt;= mid) Update(l, r, key&lt;&lt;1, w);      if(mid &lt; r) Update(l, r, key&lt;&lt;1|1, w);      Push_up(key);  }  node Merge(node p, node q){ // 区间合并, 与向上更新相同      node tmp;      tmp.len = p.len + q.len;      tmp.lb = p.lb;      tmp.rb = q.rb;      if(p.lb == p.len) tmp.lb += q.lb;      if(q.rb == q.len) tmp.rb += p.rb;      tmp.mb = max(p.rb + q.lb, max(p.mb, q.mb));      return tmp;  }  node Query(int l, int r, int key){ // 询问      if(l &lt;= tree[key].l &amp;&amp; tree[key].r &lt;= r) return tree[key];      Push_down(key);      int mid = (tree[key].l + tree[key].r) &gt;&gt; 1;      if(r &lt;= mid) return Query(l, r, key&lt;&lt;1);      else if(mid &lt; l) return Query(l, r, key&lt;&lt;1|1);      else return Merge(Query(l, mid, key&lt;&lt;1), Query(mid+1, r, key&lt;&lt;1|1));  }  int main(){      int t, n, q, op, u, v, w;      int num = 0;      scanf(&quot;%d&quot;, &amp;t);      while(t --){          scanf(&quot;%d %d&quot;, &amp;n, &amp;q);          scanf(&quot;%s&quot;, z+1);          Buildtree(1, n, 1);          printf(&quot;Case #%d:\n&quot;, ++ num); // 这里很坑，如果后面没有空格会WA掉          while(q --){              scanf(&quot;%d %d %d&quot;, &amp;op, &amp;u, &amp;v);              if(op == 1){                  scanf(&quot;%d&quot;, &amp;w);                  Update(u, v, 1, w);              }              else{                  node gg = Query(u, v, 1);                  printf(&quot;%d\n&quot;, Find_max(gg.lb, gg.mb, gg.rb));              }          }      }      return 0;  }  </code></pre>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  华中农业大学第五届程序设计大赛 H MathematicalGame [01字典树]【字典树】</title>
      <link href="/2017/05/26/72773955/"/>
      <url>/2017/05/26/72773955/</url>
      
        <content type="html"><![CDATA[<h1 id="华中农业大学第五届程序设计大赛-H-MathematicalGame-01字典树-【字典树】"><a href="#华中农业大学第五届程序设计大赛-H-MathematicalGame-01字典树-【字典树】" class="headerlink" title="华中农业大学第五届程序设计大赛 H MathematicalGame [01字典树]【字典树】"></a>华中农业大学第五届程序设计大赛 H MathematicalGame [01字典树]【字典树】</h1><p>2017年05月26日 21:55:54  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：446</p><hr><p> 博客爬取于<code>2019-04-18 17:16:36</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/72773955" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/72773955</a></p><p>题目链接： <a href="http://acm.hzau.edu.cn/problem.php?id=1206" target="_blank" rel="noopener"> http://acm.hzau.edu.cn/problem.php?id=1206</a><br>——————————————————————————————————————<br>1206: MathematicalGame<br>Time Limit: 2 Sec Memory Limit: 1280 MB<br>Submit: 170 Solved: 26<br>[Submit][Status][Web Board]<br>Description<br>Xiao Ming likes to play mathematical games very much. One day, he gets a<br>sequence of n positive integers. XOR (l , r) is defined as the XOR and of all<br>numbers in a continuous interval. Now, Xiao Ming wants to know the intervals<br>which make the XOR (l , r) become largest.</p><p>Require l, r.</p><p>Input<br>There is an integer T at the first line, indicate the case of data.</p><p>In each case, there is an integer N at the first line, indicate the length of<br>the sequence. And there are N integers, a1, a2, … , an, at the second line. (N<br>&lt;= 1,000,000)</p><p>Output<br>In each case, the first line is “Case #k:”, k is the number of test cases, the<br>next line includes two integers l and r, which separated by a space.</p><p>l, r output in lexicographic order if there are multiple results.</p><p>Sample Input<br>1<br>5<br>1 2 3 4 5<br>Sample Output<br>Case #1:<br>3 4</p><p>————————————————————————————————————————<br>题目大意：<br>问你区间异或值最大的区间是多少，如果值有多个，输出字典序最小的那个</p><p>解题思路:</p><p>相信大家都会 区间内选两个值，异或最大</p><p>那么这个也一样，只要维护的是前缀异或和就好了，这样就变成了经典问题。</p><p>然后维护结果就好了</p><p>附本题代码<br>——————————————————————————————————</p><pre><code>#include &lt;bits/stdc++.h&gt;typedef long long int LL;using namespace std;const int N   = 2e6+7;//const int INF = (~(1&lt;&lt;31));int read(){    int x=0,f=1;char ch = getchar();    while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;) ch = getchar();    while(&#39;0&#39;&lt;=ch&amp;&amp;ch&lt;=&#39;9&#39;){x=(x&lt;&lt;3)+(x&lt;&lt;1)+ch-&#39;0&#39;;ch = getchar();}    return x;}/*******************************************/int n,a,x;int trie[N*31][2],val[N*31],cnt;int l,r,mx;void inserttrie(int x,int id){    int now=0,bt;    for(int i=30;i&gt;=0;i--){        bt = (x&amp;(1&lt;&lt;i))?1:0;        if(!trie[now][bt]) trie[now][bt] = ++cnt;        now=trie[now][bt];    }    if(-1==val[now]) val[now]=id;}int ask(int x,int y){//    printf(&quot;%d -&gt;&quot; ,x);    int now=0,bt,v=0;    for(int i=30;i&gt;=0;i--){        bt = (x&amp;(1&lt;&lt;i))?1:0;//printf(&quot;%d&quot;,bt);        if(trie[now][1-bt]) bt=1-bt,v|=(1&lt;&lt;i);        now=trie[now][bt];    }//    puts(&quot;    &lt;-&quot;);    int vn = val[now]+1;//    printf(&quot;%d %d\n&quot;,v,mx);    if(v&gt;mx) mx=v,l=vn,r=y;    if(v==mx){if(vn&lt;l||vn==l&amp;&amp;y&lt;r)l=vn,r=y;}}int main(){    memset(trie,0,sizeof(trie));    memset(val,-1,sizeof(val));    int _,kcase = 0;    scanf(&quot;%d&quot;,&amp;_);    while(_--){        scanf(&quot;%d&quot;,&amp;n);l=r=1;        a=0;cnt=0;mx=0;        inserttrie(a,0);        for(int i=1;i&lt;=n;i++){            scanf(&quot;%d&quot;,&amp;x);            a^=x;//            printf(&quot;%d%c&quot;,a,(i==n)?&#39;\n&#39;:&#39; &#39;);            ask(a,i);            inserttrie(a,i);        }        printf(&quot;Case #%d:\n&quot;,++kcase);        printf(&quot;%d %d\n&quot;,l,r);        for(int i=0;i&lt;=cnt;i++){            trie[i][0]=trie[i][1]=0;            val[i]=-1;        }    }    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  华中农业大学第五届程序设计大赛 G Sequence Number [树上二分]【数据结构】</title>
      <link href="/2017/05/26/72773915/"/>
      <url>/2017/05/26/72773915/</url>
      
        <content type="html"><![CDATA[<h1 id="华中农业大学第五届程序设计大赛-G-Sequence-Number-树上二分-【数据结构】"><a href="#华中农业大学第五届程序设计大赛-G-Sequence-Number-树上二分-【数据结构】" class="headerlink" title="华中农业大学第五届程序设计大赛 G Sequence Number [树上二分]【数据结构】"></a>华中农业大学第五届程序设计大赛 G Sequence Number [树上二分]【数据结构】</h1><p>2017年05月26日 21:50:28  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：365</p><hr><p> 博客爬取于<code>2019-04-18 17:16:37</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/72773915" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/72773915</a></p><p>题目链接: <a href="http://acm.hzau.edu.cn/problem.php?id=1205" target="_blank" rel="noopener"> http://acm.hzau.edu.cn/problem.php?id=1205</a><br>————————————————————————————————————————————<br>1205: Sequence Number<br>Time Limit: 1 Sec Memory Limit: 1280 MB<br>Submit: 934 Solved: 242<br>[Submit][Status][Web Board]<br>Description<br>In Linear algebra, we have learned the definition of inversion number:</p><p>Assuming A is a ordered set with n numbers ( n &gt; 1 ) which are different from<br>each other. If exist positive integers i , j, ( 1 ≤ i ＜ j ≤ n and A[i] ＞<br>A[j]), &lt; A[i], A[j]&gt; is regarded as one of A’s inversions. The number of<br>inversions is regarded as inversion number. Such as, inversions of array</p><p>&lt;2,3,8,6,1&gt; are &lt;2,1&gt;, &lt;3,1&gt;, &lt;8,1&gt;, &lt;8,6&gt;, &lt;6,1&gt;,and the inversion number is<br>5.</p><p>Similarly, we define a new notion —— sequence number, If exist positive<br>integers i, j, ( 1 ≤ i ≤ j ≤ n and A[i] &lt;= A[j], &lt; A[i], A[j]&gt; is regarded as<br>one of A’s sequence pair. The number of sequence pairs is regarded as sequence<br>number. Define j – i as the length of the sequence pair.</p><p>Now, we wonder that the largest length S of all sequence pairs for a given<br>array A.</p><p>Input<br>There are multiply test cases.</p><p>In each case, the first line is a number N(1&lt;=N&lt;=50000 ), indicates the size<br>of the array, the 2th ~n+1th line are one number per line, indicates the<br>element Ai （1&lt;=Ai&lt;=10^9） of the array.</p><p>Output<br>Output the answer S in one line for each case.</p><p>Sample Input<br>5<br>2 3 8 6 1<br>Sample Output<br>3</p><p>——————————————————————————————————————<br>题目大意：<br>就是给你一个序列，然你求  (  1  ≤  i  ≤  j  ≤  n  a  n  d  A  i  ≤  A  j  ）  下  j  −  i<br>的最大值</p><p>解题思路:</p><p>首先记录每个数的索引,</p><p>然后按数值大小升序排序</p><p>然后遍历每次将索引更新到树上,并查找索引在他之前最小的那个位置是多少.</p><p>维护最大值就好了</p><p>复杂度  O  (  n  log  n  )</p><p>听说用单调栈降到  O  (  n  )</p><p>附本题代码<br>————————————————————————————————</p><pre><code>#include &lt;bits/stdc++.h&gt;typedef long long int LL;using namespace std;const int N   = 5e4+7;const int INF = (~(1&lt;&lt;31));int read(){    int x=0,f=1;char ch = getchar();    while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;) ch = getchar();    while(&#39;0&#39;&lt;=ch&amp;&amp;ch&lt;=&#39;9&#39;){x=(x&lt;&lt;3)+(x&lt;&lt;1)+ch-&#39;0&#39;;ch = getchar();}    return x*f;}/*******************************************/int n;struct node {    int v,id;}a[N];bool cmp(node A,node B){    return A.v&lt;B.v;}int sum[N&lt;&lt;2];void build(int rt,int l,int r){    sum[rt]=0;    if(r==l) return;    int m = r+l &gt;&gt; 1;    build(rt&lt;&lt;1,l,m);    build(rt&lt;&lt;1|1,m+1,r);}void pushup(int rt){    sum[rt]=sum[rt&lt;&lt;1]+sum[rt&lt;&lt;1|1];}void update(int rt,int l,int r,int pos,int v){    if(l==r) {sum[rt]=1;return;}    int m = r+l &gt;&gt; 1;    if(pos&lt;=m) update(rt&lt;&lt;1,l,m,pos,v);    else       update(rt&lt;&lt;1|1,m+1,r,pos,v);    pushup(rt);}int query(int rt,int l,int r,int n){    if(r==l) return l;    int m = r+l &gt;&gt; 1;    if(sum[rt&lt;&lt;1]&gt;=n) return query(rt&lt;&lt;1,l,m,n);    else              return query(rt&lt;&lt;1|1,m+1,r,n-=sum[rt&lt;&lt;1]);}int main(){    while(~scanf(&quot;%d&quot;,&amp;n)){        for(int i=1;i&lt;=n;i++)     scanf(&quot;%d&quot;,&amp;a[i].v),a[i].id=i;        build(1,1,n);        sort(a+1,a+n+1,cmp);        int mx = -1;        for(int i=1;i&lt;=n;i++){           // printf(&quot;%d-%d=%d\n&quot;,a[i].id,query(1,1,n,1),a[i].id-query(1,1,n,1));            mx = max(mx,a[i].id-query(1,1,n,1));            update(1,1,n,a[i].id,1);        }        printf(&quot;%d\n&quot;,mx);    }    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  【待补】华中农业大学第五届程序设计大赛 F Escape from the Darkness [解析几何]【数学】</title>
      <link href="/2017/05/26/72773828/"/>
      <url>/2017/05/26/72773828/</url>
      
        <content type="html"><![CDATA[<h1 id="【待补】华中农业大学第五届程序设计大赛-F-Escape-from-the-Darkness-解析几何-【数学】"><a href="#【待补】华中农业大学第五届程序设计大赛-F-Escape-from-the-Darkness-解析几何-【数学】" class="headerlink" title="【待补】华中农业大学第五届程序设计大赛 F Escape from the Darkness [解析几何]【数学】"></a>【待补】华中农业大学第五届程序设计大赛 F Escape from the Darkness [解析几何]【数学】</h1><p>2017年05月26日 21:39:29  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：308</p><hr><p> 博客爬取于<code>2019-04-18 17:16:38</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/72773828" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/72773828</a></p><p>题目链接: <a href="http://acm.hzau.edu.cn/problem.php?id=1204" target="_blank" rel="noopener"> http://acm.hzau.edu.cn/problem.php?id=1204</a><br>————————————————————————————————————————<br>1204: Escape from the Darkness<br>Time Limit: 1 Sec Memory Limit: 1280 MB<br>Submit: 99 Solved: 3<br>[Submit][Status][Web Board]<br>Description<br>Xiao Ming, a high school student, learnt blackbody radiation from the physics<br>class. The black body on the book is indicated approximately by black body<br>cavity as below:</p><p><img src="http://acm.hzau.edu.cn/upload/201704/e.jpg" alt="这里写图片描述"></p><p>from the small hole if total reflection occurs on the surface of the cavity.</p><p>Assuming in the two-dimensional coordinates, the center of the oval is at<br>origin, and the vertexes of it is respectively (a, 0), (-a, 0), (0, b), (0,<br>-b). There is a small hole at (a/2,sqrt(3)*b/2) (whose areas can be ignored).<br>A beam of light (whose diameter can be ignored) shoot into the oval through<br>the small hole. The direction of the light is (-1, 0). Assuming the light<br>totally mirror reflects on the surface of the oval, the question is how many<br>times can the light reflect before shooting out through the small hole. (If a<br>point is away from the small hole less than 0.01, we think light shoot out<br>from that point.)</p><p>Input<br>The first line is a positive integer T (1 &lt;= T &lt;= 55) which indicates the<br>numbers of the test cases. Then flowing next T lines, there are two positive<br>integer a, b (1 &lt;= b&lt;= a&lt;= 10) in each line as a group of cases.</p><p>Output<br>The output of each case is one line with a positive integer which indicates<br>the times of reflects.</p><p>Sample Input<br>1<br>1 1<br>Sample Output<br>5<br>HINT<br>The path of the light in the sample is looked as the picture shows. The light<br>reflected five times.<br><img src="http://acm.hzau.edu.cn/upload/201704/ehint.jpg" alt="这里写图片描述"></p><p>————————————————————————————————————————<br>题目大意：<br>好像很难啊 ，占坑待补。</p>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  华中农业大学第五届程序设计大赛 E One Stroke [枚举]【思维】</title>
      <link href="/2017/05/26/72773799/"/>
      <url>/2017/05/26/72773799/</url>
      
        <content type="html"><![CDATA[<h1 id="华中农业大学第五届程序设计大赛-E-One-Stroke-枚举-【思维】"><a href="#华中农业大学第五届程序设计大赛-E-One-Stroke-枚举-【思维】" class="headerlink" title="华中农业大学第五届程序设计大赛 E One Stroke [枚举]【思维】"></a>华中农业大学第五届程序设计大赛 E One Stroke [枚举]【思维】</h1><p>2017年05月26日 21:36:14  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：432</p><hr><p> 博客爬取于<code>2019-04-18 17:16:39</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/72773799" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/72773799</a></p><p>题目链接: <a href="http://acm.hzau.edu.cn/problem.php?id=1203" target="_blank" rel="noopener"> http://acm.hzau.edu.cn/problem.php?id=1203</a><br>——————————————————————————————————————<br>1203: One Stroke<br>Time Limit: 2 Sec Memory Limit: 1280 MB<br>Submit: 274 Solved: 58<br>[Submit][Status][Web Board]<br>Description<br>There is a complete binary tree which includes n nodes. Each node on the tree<br>has a weight w, each edge on the tree is directed from the parent node to the<br>child node. Give you a pen, draw from the any node along the directed edge at<br>one stroke. It is required that the sum of those drawn nodes’ s weight is no<br>more than k. How many node can be drawn at most in one stroke?</p><p>Input<br>The first line input an positive integer T(1&lt;=T&lt;=10)indicates the number of<br>test cases. Next, each case occupies two lines. The first line input two<br>positive integers n(1&lt;=n&lt;=10^6) and k,(1&lt;=k&lt;=10^9)</p><p>The second line input n integers w(1&lt;=w &lt;=10^3),, indicate the weight of nodes<br>from the first level of the tree and from left to right.</p><p>Output<br>For each test cases, output one line with the most number of nodes can be<br>drawn in one stroke. If any node likes this doesn’t exists, output -1.</p><p>Sample Input<br>1<br>5 6<br>2 3 4 1 7<br>Sample Output<br>3</p><p>——————————————————————————————————————————</p><p>题目大意：<br>就是给你一棵树，每个树上有一个权值，让你找一条最长的从上向下的链，使其权值和不大于k，问你最长的长度是多少。</p><p>解题思路：</p><p>限制了链式从上到下的，<br>所以我们可以枚举每个节点所在的链，然后找最远的权值和不到k的点，就是到这个节点最长的长度，</p><p>找的时候用二分就好了，当时脑抽写了个BIT，其实发现数组就好了啊，。。</p><p>枚举节点在dfs遍历树的过程创建链就好了，</p><p>总复杂度  O  (  n  log  n  )</p><p>注:代码是  O  (  n  log  2  n  )  把BIT换成普通数组就好了.</p><p>附本题代码<br>———————————————————————————————————————————</p><pre><code>#include &lt;bits/stdc++.h&gt;typedef long long int LL;using namespace std;const int N   = 2e6+7;//const int INF = (~(1&lt;&lt;31));int read(){    int x=0,f=1;char ch = getchar();    while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;) ch = getchar();    while(&#39;0&#39;&lt;=ch&amp;&amp;ch&lt;=&#39;9&#39;){x=(x&lt;&lt;3)+(x&lt;&lt;1)+ch-&#39;0&#39;;ch = getchar();}    return x;}/*******************************************/int n,k,mx;int w[N];LL sum[N];#define lowbit(x) (x&amp;-x)void update(int i,int v){for(;i&lt;=n;i+=lowbit(i))sum[i]+=v;}LL getSum(int i){LL ans=0;for(;i;i-=lowbit(i))ans+=sum[i];return ans;}void display(int m){    for(int i=1;i&lt;=m;i++)  printf(&quot;%d &quot;,getSum(i)-getSum(i-1)); puts(&quot;&quot;);}void solve(int m){//    display(m);    int l=1,r=m,ans=-1,mid;    while(l&lt;=r){        mid = r+l &gt;&gt; 1;        if(getSum(m)-getSum(mid-1)&lt;=k) ans = mid,r=mid-1;        else l=mid+1;    }    if(ans!=-1)   mx = (mx&gt;(m-ans+1))?mx:(m-ans+1);//    printf(&quot;---- %d %d  %d \n&quot;,ans,m,mx);}void dfs(int rt,int dep){    if(rt&gt;n) return;    update(dep,w[rt]);    if(w[rt]&lt;=k)    solve(dep);    dfs(rt&lt;&lt;1  ,dep+1);    dfs(rt&lt;&lt;1|1,dep+1);    update(dep,-w[rt]);}int main(){    int _;    scanf(&quot;%d&quot;,&amp;_);    while(_--){        scanf(&quot;%d%d&quot;,&amp;n,&amp;k);        for(int i=1;i&lt;=n;i++)      w[i]=read();        mx = -1;dfs(1,1);        printf(&quot;%d\n&quot;,mx);    }    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  华中农业大学第五届程序设计大赛 D GCD [fibonacci+矩阵乘法]【数学】</title>
      <link href="/2017/05/26/72773724/"/>
      <url>/2017/05/26/72773724/</url>
      
        <content type="html"><![CDATA[<h1 id="华中农业大学第五届程序设计大赛-D-GCD-fibonacci-矩阵乘法-【数学】"><a href="#华中农业大学第五届程序设计大赛-D-GCD-fibonacci-矩阵乘法-【数学】" class="headerlink" title="华中农业大学第五届程序设计大赛 D GCD [fibonacci+矩阵乘法]【数学】"></a>华中农业大学第五届程序设计大赛 D GCD [fibonacci+矩阵乘法]【数学】</h1><p>2017年05月26日 21:26:18  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：383</p><hr><p> 博客爬取于<code>2019-04-18 17:16:41</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/72773724" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/72773724</a></p><p>题目链接: <a href="http://acm.hzau.edu.cn/problem.php?id=1202" target="_blank" rel="noopener"> http://acm.hzau.edu.cn/problem.php?id=1202</a><br>————————————————————————————————————————<br>1202: GCD<br>Time Limit: 1 Sec Memory Limit: 1280 MB<br>Submit: 241 Solved: 44<br>[Submit][Status][Web Board]<br>Description<br><img src="http://acm.hzau.edu.cn/upload/201704/d.jpg" alt="这里写图片描述"><br>Input<br>The first line is an positive integer T . (1&lt;=T&lt;= 10^3) indicates the number<br>of test cases. In the next T lines, there are three positive integer n, m, p<br>(1&lt;= n,m,p&lt;=10^9) at each line.</p><p>Output<br><img src="http://acm.hzau.edu.cn/upload/201704/dd.jpg" alt="这里写图片描述"></p><p>Sample Input<br>1<br>1 2 3</p><p>Sample Output<br>1</p><p>————————————————————————————————————————<br>题目大意：<br>就是让你求  g  c  d  （  1  +  s  u  m  n  ,  1  +  s  u  m  m  ）</p><p>解题方法：<br>问什么叫方法，因为暴力啊。。。</p><p>首先暴力的打了一个  1  +  s  u  m  n  的表,然后惊奇的发现这就是fibonacci数列</p><p>然后就变成了  g  c  d  （  f  i  b  n  +  2  ,  f  i  b  m  +  2  ）</p><p>然后根据fibonacci数列的性质</p><p>g  c  d  （  f  i  b  n  +  2  ,  f  i  b  m  +  2  ）  =  f  i  b  (  g  c  d<br>（  n  +  2  ,  m  +  2  ）  )</p><p>所以同一个矩阵乘法就可以了</p><p>附本题代码<br>——————————————————————————————————————————</p><pre><code>#include &lt;bits/stdc++.h&gt;typedef long long int LL;using namespace std;const int N   = 2e5+7;//const int INF = (~(1&lt;&lt;31));int read(){    int x=0,f=1;char ch = getchar();    while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;) ch = getchar();    while(&#39;0&#39;&lt;=ch&amp;&amp;ch&lt;=&#39;9&#39;){x=(x&lt;&lt;3)+(x&lt;&lt;1)+ch-&#39;0&#39;;ch = getchar();}    return x;}/*******************************************/int n,m,MOD;const int M = 2;struct Matrix{    LL m[M][M];    void clear0(){        for(int i=0;i&lt;M;i++)            for(int j=0;j&lt;M;j++)                m[i][j]=0;    }    void clearE(){        for(int i=0;i&lt;M;i++)            for(int j=0;j&lt;M;j++)                m[i][j]=(i==j);    }};Matrix operator *(Matrix &amp;a,Matrix &amp;b){    Matrix c;c.clear0();    for(int k=0;k&lt;M;k++)        for(int i=0;i&lt;M;i++)            for(int j=0;j&lt;M;j++)                c.m[i][j]=(c.m[i][j]+a.m[i][k]*b.m[k][j]+MOD)%MOD;    return c;}Matrix operator ^(Matrix &amp;a,LL b){    Matrix c;c.clearE();    while(b){        if(b&amp;1) c=c*a;        b&gt;&gt;=1,a=a*a;    }    return c;}LL solve(int x){    Matrix a,b;    a.m[0][0]=0,a.m[0][1]=1;    b.m[0][0]=0,b.m[0][1]=1;    b.m[1][0]=1,b.m[1][1]=1;    b=b^x;a=a*b;    return a.m[0][0];}int main(){    int _=read();    while(_--){        n=read(),m=read(),MOD=read();        printf(&quot;%lld\n&quot;,solve(__gcd(n+2,m+2)));    }    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  华中农业大学第五届程序设计大赛 C Friends [树形dp]【动态规划】</title>
      <link href="/2017/05/26/72773662/"/>
      <url>/2017/05/26/72773662/</url>
      
        <content type="html"><![CDATA[<h1 id="华中农业大学第五届程序设计大赛-C-Friends-树形dp-【动态规划】"><a href="#华中农业大学第五届程序设计大赛-C-Friends-树形dp-【动态规划】" class="headerlink" title="华中农业大学第五届程序设计大赛 C Friends [树形dp]【动态规划】"></a>华中农业大学第五届程序设计大赛 C Friends [树形dp]【动态规划】</h1><p>2017年05月26日 21:17:40  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：388</p><hr><p> 博客爬取于<code>2019-04-18 17:16:42</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/72773662" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/72773662</a></p><p>题目链接: <a href="http://acm.hzau.edu.cn/problem.php?id=1201" target="_blank" rel="noopener"> http://acm.hzau.edu.cn/problem.php?id=1201</a><br>————————————————————————————————————————</p><p>1201: Friends<br>Time Limit: 1 Sec Memory Limit: 1280 MB<br>Submit: 151 Solved: 40<br>[Submit][Status][Web Board]<br>Description<br>In a country, the relationship between people can be indicated by a tree. If<br>two people are acquainted with each other, there will be an edge between them.<br>If a person can get in touch with another through no more than five people, we<br>should consider these two people can become friends. Now, give you a tree of N<br>people’s relationship. ( 1 &lt;= N &lt;= 1e5), you should compute the number of who<br>can become friends of each people?</p><p>Input<br>In the first line, there is an integer T, indicates the number of the cases.<br>For each case, there is an integer N indicates the number of people in the<br>first line.</p><p>In the next N-1 lines, there are two integers u and v, indicate the people u<br>and the people</p><p>v are acquainted with each other directly. People labels from 1.</p><p>Output<br>For each case, the first line is “Case #k :”, k indicates the case number.<br>In the next N lines, there is an integer in each line, indicates the number of<br>people who can become the ith person’s friends. i is from 1 to n.</p><p>Sample Input<br>1<br>8<br>1 2<br>2 3<br>3 4<br>4 5<br>5 6<br>6 7<br>7 8</p><p>Sample Output<br>Case #1:<br>6<br>7<br>7<br>7<br>7<br>7<br>7<br>6</p><p>——————————————————————————————————————————</p><p>题目大意：<br>就是有n个人，他们的朋友关系是一个树，现在通过至多5个人能联系到的也会成为朋友。问你现在的情况下，每个人会有多少个朋友。</p><p>解题思路：</p><p>很明显的树形dp</p><p>设dp[i][j] 为第i个节点的子树中距离i为j的节点个数.<br>设ans[i][j] 为整棵树中距离i为j的节点个数.</p><p>dp可以通过一次dfs计算出来,</p><p>ans稍麻烦些,</p><p>对于一个节点,  </p><p>a  n  s  [  ]  [  i  ]  =  d  p  [  ]  [  i  ]  +  a  n  s  [  ]  [  i  −  1<br>]  −  d  p  [  ]  [  i  −  2  ]  ;</p><p>转移很好理解,画棵树理解下就好了.<br>注意的是根节点要特殊处理一下</p><p>附本题代码<br>———————————————————————————————————————————</p><pre><code>#include &lt;bits/stdc++.h&gt;typedef long long int LL;using namespace std;const int N   = 2e6+7;//const int INF = (~(1&lt;&lt;31));int read(){    int x=0,f=1;char ch = getchar();    while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;) ch = getchar();    while(&#39;0&#39;&lt;=ch&amp;&amp;ch&lt;=&#39;9&#39;){x=(x&lt;&lt;3)+(x&lt;&lt;1)+ch-&#39;0&#39;;ch = getchar();}    return x;}/*******************************************/vector&lt;int &gt;G[N];int dp[N][10]; //dp[i][j] 第i个节点 距离为j的点数int ans[N][10];int n;void dfs(int u,int f){    for(int i=0;i&lt;=6;i++)dp[u][i]=(0==i);    int gz = G[u].size();    for(int i=0,to;i&lt;gz;i++){        to = G[u][i];        if(to == f) continue;        dfs(to,u);        for(int j=1;j&lt;=6;j++)            dp[u][j]+=dp[to][j-1];    }}void dfs2(int u,int f){    ans[u][0]=1;    ans[u][1]=dp[u][1]+(u!=1);    for(int j=2;j&lt;=6;j++)        ans[u][j]=dp[u][j]+(u!=1)*(ans[f][j-1]-dp[u][j-2]);    int gz = G[u].size();    for(int i=0,to;i&lt;gz;i++){        to = G[u][i];        if(to == f) continue;        dfs2(to,u);    }}int main(){    int _,kcase = 0;    scanf(&quot;%d&quot;,&amp;_);    while(_--){        scanf(&quot;%d&quot;,&amp;n);        for(int i=1,u,v;i&lt;n;i++){            scanf(&quot;%d%d&quot;,&amp;u,&amp;v);            G[u].push_back(v);            G[v].push_back(u);        }        dfs(1,0);        dfs2(1,0);        printf(&quot;Case #%d:\n&quot;,++kcase);        int res = 0;        for(int i=1;i&lt;=n;i++){            res = 0;            for(int j=6;j;j--) res+=ans[i][j];            printf(&quot;%d\n&quot;,res);        }        for(int i=1;i&lt;=n;i++)    G[i].clear();    }    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  【待补】华中农业大学第五届程序设计大赛 B Choosy in Food [高斯消元]【数学】</title>
      <link href="/2017/05/26/72773595/"/>
      <url>/2017/05/26/72773595/</url>
      
        <content type="html"><![CDATA[<h1 id="【待补】华中农业大学第五届程序设计大赛-B-Choosy-in-Food-高斯消元-【数学】"><a href="#【待补】华中农业大学第五届程序设计大赛-B-Choosy-in-Food-高斯消元-【数学】" class="headerlink" title="【待补】华中农业大学第五届程序设计大赛 B Choosy in Food [高斯消元]【数学】"></a>【待补】华中农业大学第五届程序设计大赛 B Choosy in Food [高斯消元]【数学】</h1><p>2017年05月26日 21:08:14  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：302</p><hr><p> 博客爬取于<code>2019-04-18 17:16:43</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/72773595" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/72773595</a></p><p>题目链接: <a href="http://acm.hzau.edu.cn/problem.php?id=1200" target="_blank" rel="noopener"> http://acm.hzau.edu.cn/problem.php?id=1200</a><br>————————————————————————————————————————<br>1200: Choosy in Food<br>Time Limit: 1 Sec Memory Limit: 1280 MB<br>Submit: 48 Solved: 12<br>[Submit][Status][Web Board]<br>Description<br>Xiao Ming find n trees (labeled 0…n-1) which join a circle in a magical land.<br>Each tree<br>is covered with ripe berries. Xiao Ming wants to find the tree whose berries<br>are most delicious. He starts from the tree X, walks clockwise to find the<br>target. Each time the probability of him walking k trees is Pk% . P1+P2+..+Pk<br>= 100</p><p>Now we know the target of Xiao Ming is the tree Y. Require to know expectation<br>of the number of the trees which Xiao Ming walk through</p><p>Input<br>The first parameter is T, indicates the case number.</p><p>In each case, there are four integers at the first line, N, M, X , Y (Tree<br>labels from 0 to N-1, N &lt; 100, M &lt; N).</p><p>Output<br>The expectation of the number of trees Xiao Ming walk through. It will be<br>reserved two decimal places. If Xiao Ming will never arrive the tree, output<br>-1.</p><p>Sample Input<br>2<br>4 2 0 1<br>50 50<br>4 1 0 2<br>100<br>Sample Output<br>4.20<br>2.00</p><p>————————————————————————————————————————<br>题目大意：<br>就是有一些树（真的树，能结果子那种），围城一圈，编号0~n-1。一个人从X开始顺时针出发，可以走1~M步，每步的概率是  P  i<br>,问你走到Y的期望步数是多少.</p><p>解题思路:</p><pre><code>这种套路很明显的高斯消元啊.,但是我不会高斯消元啊.....  </code></pre><p>占坑待补…</p>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  华中农业大学第五届程序设计大赛 A Little Red Riding Hood [BIT优化dp]【动态规划】</title>
      <link href="/2017/05/26/72773556/"/>
      <url>/2017/05/26/72773556/</url>
      
        <content type="html"><![CDATA[<h1 id="华中农业大学第五届程序设计大赛-A-Little-Red-Riding-Hood-BIT优化dp-【动态规划】"><a href="#华中农业大学第五届程序设计大赛-A-Little-Red-Riding-Hood-BIT优化dp-【动态规划】" class="headerlink" title="华中农业大学第五届程序设计大赛 A Little Red Riding Hood [BIT优化dp]【动态规划】"></a>华中农业大学第五届程序设计大赛 A Little Red Riding Hood [BIT优化dp]【动态规划】</h1><p>2017年05月26日 21:02:33  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：547</p><hr><p> 博客爬取于<code>2019-04-18 17:16:44</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/72773556" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/72773556</a></p><p>题目链接: <a href="http://acm.hzau.edu.cn/problem.php?id=1199" target="_blank" rel="noopener"> http://acm.hzau.edu.cn/problem.php?id=1199</a></p><p>——————————————————————————————————————————<br>1199: Little Red Riding Hood<br>Time Limit: 1 Sec Memory Limit: 1280 MB<br>Submit: 937 Solved: 166<br>[Submit][Status][Web Board]<br>Description<br>Once upon a time, there was a little girl. Her name was Little Red Riding<br>Hood. One day, her grandma was ill. Little Red Riding Hood went to visit her.<br>On the way, she met a big wolf. “That’s a good idea.”，the big wolf thought.<br>And he said to the Little Red Riding Hood, “Little Red Riding Hood, the<br>flowers are so beautiful. Why not pick some to your grandma?” “Why didn’t I<br>think of that? Thank you.” Little Red Riding Hood said.</p><p>Then Little Red Riding Hood went to the grove to pick flowers. There were n<br>flowers, each flower had a beauty degree a[i]. These flowers arrayed one by<br>one in a row. The magic was that after Little Red Riding Hood pick a flower,<br>the flowers which were exactly or less than d distances to it are quickly<br>wither and fall, in other words, the beauty degrees of those flowers changed<br>to zero. Little Red Riding Hood was very smart, and soon she took the most<br>beautiful flowers to her grandma’s house, although she didn’t know the big<br>wolf was waiting for her. Do you know the sum of beauty degrees of those<br>flowers which Little Red Riding Hood pick?</p><p>Input<br>The first line input a positive integer T (1≤T≤100), indicates the number of<br>test cases. Next, each test case occupies two lines. The first line of them<br>input two positive integer n and</p><p>k (2 &lt;= n &lt;= 10^5 ) ,1 &lt;= k &lt;= n ), the second line of them input n positive<br>integers a (1&lt;=a &lt;=10^5)</p><p>Output<br>Each group of outputs occupies one line and there are one number indicates the<br>sum of the largest beauty degrees of flowers Little Red Riding Hood can pick.</p><p>Sample Input<br>1<br>3 1<br>2 1 3<br>Sample Output<br>5</p><p>———————————————————————————————————————————<br>题目大意：<br>就是一个序列，拿取的最大价值，拿取一个后，半径为k的位置价值都变为0了。</p><p>解题思路:</p><p>很明显更的dp</p><p>设dp[i]为到拿取第i个位置的最大价值,</p><p>转移就是  </p><p>d  p  [  i  ]  =  a  [  i  ]  +  m  a  x  {  d  p  [  j  ]  ∣  ∣  j  &lt; i  −<br>k  }</p><p>由于最大值是前缀最大值，所以用一个树状数组维护就好了</p><p>附本题代码<br>———————————————————————————————————————————</p><pre><code>#include &lt;bits/stdc++.h&gt;typedef long long int LL;using namespace std;const int N   = 2e5+7;//const int INF = (~(1&lt;&lt;31));int read(){    int x=0,f=1;char ch = getchar();    while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;) ch = getchar();    while(&#39;0&#39;&lt;=ch&amp;&amp;ch&lt;=&#39;9&#39;){x=(x&lt;&lt;3)+(x&lt;&lt;1)+ch-&#39;0&#39;;ch = getchar();}    return x;}/*******************************************/int a[N];int n,k;LL mx[N];#define lowbit(x) (x&amp;-x)void update(int i,LL v){    for(;i&lt;=n;i+=lowbit(i)) mx[i]=max(mx[i],v);}LL getMax(int i){    if(i&lt;=0) return 0;    LL ans = 0;    for(;i;i-=lowbit(i)) ans = max(ans,mx[i]);    return ans;}int main(){//printf(&quot;%d\n&quot;,INF);    int _;    scanf(&quot;%d&quot;,&amp;_);    while(_--){memset(mx,0,sizeof(mx));        scanf(&quot;%d%d&quot;,&amp;n,&amp;k);        for(int i=1;i&lt;=n;i++)    a[i]=read();        LL ans = 0,tmp;        for(int i=1;i&lt;=n;i++){            tmp=a[i]+getMax(i-k-1);            update(i,tmp);            ans = max(ans,tmp);        }        printf(&quot;%d\n&quot;,ans);    }    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  2017黑龙江省赛+东北地区赛总结</title>
      <link href="/2017/05/17/72355760/"/>
      <url>/2017/05/17/72355760/</url>
      
        <content type="html"><![CDATA[<h1 id="2017黑龙江省赛-东北地区赛总结"><a href="#2017黑龙江省赛-东北地区赛总结" class="headerlink" title="2017黑龙江省赛+东北地区赛总结"></a>2017黑龙江省赛+东北地区赛总结</h1><p>2017年05月17日 01:28:43  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：1969</p><hr><p> 博客爬取于<code>2019-04-18 17:16:45</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/72355760" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/72355760</a></p><p>好吧，还是需要总结下最近的省赛和东北赛，本来想等西安回来在一起写的，但是发现省赛、东北赛暴露出的问题是在太严重了。</p><p>还是简单叙述下敝队的这两场比赛吧</p><p>省赛：<br>热身：AB是考察队伍会不会编程语言，Ｃ是一个简单的dp 。但是队友却写了好久。。。然后随便测了测环境就走了。<br>正式：<br>AB还是考察这个队伍会不会编程语言。 然后看有队伍A了C 然后想啊想，还是没想出来，又看到有好多队伍A了E ,然后就去搞E，我想了想好像结果就是输出n到1.<br>又做过山东某省赛输出-1是没意义的就直接交了一发，果断的WA了，然后mengxiang000看了D，说D出了，就交给它去写，期间My_stage说分奇偶，偶<br>数是-1.当时我这在找偶数的解，确实找不出来，然后交了一发A了。然后My_stage在推C，mengxiang000在交D，WA了之后改了几个小细节，然后再<br>交，还是WA。于是我去看了看这题，咦?怎么和湖南某年省赛的某题很像啊，枚举边然后TOP不就好了，队友怎么可能不过。算了我上去写一发，因为队友已经写出来。所以<br>我写的时候细节上就参照mengxiang000的写，然后看mengxiang000的这个TOP怎么这么奇怪？？！！啊 原来mengxiang000只把点1放<br>到了队列中，没有将其他入度为0的点放入队列，这怎么能对，然后给mengxiang000一组数据告诉他错了，发现确实这样.于是改了AC。此时4题，罚时也有点爆<br>表。这时候三个人没一个对C有思路。看有人A了 F,让My_stage给我讲了F的题意，懂了，然后不会做啊。后来想到我可以倒叙处理这些删的边。然后维护答案，然<br>后维护的时候mengxiang000说是并查集，想了想，确实没有问题。然后交给mengxiang000去写，写完后测了几组小样例。好像没问题，交WA。多次W<br>A之后我想到可能两个堆都挂上但是合并了，这样的话按照最开始染的颜色就错了，然后我想用一个数组将颜色映射过去，然后开始调。对了几个小数据，交,WA。。改了交，<br>WA。 就这样WA到结束。</p><p>想了想封榜前的rk和罚时，1=是没有希望了。。。<br>但最后发现终榜rk并没有掉？！！ 于是捡了个1=。。。</p><p>东北赛：<br>热身：<br>很有意思的热身，因为前天测试过机器，长老说答30min就退场买东西，然后返校。然后热身A题，嗯，是个水题，没错，非常水，自己不想写，甩给mengxiang0<br>00和My_stage。自己去看B. B题堆到满足的一对结果就是a*b是平方数，然后想到某年山东省赛的G题H题。知道b一定是a的倍数，然后筛一晒就好了。但是<br>没读懂题目要求的集合是什么意思。然后过去20分钟a题竟然没A？？！！ 虽然看他们的做法很迷，但是相信他们能在很短时间内A了的。然而并没有A。而且mengxi<br>ang000心态还非常炸？？！！反正是热身，治治他这个毛病，（其实我在现场赛的时候是很炸的，从去年省选到现在，但是没办法为了不影响队友的心情只能强憋，但队友<br>这样我受不了啊，趁热身赛治治他）于是交了几发WA到点我就走了，我很不解啊，这个题不是大一入学是做的题么，字符串整体倒过来，在翻转单词不就好了。问什么这俩人没<br>AC？迷。于是鄙队第一次爆０了。。。还好是热身赛。。。。。<br>正式赛：<br>正式赛更迷啊。<br>开始看A Huffman？？！！ 我还能记得huffman树，但是怎么玩来的？想不到啊，过了几分钟看有人过了E，嗯是个签到题，于是mengxiang000上<br>去写，写到一半思路有点不清晰，换给我写，我接着他写的15min 1Y。之前我在看C。觉得特别的亲切，让mengxiang000先给翻译了，然而这时候很多人过<br>的是A，于是三个人还是主要在思考huffman的，然后发现敝队就我能记得huffman了，，，然后开始还想错了，WA了2发，想起不对正确的huffman姿势<br>不对啊。期间我让My_stage去数据结构书上找，他说没找到。好吧没找到，然后凭印象给mengxiang000讲了个huffman树是怎么建的，让他去模拟.<br>这时看了看榜，我们1题，rk1 4题。Orz。。同时队友给了我C题意，我去看C,刚换完座位，我看了看C？这不sb题，秒了，于是又换了座位，过样例、交，然后就<br>换了座位，过了一会结果返回TLE？？！！<br>怎么可能TLE。然后我读了读代码，嗯，应该是卡了map的log，问mengxiang000，数据范围多大，答5e5，嗯，换成数组85min<br>2Y。然后换回mengxiang000去敲A。交WA。然后我去调了调，发现有错，然后mengxiang000改了。120min 4Y、、然后rk还是很不好，<br>但是感觉2=应该稳了。然后My_stage说J是个dp。嗯，甩给mengxiang000，后My_stage给了G题题意?嗯有意思，看了看数据范围和时限，发<br>现对新子串Manachar就差不多了，然后手痒，没让My_stage敲。自己写。过样例，交,RE。。数组小了。。又交..RE?!! 看了看Manachar，<br>嗯有处可能越界，改了交。。TLE？！！！！，woc，这么科学的复杂度怎么可能TLE。。然后交换mengxiang000上机，同时想了想G。觉得多次询问用ma<br>p记录下？然后自己立马就给否了，觉得这么玩不是很科学。然后就想了想J,嗯，好像维护两个序列就好了， 一个买的一个卖的，保证买的比卖的多，就好了于是上去写。期<br>间My_stage上厕所回来说用map记录下之前处理过的值，我直接就给否了，说没什么意义。继续敲J，同时mengxiang000和My_stage一直在想m<br>ap为什么被我否了，几分钟后mengxiang000说只有3e4个1<br>0的时候才是最坏，那么记录下的话就会快很多，想了想确实很有道理啊，于是改了交，196min<br>5Y。。。这时感觉自己是在太智障和自以为是。但是不能表现出来。。。继续写J,过了样例。测了几组队友出的数据没问题。于是交204min 1Y。<br>然后看了看榜，5题倒第一啊，罚时爆表。。于是想着在出一题冲个1=啊。<br>看榜有过了I的，但是我之前就看了，没什么思路啊，一定是用什么维护的啊，想了想我会的数据结构BIT?不是。线段树？也不对。主席树？没啥用。Splay？好像大概<br>行，但是Splay只会贴版子，变一点就不会了。。于是mengxiang000在乱搞，交了几发TLE。然后看了看气球，冠军队过了F，于是问My_stage是什<br>么意思。给我说了大概，感觉根树剖有点像，但是一个比较关键的次expacted我们三个没一个认识的，那本小字典上还没有。看了看样例还很迷（当时忘了样例可能是错<br>的，正确的样例在PC上，现在想想可能是纸质版上样例错了啊。树剖我觉得我掌握的还是很好的啊<br>说不定就A了呢。），不知道最终到底要求什么，于是就放弃了。。。于是后40min<br>敝队就在那开心的聊天了，因为后期不发气球了，我队整场只有一个气球，看旁边别的队瞅我们就一个气球还乐呵呵的傻逼样的那种奇怪的表情。。。。直到结束..</p><p>但是最终去礼堂的时候jeh老师说我们是1=、 ？！！ woc这有意思了啊。</p><p>两场比赛都是罚时爆表啊。但都捡了个1=。。。。</p><p>比赛大概就是这样。。</p><hr><p>记得省赛结束的那句“比赛结束”的时候我终于想起F题哪里少了一个映射。。那时整个人都是绝望了，感觉这次又因为我最后没调出代码而GG了。 （16年的省赛/东北赛<br>都是我在奋力敲代码然而赛终GG）。而这时我们已经大二了，如果连HLJ的省一都拿不到，那我们拿什么去打接下来的东北赛，西安邀请赛，甚至下半年的ICPC？？，当<br>时我脑子里就两个字“退役”，这两个字不断的重复，在想自己怎么这么菜。赛前训练了十几场省赛，区域赛和强校的校赛。但无论过了多久代码力依然那么菜。细节多点的题仍<br>然要调很长时间。任何一场比赛都不能多输出两个？还打什么比赛啊，还TM队长呢。。。<br>那时真的整个人都是懵逼的，mengxiang000也不说话了，My_stage也没什么表情。学弟看到我那张驴脸还过来安慰我，，最后大家去溜达买东西了，我们三<br>个还坐在赛场门口旁的，哪里也不想去。<br>知道看到长老在群里发的我们拿了1= .???!!!woc这1=是怎么拿的<br>封榜前rk多少终榜rk还多少？？？！！！太给面子了。于是心情大好，滚去礼堂zhuangb了。。。</p><p>东北赛也差不多，但东北赛本来的目标就是2=头，所以没什么压力，最后告诉我们还是1=的时候真的有点不敢相信，运气是在是太好了。两次都是一样rk，都是1=倒第3<br>，省赛如果罚时在多4min，就是2=了。。这运气实在太好了。</p><p>然后领奖，返校。</p><p>然后这两天比赛确实很累，做了湘潭重现。然而发现题都已经读不懂了。。。。于是回寝咸鱼。</p><hr><p>一直在想这两场比赛，暴露了太多的问题。<br>1 我们队真的太菜了。<br>2 签到题迟迟不AC。<br>3 一些简单东西不熟练了，比如省赛的top序。 （如果没有耽误太长时间F是不是能调出来？<br>4 现场心态急躁<br>5 这是我个人的，作为队内的数学选手，对这C题却没有思路??!!经人一说，才会做？？！<br>6 还是我个人的，作为队内数据结构选手，F题却迟迟调不出来？？！！<br>7 依旧是我个人的。思维死板，有时候猜到的东西就可以用20分钟的罚时换一换么。总想只有证明出来的东西才稳妥，现场哪有那么多时间给你证明？？！<br>8 仍然是我个人的。不读题，读题大多靠队友，浪费了队友思考的时间。</p><p>9 这是全体的，三个人的知识点太偏，思维广度不够。做题太少。训练太少。</p><hr><p>虽然结果上看还不错，但是其实还是菜到家了。<br>想毕姥爷知乎上说的“各位不怎么强啊，也就能做做ACEGJ了啊”。<br>也确实，敝队还是菜的飞起。<br>简单的5题做完就只能咸鱼了，会的东西还太少了。</p><hr><p>其实这两场比赛也并不能完全代表敝队的水平。<br>mengxiang000更擅长搞图论，dp，但这两天没题啊。随便给我网络流让他做做么。<br>My_stage 更擅长搞字符串和递推啊。还是没有题啊、、、、</p><p>像省选时 ，个人会做的题即使不限时间的话也就能A 13个水题、 什么AC机，网络流，K短路，都是队友大力AC的啊。我是一丁点都不会啊。</p><p>最后还是努力训练吧，我个人还有一个陕西宴请赛就结束这个赛季了。努力点，少把时间浪费在学校的课堂上。回头学学图论+dp+字符串<br>这些东西，不用学太深，起码把算法裸题切了。</p><p>然后就是自己数学+数据结构这方面要继续深入学习啊。连个Splay都不会啊。。。 暑假就要队内的训练了，没时间大块时间学习了。</p>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  BZOJ 1798 [Ahoi2009] Seq 维护序列seq [线段树+多重标记下传]【数据结构】</title>
      <link href="/2017/05/16/72329005/"/>
      <url>/2017/05/16/72329005/</url>
      
        <content type="html"><![CDATA[<h1 id="BZOJ-1798-Ahoi2009-Seq-维护序列seq-线段树-多重标记下传-【数据结构】"><a href="#BZOJ-1798-Ahoi2009-Seq-维护序列seq-线段树-多重标记下传-【数据结构】" class="headerlink" title="BZOJ 1798 [Ahoi2009] Seq 维护序列seq [线段树+多重标记下传]【数据结构】"></a>BZOJ 1798 [Ahoi2009] Seq 维护序列seq [线段树+多重标记下传]【数据结构】</h1><p>2017年05月16日 19:19:16  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：262</p><hr><p> 博客爬取于<code>2019-04-18 17:16:46</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/72329005" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/72329005</a></p><p>题目链接: <a href="http://www.lydsy.com/JudgeOnline/problem.php?id=1798" target="_blank" rel="noopener"> http://www.lydsy.com/JudgeOnline/problem.php?id=1798</a></p><p>————————————————————————————————————————————<br>1798: [Ahoi2009]Seq 维护序列seq</p><p>Time Limit: 30 Sec Memory Limit: 64 MB<br>Submit: 6402 Solved: 2284<br>[Submit][Status][Discuss]<br>Description</p><p>老师交给小可可一个维护数列的任务，现在小可可希望你来帮他完成。 有长为N的数列，不妨设为a1,a2,…,aN 。有如下三种操作形式：<br>(1)把数列中的一段数全部乘一个值; (2)把数列中的一段数全部加一个值; (3)询问数列中的一段数的和，由于答案可能很大，你只需输出这个数模P的值。<br>Input</p><p>第一行两个整数N和P(1≤P≤1000000000）。第二行含有N个非负整数,从左到右依次为a1,a2,…,aN,<br>(0≤ai≤1000000000,1≤i≤N)。第三行有一个整数M，表示操作总数。从第四行开始每行描述一个操作，输入的操作有以下三种形式： 操作1：“1 t<br>g c”(不含双引号)。表示把所有满足t≤i≤g的ai改为ai×c (1≤t≤g≤N,0≤c≤1000000000)。 操作2：“2 t g<br>c”(不含双引号)。表示把所有满足t≤i≤g的ai改为ai+c (1≤t≤g≤N,0≤c≤1000000000)。 操作3：“3 t<br>g”(不含双引号)。询问所有满足t≤i≤g的ai的和模P的值 (1≤t≤g≤N)。 同一行相邻两数之间用一个空格隔开，每行开头和末尾没有多余空格。<br>Output</p><p>对每个操作3，按照它在输入中出现的顺序，依次输出一行一个整数表示询问结果。<br>Sample Input</p><p>7 43<br>1 2 3 4 5 6 7<br>5<br>1 2 5 5<br>3 2 4<br>2 3 7 9<br>3 1 3<br>3 4 7</p><p>Sample Output</p><p>2<br>35<br>8</p><p>HINT</p><p>【样例说明】</p><p>初始时数列为(1,2,3,4,5,6,7)。<br>经过第1次操作后，数列为(1,10,15,20,25,6,7)。<br>对第2次操作，和为10+15+20=45，模43的结果是2。<br>经过第3次操作后，数列为(1,10,24,29,34,15,16}<br>对第4次操作，和为1+10+24=35，模43的结果是35。<br>对第5次操作，和为29+34+15+16=94,模43的结果是8。</p><p>测试数据规模如下表所示</p><p>数据编号 1 2 3 4 5 6 7 8 9 10<br>N= 10 1000 1000 10000 60000 70000 80000 90000 100000 100000<br>M= 10 1000 1000 10000 60000 70000 80000 90000 100000 100000</p><p>————————————————————————————————————————————</p><p>其实对于只有一种操作的情况,我们只要做一个lazy标记就行了,<br>但是对于两种操作的时候就有点不知所措了,</p><p>其实道理都是一样的,既然有两种操作了,呢么就用两个lazy标记不就好了么</p><p>一个add[] 一个mul[] 分别记录加法和乘法操作,</p><p>然后直接维护就好了</p><p>注意的是pushdown的时候这两个标记是要合并的,</p><p>还是代码表述的好一些。</p><pre><code>void pushdown(int rt,int l,int r){    add[rt&lt;&lt;1]  =(add[rt&lt;&lt;1]  *mul[rt]+add[rt])%p;    add[rt&lt;&lt;1|1]=(add[rt&lt;&lt;1|1]*mul[rt]+add[rt])%p;    mul[rt&lt;&lt;1]  =(mul[rt&lt;&lt;1]  *mul[rt])%p;    mul[rt&lt;&lt;1|1]=(mul[rt&lt;&lt;1|1]*mul[rt])%p;    int m = r+l &gt;&gt; 1;    sum[rt&lt;&lt;1]  =(sum[rt&lt;&lt;1]  *mul[rt]+add[rt]*(m-l+1))%p;    sum[rt&lt;&lt;1|1]=(sum[rt&lt;&lt;1|1]*mul[rt]+add[rt]*(r-m))%p;    add[rt]=0,mul[rt]=1;}</code></pre><p>附本题代码<br>————————————————————————————————————————————</p><pre><code>#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long int LL;const int N   = 100000+7;const int MOD = 1e9+7;/*************************************************/int n,p;int a[N];LL sum[N&lt;&lt;2],mul[N&lt;&lt;2],add[N&lt;&lt;2];void pushup(int rt){    sum[rt]=(sum[rt&lt;&lt;1]+sum[rt&lt;&lt;1|1])%p;}void pushdown(int rt,int l,int r){    add[rt&lt;&lt;1]  =(add[rt&lt;&lt;1]  *mul[rt]+add[rt])%p;    add[rt&lt;&lt;1|1]=(add[rt&lt;&lt;1|1]*mul[rt]+add[rt])%p;    mul[rt&lt;&lt;1]  =(mul[rt&lt;&lt;1]  *mul[rt])%p;    mul[rt&lt;&lt;1|1]=(mul[rt&lt;&lt;1|1]*mul[rt])%p;    int m = r+l &gt;&gt; 1;    sum[rt&lt;&lt;1]  =(sum[rt&lt;&lt;1]  *mul[rt]+add[rt]*(m-l+1))%p;    sum[rt&lt;&lt;1|1]=(sum[rt&lt;&lt;1|1]*mul[rt]+add[rt]*(r-m))%p;    add[rt]=0,mul[rt]=1;}void build(int rt,int l,int r){    mul[rt]=1,add[rt]=0;    if(l==r){sum[rt]=a[l]%p; return;}    int m = r+l &gt;&gt; 1;    build(rt&lt;&lt;1  ,l  ,m);    build(rt&lt;&lt;1|1,m+1,r);    pushup(rt);}void update(int rt,int l,int r,int L,int R,int tadd,int tmul){    if(L&lt;=l&amp;&amp;r&lt;=R){        if(tadd!=-1){            add[rt]=(add[rt]+tadd)%p;            sum[rt]=(sum[rt]+(LL)tadd*(r-l+1))%p;        }        if(tmul!=-1){            add[rt]=(add[rt]*tmul)%p;            mul[rt]=(mul[rt]*tmul)%p;            sum[rt]=(sum[rt]*tmul)%p;        }        return ;    }    pushdown(rt,l,r);    int m = r+l &gt;&gt; 1;    if(L&lt;=m) update(rt&lt;&lt;1  ,l  ,m,L,R,tadd,tmul);    if(R&gt; m) update(rt&lt;&lt;1|1,m+1,r,L,R,tadd,tmul);    pushup(rt);    return ;}LL query(int rt,int l,int r,int L,int R){    if(L&lt;=l&amp;&amp;r&lt;=R)    return sum[rt]%p;    pushdown(rt,l,r);    int m = r+l &gt;&gt; 1;LL ans = 0;    if(L&lt;=m) ans=(ans+query(rt&lt;&lt;1  ,l  ,m,L,R))%p;    if(R&gt; m) ans=(ans+query(rt&lt;&lt;1|1,m+1,r,L,R))%p;    pushup(rt);    return ans%p;}int main(){    while(~scanf(&quot;%d%d&quot;,&amp;n,&amp;p)){        for(int i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;a[i]);        build(1,1,n);        int m ;scanf(&quot;%d&quot;,&amp;m);        int op,l,r,c;        while(m--){            scanf(&quot;%d&quot;,&amp;op);            if(op==1){                scanf(&quot;%d%d%d&quot;,&amp;l,&amp;r,&amp;c);                update(1,1,n,l,r,-1,c);            }            else if(op==2){                scanf(&quot;%d%d%d&quot;,&amp;l,&amp;r,&amp;c);                update(1,1,n,l,r,c,-1);            }            else {                scanf(&quot;%d%d&quot;,&amp;l,&amp;r);                printf(&quot;%lld\n&quot;,query(1,1,n,l,r));            }        }    }    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  山东省第八届ACM大学生程序设计竞赛 训练总结 [8/11] 待补</title>
      <link href="/2017/05/11/71698163/"/>
      <url>/2017/05/11/71698163/</url>
      
        <content type="html"><![CDATA[<h1 id="山东省第八届ACM大学生程序设计竞赛-训练总结-8-11-待补"><a href="#山东省第八届ACM大学生程序设计竞赛-训练总结-8-11-待补" class="headerlink" title="山东省第八届ACM大学生程序设计竞赛 训练总结 [8/11] 待补"></a>山东省第八届ACM大学生程序设计竞赛 训练总结 [8/11] 待补</h1><p>2017年05月11日 21:10:00  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：555</p><hr><p> 博客爬取于<code>2019-04-18 17:16:47</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/71698163" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/71698163</a></p><p>迟来的总结<br>队友缺席一人，两人，vj 5h模拟，1+小时从下开始看榜。</p><p>F题很迷，同时我很智障，居然浪费全队2个小时，个人3+小时的时间，，，，，导致最后的GG</p><p>做题的时候要更加细心，思维要缜密，同时不能有一点懒惰，有些认为可有可有的操作还是写上更为保险一点。</p><p>因为F题我只判了  −  b  +  det  −  −  −  √  2  a  而另一个解想当然的没有判。。。炸锅<br>看F之前3题。期间我清清脑子A了C，然后就GG了，</p><p>K题最后因为实验室清楼，时间不够了，算上回寝室走路的时间，队友晚了6分钟AC，然后这个A,D<br>都是我的题，当时想F想的，脑子一片浆糊，没有想出。赛后想到了。。。。</p><p>比赛时头脑要清晰，思维要严谨，尤其是不能懒，</p><h1 id="Problem-A-SDUT-3893-Return-of-the-Nim"><a href="#Problem-A-SDUT-3893-Return-of-the-Nim" class="headerlink" title="Problem A SDUT 3893 Return of the Nim"></a>Problem A SDUT 3893 Return of the Nim</h1><p>————————————————————————————————————————————<br>有n(n 是素数)堆石子，两个人轮流玩，每次可以再一堆拿走任意个，或者在剩下的所有堆拿走相同的个数的石子，取走最后一个石子的人赢，问你谁赢</p><hr><p>n是素数,所以切入点一定是这里，想了所有素数的性质，想不出什么所以然来，</p><p>然后玩了玩，其实可以发现，<br>对于n=2 时就是威佐夫博弈，</p><p>对于n=other 的时候，n是奇数，那么对于在所有堆拿走相同的石子，其实就是相当于两个人玩了多次的正常Nim，<br>因为Nim的最优策略就是对方拿了x个石子，我就在其他堆也拿x个石子，所以这就划归为基本的Nim游戏了，，</p><p>附本题代码<br>————————————————————————————</p><pre><code>#include &lt;bits/stdc++.h&gt;typedef long long int LL;using namespace std;const int MOD = 1e9+7;const int N   = 1e5+7;int main(){    int _;    scanf(&quot;%d&quot;,&amp;_);    while(_--){int n,x;        scanf(&quot;%d&quot;,&amp;n);        if(n==2){            int m;            scanf(&quot;%d %d&quot;,&amp;n,&amp;m);            if(n&lt;m){                n=n^m;                m=m^n;                n=n^m;            }            int k=n-m;            n=(int)(k*(1+sqrt(5))/2.0);            if(n==m) puts(&quot;Watson&quot;);            else puts(&quot;Sherlock&quot;);            continue;        }        int ans = 0;        for(int i=1;i&lt;=n;i++){            scanf(&quot;%d&quot;,&amp;x);            ans ^=x;        }        if(ans) puts(&quot;Sherlock&quot;);        else puts(&quot;Watson&quot;);    }    return 0;}</code></pre><h1 id="Problem-B-SDUT-3894-Quadrat"><a href="#Problem-B-SDUT-3894-Quadrat" class="headerlink" title="Problem B SDUT 3894 Quadrat"></a>Problem B SDUT 3894 Quadrat</h1><p>————————————————————————————————————————————<br>还没弄懂题意,等邀请赛回来,,,</p><hr><h1 id="Problem-C-SDUT-3895-fireworks"><a href="#Problem-C-SDUT-3895-fireworks" class="headerlink" title="Problem C SDUT 3895 fireworks"></a>Problem C SDUT 3895 fireworks</h1><p>————————————————————————————————————————————<br>就是在一个坐标轴上,有一些点(x)有一个价值(a)<br>每秒这些点和他们临近的点的价值变成(x-0) (x+1 - a) (x-1 - a)<br>价值会叠加，问你t秒后w位置有多少个值</p><hr><p>写了写就会发现，每个点经过t妙对其他点的贡献是一个杨辉三角，</p><p>那么我们就枚举每个点对结果的贡献最后在加和就好了</p><p>附本题代码<br>————————————————————————————————————————————</p><pre><code>#include &lt;bits/stdc++.h&gt;typedef long long int LL;using namespace std;const int N   = 1e5+7;const int MOD = 1e9+7;int abs(int x){    if(x&gt;=0) return x;    return -x;}int dis(int a,int b){    return abs(a-b);}LL qmod(LL a,LL b){    LL res = 1;    while(b){        if(b&amp;1) res=res*a%MOD;        b&gt;&gt;=1,a=a*a%MOD;    }    return res;}LL Fac[N],Inv[N];void init(){    Fac[0]=1;    for(int i=1;i&lt;N;i++) Fac[i]=(Fac[i-1]*i)%MOD;    Inv[N-1]=qmod(Fac[N-1],MOD-2);    for(int i=N-2;i&gt;=0;i--) Inv[i]=(Inv[i+1]*(i+1))%MOD;}LL cal(LL t,LL c){    return Fac[t]*Inv[c]%MOD*Inv[t-c]%MOD;}int main(){    init();    LL n,t,w,x,c;    while(~scanf(&quot;%lld%lld%lld&quot;,&amp;n,&amp;t,&amp;w)){        LL ans = 0;        for(int i=1;i&lt;=n;i++){            scanf(&quot;%lld%lld&quot;,&amp;x,&amp;c);            if(dis(w,x)&gt;t|| (dis(w,x)+t)&amp;1) continue;            ans=(ans+cal(t,(t-dis(w,x))/2)*c)%MOD;        }        printf(&quot;%lld\n&quot;,ans);    }    return 0;}</code></pre><h1 id="Problem-D-SDUT-3896-HEX"><a href="#Problem-D-SDUT-3896-HEX" class="headerlink" title="Problem D SDUT 3896 HEX"></a>Problem D SDUT 3896 HEX</h1><p>————————————————————————————————————————————<br>这个题就是一个点可以走到下面临近的三个位置上，问你从(1,1)到(n,m)的走法有多少个,</p><hr><p>其实可以划到直角坐标系上,走法就是(0,1)(1,1)(1,0)</p><p>然后我们类比只有两种走法的情况 - (0,1)(1,0)</p><p>答案很明显是C(n+m,n), 那么对于三种情况当然也一样啊,</p><p>但是注意当(1,1)存在的时候(0,1)(1,0)相对就会变少结果也不一样,</p><p>然后我们可以枚举(1,1)的个数,然后就能确定三种走法的总数了,然后求下组合数就好了</p><p>附本题代码<br>————————————————————————————————————————————</p><pre><code>#include &lt;bits/stdc++.h&gt;typedef long long int LL;using namespace std;const int MOD = 1e9+7;const int N   = 1e5+7;LL qmod(LL a,LL b){    LL res = 1;    while(b){        if(b&amp;1) res=res*a%MOD;        b&gt;&gt;=1,a=a*a%MOD;    }    return res;}LL Fac[N],Inv[N];void init(){    Fac[0]=1;    for(LL i=1;i&lt;N;i++) Fac[i]=(Fac[i-1]*i)%MOD;    Inv[N-1]=qmod(Fac[N-1],MOD-2);    for(LL i=N-2;i&gt;=0;i--) Inv[i]=(Inv[i+1]*(i+1))%MOD;}LL C(LL t,LL c){    return Fac[t]*Inv[c]%MOD*Inv[t-c]%MOD;}int main(){    init();LL n,m;    while(~scanf(&quot;%lld %lld&quot;,&amp;n,&amp;m)){        n=n-m+1;n--,m--;if(n&lt;m) swap(n,m);//        printf(&quot;%lld %lld\n&quot;,n,m);        LL ll = min(n,m),lll = max(n,m);        LL ans = 0,tot,xia,zuo,xie;        for(LL i=0;i&lt;=ll;i++){            tot = n+m-i;            xia = n-i;            zuo = m-i;            xie = i;            ans=(ans+C(tot,xia)*C(tot-xia,zuo)+MOD)%MOD;        }        printf(&quot;%lld\n&quot;,ans);    }    return 0;}</code></pre><h1 id="Problem-E-SDUT-3897-news-reporter"><a href="#Problem-E-SDUT-3897-news-reporter" class="headerlink" title="Problem E SDUT 3897 news reporter"></a>Problem E SDUT 3897 news reporter</h1><p>————————————————————————————————————————————<br>队友认为是01分数规划，，但是有不太一样，最后没出。</p><hr><h1 id="Problem-F-SDUT-3898-quadratic-equation"><a href="#Problem-F-SDUT-3898-quadratic-equation" class="headerlink" title="Problem F SDUT 3898 quadratic equation"></a>Problem F SDUT 3898 quadratic equation</h1><p>————————————————————————————————————————————<br>让你判断“对于任意的x，如果方程  a  x  2  +  b  x  +  c  =  0  成立,x一定是正数”这句话是不是对的，</p><hr><p>所以就是方程不成立的时候也是YES</p><blockquote><p>对于命题P-&gt;Q</p></blockquote><blockquote></blockquote><blockquote><p>P  Q  P-&gt;Q</p></blockquote><blockquote></blockquote><blockquote><p>0</p></blockquote><blockquote><p>0</p></blockquote><blockquote><p>1</p></blockquote><blockquote></blockquote><blockquote><p>0</p></blockquote><blockquote><p>1</p></blockquote><blockquote><p>1</p></blockquote><blockquote></blockquote><blockquote><p>1</p></blockquote><blockquote><p>0</p></blockquote><blockquote><p>0</p></blockquote><blockquote></blockquote><blockquote><p>1</p></blockquote><blockquote><p>1</p></blockquote><blockquote><p>1</p></blockquote><blockquote></blockquote><blockquote><p>所以这题注意下判断  b  2  −  4  a  c  的符号就行了</p></blockquote><p>附本题代码<br>————————————————————————————</p><pre><code>#include &lt;bits/stdc++.h&gt;using namespace std;#define no  puts(&quot;NO&quot;);#define yes puts(&quot;YES&quot;);int abs(int x){    if(x&gt;=0) return x;    return -x;}int main(){    int _,a,b,c;    scanf(&quot;%d&quot;,&amp;_);    while(_--){        scanf(&quot;%d%d%d&quot;,&amp;a,&amp;b,&amp;c);        if(a==0&amp;&amp;b==0&amp;&amp;c==0){            no        }        else if(a==0&amp;&amp;b==0&amp;&amp;c!=0){            yes        }        else if(a==0&amp;&amp;b!=0&amp;&amp;c==0){            yes        }        else if(a==0&amp;&amp;b!=0&amp;&amp;c!=0){            if(c%b==0) yes            else no        }        else if(a!=0&amp;&amp;b==0&amp;&amp;c==0){            yes        }        else if(a!=0&amp;&amp;b==0&amp;&amp;c!=0){            if(b*b-a*c*4&lt;0) yes            else {                if(c%a==0){                    int d=c/a;d=abs(d);                    if(((int)(sqrt(d))*(int)(sqrt(d)))==d) yes                    else no                }                else no            }        }        else if(a!=0&amp;&amp;b!=0&amp;&amp;c==0){            if(b*b-a*c*4&lt;0) yes            else {                int d = b*b-4*a*c;                d = abs(d);                if(((int)(sqrt(d))*(int)(sqrt(d)))==d){                    int e = (int)sqrt(d);                    if( (e-b)%(a*2)==0 &amp;&amp;(e+b)%(a*2)==0) yes                    else                 no                }                else no            }        }        else if(a!=0&amp;&amp;b!=0&amp;&amp;c!=0){            if(b*b-a*c*4&lt;0) yes            else {                int d = b*b-4*a*c;                d = abs(d);                if(((int)(sqrt(d))*(int)(sqrt(d)))==d){                    int e = (int)sqrt(d);                    if( (e-b)%(a*2)==0 &amp;&amp;(e+b)%(a*2)==0) yes                    else                 no                }                else no            }        }    }    return 0;}</code></pre><h1 id="Problem-G-SDUT-3899-sum-of-power"><a href="#Problem-G-SDUT-3899-sum-of-power" class="headerlink" title="Problem G SDUT 3899 sum of power"></a>Problem G SDUT 3899 sum of power</h1><p>————————————————————————————————————————————</p><p>水签到题 不解释</p><h1 id="Problem-H-SDUT-3900-triangle"><a href="#Problem-H-SDUT-3900-triangle" class="headerlink" title="Problem H SDUT 3900 triangle"></a>Problem H SDUT 3900 triangle</h1><p>————————————————————————————————————————————<br>不会</p><h1 id="Problem-I-SDUT-3901-Parity-check"><a href="#Problem-I-SDUT-3901-Parity-check" class="headerlink" title="Problem I SDUT 3901 Parity check"></a>Problem I SDUT 3901 Parity check</h1><p>————————————————————————————————————————————<br>很容易发现循环节 1 1 0</p><p>然后大数取模就好了， 并不用写高精度</p><p>附本题代码<br>——————————————————————————————————————————</p><pre><code>#include&lt;stdio.h&gt;#include&lt;string.h&gt;using namespace std;char a[1050000];int main(){    while(~scanf(&quot;%s&quot;,a))    {        if(strcmp(a,&quot;0&quot;)==0)        {            printf(&quot;0\n&quot;);            continue;        }        int sum=0;        int n=strlen(a);        for(int i=0;i&lt;n;i++)        {            sum=sum*10+a[i]-&#39;0&#39;;            sum%=3;        }        if(sum==1||sum==2)printf(&quot;1\n&quot;);        else printf(&quot;0\n&quot;);    }}</code></pre><h1 id="Problem-J-SDUT-3902-company"><a href="#Problem-J-SDUT-3902-company" class="headerlink" title="Problem J SDUT 3902 company"></a>Problem J SDUT 3902 company</h1><p>————————————————————————————————————————————<br>队友自己做的 ,我没读题</p><h1 id="Problem-K-SDUT-3903-CF"><a href="#Problem-K-SDUT-3903-CF" class="headerlink" title="Problem K SDUT 3903 CF"></a>Problem K SDUT 3903 CF</h1><p>————————————————————————————————————————————<br>队友自己做的 ,</p><p>贪心+01包</p>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  hrbustoj 1681 回文串 [BIT]【字符串hash】</title>
      <link href="/2017/05/09/71453698/"/>
      <url>/2017/05/09/71453698/</url>
      
        <content type="html"><![CDATA[<h1 id="hrbustoj-1681-回文串-BIT-【字符串hash】"><a href="#hrbustoj-1681-回文串-BIT-【字符串hash】" class="headerlink" title="hrbustoj 1681 回文串 [BIT]【字符串hash】"></a>hrbustoj 1681 回文串 [BIT]【字符串hash】</h1><p>2017年05月09日 14:02:21  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：499</p><hr><p> 博客爬取于<code>2019-04-18 17:16:48</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/71453698" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/71453698</a></p><p>题目链接: <a href="http://acm.hrbust.edu.cn/index.php?m=ProblemSet&amp;a=showProblem&amp;problem_id=1681" target="_blank" rel="noopener"><br>http://acm.hrbust.edu.cn/index.php?m=ProblemSet&amp;a=showProblem&amp;problem_id=1681 </a><br>————————————————————————————————————————————</p><p>回文串<br>Time Limit: 1000 MS Memory Limit: 32768 K<br>Total Submit: 121(25 users) Total Accepted: 30(12 users) Rating: Special<br>Judge: No<br>Description<br>现在我们有一个很长很长的字符串，并且我们将有两种操作。<br>C i y:将第i个字符变成y<br>Q i j:检查第i个字符到第j个字符是否为一个回文串<br>Input<br>输入的第一行是一个整数T，表示一共有T组测试数据；<br>对于每组测试数据，第一行包含一个字符串长度不超过1000000。<br>接下来一行为一个整数N代表操作次数。N不超过1000000<br>接下来N行包含一种操作。<br>所有的字母都是小写字母。<br>Output<br>对于每种操作，如果相应的字符串为回文串输出”yes”，后则输出”no”。<br>Sample Input<br>1<br>aaaaa<br>4<br>Q 1 5<br>C 2 b<br>Q 1 5<br>Q 1 3<br>Sample Output<br>yes<br>no<br>yes</p><p>————————————————————————————————————————————</p><p>我们判定一个字符串是不是回文的只需判断正过来和倒过来是不是相等的就好了.</p><p>对于字符串是不是相等的 ，正常需要O(length)判定，对于本题，显然是不可取的。</p><p>所以介绍下字符串hash算法，</p><p>hash就是映射吧，将一个字符串集合中的每个映射为一个值，这些值互不相同</p><p>随意设一个常数x  </p><p>s  t  r  i  n  g  (  1  ,  i  )  =  ∑  i  =  1  i  (  s  t  r  i  n  g  [  i<br>]  ×  x  i  )</p><p>这样就能将一个字符串映射为一个正整数,</p><p>虽然这样计算的结果很可能是相同的,,但是可喜的是相同的概率十分小.所以可以直接使用.</p><p>但是一般我们采用的是unsigned long long int,在计算中也不需要取模操作,因为运算的自然溢出就相当于对  2  6  4  −  1<br>取模了。</p><p>这样下来,我们只需要将字符串正着hash一遍,倒着hash一遍,就可以了,</p><p>因为有修改操作，所以我们采用BIT维护下。</p><p><strong> 注意：判定两个子串的时候，x的指数不对应，只需要在小的那个结果乘上差的那部分  x  i  就好了 </strong></p><p>附本题代码<br>————————————————————————————————————————————</p><pre><code>#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long int LL;typedef unsigned long long int ULL;const int N = 1e6+7;ULL sum[N][2];int len ;#define lowbit(x) (x&amp;-x)void update(int i,ULL v,int w){    for(;i&lt;=len;i+=lowbit(i)) sum[i][w]+=v;}void update2(int i,ULL v,int w){    for(;i&lt;=len;i+=lowbit(i)) sum[i][w]-=v;}ULL getSum(int i,int w){    ULL res = 0;    for(;i;i-=lowbit(i)) res+=sum[i][w];    return res;}char a[N],b[10];ULL h[N];void init(){    h[0]=1;    for(int i=1;i&lt;N;i++)h[i]=h[i-1]*29;}int main(){    init();    int _;    scanf(&quot;%d&quot;,&amp;_);    while(_--){memset(sum,0,sizeof(sum));        scanf(&quot;%s&quot;,a+1);        len = strlen(a+1);        for(int i=1;a[i];i++)            update(i,h[i]*(a[i]-&#39;a&#39;+1),1),update(i,h[i]*(a[len-i+1]-&#39;a&#39;+1),0);        int n,l,r;        scanf(&quot;%d&quot;,&amp;n);        while(n--){            scanf(&quot;%s&quot;,b);            if(b[0]==&#39;Q&#39;){                scanf(&quot;%d%d&quot;,&amp;l,&amp;r);                ULL tem = getSum(r,1)-getSum(l,1);                ULL tmp = getSum(len-l+1,0)-getSum(len-r+1,0);                if(tem*h[len-r+1] == tmp*h[l]) puts(&quot;yes&quot;);                else           puts(&quot;no&quot;);            }            else {                scanf(&quot;%d%s&quot;,&amp;l,b);                update2(l,h[l]*(a[l]-&#39;a&#39;+1),1);                update2(len-l+1,h[len-l+1]*(a[l]-&#39;a&#39;+1),0);                a[l]=b[0];                update(l,h[l]*(a[l]-&#39;a&#39;+1),1);                update(len-l+1,h[len-l+1]*(a[l]-&#39;a&#39;+1),0);            }        }    }    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  第十三届北京师范大学程序设计竞赛决赛 【(6+2)/10】</title>
      <link href="/2017/05/09/71440571/"/>
      <url>/2017/05/09/71440571/</url>
      
        <content type="html"><![CDATA[<h1 id="第十三届北京师范大学程序设计竞赛决赛-【-6-2-10】"><a href="#第十三届北京师范大学程序设计竞赛决赛-【-6-2-10】" class="headerlink" title="第十三届北京师范大学程序设计竞赛决赛 【(6+2)/10】"></a>第十三届北京师范大学程序设计竞赛决赛 【(6+2)/10】</h1><p>2017年05月09日 11:30:44  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：1194</p><hr><p> 博客爬取于<code>2019-04-18 17:16:50</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/71440571" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/71440571</a></p><p>日常6题 然后GG</p><p>最后这个B题和D题也没有过掉</p><p>套路啊 智商还是不行啊</p><h1 id="A-Araleii-amp-Bill的冠名权争夺战之登顶校赛"><a href="#A-Araleii-amp-Bill的冠名权争夺战之登顶校赛" class="headerlink" title="A Araleii &amp; Bill的冠名权争夺战之登顶校赛"></a>A Araleii &amp; Bill的冠名权争夺战之登顶校赛</h1><p>————————————————————————————————————————————<br>这个A题开场几分钟队友就匆忙上机给秒了 666啊</p><p>我们这样考虑</p><p>对于一个说对的概率是1/m ,那么n个人的期望就是n/m</p><p>然而这个期望其实就是  </p><p>E  =  n  /  m  =  ∑  i  =  1  n  (  p  i  ×  i  )  (p_i  为  i  个  人  答  对  的<br>概  率  )</p><p>p  n  最大值显然是 n/m=  p  n  ×  n</p><p>所以最后答案就是1/m</p><h1 id="B-神奇的身高"><a href="#B-神奇的身高" class="headerlink" title="B 神奇的身高"></a>B 神奇的身高</h1><p>————————————————————————————————————————————</p><p>对于一个序列我们将其变成升序序列,可以直接 a[i]-i 然后求LIS. 但是这样的结果可能是负数或者0的,</p><p>然而其实很简单 对于每个a[i]-i 如果小于0 那就一定要变化,所以就对剩下的序列求LIS就可以了,求得的结果就是不用修改的,那么修改的就是n减去</p><p>附本题代码<br>——————————————————————————————————————————</p><pre><code>#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long int LL;const int N   = 100000+7;const int INF = 2000000007;int b[N],cnt,n;int main(){    while(~scanf(&quot;%d&quot;,&amp;n)){        int mx=0,x;cnt=0;        for(int i=0;i&lt;=n;i++) b[i]=INF;        for(int i=1,id;i&lt;=n;i++){            scanf(&quot;%d&quot;,&amp;x);x-=i;            if(x&lt;0) continue;            id = upper_bound(b+1,b+1+n,x)-b;            b[id]=x;            mx=mx&gt;id?mx:id;        }        printf(&quot;%d\n&quot;,n-mx);    }    return 0;}</code></pre><h1 id="C-Attack-on-Titan"><a href="#C-Attack-on-Titan" class="headerlink" title="C Attack on Titan"></a>C Attack on Titan</h1><p>————————————————————————————————————————————<br>这个题就是用50条直线,将平面内的一些点给分堆了,</p><p>如果直接找两个点之间的关系的话是复杂度是O(NKM)的,不可取,</p><p>但是问什么这个M给的是50呢？ 仔细想一想，这个50 一定是一个可以枚举的，</p><p>然后想到，对于每一条直线来说，都会将平面内的点分成两部分，那么我们给直线一边的标记为1，另一边的标记为0，这样就能将每一个点的状态压缩下来，然后将titan<br>的状态map一下，在判每一个村庄他的状态就行了。</p><p>附本题代码<br>————————————————————————————————————————————</p><pre><code>#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long int LL;const int N = 1e6+7;int n,m,k;struct point{    LL x,y;    LL flag;}cty[N],titan[N],a,b;map&lt;LL,bool&gt;mmp;LL mutli(point p0,point p1,point p2){    return ((p1.x-p0.x)*(p2.y-p0.y)-(p2.x-p0.x)*(p1.y-p0.y));}int main(){    int _;    scanf(&quot;%d&quot;,&amp;_);    while(_--){ mmp.clear();        scanf(&quot;%d%d%d&quot;,&amp;n,&amp;k,&amp;m);        for(int i=1;i&lt;=n;i++) scanf(&quot;%lld%lld&quot;,&amp;cty[i].x,&amp;cty[i].y),cty[i].flag=0ll;        for(int i=1;i&lt;=k;i++) scanf(&quot;%lld%lld&quot;,&amp;titan[i].x,&amp;titan[i].y),titan[i].flag=0ll;        for(int i=0;i&lt;m;i++){            scanf(&quot;%lld%lld%lld%lld&quot;,&amp;a.x,&amp;a.y,&amp;b.x,&amp;b.y);            for(int j=1;j&lt;=n;j++)                if(mutli(a,b,cty[j])   &gt; 0) cty[j].flag |=(1ll&lt;&lt;i);            for(int j=1;j&lt;=k;j++)                if(mutli(a,b,titan[j]) &gt; 0) titan[j].flag |=(1ll&lt;&lt;i);        }        for(int i=1;i&lt;=k;i++){            mmp[titan[i].flag]=true;//            printf(&quot;titan[%d] : %d\n&quot;,i,titan[i].flag);        }        for(int i=1;i&lt;=n;i++){//            printf(&quot;country[%d] : %d\n&quot;,i,cty[i].flag);            if(mmp[cty[i].flag]) puts(&quot;1&quot;);            else                 puts(&quot;0&quot;);        }    }    return 0;}</code></pre><h1 id="D-超级线段树"><a href="#D-超级线段树" class="headerlink" title="D 超级线段树"></a>D 超级线段树</h1><p>————————————————————————————————————————————<br>这个题简直666 啊</p><p>本质就是一个区间覆盖问题,<br>但是直接区间覆盖会TLE ,然后就一直想怎么做到O(n),,,最后GG了</p><p>其实我们可以逆序覆盖,然后每次更新的时候lazy_tag如果有,那就不给它更新了,算是上一个大剪枝了.</p><p>附本题代码<br>————————————————————————————————————————————</p><pre><code>#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long int LL;const int N = 1e6+7;inline int read(){    int x=0,f=1;char ch = getchar();    while(&#39;0&#39;&gt; ch||ch&gt; &#39;9&#39;) {if(ch==&#39;-&#39;)f=-1;ch=getchar();}    while(&#39;0&#39;&lt;=ch&amp;&amp;ch&lt;=&#39;9&#39;) {x=(x&lt;&lt;3)+(x&lt;&lt;1)+ch-&#39;0&#39;;ch=getchar();}    return x*f;}int lazy[N&lt;&lt;2];inline void build(int rt,int l,int r){    lazy[rt]=0;    if(l==r)return;    int m = r+l &gt;&gt; 1;    build(rt&lt;&lt;1  ,l  ,m);    build(rt&lt;&lt;1|1,m+1,r);}inline void pushdown(int &amp;rt){    if(lazy[rt]){        if(!lazy[rt&lt;&lt;1])  lazy[rt&lt;&lt;1]  =lazy[rt];        if(!lazy[rt&lt;&lt;1|1])lazy[rt&lt;&lt;1|1]=lazy[rt];    }}inline void update(int rt,int l,int r,int &amp;L,int &amp;R,int &amp;val){    if(lazy[rt]) return ;    if(L&lt;=l&amp;&amp;r&lt;=R){        lazy[rt]=val;        return;    }    pushdown(rt);    int m = r+l &gt;&gt; 1;    if(L&lt;=m) update(rt&lt;&lt;1  ,l  ,m,L,R,val);    if(R&gt; m) update(rt&lt;&lt;1|1,m+1,r,L,R,val);}inline void visit(int rt,int l,int r){    if(l==r){printf(&quot;%d\n&quot;,lazy[rt]);return;}    pushdown(rt);    int m = r+l &gt;&gt; 1;    visit(rt&lt;&lt;1  ,l  ,m);    visit(rt&lt;&lt;1|1,m+1,r);}int l[N],r[N],p[N];int main(){    int _=read(),n,m;    while(_--){        n=read(),m=read();        build(1,1,n);        for(int i=1;i&lt;=m;i++)   l[i]=read(),r[i]=read(),p[i]=read();        for(int i=m;i;i--)      update(1,1,n,l[i],r[i],p[i]);        visit(1,1,n);    }    return 0;}</code></pre><h1 id="E-rating计算"><a href="#E-rating计算" class="headerlink" title="E rating计算"></a>E rating计算</h1><p>————————————————————————————————————————————<br>签到水题,不解释</p><h1 id="F-进化之地-Evoland"><a href="#F-进化之地-Evoland" class="headerlink" title="F 进化之地(Evoland)"></a>F 进化之地(Evoland)</h1><p>————————————————————————————————————————————<br>稍微多点细节的搜索, 队友A的 不想补</p><h1 id="G-贪心"><a href="#G-贪心" class="headerlink" title="G 贪心"></a>G 贪心</h1><p>————————————————————————————————————————————<br>没什么说的直接二分答案就好了</p><p>附本题代码(队友代码 不要脸的贴过来了)<br>————————————————————————————————————————————</p><pre><code>#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;algorithm&gt;using namespace std;#define ll long long intstruct node{    ll x,y,ss;}a[150000];ll n,m;ll cmp(node a,node b){    return a.ss&lt;b.ss;}int Slove(ll mid){    ll sum=0;    for(ll j=1;j&lt;=n;j++)a[j].ss=mid*a[j].y+a[j].x;    sort(a+1,a+1+n,cmp);    for(ll j=1;j&lt;=mid;j++)    {        sum+=a[j].ss;    }    if(sum&lt;=m)return 1;    else return 0;}int main(){    while(~scanf(&quot;%lld%lld&quot;,&amp;n,&amp;m))    {        ll output=0;        for(ll i=1;i&lt;=n;i++)scanf(&quot;%lld&quot;,&amp;a[i].x);        for(ll i=1;i&lt;=n;i++)scanf(&quot;%lld&quot;,&amp;a[i].y);        ll l=0;        ll r=n;        while(r-l&gt;=0)        {            ll mid=(l+r)/2;            if(Slove(mid)==1)            {                output=mid;                l=mid+1;            }            else r=mid-1;        }        printf(&quot;%lld\n&quot;,output);    }}</code></pre><h1 id="H-简单的传球游戏"><a href="#H-简单的传球游戏" class="headerlink" title="H 简单的传球游戏"></a>H 简单的传球游戏</h1><p>————————————————————————————————————————————<br>这题如果直接计算的话,会涉及每次到甲的概率,通式推不出来</p><p>然后当时就分成两个值</p><p>甲  i  ：  第  i  次  传  到  甲  的  方  案  数  !  甲  i  :  第  i  次  没  有  传  到  甲  的<br>方  案  数</p><p>然后很容易构造矩阵  </p><p>[  甲  i  !  甲  i  ]  ×  [  0  1  k  −  1  k  −  2  ]  =  [  甲  i  +  1  !  甲<br>i  +  1  ]  (2)</p><p>然后矩阵乘法即可</p><p>附本题代码<br>——————————————————————————————————————————</p><pre><code>#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long int LL;const LL MOD = 1e9+7;const int M  = 2;struct Matrix{    LL m[M][M];    void clear0(){        for(int i=0;i&lt;M;i++)            for(int j=0;j&lt;M;j++)                m[i][j]=0;    }    void clearE(){        for(int i=0;i&lt;M;i++)            for(int j=0;j&lt;M;j++)                m[i][j]=(i==j);    }};Matrix operator * (Matrix &amp;a,Matrix &amp;b){    Matrix c;    c.clear0();    for(int k=0;k&lt;M;k++)        for(int i=0;i&lt;M;i++)            for(int j=0;j&lt;M;j++)                c.m[i][j]=(c.m[i][j]+a.m[i][k]*b.m[k][j]+MOD)%MOD;    return c;}Matrix operator ^(Matrix a,LL b){    Matrix c;c.clearE();    while(b){        if(b&amp;1) c=c*a;        b&gt;&gt;=1,a=a*a;    }    return c;}LL n,k;int main(){    int _;    scanf(&quot;%d&quot;,&amp;_);    while(_--){        scanf(&quot;%lld%lld&quot;,&amp;n,&amp;k);        Matrix a,b;        a.clear0(),b.clearE();        a.m[0][0]=1,a.m[0][1]=0;        a.m[1][0]=0,a.m[1][1]=0;        b.m[0][0]=0,b.m[0][1]=k-1;        b.m[1][0]=1,b.m[1][1]=k-2;        b=b^(n);        a=a*b;        printf(&quot;%lld\n&quot;,a.m[0][0]);    }    return 0;}</code></pre><h1 id="I-打怪兽"><a href="#I-打怪兽" class="headerlink" title="I 打怪兽"></a>I 打怪兽</h1><p>————————————————————————————————————————————</p><h1 id="K-最长上升子序列"><a href="#K-最长上升子序列" class="headerlink" title="K 最长上升子序列"></a>K 最长上升子序列</h1><p>————————————————————————————————————————————</p>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  第十四届北京师范大学程序设计竞赛 [6/11]</title>
      <link href="/2017/05/07/71366392/"/>
      <url>/2017/05/07/71366392/</url>
      
        <content type="html"><![CDATA[<h1 id="第十四届北京师范大学程序设计竞赛-6-11"><a href="#第十四届北京师范大学程序设计竞赛-6-11" class="headerlink" title="第十四届北京师范大学程序设计竞赛 [6/11]"></a>第十四届北京师范大学程序设计竞赛 [6/11]</h1><p>2017年05月07日 19:48:25  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：1258</p><hr><p> 博客爬取于<code>2019-04-18 17:16:52</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/71366392" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/71366392</a></p><p>虽然只是校赛,但是题目质量真的很高啊,</p><p>学到了新姿势,自己的思维还是太局限了.,</p><h1 id="A-Check-In"><a href="#A-Check-In" class="headerlink" title="A Check In"></a>A Check In</h1><p>————————————————————————————————————————————————</p><p>水题, 注意队伍名可能是bnuu这类</p><h1 id="B-Squared-Permutation"><a href="#B-Squared-Permutation" class="headerlink" title="B Squared Permutation"></a>B Squared Permutation</h1><p>————————————————————————————————————————————————</p><p>其实还是一个基础的题目,维护区间和就行了,树状数组,线段树都可以</p><p>维护的时候,维护所有位置的真实值,即如果当前值是b那么就是a[b]<br>再求区间和的时候就是基本的区间求和的操作了,</p><p>对于交换操作,很容易发现,交换的时候只对四个值有影响,<br>a[l],a[r]还有a[i]==l的位置,a[i]==r的位置,<br>先处理交换操作,然后在去修改就可以了,</p><p>复杂度是  O  (  n  log  n  )</p><p>附本题代码<br>——————————————————————————————</p><pre><code>#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long int LL;const int N = 1e5+7;int n,m,a[N],pre[N];LL sum[N&lt;&lt;2];void pushup(int rt){    sum[rt]=sum[rt&lt;&lt;1]+sum[rt&lt;&lt;1|1];}void build(int rt,int l,int r){    if(l==r){sum[rt]=a[a[l]];return;}    int m = r+l &gt;&gt; 1;    build(rt&lt;&lt;1,l,m);    build(rt&lt;&lt;1|1,m+1,r);    pushup(rt);}void update(int rt,int l,int r,int pos,int val){    if(l==r){        sum[rt]=val;        return ;    }    int m = r+l &gt;&gt; 1;    if(pos&lt;=m) update(rt&lt;&lt;1,l,m,pos,val);    else       update(rt&lt;&lt;1|1,m+1,r,pos,val);    pushup(rt);}LL query(int rt,int l,int r,int L,int R){    if(L&lt;=l&amp;&amp;r&lt;=R) return sum[rt];    int m = r+l &gt;&gt; 1;LL ans = 0;    if(L&lt;=m) ans+=query(rt&lt;&lt;1,l,m,L,R);    if(R&gt; m) ans+=query(rt&lt;&lt;1|1,m+1,r,L,R);    return ans;}int main(){    int _;    scanf(&quot;%d&quot;,&amp;_);    while(_--){        scanf(&quot;%d&quot;,&amp;n);        for(int i=1;i&lt;=n;i++){            scanf(&quot;%d&quot;,&amp;a[i]);            pre[a[i]]=i;        }//        for(int i=1;i&lt;=n;i++) printf(&quot;%d &quot;,pre[i]);puts(&quot;&quot;);        build(1,1,n);        scanf(&quot;%d&quot;,&amp;m);        int op,l,r;        for(int i=1;i&lt;=m;i++){            scanf(&quot;%d%d%d&quot;,&amp;op,&amp;l,&amp;r);            if(op == 1){                if(l==r) continue;                swap(a[l],a[r]);swap(pre[a[l]],pre[a[r]]);                update(1,1,n,l,a[a[l]]);                update(1,1,n,r,a[a[r]]);                update(1,1,n,pre[l],a[l]);                update(1,1,n,pre[r],a[r]);//printf(&quot;--%d %d   %d %d   %d %d   %d %d--\n&quot;,l,a[a[r]],r,,pre[l],a[l],pre[r],a[r]);//                for(int i=1;i&lt;=n;i++) printf(&quot;%d &quot;,a[i]);puts(&quot;&quot;);//                for(int i=1;i&lt;=n;i++) printf(&quot;%d &quot;,pre[i]);puts(&quot;&quot;);//                for(int i=1;i&lt;=n;i++) printf(&quot;%lld &quot;,query(1,1,n,i,i));puts(&quot; &lt;---&quot;);            }            else printf(&quot;%lld\n&quot;,query(1,1,n,l,r));        }    }    return 0;}</code></pre><h1 id="C-Quailty’s-Life"><a href="#C-Quailty’s-Life" class="headerlink" title="C Quailty’s Life"></a>C Quailty’s Life</h1><p>————————————————————————————————————————————————<br>不会</p><h1 id="D-Air-Hockey"><a href="#D-Air-Hockey" class="headerlink" title="D Air Hockey"></a>D Air Hockey</h1><p>————————————————————————————————————————————————<br>其实很容易想到以一个点作为参照,然后计算另一个点,<br>然后讨论一下,动点与静点越来越远的轻况 那么最开始的距离就是最近的<br>然后列方程可以求得静点到动点轨迹的垂足坐标,然后计算就可以了,</p><p>但是!但是!但是! 无论怎么修精度什么的就是过不去,最后GG,如果思路有纰漏请指正</p><hr><p>最后用三分的方法过掉的,<br>首先我们能确定两个运动轨迹是直线,那么两点距离是先变小,在变大,这就是一个凹函数,可以三分求得极值,<br>给定时间了,就能求出两点当前的位置,然后算距离就好了<br>如果这个距离大于半径和,那就是不碰撞<br>否则就是碰撞了,在[0,三分结果]二分就能得到刚好相切的时刻</p><hr><p>附本题代码</p><p>————————————————————————————————————————————</p><pre><code>#include &lt;bits/stdc++.h&gt;using namespace std;const double eps  = 1e-6;#define y1 y22double x1,y1,r1,vx1,vy1;double x2,y2,r2,vx2,vy2;double dis(double x1,double y1,double x2,double y2){    return sqrt((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2));}double cal(double t){    double xx1 = x1+vx1*t;    double yy1 = y1+vy1*t;    double xx2 = x2+vx2*t;    double yy2 = y2+vy2*t;    return dis(xx1,yy1,xx2,yy2);}int main(){    int _;    scanf(&quot;%d&quot;,&amp;_);    while(_--){        scanf(&quot;%lf %lf %lf %lf %lf&quot;,&amp;x1,&amp;y1,&amp;r1,&amp;vx1,&amp;vy1);        scanf(&quot;%lf %lf %lf %lf %lf&quot;,&amp;x2,&amp;y2,&amp;r2,&amp;vx2,&amp;vy2);        double l = 0.0,r = 1e12,mid,midmid;        for(int i=1;i&lt;200;i++){            mid = (l+l+r)/3.0;            midmid = (l+r+r)/3.0;            if(cal(mid) &lt; cal(midmid)) r=midmid;            else l=mid;        }        double dist = cal((r+l)/2.0);        if(dist &gt; r1+r2)  printf(&quot;%.9lf\n&quot;,dist-r1-r2);        else {            r=(r+l)/2.0,l=0;            for(int i=1;i&lt;200;i++){                mid = (r+l)/2.0 ;                if(cal(mid) &lt; r1+r2) r=mid;                else l=mid;            }            printf(&quot;%.9lf\n&quot;,(r+l)/2.0);        }    }    return 0;}</code></pre><h1 id="E-Simple-Database"><a href="#E-Simple-Database" class="headerlink" title="E Simple Database"></a>E Simple Database</h1><p>————————————————————————————————————————————<br>一个大模拟,没有卡复杂度之类的,但是模拟SQL也是很复杂的,有时间补上</p><h1 id="F-Training-Plan"><a href="#F-Training-Plan" class="headerlink" title="F Training Plan"></a>F Training Plan</h1><p>————————————————————————————————————————————<br>水dp,队友出的,过会儿补上</p><h1 id="G-Certain-Maze"><a href="#G-Certain-Maze" class="headerlink" title="G Certain Maze"></a>G Certain Maze</h1><p>————————————————————————————————————————————<br>这个题很有意思,初看的时候没有什么想法,就想,要是像往常那样的n*m图bfs就好了,怎么搞了呢?<br>于是想到我将这个图按照原本的规则建立一个正常一点的图不就好了么.</p><p>然后将一个/\ 变成了3*3的方阵里的对角线,刚好能满足.</p><p>附本题代码<br>————————————————————————————————————————————</p><pre><code>#include &lt;bits/stdc++.h&gt;using namespace std;bool vis[400][400],flag;char a[400][400],b[200];int xx,yy,n,m;int fx[]={0,0,1,-1};int fy[]={1,-1,0,0};void dfs(int x,int y){    vis[x][y]=true;    for(int i=0;i&lt;4;i++){        xx = x + fx[i];        yy = y + fy[i];        if(xx&lt;1||xx&gt;n*3) continue;        if(yy&lt;1||yy&gt;m*3) continue;        if(vis[xx][yy]) continue;        if(a[xx][yy]==&#39;#&#39;) continue;        dfs(xx,yy);    }}void R(int x,int y){    a[x][y]=&#39;#&#39;;    a[x-1][y-1]=&#39;#&#39;;    a[x-2][y-2]=&#39;#&#39;;}void L(int x,int y){    a[x-2][y-0]=&#39;#&#39;;    a[x-1][y-1]=&#39;#&#39;;    a[x-0][y-2]=&#39;#&#39;;}int main(){    int _;    scanf(&quot;%d&quot;,&amp;_);    while(_--){flag = 0;        scanf(&quot;%d%d&quot;,&amp;n,&amp;m);        for(int i=1;i&lt;=n*3;i++){            for(int j=1;j&lt;=m*3;j++){                a[i][j]=&#39;.&#39;;                vis[i][j]=false;            }        }        for(int i=1;i&lt;=n;i++){            scanf(&quot;%s&quot;,b+1);            for(int j=1;j&lt;=m;j++){                if(b[j]==&#39;L&#39;) L(i*3,j*3);                else          R(i*3,j*3);            }        }//        for(int i=1;i&lt;=n*3;i++){//            for(int j=1;j&lt;=m*3;j++){//                printf(&quot;%c&quot;,a[i][j]);//            }puts(&quot;&quot;);//        }        for(int i=1;i&lt;=m*3;i++)            if(a[1][i]==&#39;.&#39;) dfs(1,i);        for(int i=1;i&lt;=m*3;i++){            if(a[n*3][i]==&#39;.&#39;&amp;&amp;vis[n*3][i]) {                flag = true;                break;            }        }        if(flag) puts(&quot;Yes&quot;);        else     puts(&quot;No&quot;);    }    return 0;}</code></pre><h1 id="H-Random-Maze"><a href="#H-Random-Maze" class="headerlink" title="H Random Maze"></a>H Random Maze</h1><p>————————————————————————————————————————————</p><h1 id="I-Cactus-Exploration"><a href="#I-Cactus-Exploration" class="headerlink" title="I Cactus Exploration"></a>I Cactus Exploration</h1><p>————————————————————————————————————————————</p><h1 id="J-Whalyzh’s-Problem"><a href="#J-Whalyzh’s-Problem" class="headerlink" title="J Whalyzh’s Problem"></a>J Whalyzh’s Problem</h1><p>————————————————————————————————————————————</p><h1 id="K-ACM-Battle"><a href="#K-ACM-Battle" class="headerlink" title="K ACM Battle"></a>K ACM Battle</h1><p>————————————————————————————————————————————</p><p>其实重点就是那个10滴上面,所以只要对边爆搜即可,滴过得边就不用在滴,如果滴的大于10个就return</p><p>附本题代码<br>————————————————————————————————————————————</p><pre><code>#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 1000+7;/************************************************/struct node {    int u,v;}e[N*2];int n,m,mi,vis[N];void dfs(int x,int sum){    if(sum&gt;mi) return;    if(x==m){        mi=min(mi,sum);        return;    }    if(vis[e[x].u]||vis[e[x].v]){        dfs(x+1,sum);        return;    }    vis[e[x].u]=1;    dfs(x+1,sum+1);    vis[e[x].u]=0;    vis[e[x].v]=1;    dfs(x+1,sum+1);    vis[e[x].v]=0;}int main(){    int _;    scanf(&quot;%d&quot;,&amp;_);    while(_--){        mi = 11;        scanf(&quot;%d%d&quot;,&amp;n,&amp;m);        for(int i=1;i&lt;=n;i++)vis[i]=0;        for(int i=1,u,v;i&lt;=m;i++)     scanf(&quot;%d%d&quot;,&amp;e[i].u,&amp;e[i].v);        dfs(1,0);        if(mi&lt;=10) printf(&quot;%d\n&quot;,mi);        else       puts(&quot;GG&quot;);    }    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  CSUOJ 1503 点到圆弧的距离 [叉积+三角形外心]【计算几何】</title>
      <link href="/2017/05/07/71310488/"/>
      <url>/2017/05/07/71310488/</url>
      
        <content type="html"><![CDATA[<h1 id="CSUOJ-1503-点到圆弧的距离-叉积-三角形外心-【计算几何】"><a href="#CSUOJ-1503-点到圆弧的距离-叉积-三角形外心-【计算几何】" class="headerlink" title="CSUOJ 1503: 点到圆弧的距离 [叉积+三角形外心]【计算几何】"></a>CSUOJ 1503: 点到圆弧的距离 [叉积+三角形外心]【计算几何】</h1><p>2017年05月07日 11:24:54  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：617</p><hr><p> 博客爬取于<code>2019-04-18 17:16:53</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/71310488" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/71310488</a></p><p>题目链接： <a href="http://acm.csu.edu.cn/csuoj/problemset/problem?pid=1503" target="_blank" rel="noopener"> http://acm.csu.edu.cn/csuoj/problemset/problem?pid=1503</a><br>————————————————————————————————————————————<br>1503: 点到圆弧的距离<br>Submit Page Summary Time Limit: 1 Sec Memory Limit: 128 Mb Submitted: 850<br>Solved: 221 SpecialJudge<br>Description<br>输入一个点P和一条圆弧（圆周的一部分），你的任务是计算P到圆弧的最短距离。换句话说，你需要在圆弧上找一个点，到P点的距离最小。<br>提示：请尽量使用精确算法。相比之下，近似算法更难通过本题的数据。</p><p>Input<br>输入包含最多10000组数据。每组数据包含8个整数x1, y1, x2, y2, x3, y3, xp,<br>yp。圆弧的起点是A(x1,y1)，经过点B(x2,y2)，结束位置是C(x3,y3)。点P的位置是 (xp,yp)。输入保证A, B,<br>C各不相同且不会共线。上述所有点的坐标绝对值不超过20。</p><p>Output<br>对于每组数据，输出测试点编号和P到圆弧的距离，保留三位小数。你的输出和标准输出之间最多能有0.001的误差。</p><p>Sample Input<br>0 0 1 1 2 0 1 -1<br>3 4 0 5 -3 4 0 1<br>Sample Output<br>Case 1: 1.414<br>Case 2: 4.000<br>Hint<br>Source<br>湖南省第十届大学生计算机程序设计竞赛</p><p>————————————————————————————————————————————</p><p>首先能确定的是,在圆弧所在的扇形的角内的点,最近距离是 <code>dis(p,r)</code> ,否则是 <code>min(dis(p,a),dis(p,c))</code> .</p><p>所以就是如何确定在不在扇形所在的角内了 扇形所在的角如下图所示</p><p><img src="https://img-blog.csdn.net/20170507110706524?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzMxODQxNzE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>分为劣弧和优弧,</p><p>在判断上要有所不同,<br><img src="https://img-blog.csdn.net/20170507111743232?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzMxODQxNzE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><ul><li><p>劣弧<br>劣弧的时候很好判定这里运用了向量叉积的判定方法,只要  r  a  −  →  和  r  p  →  在  r  c  →  的  同  一  侧  且<br>r  c  →  和  r  p  →  在  r  a  −  →  的  同  一  侧  就能保证了,</p></li><li><p>优弧<br>优弧的时候麻烦一些,对于p’ 可以和劣弧相同,不赘述<br>对于p和p”却要不一样, 首先我们只要b可以再弧上的任意位置,以b为参考点是不行的.<br>但其实仔细观察  ∠  a  r  c  和点p” 其实发现这就是反过来的劣弧的情况,所以在判断是优弧的情况下来重复劣弧的过程就行了,</p></li></ul><p>那么就只剩下怎么判断优劣弧,<br>其实只要判断  ∠  a  b  c  的角度就好了 大于90度就是劣弧,小于90度就是优弧,(不解释)<br>为了方便计算我们转化为余弦公式计算,判断正负就好了</p><p>附本题代码<br>————————————————————————————————————————————</p><p>​    </p><pre><code>#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long int LL ;const int N = 1000+7;const int MOD = 1000000007;#define abs(x)  (((x)&gt;0)?(x):-(x))/***************************************/struct point{    double x,y;}a,b,c,r,p;double dis(point a,point b){    return sqrt((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y));}double dis2(point a,point b){    return ((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y));}double mutli(point p1,point p2,point p3){    return ((p2.x-p1.x)*(p3.y-p1.y) - (p2.y-p1.y)*(p3.x-p1.x));}point solvepointR(){    double  x1,x2,x3,y1,y2,y3;    x1=a.x,y1=a.y;    x2=b.x,y2=b.y;    x3=c.x,y3=c.y;    point t;    t.x=((y2-y1)*(y3*y3-y1*y1+x3*x3-x1*x1)-(y3-y1)*(y2*y2-y1*y1+x2*x2-x1*x1))/(2*(x3-x1)*(y2-y1)-2*((x2-x1)*(y3-y1)));    t.y=((x2-x1)*(x3*x3-x1*x1+y3*y3-y1*y1)-(x3-x1)*(x2*x2-x1*x1+y2*y2-y1*y1))/(2*(y3-y1)*(x2-x1)-2*((y2-y1)*(x3-x1)));    return t;}int Main(){    int kcase = 0;    while(~scanf(&quot;%lf%lf&quot;,&amp;a.x,&amp;a.y)){        scanf(&quot;%lf%lf&quot;,&amp;b.x,&amp;b.y);        scanf(&quot;%lf%lf&quot;,&amp;c.x,&amp;c.y);        scanf(&quot;%lf%lf&quot;,&amp;p.x,&amp;p.y);        r = solvepointR();//        printf(&quot;R : %lf %lf\n&quot;,r.x,r.y);        double R = dis(r,a);        double pa = dis(p,a),pc = dis(p,c),pcir=fabs(dis(p,r)-R);//        printf(&quot;%lf %lf %lf\n&quot;,pa,pc,pcir);        double ans = min(pa,pc);        if(mutli(r,c,p)*mutli(r,c,b)&gt;=0 &amp;&amp; mutli(r,a,p)*mutli(r,a,b)&gt;=0)            ans = pcir;        if( (dis2(a,b)+dis2(b,c)-dis2(a,c))/(2*dis(a,b)*dis(b,c)) &gt;=0 ){            if(mutli(r,c,p)*mutli(r,c,a)&lt;0 || mutli(r,a,p)*mutli(r,a,c)&lt;0){//                puts(&quot;----&quot;);                ans = pcir;            }        }        printf(&quot;Case %d: %.3f\n&quot;,++kcase,ans);    }    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  Codeforces 410 div 2 【解题报告】</title>
      <link href="/2017/05/03/71155475/"/>
      <url>/2017/05/03/71155475/</url>
      
        <content type="html"><![CDATA[<h1 id="Codeforces-410-div-2-【解题报告】"><a href="#Codeforces-410-div-2-【解题报告】" class="headerlink" title="Codeforces 410 div 2 【解题报告】"></a>Codeforces 410 div 2 【解题报告】</h1><p>2017年05月03日 21:21:46  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：536<br>标签：  <a href="https://so.csdn.net/so/search/s.do?q=codeforces&amp;t=blog" target="_blank" rel="noopener"> codeforces </a></p><p>个人分类：  <a href="https://blog.csdn.net/qq_33184171/article/category/6235560" target="_blank" rel="noopener"> codeforces</a></p><hr><p> 博客爬取于<code>2019-04-18 17:16:54</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/71155475" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/71155475</a></p><p>题目很6，我也很菜。和一年前比，水平没有丝毫进步。只能把AB做出来。WHY? Sorry,I don’t know.</p><p><del> 没心情，题解瞎写，一点不清楚 </del></p><h1 id="A-Mike-and-palindrome"><a href="#A-Mike-and-palindrome" class="headerlink" title="A Mike and palindrome"></a>A Mike and palindrome</h1><p>————————————————————————————————————————————<br>翻译清楚就能AC了</p><h1 id="B-Mike-and-strings"><a href="#B-Mike-and-strings" class="headerlink" title="B Mike and strings"></a>B Mike and strings</h1><p>————————————————————————————————————————————<br>枚举一个目标串，统计所有串变成这样的操作次数，维护最小值。</p><h1 id="C-Mike-and-gcd-problem"><a href="#C-Mike-and-gcd-problem" class="headerlink" title="C Mike and gcd problem"></a>C Mike and gcd problem</h1><p>————————————————————————————————————————————<br>给一个序列，仅有如下一种操作，将a[i],a[i+1] 变成a[i]-a[i+1]，a[i]+a[i+1]。问你最少操作多少次，能使序列的gcd&gt;1?</p><hr><p>不会 ，懵逼，只知道解题方向是这个操作，然后并没有发现这个操作的什么性质。。。。</p><p>然后看了别人的题解，<br>大家都能发现</p><p>奇±偶=奇<br>偶±偶=偶<br>偶±奇=奇<br>奇±奇=偶</p><p>然后又发现 至多两次能将 相邻的两个数 变成偶偶的，这样gcd就是2了</p><p>然后贪心，现将每个相邻的奇奇一次操作变成偶偶，然后再将相邻的奇偶两次操作变成偶偶， 然后统计次数就好了。</p><h1 id="D-Mike-and-distribution"><a href="#D-Mike-and-distribution" class="headerlink" title="D Mike and distribution"></a>D Mike and distribution</h1><p>————————————————————————————————————————————</p><p>给你两个序列，然你找k个索引相同的数，使得这些数分别加和乘2大于等去分别的总序列和，k&lt;=n/2+1;</p><hr><p>将其放到结构体中<br>按a降序排列，然后尽量找前面的就好，</p><p>然后考虑相邻的两个每次找b大的那个选，那么是能满足题意的。</p><p>模拟下这过程就好了</p><h1 id="E-Mike-and-code-of-a-permutation"><a href="#E-Mike-and-code-of-a-permutation" class="headerlink" title="E Mike and code of a permutation"></a>E Mike and code of a permutation</h1><p>————————————————————————————————————————————<br>题我都没敢看</p>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> codeforces </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  山东省第六届ACM大学生程序设计竞赛 训练总结 [(7+1)/12] 待补</title>
      <link href="/2017/04/29/70990783/"/>
      <url>/2017/04/29/70990783/</url>
      
        <content type="html"><![CDATA[<h1 id="山东省第六届ACM大学生程序设计竞赛-训练总结-7-1-12-待补"><a href="#山东省第六届ACM大学生程序设计竞赛-训练总结-7-1-12-待补" class="headerlink" title="山东省第六届ACM大学生程序设计竞赛 训练总结 [(7+1)/12] 待补"></a>山东省第六届ACM大学生程序设计竞赛 训练总结 [(7+1)/12] 待补</h1><p>2017年04月29日 21:20:32  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：391</p><hr><p> 博客爬取于<code>2019-04-18 17:16:55</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/70990783" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/70990783</a></p><p>这套题 ,难度并不高,水题很多,中期题不少<br>但是发挥并不是特别理想,<br>一部分是训练态度不够,中间一段时间在聊天,并没有全力出题,<br>还有队友赶紧回来啊 ,两个人磕还是不行啊,罚时爆表.</p><p>最后40分钟搞的G却没有及时出,足足晚了12分钟才AC.</p><p>封榜时间出题也应该是一个强队的标志,很明显,我队距离强队差距很远,水平差很多.</p><p>个人的话卡题时间比较长,还是对解题的正确方法思考慢,越接近正解的时候越容易乱.越乱越容易出差错.<br>还有就是不常用算法要及时复习,平时一直写线性筛,训练的时候一个埃斯托尼筛法硬是写了好久才调对.<br>还有就是思路要清晰, 其实大部分题的编码时间并不长,10~15分钟够用了,除了模拟题,非小规模数据结构题,等..</p><h1 id="Problem-A-SDUT-3251-Nias-and-Tug-of-War"><a href="#Problem-A-SDUT-3251-Nias-and-Tug-of-War" class="headerlink" title="Problem A SDUT 3251 Nias and Tug-of-War"></a>Problem A SDUT 3251 Nias and Tug-of-War</h1><p>————————————————————————————————————————————<br>水签到题 ，结构体排序 加和 比较输出即可</p><h1 id="Problem-B-SDUT-3252-Lowest-Unique-Price"><a href="#Problem-B-SDUT-3252-Lowest-Unique-Price" class="headerlink" title="Problem B SDUT 3252 Lowest Unique Price"></a>Problem B SDUT 3252 Lowest Unique Price</h1><p>————————————————————————————————————————————<br>有三种操作，<br>1.b x 插入一个x<br>2.c x 删除一个x<br>3.q 查询当前仅有一个的最小的数</p><hr><p>其实这种题一般都是用STL做 但是渣渣并不会STL</p><p>所以每次都是用树状数组+二分来搞。</p><p>但是这题我们有一个限制，就是只在当前仅有一个的数中找？</p><p>所以我们可以定义一个数组，标记每个数出现的次数，将数组中的不是1的数拿下去，是一的数放到树状数组中，然后通过二分找到第一个有数的位置就好了</p><p>复杂度虽然是  O  (  n  l  o  g  2  2  (  1  e  6  )  )  但是没有STL的大常数。所以还是可以的。</p><h1 id="Problem-C-SDUT-3253-Game"><a href="#Problem-C-SDUT-3253-Game" class="headerlink" title="Problem C SDUT 3253 Game!"></a>Problem C SDUT 3253 Game!</h1><p>————————————————————————————————————————————<br>算是个博弈吧<br>但考虑对称性， 除了1,2之外不论先手拿1个还是2个，后手都能将局面变成对称的，先手必败</p><h1 id="Problem-D-SDUT-3254-Stars"><a href="#Problem-D-SDUT-3254-Stars" class="headerlink" title="Problem D SDUT 3254 Stars"></a>Problem D SDUT 3254 Stars</h1><p>————————————————————————————————————————————<br>在一个二维坐标系上，给你  n  (  ≤  400  )  个点，问你找一个面积最小的矩形，使得这个矩形内有k个点<br>点坐标的范围在[0,400]</p><hr><p>一看到这400个点我就觉得可以做,然后发现坐标就在[0,400]内连离散化都不用了</p><p>我们要的是最小面积,首先想的是二分,但是发现面积又涉及长又涉及宽,我无法再O(n^2)内处理出,所以放弃</p><p>然后发现我可以固定一个长,然后找长为定值的时候的面积最小值,然后维护最小值就好了</p><p>发现这样在加上一个尺取法和每行的前缀和 的复杂度能做到O(n^3),可以做,</p><p>然后就A了</p><h1 id="Problem-E-SDUT-3255-BIGZHUGOD-and-His-Friends-I"><a href="#Problem-E-SDUT-3255-BIGZHUGOD-and-His-Friends-I" class="headerlink" title="Problem E SDUT 3255 BIGZHUGOD and His Friends I"></a>Problem E SDUT 3255 BIGZHUGOD and His Friends I</h1><p>————————————————————————————————————————————</p><h1 id="Problem-F-SDUT-3256-BIGZHUGOD-and-His-Friends-II"><a href="#Problem-F-SDUT-3256-BIGZHUGOD-and-His-Friends-II" class="headerlink" title="Problem F SDUT 3256 BIGZHUGOD and His Friends II"></a>Problem F SDUT 3256 BIGZHUGOD and His Friends II</h1><p>————————————————————————————————————————————</p><h1 id="Problem-G-SDUT-3257-Cube-Number"><a href="#Problem-G-SDUT-3257-Cube-Number" class="headerlink" title="Problem G SDUT 3257 Cube Number"></a>Problem G SDUT 3257 Cube Number</h1><p>————————————————————————————————————————————<br>给你一个序列，问你两个数的乘积是 <strong> 立方 </strong> 数的数对有多少个？</p><hr><p>其实和H题差不多，但是又差了很多，</p><p>假如a<em>b是立方数，那么a</em>b<em>(k^3)也是立方数,那么所有的形如a</em>b<em>(k^3)的数都能划归为a</em>b的形式,<br>那也就是说如果数x = (k^3)*b 那么k^3这部分就没有意义，消掉就好了。</p><p>这个时候考虑a*b在什么时候成立，显然  a  ∗  b  =  p  a  1  1  ∗  p  a  2  2  ∗  .  .  .  ∗  p<br>a  n  n  ,  a  i  =  0  o  r  3<br>那么对<br>a  =  p  a  1  1  ∗  p  a  2  2  ∗  .  .  .  ∗  p  a  n  n<br>b  =  p  b  1  1  ∗  p  b  2  2  ∗  .  .  .  ∗  p  b  n  n<br>那么对于所有的  a  1  +  b  1  =  3  o  r  0<br>那么对于每一个数，我都能找到与其相乘为立方数的数了</p><p>只要找这个数的素因子的指数与其对应的就好了</p><p>这个部分我们仍然可以预处理，先把每个数划归成没有(k^3)这样的因子的数.然后对其素因子分解就好了,<br>但是发现如果直接这样的话预处理部分会超时,<br>所以我们仍然利用埃斯托尼筛法,在过程中找到每个数的因子,用一个vector存就好了,素因子个数小于log<br>然后对每个数找到其对应的能乘出立方数的数</p><p>然后O(n)统计就好了</p><p>注意LL</p><h1 id="Problem-H-SDUT-3258-Square-Number"><a href="#Problem-H-SDUT-3258-Square-Number" class="headerlink" title="Problem H SDUT 3258 Square Number"></a>Problem H SDUT 3258 Square Number</h1><p>————————————————————————————————————————————<br>给你一个序列，问你两个数的乘积是 <strong> 平方 </strong> 数的数对有多少个？</p><hr><p>然后发现如果a<em>b,a</em>c是平方数那么b*c也是平方数. 其是具有传递性的,<br>那么我们就可以记录每个堆得数有多少个,然后统计就好了</p><p>考虑a*b是平方数  (  a  ≤  b  )  ,<br>那么对于定值a,<br>b一定是a的倍数.</p><p>这点很好发现因为a<em>b要是平方数的话那么其开根号一定是a</em>a*k(k也是可平方)的,</p><p>所以我们依据这个分堆就好了<br>分堆的方法是预处理. 预处理出每个数在那一堆,<br>因为在一堆的一定是某个数的倍数,那么我们可以通过埃斯托尼筛法的过程计算每个数是属于那一堆的,<br>标记的数组变成指向那个堆得映射就好了,</p><p>然后在统计答案的时候就可以在O(n)下统计了，</p><p>注意LL</p><h1 id="Problem-I-SDUT-3259-Routing-Table"><a href="#Problem-I-SDUT-3259-Routing-Table" class="headerlink" title="Problem I SDUT 3259 Routing Table"></a>Problem I SDUT 3259 Routing Table</h1><p>————————————————————————————————————————————</p><h1 id="Problem-J-SDUT-3260-Single-Round-Math"><a href="#Problem-J-SDUT-3260-Single-Round-Math" class="headerlink" title="Problem J SDUT 3260 Single Round Math"></a>Problem J SDUT 3260 Single Round Math</h1><p>————————————————————————————————————————————<br>问你有N个男的，M个女的，分成11组，每组的男女都是成对的。问你成不成立。</p><hr><p>水，<br>就是比较下N,M相不相等，相等的话男女才都能成对。<br>但是要分成11组，所以对数要是11的倍数，</p><p>判断一个大数是不是11的倍数，其实并不用高精度，只要for一遍就好了。</p><h1 id="Problem-K-SDUT-3261-Last-Hit"><a href="#Problem-K-SDUT-3261-Last-Hit" class="headerlink" title="Problem K SDUT 3261 Last Hit"></a>Problem K SDUT 3261 Last Hit</h1><p>————————————————————————————————————————————</p><h1 id="Problem-L-SDUT-3262-Circle-of-Friends"><a href="#Problem-L-SDUT-3262-Circle-of-Friends" class="headerlink" title="Problem L SDUT 3262 Circle of Friends"></a>Problem L SDUT 3262 Circle of Friends</h1><p>————————————————————————————————————————————<br>图论题，队友出的，我不会图论。</p>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  KMP废柴のKMP小练</title>
      <link href="/2017/04/28/70940766/"/>
      <url>/2017/04/28/70940766/</url>
      
        <content type="html"><![CDATA[<h1 id="KMP废柴のKMP小练"><a href="#KMP废柴のKMP小练" class="headerlink" title="KMP废柴のKMP小练"></a>KMP废柴のKMP小练</h1><p>2017年04月28日 20:22:26  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：348</p><hr><p> 博客爬取于<code>2019-04-18 17:16:56</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/70940766" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/70940766</a></p><p>经过BNUCPC，发现KMP完全不会了，于是找几个水KMP/NEXT题 压压惊。</p><p>VJ链接： <a href="https://cn.vjudge.net/contest/151711#overview" target="_blank" rel="noopener"> https://cn.vjudge.net/contest/151711#overview</a></p><h1 id="A-POJ-3461-Oulipo"><a href="#A-POJ-3461-Oulipo" class="headerlink" title="A POJ 3461 Oulipo"></a>A POJ 3461 Oulipo</h1><p>————————————————————————————————————————————<br>问你A字符串在B字符串中出现了几次，</p><hr><p>只要在KMP 的过程中记录匹配到子串尾的次数就好了</p><h1 id="B-POJ-2752-Seek-the-Name-Seek-the-Fame"><a href="#B-POJ-2752-Seek-the-Name-Seek-the-Fame" class="headerlink" title="B POJ 2752 Seek the Name, Seek the Fame"></a>B POJ 2752 Seek the Name, Seek the Fame</h1><p>————————————————————————————————————————————<br>给你一个字符串，让你找出所有的公共前后缀，升序输出它们的长度，</p><hr><p>公共前后缀那么就是每次找字符串结尾的NEXT值，其表示的就是它前面字符串的最长公共前后缀，<br>然后再对这个最长的公共前后缀重复此过程，直到找不到为止，因为找到的最长公共前后缀所能够包含母串的前后缀信息了。</p><p>实现上我们可以做一个递归，这样长度依次变小，每次里层递归结束在输出就好了。</p><h1 id="C-POJ-2406-Power-Strings"><a href="#C-POJ-2406-Power-Strings" class="headerlink" title="C POJ 2406 Power Strings"></a>C POJ 2406 Power Strings</h1><p>————————————————————————————————————————————<br>给你一个字符串，定义字符串A*B=AB ：即 “abc”“def”=“abcdef”。问你这个字符串表示成A^x形式的时候，x的最大值</p><hr><p>很好发现，我们要找的就是字符串的最小的那个循环节罢了。</p><p>而求这个循环节我们<br>可以很容想到只要找到字符串的最长公共前后缀就好了，总长度减去最长公共前后缀的长度就是最小的循环节了，如果这个循环节能整除母串长度，那就可行，</p><p>如果不行那答案就是字符串本身了，也就是1.</p><p>*画一画 很好想的， </p><h1 id="D-POJ-1961-Period"><a href="#D-POJ-1961-Period" class="headerlink" title="D POJ 1961 Period"></a>D POJ 1961 Period</h1><p>————————————————————————————————————————————<br>给你一个字符串，问你有多少个前缀可以由一个循环节 循环两次以上组成，输出每个前缀的长度和最多的循环次数</p><hr><p>还是对每个位置找循环节就好了，</p><h1 id="E-HDU-3336-Count-the-string"><a href="#E-HDU-3336-Count-the-string" class="headerlink" title="E HDU 3336 Count the string"></a>E HDU 3336 Count the string</h1><p>————————————————————————————————————————————<br>给你一个字符串，问你每个前缀在字符串中出现了多少次，输出次数和mod 10007。</p><hr><p>显然不能枚举每个字符串来KMP。</p><p>那么我们先虑暴力对每个前缀进行KMP,然后加和就好.,复杂度是O(n^2)的,</p><p>但是我们发现的是 如果对前缀ab进行KMP 那么我们找到的信息一定是包括前缀a的信息的<br>那么通过这一层关系我们可以统计了.</p><p>既然这是一个统计问题,那么很自然的想到了每个位置对结果的贡献.<br>那么每个位置对结果的贡献有<br>1.自己本身这个前缀,<br>2.这个前缀的最长的公共前后缀中 后缀部分对结果的后弦和前缀贡献是一样的加上去就好了</p><p>有事最长公共前后缀,那么就是求一遍NEXT数组</p><p>然后ans[i] = ans[NEXT[i]]+1;<br>最后加和就好了.</p><h1 id="F-HDU-3746-Cyclic-Nacklace"><a href="#F-HDU-3746-Cyclic-Nacklace" class="headerlink" title="F HDU 3746 Cyclic Nacklace"></a>F HDU 3746 Cyclic Nacklace</h1><p>————————————————————————————————————————————<br>给你一个字符串，问你最少添加几个字符使其能变成某个前缀循环至少2次组成的字符串。</p><hr><p>首先如果这个字符串本身就能表示成某个前缀循环多次组成的那么就是0了<br>然后我们想要添加尽量少的字符，那其实也就是找循环节，方法和C题是一样的，<br>找到了循环节 然后统计一下最后需要加几个字符就好了 简单计算不再赘述。</p><h1 id="G-HDU-2087-剪花布条"><a href="#G-HDU-2087-剪花布条" class="headerlink" title="G HDU 2087 剪花布条"></a>G HDU 2087 剪花布条</h1><p>————————————————————————————————————————————<br>问你母串中有多少个子串，要求子串不想交，</p><hr><p>其实和A还是一样的只不过在匹配到子串尾的时候下一步我们让它去匹配子串头就好了</p><h1 id="H-HDU-2594-Simpsons’-Hidden-Talents"><a href="#H-HDU-2594-Simpsons’-Hidden-Talents" class="headerlink" title="H HDU 2594 Simpsons’ Hidden Talents"></a>H HDU 2594 Simpsons’ Hidden Talents</h1><p>————————————————————————————————————————————<br>给你两个串stra，strb，让你求stra的前缀和strb的后缀的最大公共部分。</p><hr><p>那么我们就直接将stra作为子串想strb上匹配就好了，然后最后匹配完strb，此时子串匹配的状态就是公共部分了。</p><h1 id="I-HDU-4763-Theme-Section"><a href="#I-HDU-4763-Theme-Section" class="headerlink" title="I HDU 4763 Theme Section"></a>I HDU 4763 Theme Section</h1><p>————————————————————————————————————————————<br>据说是个EXKMP？<br>不做了。</p>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  山东省第七届ACM大学生程序设计竞赛 训练总结 [8/12] 待补</title>
      <link href="/2017/04/27/70880837/"/>
      <url>/2017/04/27/70880837/</url>
      
        <content type="html"><![CDATA[<h1 id="山东省第七届ACM大学生程序设计竞赛-训练总结-8-12-待补"><a href="#山东省第七届ACM大学生程序设计竞赛-训练总结-8-12-待补" class="headerlink" title="山东省第七届ACM大学生程序设计竞赛 训练总结 [8/12] 待补"></a>山东省第七届ACM大学生程序设计竞赛 训练总结 [8/12] 待补</h1><p>2017年04月27日 23:29:20  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：1091</p><hr><p> 博客爬取于<code>2019-04-18 17:16:57</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/70880837" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/70880837</a></p><p>中期被学弟艹到爆啊。。。。</p><p>这套题目相对简单点AC8题（相对别的套题，对鄙队来说还是很难的。。还是这套题 有陈题，签到题偏多，面上还不错）</p><p>前期交gcc CE2发，不读题，直接写wa了一发。。。 还是我训练态度不认真，，，</p><p>模拟没时间出,难题没有时间开,出题速度慢,,,,菜的一逼,要加强</p><p>比赛策略来说，前期努力找水题，找一个A一个，中期思考，轮流上机，到此还不错，但是后期还是空机很长时间，1是缺了一名模拟翻译字符串队友，2是后期题没有开，模拟<br>没人做，3是D题卡了好久，最后十几分钟才AC， 总体表现良好 待加强。</p><h1 id="Problem-A-Julyed"><a href="#Problem-A-Julyed" class="headerlink" title="Problem A Julyed"></a>Problem A Julyed</h1><p>————————————————————————————————————————————<br>没读题 队友A的 签到题 ，</p><hr><h1 id="Problem-B-Fibonacci"><a href="#Problem-B-Fibonacci" class="headerlink" title="Problem B Fibonacci"></a>Problem B Fibonacci</h1><p>————————————————————————————————————————————<br>就是问你一个数能不能被一些fibonacci数的加和表示出 要求fibo数不能连续 能输出这个式子，不能输出-1</p><hr><p>根据齐肯拉夫定理？ 好像叫这个名字，任何数都能被多个fibonacci数表示，所以那个-1的输出是没有意义的，所以只要从大的数向下找就好了</p><p>至于有些人纠结如果其中有连续的怎么办，加入 结果中有f(x)和f(x+1)的话一定能被 f(x+2)代替。</p><h1 id="Problem-C-Proxy"><a href="#Problem-C-Proxy" class="headerlink" title="Problem C Proxy"></a>Problem C Proxy</h1><p>————————————————————————————————————————————<br>简单的最短路,反向建图,计算n到其他节点的最短路,然后枚举0能到达的点维护答案即可,</p><p>主体队友写的,我的贡献只有”然后枚举0能到达的点维护答案即可,”…</p><p>————————————————update——————————————————<br>自己实现了发虽然1A，但是花了40min，还看了dij的模板，，图论这一块好弱了。。。。</p><h1 id="Problem-D-Swiss-system-tournament"><a href="#Problem-D-Swiss-system-tournament" class="headerlink" title="Problem D Swiss-system tournament"></a>Problem D Swiss-system tournament</h1><p>————————————————————————————————————————————<br>这题就是给你n*2个队伍，每个队伍有一个积分，还有一个能力值<br>现在来n轮比赛<br>每次比赛将当前积分第1大的和第2大的比，当前积分第3大的和第4大的比，当前积分第5大的和第6大的比，以此类推<br>能力值大的能比赢，且积分+1,</p><p>问你最后能力值第q大的队伍是那支。</p><p>*积分一样按队伍编号小的来。 </p><hr><p>这题很简单了 模拟一下就是一个水题，写完交了一发TLE.。。。卡了排序，<br>然后手写了归并排序，本机测试了极限数据结果时间和sort比就少了1/7，，，</p><p>然后考虑这个比赛的过程<br>发现对于比赛顺序来说，<br>前面的大的一定比后面的大的大。小的同理，</p><p>那么我们维护两个序列，一个存每场比赛的大的，另一个存每场比赛的小的，<br>然后做一个归并的工程，就能在O(n)的复杂度完成了。。</p><h1 id="Problem-E-The-Binding-of-Isaac"><a href="#Problem-E-The-Binding-of-Isaac" class="headerlink" title="Problem E The Binding of Isaac"></a>Problem E The Binding of Isaac</h1><p>————————————————————————————————————————————<br>也是个水签到题，<br>就是给你一个N<em>M的图<br>问你在(N+2)</em>(M+2)的图上有几个位置四周只有一个’#’</p><p>(开始没仔细读题，以为只会出现在N*M这个范围的四周..</p><h1 id="Problem-F-Feed-the-monkey"><a href="#Problem-F-Feed-the-monkey" class="headerlink" title="Problem F Feed the monkey"></a>Problem F Feed the monkey</h1><p>————————————————————————————————————————————<br>是个dp 我不会dp 队友出的</p><h1 id="Problem-G-Triple-Nim"><a href="#Problem-G-Triple-Nim" class="headerlink" title="Problem G Triple Nim"></a>Problem G Triple Nim</h1><p>————————————————————————————————————————————<br>Nim游戏,Alice先手,现在有N个石子,分成三堆,问让Alice数的分发有多少种,</p><p>*(a,b,c) &lt;=&gt;(a,c,b) and so on.. </p><hr><p>首先考虑最基本的博弈,就是(a^b^c)==0的时候Alice才会输,</p><p>然后考虑怎么分? 枚举复杂度是O(n^2)的显然不可取，</p><p>就考虑先分成两堆，那么这两堆一定是一样的，<br>考虑二进制<br>那么一定是  </p><p>101010111100  101010111100</p><p>这样的<br>这时候从中找几个1拿出来给第三堆就好了,,</p><p>然后枚举,dp,各种思路都试了,没有什么能做的…<br>但也发现了<br>1.n为奇数的时候一定是0,<br>2.结果的贡献只和二进制下1的个数有关,,,</p><p>那么答案就是ans[1的个数]…</p><p>然后有了qls的一个至理名言”遇事不决先打表”…</p><p>于是发现</p><p>1的个数  ans[1的个数]</p><p>1</p><p>0</p><p>2</p><p>1</p><p>3</p><p>4</p><p>4</p><p>13</p><p>5</p><p>40</p><p>6</p><p>121</p><p>…</p><p>…</p><p>n</p><p>ans[n-1]*3+1</p><p>有了表，看了一眼发现递推式，然后就AC了。。。</p><p>*注意： 要long long int 3^x会报 </p><h1 id="Problem-H-Memory-Leak"><a href="#Problem-H-Memory-Leak" class="headerlink" title="Problem H Memory Leak"></a>Problem H Memory Leak</h1><p>————————————————————————————————————————————</p><h1 id="Problem-I-Rock-Paper-Scissors"><a href="#Problem-I-Rock-Paper-Scissors" class="headerlink" title="Problem I Rock Paper Scissors"></a>Problem I Rock Paper Scissors</h1><p>————————————————————————————————————————————</p><h1 id="Problem-J-Execution-of-Paladin"><a href="#Problem-J-Execution-of-Paladin" class="headerlink" title="Problem J Execution of Paladin"></a>Problem J Execution of Paladin</h1><p>————————————————————————————————————————————</p><h1 id="Problem-K-Reversed-Words"><a href="#Problem-K-Reversed-Words" class="headerlink" title="Problem K Reversed Words"></a>Problem K Reversed Words</h1><p>————————————————————————————————————————————<br>c语言入门题 签到题</p><h1 id="Problem-L-Password"><a href="#Problem-L-Password" class="headerlink" title="Problem L Password"></a>Problem L Password</h1><p>————————————————————————————————————————————</p>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  2016年湖南省第十二届省赛 【ABGHJ】</title>
      <link href="/2017/04/27/70835664/"/>
      <url>/2017/04/27/70835664/</url>
      
        <content type="html"><![CDATA[<h1 id="2016年湖南省第十二届省赛-【ABGHJ】"><a href="#2016年湖南省第十二届省赛-【ABGHJ】" class="headerlink" title="2016年湖南省第十二届省赛 【ABGHJ】"></a>2016年湖南省第十二届省赛 【ABGHJ】</h1><p>2017年04月27日 00:45:08  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：316</p><p>个人分类：  <a href="https://blog.csdn.net/qq_33184171/article/category/6822765" target="_blank" rel="noopener"> 套题 </a> <a href="https://blog.csdn.net/qq_33184171/article/category/6362379" target="_blank" rel="noopener"><br>===== 各OJ ===== </a></p><hr><p> 博客爬取于<code>2019-04-18 17:16:58</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/70835664" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/70835664</a></p><p>做这套的时候 很迷啊 感觉回到了杭州的时候签到题半天没有A，明明很水的 题目我竟要去想容斥那套理论GG，3小时AC签到题？？！ 果然是菜的可以。，</p><p>但仔细想想，可能这套题真的偏难吧，<br>最后补题只A了4个 H是看了题解的。。</p><h1 id="A-CSU-1803-2016"><a href="#A-CSU-1803-2016" class="headerlink" title="A CSU 1803 2016"></a>A CSU 1803 2016</h1><p>————————————————————————————————————————————<br>真的是水题 啊 上来就想到容斥那一套理论，然后GG。（也暴露了我容斥反演那一套学的并不好的事实啊</p><p>其实就是考虑每一个2016<em>2016的块，对结果的贡献是相同的，所以就变成了求有几个2016</em>2016的块<br>然后边界的在计算一下就好了，如果预处理二维前缀和的话，就能O(1)做了</p><h1 id="B-CSU-1804-有向无环图"><a href="#B-CSU-1804-有向无环图" class="headerlink" title="B CSU 1804 有向无环图"></a>B CSU 1804 有向无环图</h1><p>————————————————————————————————————————————</p><p>∑  i  =  1  n  ∑  j  =  1  n  c  o  u  n  t  (  i  ,  j  )  ×  a  i  ×  b  j<br>=  ∑  i  =  1  n  a  i  ×  ∑  j  =  1  n  c  o  u  n  t  (  i  ,  j  )  ×  b<br>j</p><p>其实就是大概这意思，<br>对于里层的  ∑  ,  a  i  就是一个常数了 ,提出来就好了<br>这个时候我们只要统计就好了</p><p>现在是1-&gt;2-&gt;3 的<br>那么能到达2 的是{1}, 能到达3的是{1,2}<br>脑补下再长一点的结果,发现如果  a  能到达  b  那么能到达  a  的点都能到达  b  ,通过这个我们就可以直接计数  </p><p>c  n  t  [  t  o  ]  =  c  n  t  [  f  a  ]  +  1  ;</p><p>只要将点的个数变成点的  b  i  就好了,最后的结果就是  </p><p>∑  i  =  1  n  c  n  t  i  ×  a  i</p><p>因为给的是有向无环图，我们可以在拓扑过程中计数，能够保证每个节点的值不会有后效性。</p><h1 id="C-CSU-1805-Three-Capitals"><a href="#C-CSU-1805-Three-Capitals" class="headerlink" title="C CSU 1805 Three Capitals"></a>C CSU 1805 Three Capitals</h1><p>————————————————————————————————————————————</p><h1 id="D-CSU-1806-Toll"><a href="#D-CSU-1806-Toll" class="headerlink" title="D CSU 1806 Toll"></a>D CSU 1806 Toll</h1><p>————————————————————————————————————————————</p><h1 id="E-CSU-1807-最长上升子序列"><a href="#E-CSU-1807-最长上升子序列" class="headerlink" title="E CSU 1807 最长上升子序列~"></a>E CSU 1807 最长上升子序列~</h1><p>————————————————————————————————————————————</p><h1 id="F-CSU-1808-地铁"><a href="#F-CSU-1808-地铁" class="headerlink" title="F CSU 1808 地铁"></a>F CSU 1808 地铁</h1><p>————————————————————————————————————————————</p><h1 id="G-CSU-1809-Parenthesis"><a href="#G-CSU-1809-Parenthesis" class="headerlink" title="G CSU 1809 Parenthesis"></a>G CSU 1809 Parenthesis</h1><p>————————————————————————————————————————————<br>这题很容易想到对’(’ +1， ‘)’ -1 我们在处理前缀和的时候能够知道当前位置能不能匹配上，<br>那么对于一次交换的时候可以知道这个符号有没有能和他匹配的 最开始想用树状数组维护，然后直接找，<br>然后考虑了交换符号一样时一定是yes。还有写了好多个）(的情况发现总会找到匹配的(不会证明），<br>然后对（）的时候用树状数组进行维护，<br>提交wa。。</p><p>后来发现一组数据 交换粗体的时候 换完之后这两个符号都有匹配的<br>(( <strong> ( </strong> ))(() <strong> ) </strong> )()<br>() <strong> ( </strong> ))(() <strong> ( </strong> )()<br>但是这两个就不匹配了<br>()() <strong> ) </strong> <strong> ( </strong> ()()()</p><p>然后发现当一个位置的括号不匹配了一定是‘）’，在前面没有与它相配的’)’,这个位置的前缀和是-1的，<br>那么也好想，‘）’在原序列上贡献了-2，在交换的区间如果有&lt;2的位置就一定存在不匹配的，<br>注意这个区间是左闭右开的，因为左边还有多个2的贡献，</p><p>然后就是查询区间内有没有&lt;2的就好了, 维护这个方法就很多了,RMQ,BIT.SEGMENT_TREE…</p><h1 id="H-CSU-1810-Reverse"><a href="#H-CSU-1810-Reverse" class="headerlink" title="H CSU 1810 Reverse"></a>H CSU 1810 Reverse</h1><p>————————————————————————————————————————————</p><p>做这题开始的时候思路还是很清晰的,<br>一定是求每个位置的贡献,然后统计,</p><p>然后这个贡献怎么求,<br>对于这个位置的值是本身,<br>一个是交换的区间不包含它,那就是  (  i  )  ∗  (  1  +  i  )  /  2  +  (  n  −  i  )  ∗  (  1<br>+  n  −  i  )  /  2<br>第二个是交换的区间以i为轴 那区间就是min(i,n-i)</p><p>然后关键就是这个位置的值是被交换过来的值,我们要怎么求? 这里我就想蒙蔽了..<br>交换多次要多统计的a[j]~a[k]中的数,然后想了想乱糟的,,就放弃了</p><p><del> 中间还思路想到了一个奇怪的想法….过了第一个样例…. </del></p><p>后来看了题解,<br>发现在上述基础上接着再按求贡献的思路找,<br>找每个  a  j  对这个贡献的贡献就好了,</p><p>依然考虑每个  a  j  有几种交换能交换到  i  的位置.<br>对于每个  a  j  交换到  i  的位置的情况数  m  i  n  (  j  ,  n  −  j  +  1  )<br>其实细分啊  a  j  在  i  左边的就是  a  [  j  ]  ∗  j  右边的就是  a  [  j  ]  ∗  (  n  −  j<br>+  1  )</p><p>维护的时候就线预处理处理前缀和就好了,这样就能在O(n)复杂度计算每个位置的贡献了..</p><h1 id="I-CSU-1811-Tree-Intersection"><a href="#I-CSU-1811-Tree-Intersection" class="headerlink" title="I CSU 1811 Tree Intersection"></a>I CSU 1811 Tree Intersection</h1><p>————————————————————————————————————————————</p><h1 id="J-CSU-1812-三角形和矩形"><a href="#J-CSU-1812-三角形和矩形" class="headerlink" title="J CSU 1812 三角形和矩形"></a>J CSU 1812 三角形和矩形</h1><p>————————————————————————————————————————————</p><p>因为图形和坐标轴是平行的 ,扫描线走一遍就行;</p><p>当然还可以暴力的求凸包交,然后面积和减去面积交就是面积并了..</p><h1 id="K-CSU-1813-盖房子"><a href="#K-CSU-1813-盖房子" class="headerlink" title="K CSU 1813 盖房子"></a>K CSU 1813 盖房子</h1><p>————————————————————————————————————————————</p>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 各OJ </tag>
            
            <tag> 套题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>必须要会的Git基本使用及常用命令操作</title>
      <link href="/2017/04/25/studyofgit/"/>
      <url>/2017/04/25/studyofgit/</url>
      
        <content type="html"><![CDATA[<p>之前一直用的svn，后来换了之后才发现git的强大功能，是svn不能比的。缺点就是可能上手比较难一点，刚开始自己研究了两天才摸索出来一些基本使用方法。<br>最近做项目需要建库等等，都用到了git，随着越来越多的使用，也越来有越多的认识。<br><a id="more"></a><br>一开始都是别人建好远程库，克隆下来就行了。<br>下面内容只是带你git入门，一些基础的东西，是开发过程中一些基本的操作，单单这些你会用了之后就能发现他的好处，以及使用命令行Enter敲击时的快感，还能提高逼格。<br>当然我们还是为了方便项目管理。</p><p>#####安装<br>git工具下载地址，可以选择适合自己的操作系统：<a href="https://git-scm.com/downloads" target="_blank" rel="noopener">https://git-scm.com/downloads</a><br>安装完git，要配置环境变量，拷贝git安装目录下的bin文件目录，如D:\Program Files\Git\bin<br>,将目录拷贝添加到PATH变量后。<br><strong>注意：与前面的值要用“;”号隔开</strong><br>具体步骤：</p><blockquote><p>右键计算机-属性-高级系统设置-环境变量-PATH将目录添加到后面，%JAVA_HOME%\bin;%JAVA_HOME%\jre\bin;D:\Program Files\Git\bin</p></blockquote><p>安装完成后使用 <code>git --version</code>命令查看一下git版本，测试是否安装、配置成功。</p><p>#####克隆远程库<br>使用cmd（安装过git直接可以右键文件夹使用<code>git bash here</code>）定位到要放置仓库的目录<br><code>git clone [远程仓库地址]</code><br>远程仓库就是托管到第三方平台上面的库。<br>常用的有github，这个私有是收费的，要用免费的只能是公共的。<br>目前国内用的比较多的<a href="https://coding.net/" target="_blank" rel="noopener">coding</a> ，和开源中国的<a href="http://git.oschina.net/" target="_blank" rel="noopener">码云</a>。原理都一样，只不过看起来会有点视觉上的差别，个人觉得coding比较简洁,适合学习，刚入门git的新手练习。而且视图更直观。<br>码云是我现在用的，功能要比coding多，包括直接下载上传文件以及打包好的apk文件。</p><p>在这里要说一下克隆的时候有的坑，<strong>要克隆远程仓库必须是你在这个项目中，就是项目所有者（管理员）把你添加进这个项目成员</strong>。输入克隆的指令后，如果是第一次使用会提示你输入用户名，和密码。</p><p>前面步骤如果无误，之后会显示克隆的进度，直到完成克隆。</p><p>#####创建代码库<br>包括远程库（第三方平台）、本地库（存放代码信息）。</p><ul><li>创建远程库：根据第三方平台提示进行创建，一般都有步骤说明，按照说明来就好。<br>创建完成后建议初始化一下仓库，<br>可以在远程上根据提示，创建使用README.md文件初始化项目。<br>也可以使用git命令：<pre><code>git initecho &quot;# HelloWorld&quot; &gt;&gt; README.mdgit add README.mdgit commit -m &quot;first commit&quot;</code></pre>建议使用前者，直接在第三方上创建。</li><li>创建本地仓库：有两种方法<br>1、使用git命令<br><code>git init</code><br>2、android Studio中（这里使用AS为例，其它的IDEA、webStorm操作都一样）<br>点击<code>VCS-import into version control-create git repository</code><br>会弹出选择仓库的路径，直接选当前项目就行，然后确定。<br>创建完之后，找到项目路径会发现文件夹下多了个.git文件，这个就是存放代码的仓库。<br>而且项目中的文件的名称都会变为红色，说明已经有仓库了，但是这些红色的项目文件，并没有加到本地仓库（.git仓库文件中）。<br><strong>（关于颜色后面我会具体说，各种颜色代表的状态）</strong></li><li>关联本地和远程库<br>关联就是把本地仓库的.git仓库文件，和远程（coding）创建的仓库联系起来，每次提交代码，将本地.git中代码，提交到远程库。<br>使用命令：<br><code>git remote add origin [远程仓库地址]</code><br>如果是首次使用，会提示输入用户名+密码，用户名一般是邮箱，输错是关联不成功的。<br>关联成功则无提示，接着输入命令<br><code>git push origin master</code><br>如果失败，很大可能是远程仓库已存在文件。可以执行<br><code>git push -f origin master</code>强制提交。<br>提交过程是能看到进度的。<br>提交完成后可以去平台上查看有没有代码就知道是否成功。</li></ul><p><strong>注意：所有命令行操作必须使用cmd或者git bash定位到项目目录下</strong></p><p>#####仓库基本使用<br>提交过程：<br><code>右键项目-git-add，弹框，选择是</code>；<br>这时候只是把代码添加到本地仓库，<br><code>再右键项目选择commit  directory 在弹框的commit message中输入提交信息，选择commit and push</code><br>然后会显示进度。<br>在多人协作开发一个项目的时候，提交之前一定要先pull一下（<code>VCS - pull</code>）,如果有冲突，选择合并或者是选择远程的，还是本地的，三者选一。<br>处理好这些再进行提交操作。</p><p>#####分支管理<br>分支作为git一个重要的存在，可以进行版本回退，或者协作开发都是一个很便利的存在。<br>在创建仓库的时候，默认会有个master分支，如果是首次开发，则不需要创建分支。<br>但是在版本迭代的时候，特别是大版本迭代，就用到了分支，分支是相互独立存在的仓库。<br>互不影响，在克隆的时候切换一下分支，就会把不同分支下的仓库内容拷贝过来，就像1.0、2.0版本，是分开的，1.0在master分支，2.0版本在maste2分支，可以随时修改历史版本。</p><p><strong>常用命令</strong><br>创建并切换到新建分支：<br><code>git checkout -b master2</code><br>切换分支：<br><code>git checkout master2</code><br>删除分支：<br><code>git branch -d fmaster2</code><br>将分支推送到远程仓库：<br><code>git push origin &lt;branch&gt;</code></p><p>#####关于颜色<br>白色（正常色）：未改动或者没有仓库时的颜色。上<br>红色：未添加仓库的，在创建仓库时会出现。<br>绿色：已添加到本地仓库，没有进行commit push提交远程的。<br>蓝色：修改已经提交到本地仓库的代码。</p><p>#####常见问题</p><blockquote><p>有一种情况是提交/强制提交的时候出现</p></blockquote><p><code>error: src refspec master does not match any.error: failed to push some refs to &#39;https://github.com/wapchief/chat-room-JFrame.git&#39;</code><br>说明是本地代码库为空<br>解决办法：<br>1、在项目中，如android studio，打开项目，右键-&gt;Git-&gt;+Add，然后重新右键-&gt;Git-&gt;commit Directory-&gt;commit and push-&gt;commit。执行之后会发现代码文件颜色都变成正常的白色，之后回到命令行执行提交操作<br>2、在本地仓库创建一个文件，推送到仓库<br><code>touch READMEgit add README git commit -m &#39;first commit&#39;git push origin master</code><br>如果按照上面的步骤来的话是不会出现这种情况的，这种情况出现于已有现成的项目，并且本地项目的代码未提交到本地仓库。这时候提交到远程，就会判定你本地仓库为空。</p><blockquote><p>补充一个在提交过程中出现无法解决问题的办法</p></blockquote><p>如果在使用命令行操作时出现无法解决的错误，直接进入到项目文件，删除<code>.git</code>文件,然后右键该项目目录，或者使用cmd定位到该目录，重新执行</p><pre><code>git init  #初始化本地仓库git remote add origin [远程库地址]  #关联远程库git add . #提交本地代码到本地仓库的暂存区git commit -m &#39;[提交说明]&#39; #提交本地代码到本地仓库，并附上提交说明git push -f origin master #强制推送到远程库</code></pre><hr><p>关于这些只是对于刚入门的学习者有些帮助，在我学习的时候也遇到了好多坑，至今有些问题还能遇到，但是不至于手忙脚乱，起码知道问题出在了哪个环节。<br>Git是一个很强大的版本控制工具，有很多功能，需要尝试去深入研究，希望学习者能够感受到他带来的便捷。</p>]]></content>
      
      
      <categories>
          
          <category> 实用技能 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  第十五届北京师范大学程序设计竞赛 [(6+1)/11,待补]</title>
      <link href="/2017/04/24/70565596/"/>
      <url>/2017/04/24/70565596/</url>
      
        <content type="html"><![CDATA[<h1 id="第十五届北京师范大学程序设计竞赛-6-1-11-待补"><a href="#第十五届北京师范大学程序设计竞赛-6-1-11-待补" class="headerlink" title="第十五届北京师范大学程序设计竞赛 [(6+1)/11,待补]"></a>第十五届北京师范大学程序设计竞赛 [(6+1)/11,待补]</h1><p>2017年04月24日 01:09:43  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：666</p><hr><p> 博客爬取于<code>2019-04-18 17:17:00</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/70565596" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/70565596</a></p><p>23号和队友用一个账号一起做这套题，开了挂，用了两台电脑，由于我们做的时候还不能添加到BNUVJ，队内交流还少，因为中文题面嘛，基本相当于两个人分别打个人了<br>。。。</p><p>但是鄙队实在是菜的抠脚啊，最后仅出6题。j题连题意都没懂有木有（这可是中文题面 qaq。</p><p>qls说封顶8题,那最后我怎么也要补题补到9题啊….</p><h1 id="BNUOJ-52517-A-Another-Server"><a href="#BNUOJ-52517-A-Another-Server" class="headerlink" title="BNUOJ 52517 A Another Server"></a>BNUOJ 52517 A Another Server</h1><p>————————————————————————————————————————————<br>思维题队友过的。明天起来补上.</p><p>原来就是傻逼题，，，<br>题目说的是第i条边链接的是[i+1/2]和[i+1/2]+1,我竟当成了第i个点…</p><p>懵逼到怀疑人生,全场最水的不出 有木有啊… ,最后仔细看了发题,……</p><p>其实连起来发现是<br>1=2=3=4=…=n .(等号代表一个线,,,)</p><p>只要求  m  a  x  {  a  i  +  a  i  +  1  |  i  ∈  [  1  ,  n  −  1  ]  }<br>就好了嘛。。。</p><pre><code>#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long int LL;const double eps = 1e-5;const int    N   = 100+7;int _,n;int main(){    int _;    scanf(&quot;%d&quot;,&amp;_);    while(_--){        scanf(&quot;%d&quot;,&amp;n);        int mx = 10000000;        int a,b;        for(int i=1;i&lt;=n-1;i++){            scanf(&quot;%d%d&quot;,&amp;a,&amp;b);            mx = min(mx,a+b);        }        printf(&quot;%d\n&quot;,mx);    }    return 0;}</code></pre><h1 id="BNUOJ-52509-B-Borrow-Classroom"><a href="#BNUOJ-52509-B-Borrow-Classroom" class="headerlink" title="BNUOJ 52509 B Borrow Classroom"></a>BNUOJ 52509 B Borrow Classroom</h1><p>————————————————————————————————————————————<br>明确题意后很好确定,这是LCA相关问题</p><p>只要满足<br>1. A到C不比B到C慢<br>2. 如果A和C在一个1(根节点)的子树上, A到1不比C到1加B到C慢<br>3. 如果A和C不在一个1的子树上,A到1不比C到[C马上到1的那个节点]加B到C慢</p><p>满足以上任何一条都是yes的情况 ,否则就是no</p><p>由于涉及了[C马上到1的那个节点],我是先预处理了一下这个然后直接判断</p><p>找树上两点关系的时候渣渣只会写树剖,代码长的一逼啊..</p><pre><code>#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long int LL ;const double pi  = acos(-1.0);const double eps = 1e-8;const int    N   = 1e5+7;/***********************************************************************/int _,n,q,cnt,mx;vector&lt;int &gt;G[N];void add(int u,int v){    G[u].push_back(v);    G[v].push_back(u);}int sz[N],son[N],fa[N],dep[N];void dfs1(int u,int f,int d){    sz[u]=1,son[u]=0,fa[u]=f,dep[u]=d;    int gz = G[u].size();    for(int i=0,to;i&lt;gz;i++){        to = G[u][i];        if(to==f) continue;        dfs1(to,u,d+1);        sz[u] += sz[to];        if(sz[son[u]]&lt;sz[to]) son[u]=to;    }}int top[N],tree[N];void dfs2(int u,int tp){    tree[u]=++cnt,top[u]=tp;    if(son[u])dfs2(son[u],tp);    int gz = G[u].size();    for(int i=0,to;i&lt;gz;i++){        to = G[u][i];        if(to==fa[u]||to==son[u]) continue;        dfs2(to,to);    }}int to1[N];int findto1(int x){    if(to1[x])   return to1[x];    if(1==fa[x]) return x;    else         return findto1(fa[x]);}int findi(int x,int y){    int tx = top[x],ty = top[y];    int ans = 0;    while(tx!=ty){        if(dep[tx]&lt;dep[ty]) swap(tx,ty),swap(x,y);//        printf(&quot;(%d %d) [%d %d]\n&quot;,x,y,tree[tx],tree[y]);        ans+=tree[x]-tree[tx]+1;        x=fa[tx],tx=top[x];    }//    printf(&quot;%d\n&quot;,ans);    if(dep[x]&lt;dep[y])swap(x,y);    ans+=tree[x]-tree[y]+1;    return ans-1;}int main(){    int _;    scanf(&quot;%d&quot;,&amp;_);    while(_--){        cnt = 0;        scanf(&quot;%d%d&quot;,&amp;n,&amp;q);        for(int i=1,u,v;i&lt;n;i++){to1[i]=0;            scanf(&quot;%d%d&quot;,&amp;u,&amp;v);            add(u,v);        }        dfs1(1,0,1);        dfs2(1,1);        for(int i=2;i&lt;=n;i++)     to1[i]=findto1(i);//        for(int i=2;i&lt;=n;i++)     printf(&quot;to1[%d]=%d\n&quot;,i,to1[i]);//        for(int i=1;i&lt;=n;i++)     printf(&quot;tree[%d]=%d\n&quot;,i,tree[i]);        int a,b,c;        for(int tmp,i=1;i&lt;=q;i++){            scanf(&quot;%d%d%d&quot;,&amp;a,&amp;b,&amp;c);            tmp = findi(b,c);//            printf(&quot;%d  ++\n&quot;,tmp);            if(tmp&gt;=findi(a,c)) puts(&quot;YES&quot;);            else if(tmp+findi(c,to1[c])&gt;=findi(a,1)&amp;&amp;to1[a]!=to1[c]) puts(&quot;YES&quot;);            else if(tmp+findi(c,to1[c])&gt;=findi(a,to1[c])) puts(&quot;YES&quot;);            else puts(&quot;NO&quot;);        }        for(int i=1;i&lt;=n;i++)G[i].clear();    }    return 0;}</code></pre><h1 id="BNUOJ-52506-C-Captcha-Cracker"><a href="#BNUOJ-52506-C-Captcha-Cracker" class="headerlink" title="BNUOJ 52506 C Captcha Cracker"></a>BNUOJ 52506 C Captcha Cracker</h1><p>————————————————————————————————————————————<br>水签到，不解释</p><h1 id="BNUOJ-52503-D-Disdain-Chain"><a href="#BNUOJ-52503-D-Disdain-Chain" class="headerlink" title="BNUOJ 52503 D Disdain Chain"></a>BNUOJ 52503 D Disdain Chain</h1><p>————————————————————————————————————————————<br>思维题吧， 就是画了画发现，因为是一个完全图，只要加一个节点，那么其最长链都是n的，所以无脑输出n-1个0 和一个(1&lt;&lt;(n*(n-1)/2))就好了</p><pre><code>int main(){    int _;    scanf(&quot;%d&quot;,&amp;_);    while(_--){        scanf(&quot;%d&quot;,&amp;n);        for(int i=1;i&lt;n;i++) printf(&quot;%d\n&quot;,0);        printf(&quot;%d\n&quot;,1&lt;&lt;(n*(n-1)/2));    }    return 0;}</code></pre><h1 id="BNUOJ-52505-E-Euclidean-Geometry"><a href="#BNUOJ-52505-E-Euclidean-Geometry" class="headerlink" title="BNUOJ 52505 E Euclidean Geometry"></a>BNUOJ 52505 E Euclidean Geometry</h1><p>————————————————————————————————————————————<br>开始想的是枚举最长的边上的圆的半径，从0到边长。开始以为是一个凸函数，三分就行了，但是写完样例没有过，然后发现其实最大的园面积的和 相当于在<br>x  +  y  =  a  w  =  x  2  +  y  2<br>求w的最大值，显然  x  =  a  的时候w最大.<br>回来思考最大的面积和,也就是使一个圆的半径最大化,因为有不能相交的限制,所以最大的圆的半径就是第二长的边的长读,然后在算上当前状态下另外的两个园就好了(其中<br>有一个是半径为0的园,另一个半径就是最长边减次长边.</p><pre><code>int main(){    int _;    scanf(&quot;%d&quot;,&amp;_);    while(_--){        scanf(&quot;%d%d%d&quot;,&amp;a,&amp;b,&amp;c);        if(b&lt;c) swap(b,c);        if(a&lt;b) swap(a,b);        if(b&lt;c) swap(b,c);        printf(&quot;%.12lf\n&quot;,pi*(b*b+(a-b)*(a-b)));    }    return 0;}</code></pre><h1 id="BNUOJ-52513-F-Find-Quailty"><a href="#BNUOJ-52513-F-Find-Quailty" class="headerlink" title="BNUOJ 52513 F Find Quailty"></a>BNUOJ 52513 F Find Quailty</h1><p>————————————————————————————————————————————<br>神题啊 我是不会补的,</p><h1 id="BNUOJ-52514-G-Graph-Compression"><a href="#BNUOJ-52514-G-Graph-Compression" class="headerlink" title="BNUOJ 52514 G Graph Compression"></a>BNUOJ 52514 G Graph Compression</h1><p>————————————————————————————————————————————<br>还没看题.尽量补</p><h1 id="BNUOJ-52512-H-Honorable-Mention"><a href="#BNUOJ-52512-H-Honorable-Mention" class="headerlink" title="BNUOJ 52512 H Honorable Mention"></a>BNUOJ 52512 H Honorable Mention</h1><p>————————————————————————————————————————————<br>看N的大小,我想大力分块,</p><p>然后细节还没想好,想好补上.</p><h1 id="BNUOJ-52508-I-Idol-Master"><a href="#BNUOJ-52508-I-Idol-Master" class="headerlink" title="BNUOJ 52508 I Idol Master"></a>BNUOJ 52508 I Idol Master</h1><p>————————————————————————————————————————————<br>完全没想法啊</p><h1 id="BNUOJ-52516-J-Just-A-String"><a href="#BNUOJ-52516-J-Just-A-String" class="headerlink" title="BNUOJ 52516 J Just A String"></a>BNUOJ 52516 J Just A String</h1><p>————————————————————————————————————————————<br>在我理解的题意中,字符串长什么样无关结果….hhh…gg</p><p>懂了字符串对结果的影响了</p><p>比如说我有一个字符串，这个时候我找到的是f(i,j) ,<br>XXXABCABCABCXXX f(6,10)<br>那么strA：XXXABC strB:ABC strC:ABCXXX<br>并不一定是前后缀相交的那个串才是B</p><p>然后考虑怎么计算结果，<br>直接暴力算的话+KMP的话也是  O  (  n  3  )  的<br>很好考虑，我们一定是枚举(i,j)找到前后缀,<br>然后找这个前后串的那个公共部分.</p><p>一般我们固定一个值去枚举另一个值,这里也是一样,<br>考虑KMP的过程中就是一个子串在一个母串上匹配,<br>然后我们惊奇的发现这个过程不就是在整个穿上进行KMP,母串每个位置的时候匹配的子串最长是多长?</p><p>统计的过程直接放到KMP就好了</p><p>最后就是在枚举后缀的,对整个字符串进行KMP,在KMP的过程中统计,</p><pre><code>char a[N],*p;int Next[N];void get_next(char *s,int len){    for(int i=0,j=-1;i&lt;=len;++i,++j){        Next[i]=j;        while(j&gt;=0&amp;&amp;s[i]!=s[j]) j = Next[j];    }//    for(int i=0;i&lt;=len;i++) printf(&quot;%d%c&quot;,Next[i],(i==len)?&#39;\n&#39;:&#39; &#39;);}int Main(){    int _;    scanf(&quot;%d&quot;,&amp;_);    while(_--){        scanf(&quot;%s&quot;,a);        int len = strlen(a);        LL ans = 0;        for(int k=0;k&lt;len;k++){            p=a+k;            get_next(p,len-k);            for(int j=0,i=0;i&lt;=len;i++,j++){                ans ^= 1LL*(j)*(j)*(len-k-j)*(i-j) ;                while(j&gt;=0&amp;&amp;a[i]!=p[j]) j=Next[j];            }        }        printf(&quot;%lld\n&quot;,ans);    }    return 0;}</code></pre><h1 id="BNUOJ-52511-K-Keep-In-Line"><a href="#BNUOJ-52511-K-Keep-In-Line" class="headerlink" title="BNUOJ 52511 K Keep In Line"></a>BNUOJ 52511 K Keep In Line</h1><p>————————————————————————————————————————————<br>简单模拟</p><pre><code>int _,n;map&lt;string,int&gt;mmp;string a[N],op[N];int h[N];int main(){    cin&gt;&gt;_;    while(_--){        mmp.clear();        memset(h,1,sizeof(h));        cin&gt;&gt;n;        for(int i=1;i&lt;=n;i++){            cin&gt;&gt;op[i]&gt;&gt;a[i];            if(!mmp[a[i]]) mmp[a[i]]=++cnt;        }        int ans = 0,tmp=0,tem=1;        for(int i=1;i&lt;=n;i++){            if(op[i][0]==&#39;o&#39;){                tmp = mmp[a[i]];                if(tmp == tem)  ans++;                h[tmp]=0;                while(!h[tem])tem++;            }        }        printf(&quot;%d\n&quot;,ans);    }    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  Google Code Jam 2017 Round 1B [B-large不会]</title>
      <link href="/2017/04/23/70481823/"/>
      <url>/2017/04/23/70481823/</url>
      
        <content type="html"><![CDATA[<h1 id="Google-Code-Jam-2017-Round-1B-B-large不会"><a href="#Google-Code-Jam-2017-Round-1B-B-large不会" class="headerlink" title="Google Code Jam 2017 Round 1B [B-large不会]"></a>Google Code Jam 2017 Round 1B [B-large不会]</h1><p>2017年04月23日 04:05:38  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：873</p><hr><p> 博客爬取于<code>2019-04-18 17:17:01</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/70481823" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/70481823</a></p><h1 id="A-Steed-2-Cruise-Control"><a href="#A-Steed-2-Cruise-Control" class="headerlink" title="A. Steed 2: Cruise Control"></a>A. Steed 2: Cruise Control</h1><p>————————————————————————————————————————————<br>一个人要从0骑马到D，路上可能有多个骑马者，为了表示尊重，后面追过来的马不能超过前面的马，要减速到与前面的马相同的速度，现在问你这个人最开始的速度为多大的时<br>候能保证在整个过程中不会超过别人，</p><p>很明显的二分答案。</p><p>注意浮点型二分的次数即可。<br>判断的时候只要判断中间有没有马在这个人到D的时候还没有到达D就行了。。</p><p>附本题代码<br>————————————————————————————————————————————</p><pre><code>int _,d,n;int k[10000],s[10000];bool check(double x){    double t = 1.0*d/x;    for(int i=1;i&lt;=n;i++){        if(t*s[i]+k[i] + 1e-8 &lt;=d*1.0) return false;    }    return true;}int main(){    freopen(&quot;A-large (1).in&quot;,&quot;r&quot;,stdin);    freopen(&quot;A-large (1).txt&quot;,&quot;w&quot;,stdout);    int kcase = 0;    scanf(&quot;%d&quot;,&amp;_);    while(_--){        scanf(&quot;%d%d&quot;,&amp;d,&amp;n);        for(int i=1;i&lt;=n;i++)       scanf(&quot;%d%d&quot;,&amp;k[i],&amp;s[i]);        double l=0,r=1e15,mid;        for(int i=0;i&lt;300;i++){            mid = (r+l)/2;            if(check(mid))l=mid;            else  r=mid;        }        printf(&quot;Case #%d: &quot;,++kcase);        printf(&quot;%.6lf\n&quot;,l);    }    return 0;}</code></pre><h1 id="B-Stable-Neigh-bors"><a href="#B-Stable-Neigh-bors" class="headerlink" title="B. Stable Neigh-bors"></a>B. Stable Neigh-bors</h1><p>————————————————————————————————————————————<br>这个大数据的我不会做,,</p><p>就是一种东西的头发空有6种颜色的可能其中有红,黄,蓝,橙色,紫色,绿色<br>橙色=红+黄<br>紫色=红+蓝<br>绿色=黄+蓝</p><p>现在有相同颜色的两个东西不能挨着，（注意：像橙色和红色这种也不能挨着，），问你存不存在一个排列，使得N各这些东西能够围城一圈。<br>给了你每个颜色的东西有多少个。</p><p>大数据没搞<br>我就不会图论，怎么建图实在弄不明白，然后水了发小数据<br>小数据就很好写了<br>只有RYB三种颜色，只要不相同就能挨着，<br>那么考虑不可能的情况就是当其中两种小的个数和小于最大的那个的个数，这样的话一定会有同色挨着的。</p><p>然后对于可行的时候我们只要在颜色最大的那个基础上进行插入另外两种颜色就好了，<br>一种从左边开始挨个插，另一种从右边开始挨个插就好了，</p><p>附小数据代码<br>————————————</p><pre><code>int _,n,r,o,y,g,b,v;int flag ;void dfs(int t,string s,int m,int R,int G,int B){//    puts(&quot;--&quot;);    if(flag==0) return ;    if(n==m&amp;&amp;flag) {        if(s[0]!=s[n-1]){            flag = 0;            cout&lt;&lt;s&lt;&lt;endl;        }    }    for(int i=1;i&lt;=3&amp;&amp;flag;i++){        if(i==t) continue;        if(i==1&amp;&amp;R)s+=&quot;R&quot;,dfs(i,s,m+1,R-1,G  ,B  );        if(i==2&amp;&amp;G)s+=&quot;G&quot;,dfs(i,s,m+1,R  ,G-1,B  );        if(i==3&amp;&amp;B)s+=&quot;B&quot;,dfs(i,s,m+1,R  ,G  ,B-1);    }}void dfs1(int R,int Y,int B){    string s=&quot;&quot;;    for(int i=1;i&lt;=R;i++){        s+=&quot;R&quot;;        if(i&lt;=Y) s+=&quot;Y&quot;;        if(i+B&gt;R) s+=&quot;B&quot;;    }//    printf(&quot;%d *1 &quot;,s.size());    cout&lt;&lt;s&lt;&lt;endl;}void dfs2(int R,int Y,int B){    string s=&quot;&quot;;    for(int i=1;i&lt;=Y;i++){        s+=&quot;Y&quot;;        if(i&lt;=R) s+=&quot;R&quot;;        if(i+B&gt;Y) s+=&quot;B&quot;;    }//    printf(&quot;%d *2 &quot;,s.size());    cout&lt;&lt;s&lt;&lt;endl;}void dfs3(int R,int Y,int B){    string s=&quot;&quot;;    for(int i=1;i&lt;=B;i++){        s+=&quot;B&quot;;        if(i&lt;=Y) s+=&quot;Y&quot;;        if(i+R&gt;B) s+=&quot;R&quot;;    }//    printf(&quot;%d *3 &quot;,s.size());    cout&lt;&lt;s&lt;&lt;endl;}int main(){    freopen(&quot;B-small-attempt2.in&quot;,&quot;r&quot;,stdin);    freopen(&quot;B-small-attempt2.txt&quot;,&quot;w&quot;,stdout);    int kcase = 0;    scanf(&quot;%d&quot;,&amp;_);    while(_--){        scanf(&quot;%d&quot;,&amp;n);        scanf(&quot;%d%d%d%d%d%d&quot;,&amp;r,&amp;o,&amp;y,&amp;g,&amp;b,&amp;v);//        printf(&quot;%d: %d %d %d %d %d %d\n&quot;,n,r,o,y,g,b,v);        int a[4];        a[0]=r;        a[1]=y;        a[2]=b;        sort(a,a+3);printf(&quot;Case #%d: &quot;,++kcase);        if(a[0]+a[1]&lt;a[2]) puts(&quot;IMPOSSIBLE&quot;);        else {            flag = 1;                 if(r&gt;=y&amp;&amp;r&gt;=b) dfs1(r,y,b);            else if(y&gt;=r&amp;&amp;y&gt;=b) dfs2(r,y,b);            else if(b&gt;=y&amp;&amp;b&gt;=r) dfs3(r,y,b);        }    }    return 0;}</code></pre><h1 id="C-Pony-Express"><a href="#C-Pony-Express" class="headerlink" title="C. Pony Express"></a>C. Pony Express</h1><p>————————————————————————————————————————————<br>给你N的N个城市上每个有一匹马（马最多能走  E  i  ，速度是  S  i  ） 到每个城市可以选择换马或者不换马 然后Q次询问 问你从点  u  到点<br>v  最快的时间</p><p>数据范围很小 ,尤其是  N  ≤  100  ,很明显的提示了floyd</p><p>我们可以这样做,先对距离进行floyd,找到两点间的最短距离,</p><p>然后根据这个距离和  E  i  的关系确定一个最少时间的图,对其跑floyd,就是我们所有的结果了,查询的时候O(1)查询就好了.</p><p>附本题代码<br>————————————————————</p><pre><code>int _,n,q;double d[111],s[111];double a[111][111],b[111][111];int main(){    freopen(&quot;C-large-practice.in&quot;,&quot;r&quot;,stdin);    freopen(&quot;C-large-practice.txt&quot;,&quot;w&quot;,stdout);    int kcase = 0;    scanf(&quot;%d&quot;,&amp;_);    while(_--){        scanf(&quot;%d%d&quot;,&amp;n,&amp;q);        for(int i=1;i&lt;=n;i++)    scanf(&quot;%lf%lf&quot;,&amp;d[i],&amp;s[i]);        LL x;        for(int i=1;i&lt;=n;i++)            for(int j=1;j&lt;=n;j++){                scanf(&quot;%lld&quot;,&amp;x);                if(x==-1) x=1000000000000000000ll;                a[i][j]=1.0*x;                if(i==j) a[i][j]=0.0;            }        for(int k=1;k&lt;=n;k++)            for(int i=1;i&lt;=n;i++)                for(int j=1;j&lt;=n;j++)                    if(a[i][j]&gt;a[i][k]+a[k][j])                        a[i][j]=a[i][k]+a[k][j];        for(int i=1;i&lt;=n;i++)            for(int j=1;j&lt;=n;j++){                if(a[i][j]==1.0*1000000000000000000ll) b[i][j]=a[i][j];                else if(a[i][j]&lt;=d[i]) b[i][j]=a[i][j]/s[i];                else b[i][j]=1.0*1000000000000000000ll;            }        for(int k=1;k&lt;=n;k++)            for(int i=1;i&lt;=n;i++)                for(int j=1;j&lt;=n;j++)                    if(b[i][j]&gt;b[i][k]+b[k][j])                        b[i][j]=b[i][k]+b[k][j];        printf(&quot;Case #%d:&quot;,++kcase);        for(int i=1,u,v;i&lt;=q;i++){            scanf(&quot;%d%d&quot;,&amp;u,&amp;v);            printf(&quot; %.6lf&quot;,b[u][v]);        }puts(&quot;&quot;);    }    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  第十四届浙江省赛 ZOJ 3962~3965 【E,F,G,H】 (其他并不准备补。)</title>
      <link href="/2017/04/22/70478134/"/>
      <url>/2017/04/22/70478134/</url>
      
        <content type="html"><![CDATA[<h1 id="第十四届浙江省赛-ZOJ-3962-3965-【E-F-G-H】-其他并不准备补。"><a href="#第十四届浙江省赛-ZOJ-3962-3965-【E-F-G-H】-其他并不准备补。" class="headerlink" title="第十四届浙江省赛 ZOJ 3962~3965 【E,F,G,H】 (其他并不准备补。)"></a>第十四届浙江省赛 ZOJ 3962~3965 【E,F,G,H】 (其他并不准备补。)</h1><p>2017年04月22日 23:30:04  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：778</p><hr><p> 博客爬取于<code>2019-04-18 17:17:02</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/70478134" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/70478134</a></p><p>EF是纯自己做的,G,H是参(chao)考(xi)了dalao们的思(dai)路(ma)才补上的.</p><h1 id="ZOJ-3962-E-Seven-Segment-Display"><a href="#ZOJ-3962-E-Seven-Segment-Display" class="headerlink" title="ZOJ 3962 E Seven Segment Display"></a>ZOJ 3962 E Seven Segment Display</h1><p>————————————————————————————————————————————</p><p>现在就是有一个8位16进制的一个数x，数字[0,F]有自己的贡献 ,问你[x,x+n]的数中的贡献和是多少,<br>(注意FFFFFFFF+1 是00000000)</p><p>解题思路:<br>当时想的是数位dp<br>每次计算当前数字为i的时候的结果,然后超时了,, 最后测试发现是被卡卡常了<br>最最后终于观察到,有几个数字的贡献是一样的,贡献只有[2,7]6种,这样的话 ,我就枚举6种贡献的数字,算式优化了下常数,然后AC….</p><p>其他处理的时候就是注意要是超过了0xffffffff 将区间变成首尾的两段和就行了.</p><p>附本题代码<br>————————————————————————————————————————</p><pre><code>#include&lt;stdio.h&gt;#include&lt;math.h&gt;#include&lt;string.h&gt;typedef long long int LL;using namespace std;inline int read(){    int x=0,f=1;char ch=getchar();    while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;){if(ch==&#39;-&#39;)f=-1;ch=getchar();}    while(ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;){x=x*10+ch-&#39;0&#39;;ch=getchar();}    return x*f;}int val[16]={6,2,5,5,4,5,6,3,7,6,6,5,4,5,5,4};char a[45];int getnum(char a){    if(a&gt;=&#39;0&#39;&amp;&amp;a&lt;=&#39;9&#39;)return a-&#39;0&#39;;    return a-&#39;A&#39;+10;}int num[30],len;LL dp[30][16+2][10];LL dfs(int pos,int pre,bool limit,int sum,int &amp;n){    if(pos&lt;0) return sum;    if(!limit&amp;&amp;dp[pos][sum][n]!=-1) return dp[pos][sum][n];    int endi = 15; if(limit) endi = num[pos];    LL res = 0;    for(int i=0;i&lt;=endi;i++)        res+=dfs(pos-1,i,limit&amp;&amp;(endi==i),sum+(val[i]==n),n);    if(!limit) dp[pos][sum][n] = res;    return res;}LL solve(LL n,int i){    if(n&lt;0) return 0;    len = 0;LL tem = n;    while(n){        num[len++]=n%16;        n/=16;    }    LL ans = dfs(len-1,0,1,0,i);    if(i == val[0])  ans+=(tem+1)*(8-len);//前导0;    return ans;}int main(){    memset(dp,-1,sizeof(dp));//    for(int i=0;i&lt;16;i++) solve(1ll*0xffffffff,i);    int t=read();    while(t--){        int n=read();n--;        LL nn = 0;        for(int i=0;i&lt;8;i++)  nn=(nn&lt;&lt;4)+getnum(getchar());        LL n16 = 0xffffffff;        LL ans = 0;        if(nn+n&lt;=n16){            for(int i=2;i&lt;=7;i++)                ans+=(solve(nn+n,i)-solve(nn-1,i))*i;        }        else {            for(int i=2;i&lt;=7;i++)                ans+=(solve(n16,i)-solve(nn-1,i))*i;            for(int i=2;i&lt;=7;i++)                ans+=solve(nn+n-n16-1,i)*i;        }        printf(&quot;%lld\n&quot;,ans);    }    return 0;}</code></pre><h1 id="ZOJ-3963-F-Heap-Partition"><a href="#ZOJ-3963-F-Heap-Partition" class="headerlink" title="ZOJ 3963 F Heap Partition"></a>ZOJ 3963 F Heap Partition</h1><p>————————————————————————————————————————————</p><p>现在有一个序列，让你把它分成几个集合，使得每个集合中的数能被放到最大堆上，其父子节点关系满足  s  j  ≤  s  i  a  n  d  j  &lt; i</p><p>首先很容易想到，就是找这个数前面有没有比它小的，有就作为这个数的儿子就好了，<br>注意的是一个节点只有两个儿子，明确这个，随便搞搞就行了。</p><p>（其实我这个并查集是不用的，只需要写个数组映射过去就好，当时纯属脑抽</p><p>附本题代码<br>————————————————————————————————————————————</p><pre><code>#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 100000+7000;int a[N],h[N];int n;int sum[N];#define lowbit(x) (x&amp;-x)void update(int i,int v){    for(;i&lt;=n;i+=lowbit(i)) sum[i]+=v;}int getSum(int i){    int ans = 0;    for(;i;i-=lowbit(i)) ans+=sum[i];    return ans;}int BS(int x){    int l=1,r=n,mid,ans;    while(l&lt;=r){        mid = r+l &gt;&gt;1;        if(getSum(mid)&gt;=x) r=mid-1,ans = mid;        else   l=mid+1;    }    return ans;}int pre[N];int findi(int x){    int r = x;    while(r!=pre[r])r=pre[r];    int i=x,j;    while(i!=r){        j=pre[i];        pre[i]=r;        i=j;    }    return r;}void join(int x,int y){    int fx=findi(x),fy=findi(y);    pre[fy]=fx;}vector&lt;int &gt;G[N];int main(){    int _;    scanf(&quot;%d&quot;,&amp;_);    while(_--){        int ans = 0,x,y;        scanf(&quot;%d&quot;,&amp;n);        for(int i=1;i&lt;=n;i++) pre[i]=i;        for(int i=1;i&lt;=n;i++){            scanf(&quot;%d&quot;,&amp;a[i]);            int flag = getSum(a[i]);            if(flag){                x = BS(flag);                update(x,-1);                join(h[x],i);            }            update(a[i],2);            h[a[i]]=i;        }//        for(int i=1;i&lt;=n;i++){//            printf(&quot;%d %d\n&quot;,h[i],pre[i]);//        }        for(int fi,i=1;i&lt;=n;i++){            fi = findi(i);            if(fi==i) {                ans++;                G[i].push_back(0);            }            G[fi].push_back(i);        }        printf(&quot;%d\n&quot;,ans);        for(int i=1;i&lt;=n;i++){            int sz = G[i].size();//            printf(&quot;%d  ++\n&quot;,sz);            if(sz){                printf(&quot;%d&quot;,sz-1);                for(int j=1;j&lt;sz;j++)printf(&quot; %d&quot;,G[i][j]);                puts(&quot;&quot;);            }        }        for(int i=1;i&lt;=n;i++){            sum[i]=0;            G[i].clear();        }    }    return 0;}</code></pre><h1 id="ZOJ-3964-G-Yet-Another-Game-of-Stones"><a href="#ZOJ-3964-G-Yet-Another-Game-of-Stones" class="headerlink" title="ZOJ 3964 G Yet Another Game of Stones"></a>ZOJ 3964 G Yet Another Game of Stones</h1><p>————————————————————————————————————————————<br>有N堆石子，Alice和Bob轮流取石子，现在规定对于每堆石子Bob想怎么拿怎么拿，但是堆Alice不一样<br>如果对应  b  i  =  0  那么对Alice也没有限制<br>如果对应  b  i  =  1  那么对Alice只能拿奇数个石子<br>如果对应  b  i  =  2  那么对Alice只能拿偶数个石子<br>对于不能操作的人输,Alice先手,问你谁是赢家</p><hr><p>首先考虑,如果  b  i  =  0  恒成立，那么就是退化为最基本的Nim游戏即可。</p><p>然后考虑有  b  i  =  1  的情况，如果对应的  a  i  =  1  ，那么就相当于  b  i  =  0  ，<br>除去  a  i  =  1  的情况发现一个的时候相当于先后手交换。那么显然如有两个以上  b  i  =  1  Alice一定输。</p><p>然后考虑有  b  i  =  2  的情况，如果对应的  a  i  ，那么在Bob不傻的情况下Alice一定取不完这堆。如果有多个  b  i  =<br>2  那么Bob至少能使其中一堆变成  a  i  ，那么Alice还是输。</p><p>能确定  b  i  =  1  和  b  i  =  2  之多只能由一种且只有一个Alice才有可能赢。</p><p>最后大力讨论一下就好了。</p><p>（学习了这种分类讨论实现起来666的姿势</p><p>附本题代码<br>————————————————————————————————————————————</p><pre><code>int _,n;int  a[N],b[N];bool solve(){    int ans = 0;    bool flag = false;    for(int i=1;i&lt;=n;i++){        if(b[i]==0)          ans^=a[i];        else if(b[i]==1){            if(a[i]==1)ans^=1;            else {                if(flag ) return false;                flag = true;                if(~a[i]&amp;1) ans^=1;            }        }        else {            if(a[i]&amp;1) return false;            if(flag)  return false;            flag = true;        }    }    return flag?ans==0:ans;}int main(){    int _;    scanf(&quot;%d&quot;,&amp;_);    while(_--){        scanf(&quot;%d&quot;,&amp;n);        for(int i=1;i&lt;=n;i++)       scanf(&quot;%d&quot;,&amp;a[i]);        for(int i=1;i&lt;=n;i++)       scanf(&quot;%d&quot;,&amp;b[i]);        puts(solve()?&quot;Alice&quot;:&quot;Bob&quot;);    }    return 0;}</code></pre><h1 id="ZOJ-3965-H-Binary-Tree-Restoring"><a href="#ZOJ-3965-H-Binary-Tree-Restoring" class="headerlink" title="ZOJ 3965 H Binary Tree Restoring"></a>ZOJ 3965 H Binary Tree Restoring</h1><p>————————————————————————————————————————————<br>给你一个二叉树的两种dfs遍历的顺序,让你构造出一个满足这两种dfs序的二叉树.(有SPJ);</p><p>首先考虑我们在讲一个树形结构转化为线结构的时候,通过dfs序,可以将一个节点为根的子树中其他节点包含起来,编号是连续的,从而能够采用线段树and so<br>on的数据结构维护.</p><p>同理在dfs序中一个连续的区间即可能是一个子树中的结构<br>同时思考dfs序不同是因为遍历的不知道是按左儿子先,还是右儿子先.于是产生了多种dfs序..</p><p>也就是说<br>对于A,B两个序列来说,会各自有一个区间相互对应为同一个子树.(且这两个区间内的元素的集合是相同的.</p><p>明确了这个我们只要对相同的区间搜下去并记录父亲节点就好了.</p><p>注意的是这个节点的父亲节点一定在两个序列中比最早出现的那个出现的还早.<br>还有就是一个节点只能由两个儿子,如果满了拿这颗子树就应该网上找节点加上去.(维护过程就类似并查集了.</p><p>附本题代码<br>————————————————————————————————————————————</p><pre><code>int _,n,q,mx;int a[N],b[N];int h[N],f[N];int visa[N],visb[N];void dfs(int l1,int r1,int l2,int r2,int fa) {    if(l1&gt;r1||r1&gt;n||r2&gt;n)   return;    if(a[l1]==b[l2]) {        f[a[l1]]=fa;if(h[fa]) h[fa]--;        dfs(l1+1,r1,l2+1,r2,a[l1]);    }    else {        int len1=visa[b[l2]]-l1-1;        int len2=visb[a[l1]]-l2-1;        dfs(l1,l1+len1,l2+len2+1,l2+len1+len2+1,fa);        dfs(l1+len1+1,l1+len1+len2+1,l2,l2+len2,fa);        while(!h[fa])   fa=f[fa];        dfs(l1+len1+len2+2,r1,l2+len1+len2+2,r2,fa);    }}int main(){    int _;    scanf(&quot;%d&quot;,&amp;_);    while(_--){        scanf(&quot;%d&quot;,&amp;n);        for(int i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;a[i]),visa[a[i]]=i,h[i]=2;h[0]=2;        for(int i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;b[i]),visb[b[i]]=i;        dfs(1,n,1,n,0);        for(int i=1;i&lt;=n;i++) printf(&quot;%d%c&quot;,f[i],(i&lt;n)?&#39; &#39;:&#39;\n&#39;);    }    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  51Nod-算法马拉松23 B 谷歌的恐龙 [概率期望]【数学】</title>
      <link href="/2017/04/21/70328966/"/>
      <url>/2017/04/21/70328966/</url>
      
        <content type="html"><![CDATA[<h1 id="51Nod-算法马拉松23-B-谷歌的恐龙-概率期望-【数学】"><a href="#51Nod-算法马拉松23-B-谷歌的恐龙-概率期望-【数学】" class="headerlink" title="51Nod-算法马拉松23 B 谷歌的恐龙 [概率期望]【数学】"></a>51Nod-算法马拉松23 B 谷歌的恐龙 [概率期望]【数学】</h1><p>2017年04月21日 16:27:27  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：980</p><hr><p> 博客爬取于<code>2019-04-18 17:17:03</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/70328966" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/70328966</a></p><p>题目链接: <a href="http://www.51nod.com/onlineJudge/questionCode.html#!problemId=1765" target="_blank" rel="noopener"> http://www.51nod.com/onlineJudge/questionCode.html#!problemId=1765</a><br>————————————————————————————————————————————<br>1765 谷歌的恐龙<br>基准时间限制：1 秒 空间限制：1048576 KB 分值: 80 难度：5级算法题 收藏 关注<br>相信网络不好的选手一定很熟悉Chrome里面那个恐龙的游戏，这个题目就是根据那个游戏简化得来的。<br>给出一个正整数n，把恐龙的跳跃简化成一个[0,n)的随机数，再给出一个正整数m，把障碍简化为[0,n)中m个不同的的整数，把分数简化成所有生成的随机数的和。<br>把整个游戏简化为，每次生成一个[0,n)的随机数，如果这个随机数和给出的m个数字中的其中一个数字相等，那么就停止生成随机数，否则继续生成，求出所有生成的数的<br>和的期望。<br>Input<br>第一行两个正整数n(1&lt;=n&lt;=10000000),m(1&lt;=m&lt;=n)<br>第二行m个整数a_i表示障碍(0&lt;=a_i&lt; n)<br>Output<br>一行一个实数E表示期望，保留6位小数。<br>注意了本题没有SPJ，必须和答案完全相同才能通过本题</p><p>样例解释：当生成的是0的时候继续，生成的是1的时候停止<br>E=1/2+1/4+…..=1<br>Input示例<br>2 1<br>1<br>Output示例<br>1.000000<br>————————————————————————————————————————————</p><p>本题就是简单的求期望</p><p>设x为选择的数的期望和</p><p>E  =  m  n  ×  x  m  +  n  −  m  n  ×  (  n  ×  (  n  −  1  )  2  −  x  n  −<br>m  +  E  )<br>⇒  E  =  x  n  +  n  ×  (  n  −  1  )  2  −  x  n  +  n  −  m  n  ×  E<br>⇒  E  −  n  −  m  n  ×  E  =  x  +  n  ×  (  n  −  1  )  2  −  x  n<br>⇒  E  ×  m  n  =  n  ×  (  n  −  1  )  2  n<br>⇒  E  ×  m  =  n  ×  (  n  −  1  )  2<br>⇒  E  =  n  ×  (  n  −  1  )  2  ×  m</p><p>然后就….</p><p>附本题代码<br>——————————————————————————————————————————</p><pre><code>#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long int LL;const int N = 200000+7;int main() {    LL n, m;    scanf(&quot;%lld%lld&quot;, &amp;n, &amp;m);    printf(&quot;%.6f\n&quot;, n * 1.0 * (n - 1) / 2 / m);    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  51nod 1718 Cos的多项式 【数学】</title>
      <link href="/2017/04/21/70313683/"/>
      <url>/2017/04/21/70313683/</url>
      
        <content type="html"><![CDATA[<h1 id="51nod-1718-Cos的多项式-【数学】"><a href="#51nod-1718-Cos的多项式-【数学】" class="headerlink" title="51nod 1718 Cos的多项式 【数学】"></a>51nod 1718 Cos的多项式 【数学】</h1><p>2017年04月21日 13:11:03  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：659</p><hr><p> 博客爬取于<code>2019-04-18 17:17:04</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/70313683" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/70313683</a></p><p>题目链接： <a href="http://www.51nod.com/onlineJudge/questionCode.html#!problemId=1718" target="_blank" rel="noopener"> http://www.51nod.com/onlineJudge/questionCode.html#!problemId=1718</a><br>————————————————————————————————————————————<br>1718 Cos的多项式<br>基准时间限制：1 秒 空间限制：131072 KB 分值: 40 难度：4级算法题 收藏 关注<br>小明对三角函数充满了兴趣，有一天他突然发现一个神奇的性质。<br>2cos(nx)似乎可以表示成2cos(x)的一个多项式。<br>但是小明并不能证明它的正确性。<br>现在给定n，问是否可以表示成这样的多项式，如果可以，只需输出各项系数的和。（Tip:如果这个和很大，那就高精度咯:)）<br>否则输出No</p><p>样例解释：2<em>cos(3x)=(2</em>cosx)^3-3<em>(2</em>cosx)，系数为1和-3，他们的和为-2。<br>Input<br>一个数表示n（n&lt;=1e15)<br>Output<br>如果能表示 输出各项系数和<br>不能 输出No<br>Input示例<br>3<br>Output示例<br>-2 </p><p>————————————————————————————————————————————</p><p>我们知道</p><p>n  2  c  o  n  (  n  x  )  系数和</p><p>1</p><p>2  c  o  s  (  x  )</p><p>1</p><p>2</p><p>(  2  c  o  s  (  x  )  )  2  −  2</p><p>-1 </p><p>然后不会了…</p><p>考虑<br>2  c  o  s  (  (  n  −  1  )  x  )  =  2  (  c  o  s  (  n  x  )  c  o  s  (<br>x  )  +  s  i  n  (  n  x  )  s  i  n  (  x  )  )<br>2  c  o  s  (  (  n  +  1  )  x  )  =  2  (  c  o  s  (  n  x  )  c  o  s  (<br>x  )  −  s  i  n  (  n  x  )  s  i  n  (  x  )  )</p><p>⇒  2  c  o  s  (  (  n  −  1  )  x  )  +  2  c  o  s  (  (  n  +  1  )  x  )<br>=  2  c  o  s  (  n  x  )  ×  2  c  o  s  (  x  )</p><p>设  f  (  n  )  =  2  c  o  s  (  n  x  )<br>有  f  (  n  −  1  )  +  f  (  n  +  1  )  =  f  (  n  )  f  (  1  )  ⇒  f  (<br>n  +  1  )  =  f  (  n  )  f  (  1  )  −  f  (  n  −  1  )  ⇒  f  (  n  +  1<br>)  =  f  (  n  )  ×  2  c  o  s  (  x  )  −  f  (  n  −  1  )</p><p>这样就有了推出所有公式了</p><p>然后计算出系数和 震惊的发现其结果竟是有循环节的!!!!</p><p>然后打表AC</p><p>附本题代码<br>————————————————————————————————————————</p><pre><code>#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long int LL;const int N = 200000+7;LL n;int a[6] = {1,-1,-2,-1,1,2};int main(){    scanf(&quot;%lld&quot;,&amp;n);    printf(&quot;%d&quot;,a[(n+5)%6]);    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  BZOJ 3224 Tyvj 1728 普通平衡树 [Splay]【数据结构】</title>
      <link href="/2017/04/20/70304674/"/>
      <url>/2017/04/20/70304674/</url>
      
        <content type="html"><![CDATA[<h1 id="BZOJ-3224-Tyvj-1728-普通平衡树-Splay-【数据结构】"><a href="#BZOJ-3224-Tyvj-1728-普通平衡树-Splay-【数据结构】" class="headerlink" title="BZOJ 3224: Tyvj 1728 普通平衡树 [Splay]【数据结构】"></a>BZOJ 3224: Tyvj 1728 普通平衡树 [Splay]【数据结构】</h1><p>2017年04月20日 20:53:09  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：450</p><hr><p> 博客爬取于<code>2019-04-18 17:17:07</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/70304674" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/70304674</a></p><p>题目链接: <a href="http://www.lydsy.com/JudgeOnline/problem.php?id=3224" target="_blank" rel="noopener"> http://www.lydsy.com/JudgeOnline/problem.php?id=3224</a></p><p>————————————————————————————————————————————<br>3224: Tyvj 1728 普通平衡树</p><p>Time Limit: 10 Sec Memory Limit: 128 MB<br>Submit: 12058 Solved: 5154<br>[Submit][Status][Discuss]<br>Description</p><p>您需要写一种数据结构（可参考题目标题），来维护一些数，其中需要提供以下操作：<br>1. 插入x数<br>2. 删除x数(若有多个相同的数，因只删除一个)<br>3. 查询x数的排名(若有多个相同的数，因输出最小的排名)<br>4. 查询排名为x的数<br>5. 求x的前驱(前驱定义为小于x，且最大的数)<br>6. 求x的后继(后继定义为大于x，且最小的数)</p><p>Input</p><p>第一行为n，表示操作的个数,下面n行每行有两个数opt和x，opt表示操作的序号(1&lt;=opt&lt;=6)</p><p>Output</p><p>对于操作3,4,5,6每行输出一个数，表示对应答案</p><p>Sample Input</p><p>10<br>1 106465<br>4 1<br>1 317721<br>1 460929<br>1 644985<br>1 84185<br>1 89851<br>6 81968<br>1 492737<br>5 493598</p><p>Sample Output</p><p>106465<br>84185<br>492737</p><p>HINT</p><p>1.n的数据范围：n&lt;=100000</p><p>2.每个数的数据范围：[-2e9,2e9]<br>Source</p><p>平衡树</p><p>————————————————————————————————————————————</p><p>这两天不知怎地 一点思考能力都没有。 于是学了学Splay</p><p>其实Splay很好懂 只要知道平衡树的左旋和右旋操作，知道作用是吧一棵树做矮，就是不使它的某一条链变成。</p><p>本质还是一颗二叉树，只不过多了伸展的操作，也就是能通过左旋，右旋降低树高，保证某些操作总是在O(logn)的 不会变成O(n)。</p><p>—————————-update————————–<br>若干年过去了 终于我会写了SPLAY 补上一发自己的代码 放到上面了，，，</p><p>附模板<br>————————————————————————————————————</p><p>​<br>    /<strong><strong><strong><strong><strong><strong>**</strong></strong></strong></strong></strong></strong><br>    自己写的代码<br>    <strong><strong><strong><strong><strong><strong>**</strong></strong></strong></strong></strong></strong>/</p><pre><code>#include &lt;bits/stdc++.h&gt;typedef long long int LL;const int N = 200000+7;const int INF = (~(1&lt;&lt;31));inline int read(){    int x=0,f=1;char ch=getchar();    for(;ch&lt;&#39;0&#39;||&#39;9&#39;&lt;ch;ch=getchar())   if(ch==&#39;-&#39;)f=-1;    for(;&#39;0&#39;&lt;=ch&amp;&amp;ch&lt;=&#39;9&#39;;ch=getchar()) x=(x&lt;&lt;3)+(x&lt;&lt;1)+ch-&#39;0&#39;;    return x*f;}/*******************************************************//*************SPLAY-tree************/int n,m;int ch[N][2];  //ch[][0] lson ch[][1] rsonint f[N];      //fatherint sz[N];     //sizeint val[N];    //value of node_iint cnt[N];    // counts of the node_iint root;      //root of splay-treeint tot;       //tot,total,is the number of node of treevoid pushup(int x){    if(x)sz[x]=sz[ch[x][0]]+sz[ch[x][1]]+cnt[x];}void rotate(int x,int k){   // k = 0 左旋， k = 1 右旋    int y=f[x];int z=f[y];    ch[y][!k]=ch[x][k];if(ch[x][k])f[ch[x][k]]=y;    f[x]=z;if(z)ch[z][ch[z][1]==y]=x;    f[y]=x;ch[x][k]=y;    pushup(y),pushup(x);}void splay(int x,int goal){    for(int y=f[x];f[x]!=goal;y=f[x])        rotate(x,(ch[y][0]==x));    if(goal==0) root=x;}void newnode(int rt,int v,int fa){//    printf(&quot;newnode : rt =  %d\n&quot;,rt);    f[rt]=fa;val[rt]=v,sz[rt]=cnt[rt]=1;    ch[rt][0]=ch[rt][1]=0;}void delnode(int &amp;rt){ //其实是为内存回收做准备的  回头再完善    f[rt]=val[rt]=sz[rt]=cnt[rt]=0;    ch[rt][0]=ch[rt][1]=rt=0;}/***************************以下是DEBUG***************************/void Traversal(int rt){    if(!rt) return;    Traversal(ch[rt][0]);    printf(&quot;%d f[]=%d sz[]=%d lson=%d rson=%d val[]=%d\n&quot;,rt,f[rt],sz[rt],ch[rt][0],ch[rt][1],val[rt]);    Traversal(ch[rt][1]);}void debug(){    printf(&quot;ROOT = %d &lt;---\n&quot;,root);    Traversal(root);}/**************************以下是前置操作**************************///以x为根的子树 的极值点  0 极小 1 极大int extreme(int x,int k){    while(ch[x][k])x=ch[x][k];splay(x,0);    return x;}//以x为根的子树 第k个数的位置int kth(int x,int k){    if(sz[ch[x][0]]+1&lt;=k&amp;&amp;k&lt;=sz[ch[x][0]]+cnt[x]) return x;    else if(sz[ch[x][0]]&gt;=k) return kth(ch[x][0],k);    else return kth(ch[x][1],k-sz[ch[x][0]]-cnt[x]);}int search(int rt,int x){        if(ch[rt][0]&amp;&amp;val[rt]&gt;x) return search(ch[rt][0],x);    else if(ch[rt][1]&amp;&amp;val[rt]&lt;x)return search(ch[rt][1],x);    else return rt;}/***************************以下是正经操作*************************///前驱int prec(int x){    int k=search(root,x);    splay(k,0);//debug();    if(val[k]&lt;x) return k;    return extreme(ch[k][0],1);}//后继int sufc(int x){    int k=search(root,x);    splay(k,0);//debug();    if(val[k]&gt;x) return k;    return extreme(ch[k][1],0);}int rk(int x){    int k=search(root,x);    splay(k,0);    return sz[ch[root][0]]+1;}//按照二叉排序树性质插入xvoid _insert(int x){    int y=search(root,x),k=-1;    if(val[y]==x){        cnt[y]++;        sz[y]++;        for(int yy=y;yy;yy=f[yy]) pushup(yy);    }    else {        int p=prec(x),s=sufc(x);        splay(p,0);splay(s,p);        newnode(++tot,x,ch[root][1]);        ch[ch[root][1]][0]=tot;        for(int z=ch[root][1];z;z=f[z])pushup(z);    }    if(k==-1) splay(y,0);else splay(tot,0);}void _delete(int x){    int y=search(root,x);    if(val[y]!=x) return;    if(cnt[y]&gt;1){        cnt[y]--;        sz[y]--;        for(int yy=y;yy;yy=f[yy]) pushup(yy);    }    else if(ch[y][0]==0||ch[y][1]==0){        int z=f[y];        ch[z][ch[z][1]==y]=ch[y][ch[y][0]==0];        f[ch[y][ch[y][0]==0]]=z;delnode(y);        for(int yy=z;yy;yy=f[yy]) pushup(yy);    }    else {        int p=prec(x),s=sufc(x);        splay(p,0);splay(s,p);        ch[ch[root][1]][0]=0;        delnode(ch[ch[root][1]][0]);        for(int yy=s;yy;yy=f[yy]) pushup(yy);    }}/*****************************************************/int main(){    scanf(&quot;%d&quot;,&amp;n);    tot=0,root=1;    newnode(++tot,-INF,0),newnode(++tot,INF,root);    ch[root][1]=tot;    for(int op,x;n--;){        op=read(),x=read();             if(op==1) _insert(x);        else if(op==2) _delete(x);        else if(op==3) printf(&quot;%d\n&quot;,rk(x)-1);        else if(op==4) printf(&quot;%d\n&quot;,val[kth(root,x+1)]);        else if(op==5) printf(&quot;%d\n&quot;,val[prec(x)]);        else           printf(&quot;%d\n&quot;,val[sufc(x)]);    }    return 0;}</code></pre><p>​<br>    /<strong><strong><strong><strong><strong><strong>**</strong></strong></strong></strong></strong></strong><br>    当年套的模板代码<br>    <strong><strong><strong><strong><strong><strong>**</strong></strong></strong></strong></strong></strong>/</p><pre><code>#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 100000+7;int root,tot;int father[N],data[N],cnt[N],value[N];int son[N][3];inline void Rotate(int x,int w){    int y=father[x];    cnt[y]=cnt[y]-cnt[x]+cnt[son[x][w]];    cnt[x]=cnt[x]-cnt[son[x][w]]+cnt[y];    son[y][3-w]=son[x][w];    if(son[x][w]) father[son[x][w]]=y;    father[x]=father[y];    if(father[y]){        if(y==son[father[y]][1]) son[father[y]][1]=x;        else  son[father[y]][2]=x;    }    father[y]=x;    son[x][w]=y;}inline void splay(int x){    int y;    while(father[x]){        y=father[x];        if(!father[y]){            if(x==son[y][1]) Rotate(x,2);            else Rotate(x,1);        }        else{            if(y==son[father[y]][1]){                if(x==son[y][1]) Rotate(y,2),Rotate(x,2);                else             Rotate(x,1),Rotate(x,2);            }            else {                if(x==son[y][2]) Rotate(y,1),Rotate(x,1);                else             Rotate(x,2),Rotate(x,1);            }        }    }    root = x;    return ;}inline int Search(int x,int w){    while(data[x]!=w){        if(w==data[x]) return x;        if(w&lt;data[x]) {            if(!son[x][1]) break;            x = son[x][1];        }        else {            if(!son[x][2]) break;            x = son[x][2];        }    }    return x;}inline void Insert(int w){    int k,kk;bool flag;    if(!tot){        tot=1;        father[1]=0;cnt[1]=1;data[1]=w;root=1;value[1]=1;        return ;    }    k = Search(root,w);    if(data[k]==w){        value[k]++;kk=k;        flag = true;    }    else{        tot++;        data[tot]=w;        father[tot]=k;        cnt[tot]=1;        value[tot]=1;        if(data[k]&gt;w) son[k][1]=tot;        else          son[k][2]=tot;        flag = false;    }    while(k){        cnt[k]++;k=father[k];    }    if(flag) splay(kk);else splay(tot);}inline int Extreme(int x,int w){    const int lala[3]={0,2147483647,-2147483647};    int k=Search(x,lala[w]),tmp;    tmp = data[k];    splay(k);    return tmp;}inline void del(int x){    int k=Search(root,x),y;    splay(k);    if(data[k]==x){        if(value[k]&gt;1){            value[k]--;            cnt[k]--;        }        else if(!son[k][1]){                y=son[k][2];                son[k][2]=0;                cnt[k]=0;                data[k]=0;                value[k]=0;                root = y;                father[root]=0;        }        else {            father[son[k][1]]=0;            y=Extreme(son[k][1],1);            son[root][2]=son[k][2];            cnt[root]=cnt[root]+cnt[son[k][2]];            if(son[root][2])father[son[root][2]]=root;            data[k]=0;son[k][1];son[k][2]=0;            value[k]=0;        }    }}inline int pred(int x){    int k = Search(root,x);    splay(k);    if(data[k]&lt;x) return data[k];    return Extreme(son[k][1],1);}inline int succ(int x){    int k = Search(root,x);    splay(k);    if(data[k]&gt;x) return data[k];    return Extreme(son[k][2],2);}inline int kth(int x,int w){    int i=root,tmp;    while(!((x&gt;=cnt[son[i][w]]+1)&amp;&amp;(x&lt;=cnt[son[i][w]]+value[i]))&amp;&amp;i){        if(x&gt;cnt[son[i][w]]+value[i]){            x = x - cnt[son[i][w]]-value[i];            i = son[i][3-w];        }        else i = son[i][w];    }    tmp = i;splay(i);    return tmp;}inline int findnum(int x){    int k = Search(root,x);splay(k);    root = k;    return cnt[son[k][1]]+1;}int main(){    int n,op,x;    scanf(&quot;%d&quot;,&amp;n);    for(int i=1;i&lt;=n;i++){        scanf(&quot;%d%d&quot;,&amp;op,&amp;x);        if(1==op) Insert(x);        else if(2==op) del(x);        else if(3==op) printf(&quot;%d\n&quot;,findnum(x));        else if(4==op) printf(&quot;%d\n&quot;,data[kth(x,1)]);        else if(5==op) printf(&quot;%d\n&quot;,pred(x));        else if(6==op) printf(&quot;%d\n&quot;,succ(x));    }    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  BZOJ 2243 [SDOI2011]染色 [树链剖分+细节]【数据结构】</title>
      <link href="/2017/04/18/70232210/"/>
      <url>/2017/04/18/70232210/</url>
      
        <content type="html"><![CDATA[<h1 id="BZOJ-2243-SDOI2011-染色-树链剖分-细节-【数据结构】"><a href="#BZOJ-2243-SDOI2011-染色-树链剖分-细节-【数据结构】" class="headerlink" title="BZOJ 2243: [SDOI2011]染色 [树链剖分+细节]【数据结构】"></a>BZOJ 2243: [SDOI2011]染色 [树链剖分+细节]【数据结构】</h1><p>2017年04月18日 20:20:01  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：568</p><hr><p> 博客爬取于<code>2019-04-18 17:17:08</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/70232210" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/70232210</a></p><p>题目链接： <a href="http://www.lydsy.com/JudgeOnline/problem.php?id=2243" target="_blank" rel="noopener"> http://www.lydsy.com/JudgeOnline/problem.php?id=2243</a><br>————————————————————————————————————————————————<br>2243: [SDOI2011]染色</p><p>Time Limit: 20 Sec Memory Limit: 512 MB<br>Submit: 7492 Solved: 2803<br>[Submit][Status][Discuss]<br>Description</p><p>给定一棵有n个节点的无根树和m个操作，操作有2类：<br>1、将节点a到节点b路径上所有点都染成颜色c；<br>2、询问节点a到节点b路径上的颜色段数量（连续相同颜色被认为是同一段），如“112221”由3段组成：“11”、“222”和“1”。<br>请你写一个程序依次完成这m个操作。<br>Input</p><p>第一行包含2个整数n和m，分别表示节点数和操作数；<br>第二行包含n个正整数表示n个节点的初始颜色<br>下面 行每行包含两个整数x和y，表示x和y之间有一条无向边。<br>下面 行每行描述一个操作：<br>“C a b c”表示这是一个染色操作，把节点a到节点b路径上所有点（包括a和b）都染成颜色c；<br>“Q a b”表示这是一个询问操作，询问节点a到节点b（包括a和b）路径上的颜色段数量。<br>Output</p><p>对于每个询问操作，输出一行答案。<br>Sample Input</p><p>6 5<br>2 2 1 2 1 1<br>1 2<br>1 3<br>2 4<br>2 5<br>2 6<br>Q 3 5<br>C 2 1 1<br>Q 3 5<br>C 5 1 2<br>Q 3 5</p><p>Sample Output</p><p>3<br>1<br>2</p><p>HINT</p><p>数N&lt;=10^5，操作数M&lt;=10^5，所有的颜色C为整数且在[0, 10^9]之间。</p><p>Source</p><p>第一轮day1</p><p>————————————————————————————————————————————————</p><p>在树上两点间的路上进行修改 那么就是树链剖分，<br>根据操作 是区间染色 所以要用线段树维护</p><p>注意在维护的时候线段树上的每个点要多维护一个最左边和最右边的颜色。<br>方便合并的时候计算颜色个数</p><p>然后就是注意颜色可能为0<br>lazy标记的时候改成-1， 习惯性的用0 WA到死啊。</p><p>附本题代码</p><p>————————————————————————————————————————</p><p>​    </p><pre><code>#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 1e5+7;/***************************************/int n,m;int c[N];vector&lt;int &gt;G[N];int fa[N],sz[N],son[N],dep[N];int dfs1(int u,int f,int d){    fa[u]=f,sz[u]=1,son[u]=0,dep[u]=d;    int gz = G[u].size();    for(int to,i=0;i&lt;gz;i++){        to = G[u][i];        if(to==f) continue;        dfs1(to,u,d+1);        sz[u]+=sz[to];        if(sz[son[u]]&lt;sz[to]) son[u]=to;    }}int top[N],tree[N],pre[N],cnt;int dfs2(int u,int tp){    top[u]=tp,tree[u]=++cnt,pre[tree[u]]=u;    if(son[u]) dfs2(son[u],tp);    int gz = G[u].size();    for(int to,i=0;i&lt;gz;i++){        to = G[u][i];        if(to==fa[u]||to==son[u])continue;        dfs2(to,to);    }}int sum[N&lt;&lt;2],lazy[N&lt;&lt;2],lc[N&lt;&lt;2],rc[N&lt;&lt;2];void pushup(int rt){    sum[rt] = sum[rt&lt;&lt;1]+sum[rt&lt;&lt;1|1]-(rc[rt&lt;&lt;1] == lc[rt&lt;&lt;1|1]);    lc[rt]=lc[rt&lt;&lt;1],rc[rt]=rc[rt&lt;&lt;1|1];}void pushdown(int rt){    if(lazy[rt]!=-1){        lazy[rt&lt;&lt;1] = lazy[rt&lt;&lt;1|1] = lazy[rt];        sum [rt&lt;&lt;1] = sum [rt&lt;&lt;1|1] = 1;        lc[rt&lt;&lt;1]   = rc[rt&lt;&lt;1]   = lazy[rt];        lc[rt&lt;&lt;1|1] = rc[rt&lt;&lt;1|1] = lazy[rt];        lazy[rt]=-1;    }}void build(int rt,int l,int r){    if(l==r){        sum[rt]=1,rc[rt]=lc[rt]=c[pre[l]];        return ;    }    int m = (r+l)&gt;&gt;1;    build(rt&lt;&lt;1  ,l  ,m);    build(rt&lt;&lt;1|1,m+1,r);    pushup(rt);}void update(int rt,int l,int r,int L,int R,int clr){    if(L&lt;=l&amp;&amp;r&lt;=R){        rc[rt]=lc[rt]=lazy[rt]=clr;        sum[rt] = 1;        return ;    }    pushdown(rt);    int m = (r+l)&gt;&gt;1;    if(L&lt;=m) update(rt&lt;&lt;1  ,l  ,m,L,R,clr);    if(R&gt; m) update(rt&lt;&lt;1|1,m+1,r,L,R,clr);    pushup(rt);    return ;}int query(int rt,int l,int r,int L,int R){    if(L&gt;R) return 0;    if(L&lt;=l&amp;&amp;r&lt;=R) return sum[rt];    pushdown(rt);    int ans = 0,m = (r+l)&gt;&gt;1;    if(R&lt;=m)      ans = query(rt&lt;&lt;1  ,l,  m,L,R);    else if(L&gt;m)  ans = query(rt&lt;&lt;1|1,m+1,r,L,R);    else          ans = query(rt&lt;&lt;1  ,l,  m,L,R)+                        query(rt&lt;&lt;1|1,m+1,r,L,R)-                        (rc[rt&lt;&lt;1]==lc[rt&lt;&lt;1|1]);    pushup(rt);    return ans;}int query_color(int rt,int l,int r,int pos){    if(l==r)  return lc[rt];    pushdown(rt);    int m = (r+l)&gt;&gt;1,ans;    if(pos&lt;=m) ans = query_color(rt&lt;&lt;1  ,l  ,m,pos);    else       ans = query_color(rt&lt;&lt;1|1,m+1,r,pos);    pushup(rt);    return ans;}void init(){    cnt = 0;    for(int i=1;i&lt;=n;i++)G[i].clear();    memset(sum,0,sizeof(sum));    memset(lazy,-1,sizeof(lazy));};void brush(int x,int y,int clr){    int fx = top[x],fy = top[y];    while(fx!=fy){        if(dep[fx]&lt;dep[fy]) swap(fx,fy),swap(x,y);        update(1,1,n,tree[fx],tree[x],clr);        x = fa[fx],fx = top[x];    }    if(tree[x]&gt;tree[y]) swap(x,y);    update(1,1,n,tree[x],tree[y],clr);    return ;}void solve(int x,int y){    int fx = top[x],fy = top[y];    int ans = 0;    while(fx!=fy){        if(dep[fx]&lt;dep[fy]) swap(fx,fy),swap(x,y);        ans += query(1,1,n,tree[fx],tree[x]);        if(query_color(1,1,n,tree[fa[fx]]) == query_color(1,1,n,tree[fx])) ans--;        x = fa[fx],fx = top[x];    }    if(tree[x]&gt;tree[y]) swap(x,y);    ans += query(1,1,n,tree[x],tree[y]);    printf(&quot;%d\n&quot;,ans);    return ;}int main(){    while(~scanf(&quot;%d%d&quot;,&amp;n,&amp;m)){        init();        for(int i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;c[i]);        for(int i=2,u,v;i&lt;=n;i++){            scanf(&quot;%d %d&quot;,&amp;u,&amp;v);            G[u].push_back(v);            G[v].push_back(u);        }        dfs1(1,-1,1);        dfs2(1,1);        build(1,1,n);        int l,r,x;        char a[10];        while(m--){            scanf(&quot;%s&quot;,a);            scanf(&quot;%d %d&quot;,&amp;l,&amp;r);            if(a[0]==&#39;C&#39;){                scanf(&quot;%d&quot;,&amp;x);                brush(l,r,x);            }            else  solve(l,r);        }    }    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  Codeforces Round</title>
      <link href="/2017/04/18/70227611/"/>
      <url>/2017/04/18/70227611/</url>
      
        <content type="html"><![CDATA[<h1 id="Codeforces-Round-409-div2-【A-D√-E待补】"><a href="#Codeforces-Round-409-div2-【A-D√-E待补】" class="headerlink" title="Codeforces Round #409 div2 【A~D√ E待补】"></a>Codeforces Round #409 div2 【A~D√ E待补】</h1><p>2017年04月18日 13:59:30  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：406<br>标签：  <a href="https://so.csdn.net/so/search/s.do?q=codeforces&amp;t=blog" target="_blank" rel="noopener"> codeforces </a></p><p>个人分类：  <a href="https://blog.csdn.net/qq_33184171/article/category/6822765" target="_blank" rel="noopener"> 套题 </a></p><hr><p> 博客爬取于<code>2019-04-18 17:17:09</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/70227611" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/70227611</a></p><h2 id="A-Vicious-Keyboard"><a href="#A-Vicious-Keyboard" class="headerlink" title=" A Vicious Keyboard "></a><a href="http://codeforces.com/contest/801/problem/A" target="_blank" rel="noopener"> A Vicious Keyboard </a></h2><p>————————————————————————————————————————————<br>数据量很小<br>直接暴力枚举所有情况 维护个最大值过去就行了</p><h2 id="B-Valued-Keys"><a href="#B-Valued-Keys" class="headerlink" title=" B Valued Keys "></a><a href="http://codeforces.com/contest/801/problem/B" target="_blank" rel="noopener"> B Valued Keys </a></h2><p>————————————————————————————————————————————<br>开始读错题了<br>正确的题意应该是L<br>现在有f（s1,s2） = s3 ,s3是s1，s2两个字符串对应位置上值小的字母组成的新字符串<br>现在给你s1，s3 问你有没有满足的s2 有的话输出一个，没有输出=1</p><p>所以就判断有没有s1上的字母小于s3上的字母的情况就行了 有的话就是-1<br>不然直接出书s3就行了</p><h2 id="C-Voltage-Keepsake"><a href="#C-Voltage-Keepsake" class="headerlink" title=" C Voltage Keepsake "></a><a href="http://codeforces.com/contest/801/problem/C" target="_blank" rel="noopener"> C Voltage Keepsake </a></h2><p>————————————————————————————————————————————<br>就是有一堆机器，每个机器每秒需要消耗a能量，最开始有b能量，现在有一个充电器，每秒能充p点能量，<br>问你我这些机器到第一个能量值为0的情况的最长时间是多少。（实数范畴内）</p><p>很明显如果  ∑  n  i  =  1  a  ≤  p  的时候能无限的使用下去</p><p>对于其他情况,很容易想到二分答案,</p><h2 id="D-Volatile-Kite"><a href="#D-Volatile-Kite" class="headerlink" title=" D Volatile Kite "></a><a href="http://codeforces.com/contest/801/problem/D" target="_blank" rel="noopener"> D Volatile Kite </a></h2><p>————————————————————————————————————————————</p><p>给你一个凸包,让你找一个最大的可移动距离 ,使得所有点都任意的在这个最大距离内移动后还是一个凸包,</p><p>很显然 对于一个图形是不是凸包这要考虑三个点有没有凹的情况就可以了.</p><p>那么就枚举每个点的情况 然后维护最小值就好了.</p><p>对于每个点的时候 我们考虑与其相邻的两个点,</p><p>那么这时候最大的情况就是这3个点在一条直线上的时候</p><p><img src="https://img-blog.csdn.net/20170418135837747?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzMxODQxNzE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>三个园的半径就是我们所求的最大范围, 转换过来就是高的一半</p><h2 id="E-Vulnerable-Kerbals"><a href="#E-Vulnerable-Kerbals" class="headerlink" title=" E Vulnerable Kerbals "></a><a href="http://codeforces.com/contest/801/problem/E" target="_blank" rel="noopener"> E Vulnerable Kerbals </a></h2><p>————————————————————————————————————————————</p><p>还不会 待补</p>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> codeforces </tag>
            
            <tag> 套题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  hdu 1520 Anniversary party [树形dp入门]【动态规划】</title>
      <link href="/2017/03/29/68234083/"/>
      <url>/2017/03/29/68234083/</url>
      
        <content type="html"><![CDATA[<h1 id="hdu-1520-Anniversary-party-树形dp入门-【动态规划】"><a href="#hdu-1520-Anniversary-party-树形dp入门-【动态规划】" class="headerlink" title="hdu 1520 Anniversary party [树形dp入门]【动态规划】"></a>hdu 1520 Anniversary party [树形dp入门]【动态规划】</h1><p>2017年03月29日 23:29:07  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：208<br>标签：  <a href="https://so.csdn.net/so/search/s.do?q=动态规划&amp;t=blog" target="_blank" rel="noopener"> 动态规划 </a> <a href="https://so.csdn.net/so/search/s.do?q=dp&amp;t=blog" target="_blank" rel="noopener"> dp</a></p><p>个人分类：  <a href="https://blog.csdn.net/qq_33184171/article/category/6117382" target="_blank" rel="noopener"> hdu </a> <a href="https://blog.csdn.net/qq_33184171/article/category/6362438" target="_blank" rel="noopener"><br>==== 动态规划 ==== </a></p><hr><p> 博客爬取于<code>2019-04-18 17:17:10</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/68234083" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/68234083</a></p><p>题目链接： <a href="http://acm.split.hdu.edu.cn/showproblem.php?pid=1520" target="_blank" rel="noopener"> http://acm.split.hdu.edu.cn/showproblem.php?pid=1520</a><br>————————————————————————————————————————————</p><p>Anniversary party</p><p>Time Limit: 2000/1000 MS (Java/Others) Memory Limit: 65536/32768 K<br>(Java/Others)<br>Total Submission(s): 10549 Accepted Submission(s): 4415</p><p>Problem Description<br>There is going to be a party to celebrate the 80-th Anniversary of the Ural<br>State University. The University has a hierarchical structure of employees. It<br>means that the supervisor relation forms a tree rooted at the rector V. E.<br>Tretyakov. In order to make the party funny for every one, the rector does not<br>want both an employee and his or her immediate supervisor to be present. The<br>personnel office has evaluated conviviality of each employee, so everyone has<br>some number (rating) attached to him or her. Your task is to make a list of<br>guests with the maximal possible sum of guests’ conviviality ratings.</p><p>Input<br>Employees are numbered from 1 to N. A first line of input contains a number N.<br>1 &lt;= N &lt;= 6 000. Each of the subsequent N lines contains the conviviality<br>rating of the corresponding employee. Conviviality rating is an integer number<br>in a range from -128 to 127. After that go T lines that describe a supervisor<br>relation tree. Each line of the tree specification has the form:<br>L K<br>It means that the K-th employee is an immediate supervisor of the L-th<br>employee. Input is ended with the line<br>0 0</p><p>Output<br>Output should contain the maximal sum of guests’ ratings.</p><p>Sample Input<br>7<br>1<br>1<br>1<br>1<br>1<br>1<br>1<br>1 3<br>2 3<br>6 4<br>7 4<br>4 5<br>3 5<br>0 0</p><p>Sample Output<br>5<br>————————————————————————————————————————————<br>题意:<br>一个树,每个节点有一个权值,这些节点不能拿挨着的,<br>一些节点会获得他们的权值,问你最大的权值和是多少</p><p>解题思路:</p><p>树形dp的入门题目</p><p>很容易想,<br>dp[N][2]<br>其中dp[u][0],代表 <strong> 不选节点u </strong> 的最大权值和 ,<br>dp[u][1]代表 <strong> 选节点u </strong> 的最大权值和 ,</p><p>转移就是<br>dp[fa][0]=max(dp[u][0],dp[u][1])<br>dp[fa][1]=dp[u][0];<br>很好想.</p><p>附本题代码<br>————————————————————————————————————————————</p><pre><code>#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long int LL;#define lowbit(x) (x&amp;-x)#define abs(x) ((x)&gt;0?(x):-(x))const int N = 10000+10;vector&lt;int &gt;G[N];void add(int u,int v){    G[u].push_back(v);    G[v].push_back(u);}int dp[N][2],w[N],n;void dfs(int u,int fa){    dp[u][1]=w[u];    dp[u][0]=0;    int gz=G[u].size();    for(int i=0,to;i&lt;gz;i++){        to = G[u][i];        if(to==fa) continue;        dfs(to,u);        dp[u][0]+=max(dp[to][1],dp[to][0]);        dp[u][1]+=dp[to][0];    }}void init(){    for(int i=0;i&lt;=n;i++)        G[i].clear();}int main(){    while(~scanf(&quot;%d&quot;,&amp;n)&amp;&amp;n){        init();        for(int i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;w[i]);        for(int u,v;true;){            scanf(&quot;%d%d&quot;,&amp;u,&amp;v);            if(u==v&amp;&amp;0==v) break;            add(u,v);        }        dfs(1,0);        printf(&quot;%d\n&quot;,max(dp[1][1],dp[1][0]));    }    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hdu </tag>
            
            <tag> 动态规划 </tag>
            
            <tag> dp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  2015年百度之星程序设计大赛 - 初赛(1) 【解题报告】【未完待续】</title>
      <link href="/2017/03/29/68083224/"/>
      <url>/2017/03/29/68083224/</url>
      
        <content type="html"><![CDATA[<h1 id="2015年百度之星程序设计大赛-初赛-1-【解题报告】【未完待续】"><a href="#2015年百度之星程序设计大赛-初赛-1-【解题报告】【未完待续】" class="headerlink" title="2015年百度之星程序设计大赛 - 初赛(1) 【解题报告】【未完待续】"></a>2015年百度之星程序设计大赛 - 初赛(1) 【解题报告】【未完待续】</h1><p>2017年03月29日 20:35:11  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：1001</p><hr><p> 博客爬取于<code>2019-04-18 17:17:11</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/68083224" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/68083224</a></p><p>总结一波 ：<br>还是读题不清，中文题关键部分读错，导致最终GG，<br>计算几何薄弱，模板匮乏。</p><h1 id="超级赛亚ACMer"><a href="#超级赛亚ACMer" class="headerlink" title="超级赛亚ACMer"></a>超级赛亚ACMer</h1><p>虽然题目说打完一次k–,但是没有限定顺序 所以这个限制可以忽略不计</p><p>然后说正常怎么来,<br>先从小到大排序一遍,然后每一次遇到与其相等的就升级战斗力.<br>为了确保我下一次还能升级战斗力,我就变成比当前战斗力+k小的最大的那个战斗力就行了,<br>然后扫一遍即可,</p><p>(当时以为遇到相等的不能赢.wa一发…</p><pre><code>#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long int LL;#define lowbit(x) (x&amp;-x)#define abs(x) ((x)&gt;0?(x):-(x))const int N = 10000+7;LL n,m,k,mx;LL a[N];LL mylb(LL x){    LL l=1,r=n,mid,ans=0;    while(l&lt;=r){        mid = (l+r)&gt;&gt;1;        if(a[mid]&lt;=x)            l = mid + 1,ans = mid;        else r = mid - 1;    }    return ans ;}int main(){    int _,kcase = 0;    scanf(&quot;%d&quot;,&amp;_);    while(_--){        a[0]=0;mx = 0;        scanf(&quot;%I64d%I64d%I64d&quot;,&amp;n,&amp;m,&amp;k);        for(int i=1;i&lt;=n;i++){            scanf(&quot;%I64d&quot;,&amp;a[i]);            if(a[i]&lt;=m){                mx = (mx&gt;a[i])?mx:a[i];            }        }        m = mx;        sort(a+1,a+n+1);//        for(int i=1;i&lt;=n;i++)     printf(&quot;%I64d%c&quot;,a[i],(i==n)?&#39;\n&#39;:&#39; &#39; );        int sum = 0;        for(int i=1;i&lt;=n;i++){            if(m&gt;=a[i]) sum++;            else break;            if(a[i]==m&amp;&amp;k) m=a[mylb(m+k)],k--;//            printf(&quot;%I64d%c&quot;,m,(i==n)?&#39;\n&#39;:&#39; &#39; );        }//        printf(&quot;%d\n&quot;,sum);        printf(&quot;Case #%d:\n&quot;,++kcase);        if(sum==n) puts(&quot;why am I so diao?&quot;);        else       puts(&quot;madan!&quot;);    }    return 0;}</code></pre><h1 id="找连续数"><a href="#找连续数" class="headerlink" title="找连续数"></a>找连续数</h1><p>这个题还是很简单的<br>我们要找一个长度为k的区间使得其中元素升序后连续,<br>那么也就说明了这个区间是没有重复元素的,<br>那么确保了区间内没有相同元素的后<br>其实也就是找这个区间的最大值和最小值的差是不是等于k-1 ,</p><p>确定区间有没有相同元素,可以预处理出每个位置的数出现过的在前面的最近位置,</p><p>然后计算的时候我们可以枚举右界,<br>根据预处理相同元素的位置,能够维护左界,<br>因为元素没有变化,所以最大最小值可以用ST表预处理出来<br>一次O(n)就能统计了</p><pre><code>#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long int LL;#define lowbit(x) (x&amp;-x)#define abs(x) ((x)&gt;0?(x):-(x))const int N = 100000+7;LL a[N];LL mx[N][20],mi[N][20];int mm[N];int n,m,x;void initrmq(){    mm[0]=-1;    for(int i=1;i&lt;=n;i++){        mm[i]=((i&amp;(i-1))==0)?mm[i-1]+1:mm[i-1];        mi[i][0]=mx[i][0]=a[i];    }    for(int j=1;j&lt;=mm[n];j++)        for(int i=1;i+(1&lt;&lt;j)-1&lt;=n;i++){            mi[i][j]=min(mi[i][j-1],mi[i+(1&lt;&lt;(j-1))][j-1]);            mx[i][j]=max(mx[i][j-1],mx[i+(1&lt;&lt;(j-1))][j-1]);        }}LL rmqmi(int x,int y){    int k=mm[y-x+1];    return min(mi[x][k],mi[y-(1&lt;&lt;k)+1][k]);}LL rmqmx(int x,int y){    int k=mm[y-x+1];    return max(mx[x][k],mx[y-(1&lt;&lt;k)+1][k]);}map&lt;LL,int&gt;mmp;int pre[N];int main(){    mmp.clear();    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);    for(int i=1;i&lt;=n;i++){        pre[i]=0;        scanf(&quot;%I64d&quot;,&amp;a[i]);        pre[i]=mmp[a[i]];        mmp[a[i]]=i;    }    initrmq();    puts(&quot;Case #1:&quot;);    while(m--){        scanf(&quot;%d&quot;,&amp;x);        int sum = 0,l = 0;        for(int i=1;i&lt;=n;i++){            l=max(l,pre[i]);            if(i-l&gt;=x){                if(rmqmx(i-x+1,i)-rmqmi(i-x+1,i)+1==1ll*x)                    sum++;            }        }        printf(&quot;%d\n&quot;,sum);    }    return 0;}</code></pre><h1 id="序列变换"><a href="#序列变换" class="headerlink" title="序列变换"></a>序列变换</h1><p>这个题也很水,</p><p>如果直接进行求解 很困难,那么反过来想想,如果知道了一个数 来判断可不可行是不是非常好做了呢,<br>显然是的 ,<br>左边的尽量让他小就行了,</p><p>我们考虑如果花费为  x  时能满足题意,那么  [  x  ,  +  ∞  )  都是满足的</p><p>所以我们可以二分来做就好了</p><p>(最开始把所求看成了  c  o  s  t  (  A  ,  B  )  =  ∑  n  i  =  1  m  a  x  (  |  A  i<br>−  B  i  |  )  。  mabi</p><pre><code>#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long int LL;#define lowbit(x) (x&amp;-x)#define abs(x) ((x)&gt;0?(x):-(x))const int N = 100000+7;int a[N],b[N],n;bool check(int x){    for(int i=1;i&lt;=n;i++) b[i]=a[i];    b[1]-=x;    for(int i=2;i&lt;=n;i++){        if(b[i-1]+1&lt;=b[i]+x) b[i]=max(b[i-1]+1,b[i]-x);        else return false;    }    for(int i=2;i&lt;=n;i++)        if(b[i-1]&gt;=b[i]) return false;//    for(int i=1;i&lt;=n;i++) printf(&quot;%d &quot;,b[i]); puts(&quot;&quot;);    return true;}int main(){    int _,kcase = 0;    scanf(&quot;%d&quot;,&amp;_);    while(_--){        scanf(&quot;%d&quot;,&amp;n);        for(int i=1;i&lt;=n;i++)   scanf(&quot;%d&quot;,&amp;a[i]);        int l=0,r=10000000,mid,ans;        while(l&lt;=r){            mid = (r+l)&gt;&gt;1;//            printf(&quot;%d &lt;--\n&quot;,mid);            if(check(mid))                ans=mid,r=mid-1;            else l = mid+1;        }        printf(&quot;Case #%d:\n&quot;,++kcase);        printf(&quot;%d\n&quot;,ans);    }    return 0;}</code></pre><h1 id="KPI"><a href="#KPI" class="headerlink" title="KPI"></a>KPI</h1><p>这题就是一个模拟,我这里是 <strong> 离线+二分+树状数组 </strong> 做的时间复杂度是  O  (  n  log  2  2  n  )</p><p>首先离线出来每个数,按照题意的顺序操作,但是每次都是插入到树状数组中,这样我就能用  O  (  log  2  2  n  )<br>的复杂度来处理查询操作了,对于其他操作,我先拿一个数组来存每次的操作元素是谁,那么也可以  O  (  log  2  n  )  处理了</p><pre><code>#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long int LL;#define lowbit(x) (x&amp;-x)#define abs(x) ((x)&gt;0?(x):-(x))const int N = 100000+7;int op[N];int b[N],c[N],m;int x,n,k;char a[20];int sum[N];void update(int i,int v){    for(;i&lt;=m;i+=lowbit(i)) sum[i]+=v;}int getSum(int i){    int ans=0;    for(;i;i-=lowbit(i)) ans+=sum[i];    return ans ;}int mylb(int x){    int l=1,r=m,mid,ans;    while(l&lt;=r){        mid = (r+l)&gt;&gt;1;        if(getSum(mid)&gt;=x)            ans=mid,r=mid-1;        else l=mid+1;    }    return ans ;}int mybs(int x){    int l=1,r=m,mid,ans;    while(l&lt;=r){        mid = (r+l)&gt;&gt;1;        if(b[mid]&gt;=x)            ans = mid,r=mid-1;        else l=mid+1;    }    return ans ;}void init(){    memset(sum,0,sizeof(sum));    m=0,k=0;}int main(){    int kcase = 0;    while(~scanf(&quot;%d&quot;,&amp;n)){        init();        for(int i=1;i&lt;=n;i++){            scanf(&quot;%s&quot;,a);            if(a[0]==&#39;i&#39;){                op[i]=1;                scanf(&quot;%d&quot;,&amp;x);                b[++m]=x;            }            else if(a[0]==&#39;q&#39;){                op[i]=2;            }            else if(a[0]==&#39;o&#39;){                op[i]=(++k)*10+3;            }        }        printf(&quot;Case #%d:\n&quot;,++kcase);//        for(int i=1;i&lt;=n;i++){//            printf(&quot;%d &lt;--\n&quot;,op[i]);//        }        for(int i=1;i&lt;=m;i++) c[i]=b[i];        sort(b+1,b+m+1);//        m = unique(b+1,b+m+1)-(b+1);        int sum = 0,num = 0;        for(int i=1;i&lt;=n;i++){            if(op[i]==1){                sum++;num++;                update(mybs(c[num]),1);                continue;            }            else if(op[i]==2){                printf(&quot;%d\n&quot;,b[mylb(sum/2+1)]);                continue;            }            op[i]/=10;            update(mybs(c[op[i]]),-1);sum--;        }    }    return 0;}</code></pre><h1 id="三阶魔方"><a href="#三阶魔方" class="headerlink" title="三阶魔方"></a>三阶魔方</h1><p>不会玩魔方啊 不会做….(这两点可能惯性并不是很大,,,,)</p><h1 id="矩形面积"><a href="#矩形面积" class="headerlink" title="矩形面积"></a>矩形面积</h1><p>这题很明显的是要对所有的矩形求凸包,然后求最小面积的矩形覆盖,旋转卡壳可过,</p><p><a href="http://blog.csdn.net/pi9nc/article/details/11715227" target="_blank" rel="noopener"> 旋转卡壳应用很详细的介绍 </a></p><p>贴上模板就行了.</p><pre><code>#include &lt;map&gt;  #include &lt;set&gt;  #include &lt;vector&gt;  #include &lt;math.h&gt;  #include &lt;string&gt;  #include &lt;stdio.h&gt;  #include &lt;stdlib.h&gt;  #include &lt;string.h&gt;  #include &lt;iostream&gt;  #include &lt;algorithm&gt;  #include &lt;functional&gt;  using namespace std;  const int MAXN=1005;  const double eps=1e-10;  int dcmp(double x){      if(fabs(x)&lt;eps)return 0;      if(x&gt;0)return 1;      return -1;  }                                                   //弄精度  struct Point {      double x,y;  }p[MAXN];                                           //搞点  double dot(Point a,Point b,Point c){      double s1=b.x-a.x;      double t1=b.y-a.y;      double s2=c.x-a.x;      double t2=c.y-a.y;      return s1*s2+t1*t2;  }                                                     //点积  int n,res[MAXN],top;  bool cmp(Point a,Point b){      if(a.y==b.y)return a.x&lt;b.x;      return a.y&lt;b.y;  }  bool mult(Point sp,Point ep,Point op){      return (sp.x-op.x)*(ep.y-op.y)&gt;=(ep.x-op.x)*(sp.y-op.y);  }  void Graham(){      int len;      top=1;      sort(p,p+n,cmp);      if(n==0)return;res[0]=0;      if(n==1)return;res[1]=1;      if(n==2)return;res[2]=2;      for(int i=2;i&lt;n;i++){          while(top&amp;&amp;mult(p[i],p[res[top]],p[res[top-1]]))top--;          res[++top]=i;      }      len=top;      res[++top]=n-2;      for(int i=n-3;i&gt;=0;i--){          while(top!=len&amp;&amp;mult(p[i],p[res[top]],p[res[top-1]]))top--;          res[++top]=i;      }  }                                                               //求凸包  double dist(Point a,Point b){      return sqrt((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y));  }  double Cross(Point a,Point b,Point c){      return (c.x-a.x)*(b.y-a.y) - (b.x-a.x)*(c.y-a.y);  }  double ComGeo(){      int R=1,U=1,L;      double ans=99999999999999;      for(int i=0;i&lt;top;i++){          while(dcmp(fabs(Cross(p[res[i]],p[res[(i+1)%top]],p[res[(U+1)%top]]))-fabs(Cross(p[res[i]],p[res[(i+1)%top]],p[res[U]])))&gt;=0) U=(U+1)%top;//最上面一点          while(dcmp(dot(p[res[i]],p[res[(i+1)%top]],p[res[(R+1)%top]])-dot(p[res[i]],p[res[(i+1)%top]],p[res[R]]))&gt;0) R=(R+1)%top;//最右一点          if(i==0)L=R;          while(dcmp(dot(p[res[i]],p[res[(i+1)%top]],p[res[(L+1)%top]])-dot(p[res[i]],p[res[(i+1)%top]],p[res[L]]))&lt;=0) L=((L+1)%top)%top;//最左一点          //旋转卡壳精髓所在          double d=dist(p[res[i]],p[res[(i+1)%top]])*dist(p[res[i]],p[res[(i+1)%top]]);          double area=fabs(Cross(p[res[i]],p[res[(i+1)%top]],p[res[U]]))*//求面积          fabs(dot(p[res[i]],p[res[(i+1)%top]],p[res[R]])-dot(p[res[i]],p[res[(i+1)%top]],p[res[L]]))/d;          if(area&lt;ans) ans = area;      }      return ans;  }                                               //旋转卡壳  int main()  {      int t;      scanf(&quot;%d&quot;,&amp;t);      int k=1;      while(t--){          int m;          scanf(&quot;%d&quot;,&amp;m);          n=0;          double x;          for(int i=0;i&lt;m;i++){              for(int j=1;j&lt;=8;j++){                  scanf(&quot;%lf&quot;,&amp;x);                  if(j&amp;1)p[n].x=x;                  else p[n++].y=x;              }          }          Graham();          double ans;          if(top&lt;3)ans=0;          else          ans=ComGeo();          long long sum=ans+0.5;   //进1法 因为要覆盖上 所以不能四舍五入        printf(&quot;Case #%d:\n%I64d\n&quot;,k++,sum);        }      return 0;  }  </code></pre>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  POJ 2187 Beauty Contest [旋转卡壳]【计算几何】</title>
      <link href="/2017/03/29/68070650/"/>
      <url>/2017/03/29/68070650/</url>
      
        <content type="html"><![CDATA[<h1 id="POJ-2187-Beauty-Contest-旋转卡壳-【计算几何】"><a href="#POJ-2187-Beauty-Contest-旋转卡壳-【计算几何】" class="headerlink" title="POJ 2187 Beauty Contest [旋转卡壳]【计算几何】"></a>POJ 2187 Beauty Contest [旋转卡壳]【计算几何】</h1><p>2017年03月29日 19:57:49  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：358</p><hr><p> 博客爬取于<code>2019-04-18 17:17:12</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/68070650" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/68070650</a></p><p>题目链接： <a href="http://poj.org/problem?id=2187" target="_blank" rel="noopener"> http://poj.org/problem?id=2187 </a><br>————————————————————————————————————————————<br>Beauty Contest<br>Time Limit: 3000MS Memory Limit: 65536K<br>Total Submissions: 36877 Accepted: 11417<br>Description</p><p>Bessie, Farmer John’s prize cow, has just won first place in a bovine beauty<br>contest, earning the title ‘Miss Cow World’. As a result, Bessie will make a<br>tour of N (2 &lt;= N &lt;= 50,000) farms around the world in order to spread<br>goodwill between farmers and their cows. For simplicity, the world will be<br>represented as a two-dimensional plane, where each farm is located at a pair<br>of integer coordinates (x,y), each having a value in the range -10,000 …<br>10,000. No two farms share the same pair of coordinates.</p><p>Even though Bessie travels directly in a straight line between pairs of farms,<br>the distance between some farms can be quite large, so she wants to bring a<br>suitcase full of hay with her so she has enough food to eat on each leg of her<br>journey. Since Bessie refills her suitcase at every farm she visits, she wants<br>to determine the maximum possible distance she might need to travel so she<br>knows the size of suitcase she must bring.Help Bessie by computing the maximum<br>distance among all pairs of farms.</p><p>Input</p><ul><li><p>Line 1: A single integer, N </p></li><li><p>Lines 2..N+1: Two space-separated integers x and y specifying coordinate of each farm<br>Output</p></li><li><p>Line 1: A single integer that is the squared distance between the pair of farms that are farthest apart from each other.<br>Sample Input</p></li></ul><p>4<br>0 0<br>0 1<br>1 1<br>1 0<br>Sample Output</p><p>2<br>Hint</p><p>Farm 1 (0, 0) and farm 3 (1, 1) have the longest distance (square root of 2)</p><p>————————————————————————————————————————————</p><p>没啥说的就是一个旋转卡壳,算是留个模板</p><p>————————————————————————————————————————————</p><pre><code>#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=100000+10;int N,top;struct node{    int x,y;}p[maxn],point,stack[maxn];int get_cross(node a,node b,node c){    return (b.x-a.x)*(c.y-a.y)-(b.y-a.y)*(c.x-a.x);}int get_dis(node a,node b){    return (a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y);}void find_point(){    int col=0; point=p[0];    for(int i=1;i&lt;N;i++){        if(p[i].y&lt;point.y || (p[i].y==point.y &amp;&amp; p[i].x&lt;point.x)){            col=i; point=p[i];        }    }    swap(p[0],p[col]);}bool cmp(node a,node b){//we sort these points as the clockwise.    int t=get_cross(point,a,b);    if(t&lt;0)return true;    if(t&gt;0)return false;    int xx=get_dis(point,a),yy=get_dis(point,b);    return xx&lt;yy;}void Graham(){    top=1; p[N]=p[0];    stack[0]=p[0]; stack[1]=p[1];    for(int i=2;i&lt;N;i++){//it rotates as the clockwise.        while(top&gt;=1 &amp;&amp; get_cross(stack[top-1],stack[top],p[i])&gt;=0)top--;        stack[++top]=p[i];    }}void rotating_colipers(){    int ans=0,x=2; stack[top+1]=stack[0];    for(int i=1;i&lt;=top;i++){        while(get_cross(stack[x+1],stack[i+1],stack[i])&gt;get_cross(stack[x],stack[i+1],stack[i])){            x=(x+1)%(top+1);        }        ans=max(ans,get_dis(stack[x],stack[i]));        ans=max(ans,get_dis(stack[x],stack[i+1]));        ans=max(ans,get_dis(stack[x+1],stack[i+1]));        ans=max(ans,get_dis(stack[x+1],stack[i]));    }    printf(&quot;%d&quot;,ans);}int main(){    scanf(&quot;%d&quot;, &amp;N);    for(int i=0;i&lt;N;i++){        scanf(&quot;%d%d&quot;,&amp;p[i].x, &amp;p[i].y);    }    if(N==2)printf(&quot;%d&quot;,get_dis(p[0],p[1]));    else{        find_point();        sort(p+1,p+N,cmp);        Graham();        rotating_colipers();    }    puts(&quot;&quot;);    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  Codeforces Round</title>
      <link href="/2017/03/27/66652353/"/>
      <url>/2017/03/27/66652353/</url>
      
        <content type="html"><![CDATA[<h1 id="Codeforces-Round-401-Div-2-【结题报告】"><a href="#Codeforces-Round-401-Div-2-【结题报告】" class="headerlink" title="Codeforces Round #401 (Div. 2) 【结题报告】"></a>Codeforces Round #401 (Div. 2) 【结题报告】</h1><p>2017年03月27日 00:47:49  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：278</p><hr><p> 博客爬取于<code>2019-04-18 17:17:13</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/66652353" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/66652353</a></p><p>总结下，<br>看题慢，读错题，代码能力渣，思维不敏捷，菜的一逼。</p><h1 id="Shell-Game"><a href="#Shell-Game" class="headerlink" title="Shell Game"></a>Shell Game</h1><p>————————————————————————————————————————————</p><p>傻逼题，，<br>明确题意<br>枚举下所有情况 就能AC了。。</p><pre><code>int main(){    int n,x;    scanf(&quot;%d&quot;,&amp;n);    scanf(&quot;%d&quot;,&amp;x);    n%=6;    if(x==0){     if(n== 5|| n==0 ) puts(&quot;0&quot;);     if(n== 2|| n==1 ) puts(&quot;1&quot;);     if(n== 4|| n==3 ) puts(&quot;2&quot;);    }    if(x==1){     if(n== 1|| n==4 ) puts(&quot;0&quot;);     if(n== 5|| n==2 ) puts(&quot;2&quot;);     if(n== 3|| n==0 ) puts(&quot;1&quot;);    }    if(x==2){     if(n== 3|| n==2 ) puts(&quot;0&quot;);     if(n== 5|| n==4 ) puts(&quot;1&quot;);     if(n== 1|| n==0 ) puts(&quot;2&quot;);    }    return 0;}</code></pre><h1 id="Game-of-Credit-Cards"><a href="#Game-of-Credit-Cards" class="headerlink" title="Game of Credit Cards"></a>Game of Credit Cards</h1><p>————————————————————————————————————————————<br>贪心题<br>先对两个序列排序，<br>对于两个问题要分开考虑,<br>但是大同小异 ,<br>第一个就是尽量抗伤害<br>第二个就是尽量输出,类似田忌赛马</p><pre><code>#include &lt;bits/stdc++.h&gt;typedef long long int LL ;using namespace std;const int N   = 100000+7;const int MOD = 1000000007;/*******************************************************/#define all(x) x.begin(),x.end()int main() {    int n;    cin &gt;&gt;n;    string a,b;    cin&gt;&gt;a&gt;&gt;b;    sort(all(a));    sort(all(b));    int ans1 = n;    for (int i=0,j=0; i&lt;n; ++i) {        if (b[i] &gt;= a[j]) {            ans1--;            j++;        }    }    int ans2 = 0;    for (int i=0,j; i&lt;n; ++i) {        if (b[i] &gt; a[j]) {            ans2++;            j++;        }    }    cout &lt;&lt;ans1 &lt;&lt;endl &lt;&lt;ans2 &lt;&lt;endl;}</code></pre><h1 id="Alyona-and-Spreadsheet"><a href="#Alyona-and-Spreadsheet" class="headerlink" title="Alyona and Spreadsheet"></a>Alyona and Spreadsheet</h1><p>————————————————————————————————————————————<br>给你一个N*M的方阵，每个方阵有一个值，有Q次询问，<br>问你第x行到第y行中存不存在一列是单调不减的 存在yes 否则no</p><p>其实很简单，我预处理出来到每一行的最长的那个列就好了，</p><p>然后询问的时候就能做到O(1)</p><p>详看代码吧</p><pre><code>#include &lt;bits/stdc++.h&gt;typedef long long int LL ;using namespace std;const int N   = 1e5+7;const int MOD = 1000000007;/*******************************************************/vector&lt;int &gt;a[100005];vector&lt;int &gt;b[100005];int h[100005];int main(){    int n,m,x;    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);    for(int i=1;i&lt;=n;i++){        a[i].clear();        a[i].push_back(0);        b[i].push_back(0);        for(int j=1;j&lt;=m;j++){            scanf(&quot;%d&quot;,&amp;x);            a[i].push_back(x);            b[i].push_back(0);        }    }    for(int i=2;i&lt;=n;i++){        for(int j=1;j&lt;=m;j++){            if(a[i][j]&lt;a[i-1][j]){                a[i-1][j]=0;            }        }    }    for(int i=1;i&lt;=n;i++){        for(int j=1;j&lt;=m;j++){            if(0!=a[i][j]) a[i][j]=1;        }    }    for(int j=1;j&lt;=m;j++)b[1][j]=1;    for(int i=2;i&lt;=n;i++){        for(int j=1;j&lt;=m;j++){            b[i][j]=1+b[i-1][j];            if(a[i-1][j]==0) b[i][j]=1;        }    }    for(int i=1;i&lt;=n;i++){        for(int j=1;j&lt;=m;j++){            h[i]=max(h[i],b[i][j]);        }    }    int q,l,r;    scanf(&quot;%d&quot;,&amp;q);    while(q--){        scanf(&quot;%d%d&quot;,&amp;l,&amp;r);        if(h[r]&gt;=r-l+1) puts(&quot;Yes&quot;);        else            puts(&quot;No&quot;);    }    return 0;}</code></pre><h1 id="Cloud-of-Hashtags"><a href="#Cloud-of-Hashtags" class="headerlink" title="Cloud of Hashtags"></a>Cloud of Hashtags</h1><p>————————————————————————————————————————————<br>给你一堆字符串 对于每个字符串只能删除后缀, 删除最少的字符 使得这些字符串字典序单调不减</p><p>正着考虑 很明显 无法解决,<br>但是因为只能删后缀,那么从后向前考虑就没有问题了<br>只要使得s[i-1]的字典序依次小于s[i]就行了</p><p>自己的代码太丑了<br>献上巨巨优美的代码</p><pre><code>#include &lt;bits/stdc++.h&gt;typedef long long int LL ;using namespace std;const int N   = 1e5+7;const int MOD = 1000000007;/*******************************************************/int n, l[500005]; string s[500005];void solve(int x, int y) {    int len = min(l[x], l[y]);    for(int i=0;i&lt;=len-1;i++) {        if (s[x][i] &lt; s[y][i]) return ;        if (s[x][i] &gt; s[y][i]) {            l[x] = i;            return ;        }    }    if (l[x] &lt;= l[y]) return; else l[x] = len;}int main() {    scanf(&quot;%d&quot;, &amp;n);    for(int i=1;i&lt;=n;i++) cin &gt;&gt; s[i], l[i] = s[i].length();    for (int i = n; i &gt; 1; -- i) solve(i - 1, i);    for(int i=1;i&lt;=n;i++) {        for(int j=0;j&lt;=l[i]-1;j++) printf(&quot;%c&quot;, s[i][j]);        printf(&quot;\n&quot;);    }    return 0;}</code></pre><h1 id="Hanoi-Factory"><a href="#Hanoi-Factory" class="headerlink" title="Hanoi Factory"></a>Hanoi Factory</h1><p>————————————————————————————————————————————<br>给你一堆圆圈,有内半径和外半径 还有厚度,,现在让你将其摞在一起 ,<br>外半径大的不能再外半径小的上面,<br>不能从内半径中掉出去<br>问你能摞成的厚度最大是多少</p><p>很简单,先对外半径升序排相等的使内半径升序<br>然后从前开始找,能摞在这个圆圈上的厚度最大的为多少,<br>维护个最大值就行了</p><p>用线段树维护半径就行了,注意要离散化.</p><p>（后看到有人使用树状数组维护的因为维护的是前缀最大，所以没毛病，当时可能脑袋有点浑，并没有看太清晰就写了。。</p><pre><code>#include &lt;bits/stdc++.h&gt;typedef long long int LL ;using namespace std;const int N   = 1e5+7;const int MOD = 1000000007;/*******************************************************/struct node{    int l,r; //节点的区间    LL  mx; //节点的值    int m(){return (l+r)&gt;&gt;1;}    int len(){return r-l+1;}}tree[N&lt;&lt;3];#define ll  (rt&lt;&lt;1)#define rr  (rt&lt;&lt;1|1)#define mid (tree[rt].m())void pushup(int rt)  {    tree[rt].mx=max(tree[ll].mx,tree[rr].mx);}void build(int rt,int l,int r){    tree[rt].l=l,tree[rt].r=r,tree[rt].mx=0;;    if(l==r)  return ;    build(ll,l,mid);    build(rr,mid+1,r);}void update(int rt,int pos,LL mx){    if(tree[rt].l==tree[rt].r){        tree[rt].mx=mx;        return;    }    if(pos&lt;=mid)  update(ll,pos,mx);    else          update(rr,pos,mx);    pushup(rt);}LL query(int rt,int L,int R){//    printf(&quot;%d %d\n&quot;,tree[rt].l,tree[rt].r);    if(L&lt;=tree[rt].l&amp;&amp;tree[rt].r&lt;=R)        return tree[rt].mx;    LL a=0,b=0;    if(L&lt;=mid)    a=query(ll,L,R);    if(R&gt; mid)    b=query(rr,L,R);    return max(a,b);}/*******************************/struct node2 {    int a,b,h;}r[100005];int p[200005];bool cmp(node2 A,node2 B){    if(A.b==B.b) return A.a&lt;B.a;    return A.b&lt;B.b;}LL dp[100005];int n,sz;int ls(int x){    return lower_bound(p+1,p+sz+1,x)-p;}int main(){    scanf(&quot;%d&quot;,&amp;n);    for(int i=1;i&lt;=n;i++){        scanf(&quot;%d%d%d&quot;,&amp;r[i].a,&amp;r[i].b,&amp;r[i].h);        p[i]=r[i].a,p[i+n]=r[i].b;    }    sort(r+1,r+n+1,cmp);    sort(p+1,p+1+n*2);    sz = unique(p+1,p+1+n*2)-(p+1);    build(1,1,sz);//    for(int i=1;i&lt;=n;i++){//        printf(&quot;%d %d %d\n&quot;,r[i].a,r[i].b,r[i].h);//    }    LL mx = 0;    for(int i=1;i&lt;=n;i++){        dp[i]=r[i].h;        dp[i]+=query(1,ls(r[i].a+1),ls(r[i].b));    //   printf(&quot;%lld\n&quot;,query(1,ls(r[i].a+1),ls(r[i].b)));        update(1,ls(r[i].b),dp[i]);        mx = max(mx,dp[i]);    }    printf(&quot;%lld\n&quot;,mx);    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  2017广东工业大学程序设计竞赛决赛【解题报告】[补完√]</title>
      <link href="/2017/03/26/66548177/"/>
      <url>/2017/03/26/66548177/</url>
      
        <content type="html"><![CDATA[<h1 id="2017广东工业大学程序设计竞赛决赛【解题报告】-补完√"><a href="#2017广东工业大学程序设计竞赛决赛【解题报告】-补完√" class="headerlink" title="2017广东工业大学程序设计竞赛决赛【解题报告】[补完√]"></a>2017广东工业大学程序设计竞赛决赛【解题报告】[补完√]</h1><p>2017年03月26日 23:00:02  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：1944</p><hr><p> 博客爬取于<code>2019-04-18 17:17:14</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/66548177" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/66548177</a></p><p>先总结：<br>个人方面:审题不清，代码不稳。套路题过不掉。GG<br>比赛环境方面,判题慢到死,简直没法玩,做的最累的一套水题,如果能及时返回结果,对个人做题心态,感觉都会有提升的.</p><h1 id="Problem-A-两只老虎"><a href="#Problem-A-两只老虎" class="headerlink" title="Problem A 两只老虎"></a>Problem A 两只老虎</h1><p>————————————————————————————————————————————<br>首先考虑对于假如一只老虎只有两个耳朵或一个尾巴 ，那么总老虎数就是a/2+b，但是一共只有c/4个老虎，那么多出来的就是正常老虎的个数。即a/2+b-c/4</p><pre><code>int main(){    int _,a,b,c;    scanf(&quot;%d&quot;,&amp;_);    while(_--){        scanf(&quot;%d%d%d&quot;,&amp;a,&amp;b,&amp;c);        a/=2;c/=4;        printf(&quot;%d\n&quot;,a+b-c);    }    return 0;}</code></pre><h1 id="Problem-B-占点游戏"><a href="#Problem-B-占点游戏" class="headerlink" title="Problem B 占点游戏"></a>Problem B 占点游戏</h1><p>————————————————————————————————————————————<br>比赛的时候理解错了题,以为是每轮两个人都走一格,然后看不懂样例,<br>目测就是两点的曼哈顿距离和N比较下，<br>如果两个人不能相遇 ，则 -1<br>能相遇 那么 结果就是1or2 讨论一下就好</p><p>瞎猜的 没写代码 。。 等重现，，，</p><p>——————————————update————————————————</p><p>事实就是这样<br>考虑一个点能不能走到另一个点<br>如果能走到<br>—如果距离是奇数<br>——如果n是奇数 那么先手多2<br>——如果n是偶数 那么平<br>—如果距离是偶数<br>——如果n是奇数 先手多1<br>——如果n是偶数 后手多1<br>不能走到<br>—如果n是奇数 先手多1<br>—如果n是偶数 平</p><pre><code>#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long int LL;#define lowbit(x) (x&amp;-x)#define abs(x) ((x)&gt;0?(x):-(x))int main(){    int _,n,x1,y1,x2,y2;    scanf(&quot;%d&quot;,&amp;_);    while(_--){        scanf(&quot;%d%d%d%d%d&quot;,&amp;n,&amp;x1,&amp;y1,&amp;x2,&amp;y2);        int dis = abs(x1-x2)+abs(y1-y2);//        printf(&quot;%d  &lt;--- \n&quot;,dis);        if((n+1)/2&gt;=dis){            if(dis&amp;1) {                if(n&amp;1) puts(&quot;2&quot;);                else puts(&quot;-1&quot;);            }            else {                puts(&quot;1&quot;);            }        }        else {            if(n&amp;1) puts(&quot;1&quot;);            else    puts(&quot;-1&quot;);        }    }    return 0;}</code></pre><h1 id="Problem-C-爬楼梯"><a href="#Problem-C-爬楼梯" class="headerlink" title="Problem C 爬楼梯"></a>Problem C 爬楼梯</h1><p>————————————————————————————————————————————<br>出烂了的题目,</p><p>f[i]=f[i-1]+f[i-2]+f[i-3];<br>代表转移个过程,</p><pre><code>int f[200];int main(){    f[0]=1,f[1]=1,f[2]=2,f[3]=4;    for(int i=4;i&lt;=22;i++){        f[i]=f[i-1]+f[i-2]+f[i-3];        f[i]%=10007;    }    int _,n,x;    scanf(&quot;%d&quot;,&amp;_);    while(_--){        scanf(&quot;%d&quot;,&amp;n);        int ans = 1;        for(int i=1;i&lt;n;i++){            scanf(&quot;%d&quot;,&amp;x);            ans*=f[x];            ans%=10007;        }        printf(&quot;%d\n&quot;,ans);    }    return 0;}</code></pre><h1 id="Problem-D-只有通过毁灭才能揭示真理"><a href="#Problem-D-只有通过毁灭才能揭示真理" class="headerlink" title="Problem D 只有通过毁灭才能揭示真理"></a>Problem D 只有通过毁灭才能揭示真理</h1><p>————————————————————————————————————————————<br>这个明白题意就能AC了</p><pre><code>int main(){    int _,a,b,c;    scanf(&quot;%d&quot;,&amp;_);    while(_--){        scanf(&quot;%d%d%d&quot;,&amp;a,&amp;b,&amp;c);        printf(&quot;%d\n&quot;,a*b+(a/30)*c);    }    return 0;}</code></pre><h1 id="Problem-E-倒水-Water"><a href="#Problem-E-倒水-Water" class="headerlink" title="Problem E 倒水(Water)"></a>Problem E 倒水(Water)</h1><p>————————————————————————————————————————————</p><p>其实这题贪心就好，<br>我们要最少的水杯，那就倍增的将若干个杯子变成一个就好了，<br>那么也就是说  2  x  最后都能变成一个水杯, 这是不花费是最少的杯子个数<br>而我们要是最后的杯子个数&lt;=k<br>那么只要最贪心的这个最小的两个  2  x  变成一个就好了,<br>那么就是不断的加上最小的一个  2  x  ,最后能将这两个凑成一个</p><p>暴力写就好了 时间上不会超过  \logn  的.</p><p>(其实就是一个树状数组更新的过程么。。</p><pre><code>#define lowbit(x) (x&amp;-x)int a[N];int cal(LL a){    int num = 0;    while(a){        if(a&amp;1) num++;        a&gt;&gt;=1;    }    return num;}int main(){    int _,k;    LL n;    scanf(&quot;%d&quot;,&amp;_);    while(_--){        scanf(&quot;%lld&quot;,&amp;n);        scanf(&quot;%d&quot;,&amp;k);        LL ans = 0;        while(cal(n)&gt;k){            ans+=lowbit(n);            n+=lowbit(n);        }        printf(&quot;%lld\n&quot;,ans);    }    return 0;}</code></pre><h1 id="Problem-F-tmk找三角"><a href="#Problem-F-tmk找三角" class="headerlink" title="Problem F tmk找三角"></a>Problem F tmk找三角</h1><p>————————————————————————————————————————————<br>这题只知道要对树进行剖分,但是对于链上能不能构成三角形,我实在没有想到一个合适的复杂度来处理,</p><p>最后在他人的提示下才知道怎么处理,<br>先反过来想,一个序列里的数不能构成三角形,那么是fibo数列,没有问题,(详见2016CCPC长春签到题)<br>那么在  10  9  的范围内fibo的长度也不超过50<br>那么也就是说如果数列的长度大于50 那么一定可以构成三角形,</p><p>所以对于大数据我们这样处理就好, 小数据就可以  O  (  50  )  处理就好了</p><p>个人用的是树剖,将边权转化为点权,<br>S-&gt;T路径上的所有点权处理一下就行了<br>(注意要去掉LCA(S,T)的点权</p><p>后来知道这是一个陈题,赛后在别处AC了一发</p><pre><code>#include &lt;bits/stdc++.h&gt;#define abs(x)   ((x)&gt;0?(x):-(x))typedef long long int LL ;using namespace std;const int N   = 100000+7;const int MOD = 1000000007;/*******************************************************/int n,m;int c[N];vector&lt;pair&lt;int,int&gt; &gt;G[N];void add(int u,int v,int w){    G[u].push_back(make_pair(v,w));    G[v].push_back(make_pair(u,w));}int fa[N],dep[N],sz[N],son[N];void dfs1(int u,int f,int d){    fa[u]=f,dep[u]=d,sz[u]=1,son[u]=0;    int gz=G[u].size();    for(int i=0,to;i&lt;gz;i++){        to=G[u][i].first;        if(to==f) continue;        c[to]=G[u][i].second;        dfs1(to,u,d+1);        sz[u]+=sz[to];        if(sz[son[u]]&lt;sz[to]) son[u]=to;    }}int top[N],tree[N],pre[N],cnt;void dfs2(int u,int tp){    top[u]=tp,tree[u]=++cnt,pre[tree[u]]=u;    if(son[u])dfs2(son[u],tp);    int gz=G[u].size();    for(int i=0,to;i&lt;gz;i++){        to=G[u][i].first;        if(to==fa[u]||to==son[u]) continue;        dfs2(to,to);    }}int b[100];void solve2(int x,int y,int lca){    int fx=top[x],fy=top[y];    int tot=0;    while(fx!=fy){        if(dep[fx]&lt;dep[fy]) swap(fx,fy),swap(x,y);//        printf(&quot;%d %d  &lt;-----\n&quot;,x,fx);        for(int i=tree[x];i&gt;=tree[fx];i--){//            printf(&quot;%d&lt;-\n&quot;,i);            if(pre[i]==lca) continue;            b[tot++]=c[pre[i]];        }        x=fa[fx],fx=top[x];    }    if(dep[x]&lt;dep[y]) swap(x,y);    for(int i=tree[x];i&gt;=tree[y];i--){        if(pre[i]==lca) continue;        b[tot++]=c[pre[i]];    }    sort(b,b+tot);//    for(int i=0;i&lt;tot;i++) printf(&quot;%d &quot;,b[i]);puts(&quot;&quot;);    for(int i=2;i&lt;tot;i++){        if(b[i-1]+b[i-2]&gt;b[i]){            puts(&quot;Yes&quot;);            return ;        }    }    puts(&quot;No&quot;);    return ;}void solve(int x,int y){    int u=x,v=y;    int fx=top[x],fy=top[y];    int tot=0;    while(fx!=fy){        if(dep[fx]&lt;dep[fy]) swap(fx,fy),swap(x,y);        tot+=abs(tree[x]-tree[fx])+1;        x=fa[fx],fx=top[x];    }    if(dep[x]&lt;dep[y]) swap(x,y);    tot+=abs(tree[x]-tree[y]);    if(tot&gt;=60) puts(&quot;Yes&quot;);    else solve2(u,v,y);    return ;}void init(){    cnt = 0;c[1]=0;    for(int i=1;i&lt;=n;i++)    G[i].clear();}int main(){    int _;//    scanf(&quot;%d&quot;,&amp;_);    while(~scanf(&quot;%d&quot;,&amp;n)){        init();        for(int i=2,u,v,w;i&lt;=n;i++){            scanf(&quot;%d%d%d&quot;,&amp;u,&amp;v,&amp;w);            add(u,v,w);        }        dfs1(1,0,1);fa[1]=1;        dfs2(1,1);//        for(int i=1;i&lt;=n;i++) printf(&quot;%d &quot;,tree[i]);puts(&quot;&quot;);        scanf(&quot;%d&quot;,&amp;m);        int u,v;        while(m--){            scanf(&quot;%d%d&quot;,&amp;u,&amp;v);            solve(u,v);        }    }    return 0;}</code></pre><h1 id="Problem-G-等凹数字"><a href="#Problem-G-等凹数字" class="headerlink" title="Problem G 等凹数字"></a>Problem G 等凹数字</h1><p>————————————————————————————————————————————<br>这道题最开始以为是一个数位dp,想在求区间回文数个数的代码上改一改 ,但是因为渣渣实在太菜,没有调出来,</p><p>快结束暴力处理了一下范围内所有 <strong> 等凹数字 </strong> ,发现只有180k+,<br>那么我们只要对区间进行二分就好了.</p><p><strong> </strong> <del> 注:这题只是意念AC,等重现赛在提交一下 </del> (已经AC) </p><p>后来看题解说数位DP也能过 等下课回来补一个<br>(数位dp做法已更新 在下面)</p><pre><code>#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long int LL;LL  sum;LL a[500000],cnt;int num[20],len;void solve1(int n){    if(n&lt;10) return ;    LL tem = n;len =0 ;    num[len++]=n%10;    n/=10;    while(n){        num[len++]=n%10;        tem=tem*10+n%10;        n/=10;    }    if(num[0]!=num[len-1])    a[++cnt]=tem;}void solve2(int n){    if(n&lt;10) return ;    LL tem = n;len = 0;    while(n){        num[len++]=n%10;        tem=tem*10+n%10;        n/=10;    }    if(num[0]!=num[len-1])    a[++cnt]=tem;}void dfs(int s,int pre,int l,int n,bool state){    if(s&gt;=l) {        if(state){            solve1(n);            solve2(n);        }        return ;    }    for(int i=pre;i&gt;=0;i--){        dfs(s+1,i,l,n*10+i,i&lt;pre||state);    }}LL cal(LL n){    int l =1,r=cnt,mid,ans;    while(l&lt;=r){        mid = (l+r)&gt;&gt;1;        if(a[mid]&gt;n) {            r=mid-1;        }        else l=mid+1;    }    return r;}int main(){    cnt = 0;    for(int i=2;i&lt;=9;i++)        dfs(0,9,i,0,0);//    printf(&quot;\n%lld\n&quot;,cnt);    sort(a+1,a+cnt+1);//    for(int i=1;i&lt;=cnt;i++){//        if(a[i]&lt;=100000) sum++;//        else break;//        printf(&quot;%lld,&quot;,a[i]);//    }//    printf(&quot;%d\n&quot;,sum);    int _,k;    LL n,a,b;    scanf(&quot;%d&quot;,&amp;_);    while(_--){        scanf(&quot;%lld%lld&quot;,&amp;a,&amp;b);        printf(&quot;%lld\n&quot;,cal(b)-cal(a-1));    }    return 0;}</code></pre><p>————–Update————–<br>数位dp是可解的</p><p>在基础的求回文数的数位dp上面多开两个维度,记录最高位的数字和前一位的数字即可</p><p>dp[最高位][当前位][前一位的数字][最高位的数字][可不可行(其实可以去掉这一维)]</p><p>dfs(最高位,当前位,前一位的数字,最高位的数字,数位限制,可不可行)</p><p>转移的时候 只要考虑等凹数字的性质搜下去就行了 对于不满足的 可以不用搜</p><p>最开始并没有想到要记录最高位的数字 这时候不记忆化 也能能AC(因为数据水 没有卡t)<br>最后在 <strong> Dei. </strong> 的提示下 才写对 鸣谢</p><pre><code>#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long int LL;int num[20],temp[20],len;LL dp[20][20][10][10][2];LL dfs(int pos,int cur,int pre,int fir,bool limit,bool state){    if(cur&lt;0) return state&amp;&amp;(pos&gt;=2);    if(!limit&amp;&amp;dp[pos][cur][pre][fir][state]!=-1)        return dp[pos][cur][pre][fir][state];    int endi = 9;    if(limit) endi = num[cur];    LL res = 0;    for(int i=0;i&lt;=endi;i++){        temp[cur]=i;        if(pos==cur&amp;&amp;0==i){            res+=dfs(pos-1,cur-1,i,0,limit&amp;&amp;(i==endi),state);        }        else if(state&amp;&amp;cur&lt;(pos+1)/2){            if(temp[pos-cur]==i)            res+=dfs(pos,cur-1,i,fir,limit&amp;&amp;(i==endi),temp[pos-cur]==i);        }        else if(state){            if(pos!=cur&amp;&amp;i&gt;pre) continue;            if(i==temp[pos]&amp;&amp;cur==(pos+1)/2) continue;                res+=dfs(pos,cur-1,i,temp[pos],limit&amp;&amp;(i==endi),state);        }    }    if(!limit) dp[pos][cur][pre][fir][state]=res;    return res;}LL solve(LL n){    len = 0;    while(n){        num[len++]=n%10;        n/=10;    }    return dfs(len-1,len-1,0,0,1,1);}int main(){    memset(dp,-1,sizeof(dp));    int _;    LL l,r;    scanf(&quot;%d&quot;,&amp;_);    while(_--){        scanf(&quot;%lld%lld&quot;,&amp;l,&amp;r);        printf(&quot;%lld\n&quot;,solve(r)-solve(l-1));    }    return 0;}</code></pre><h1 id="Problem-H-tmk买礼物"><a href="#Problem-H-tmk买礼物" class="headerlink" title="Problem H tmk买礼物"></a>Problem H tmk买礼物</h1><p>————————————————————————————————————————————<br>这道题被 Pending Rejudging了 但绝对能AC</p><p>51nod上有一个加强版的题目 题号 <a href="http://www.51nod.com/onlineJudge/questionCode.html#!problemId=1821" target="_blank" rel="noopener"> 1821</a></p><p>就是先升序排一下,在维护一个从0开始的变量,如果 <code>ans+1&gt;=a[i]</code> 的话就说明  [  0  ,  a  n  s  +  a  [  i<br>]  ]  元素都能凑出来</p><p>处理一下就好了</p><pre><code>int a[N];int main(){    int _,n;    scanf(&quot;%d&quot;,&amp;_);    while(_--){        scanf(&quot;%d&quot;,&amp;n);        for(int i=1;i&lt;=n;i++){            scanf(&quot;%d&quot;,&amp;a[i]);        }        sort(a+1,a+n+1);        LL ans = 0;        for(int i=1;i&lt;=n;i++){            if(ans+1&gt;=a[i]) ans+=a[i];            else  break;        }        printf(&quot;%lld\n&quot;,ans);    }    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  HDU 5936 Difference [思维啊]【思维】</title>
      <link href="/2017/03/25/65937719/"/>
      <url>/2017/03/25/65937719/</url>
      
        <content type="html"><![CDATA[<h1 id="HDU-5936-Difference-思维啊-【思维】"><a href="#HDU-5936-Difference-思维啊-【思维】" class="headerlink" title="HDU 5936 Difference [思维啊]【思维】"></a>HDU 5936 Difference [思维啊]【思维】</h1><p>2017年03月25日 16:34:26  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：490</p><p>个人分类：  <a href="https://blog.csdn.net/qq_33184171/article/category/6253262" target="_blank" rel="noopener"> 思维 </a> <a href="https://blog.csdn.net/qq_33184171/article/category/6117382" target="_blank" rel="noopener"><br>hdu </a></p><hr><p> 博客爬取于<code>2019-04-18 17:17:15</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/65937719" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/65937719</a></p><p>题目链接： <a href="http://acm.hdu.edu.cn/showproblem.php?pid=5936" target="_blank" rel="noopener"> http://acm.hdu.edu.cn/showproblem.php?pid=5936</a></p><p>————————————————————————————————————————————<br>Difference</p><p>Time Limit: 6000/3000 MS (Java/Others) Memory Limit: 65536/65536 K<br>(Java/Others)<br>Total Submission(s): 733 Accepted Submission(s): 192</p><p>Problem Description<br>Little Ruins is playing a number game, first he chooses two positive integers<br>y and K and calculates f(y,K), here</p><p>f  (  y  ,  K  )  =  ∑  z  i  n  e  v  e  r  y  d  i  g  i  t  s  o  f  y  z<br>K  (  f  (  233  ,  2  )  =  2  2  +  3  2  +  3  2  =  22  )</p><p>then he gets the result</p><p>x  =  f  (  y  ,  K  )  −  y</p><p>As Ruins is forgetful, a few seconds later, he only remembers K, x and forgets<br>y. please help him find how many y satisfy  x  =  f  (  y  ,  K  )  −  y  .</p><p>Input<br>First line contains an integer T, which indicates the number of test cases.</p><p>Every test case contains one line with two integers x, K.</p><p>Limits<br>1≤T≤100<br>0≤x≤109<br>1≤K≤9</p><p>Output<br>For every test case, you should output ‘Case #x: y’, where x indicates the<br>case number and counts from 1 and y is the result.</p><p>Sample Input<br>2<br>2 2<br>3 2</p><p>Sample Output<br>Case #1: 1<br>Case #2: 2</p><p>————————————————————————————————————————————</p><p>题目大意:<br>就是给你k,x,问y的可能数</p><p>解题思路:<br>首先看到这个题实在没有好的想法,后发现,  f  (  y  ,  k  )  最大也不过  f  (  999999999  ,  9  )<br>,这样也才不到10位,<br>但是即使这样 还是不太好找 后想到将这10位分成前5位和后5位,预处理出来然后就行匹配,</p><p>这个匹配我们有很多种方法搞了,<br>首先在预处理的时候进行排序,在前5位时注意要  f  (  y  ,  k  )  −  y  ∗  100000  后5位  f  (  y  ,  k<br>)  −  y  即可</p><p>那么就是找两集合的元素加和为x的方案数了,</p><p>可以枚举一个来二分另一个,  O  (  100000  log  (  100000  )  )<br>也可以对一个从前找,另一个从后找,(双指针法)  O  (  100000  ∗  2  )</p><p>代码注意细节就好</p>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hdu </tag>
            
            <tag> 思维 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  SPOJ SUBXOR - SubXor [Trie]【思维】</title>
      <link href="/2017/03/25/65935956/"/>
      <url>/2017/03/25/65935956/</url>
      
        <content type="html"><![CDATA[<h1 id="SPOJ-SUBXOR-SubXor-Trie-【思维】"><a href="#SPOJ-SUBXOR-SubXor-Trie-【思维】" class="headerlink" title="SPOJ SUBXOR - SubXor [Trie]【思维】"></a>SPOJ SUBXOR - SubXor [Trie]【思维】</h1><p>2017年03月25日 12:38:34  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：334</p><p>个人分类：  <a href="https://blog.csdn.net/qq_33184171/article/category/6667053" target="_blank" rel="noopener"> SPOJ </a> <a href="https://blog.csdn.net/qq_33184171/article/category/6253262" target="_blank" rel="noopener"><br>思维 </a> <a href="https://blog.csdn.net/qq_33184171/article/category/6121214" target="_blank" rel="noopener"> 位运算</a></p><hr><p> 博客爬取于<code>2019-04-18 17:17:17</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/65935956" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/65935956</a></p><p>题目链接： <a href="http://www.spoj.com/problems/SUBXOR/en/" target="_blank" rel="noopener"> http://www.spoj.com/problems/SUBXOR/en/</a></p><p>————————————————————————————————————————————<br>SUBXOR - SubXor<br>no tags<br>A straightforward question. Given an array of positive integers you have to<br>print the number of subarrays whose XOR is less than K.<br>Subarrays are defined as a sequence of continuous elements Ai, Ai+1, …, Aj .<br>XOR of a subarray is defined as Ai^Ai+1^ … ^Aj.<br>Symbol ^ is Exclusive Or. You can read more about it here:<br><a href="http://en.wikipedia.org/wiki/Exclusive_or" target="_blank" rel="noopener"> http://en.wikipedia.org/wiki/Exclusive_or</a></p><p>Input Format:</p><p>First line contains T, the number of test cases. Each of the test case<br>consists of N and K in one line, followed by N space separated integers in<br>next line.</p><p>Output Format:</p><p>For each test case, print the required answer.</p><p>Constraints:</p><p>1 ≤ T ≤ 10<br>1 ≤ N ≤ 10^5<br>1 ≤ A[i] ≤ 10^5<br>1 ≤ K ≤ 10^6<br>Sum of N over all testcases will not exceed 10^5.</p><p>Sample Input:</p><p>1<br>5 2<br>4 1 3 2 7<br>Sample Output:</p><p>3<br>Explanation:</p><p>Only subarrays satisfying the conditions are [1],[1,3,2] and [3,2].</p><p>————————————————————————————————————————————<br>题目大意:<br>给你一个序列,问你有多少个区间的所有元素异或和小于k</p><p>解题思路:</p><p>首先我们很容易想到,<br>对于一个区间异或和 可以先预处理出前缀异或和 <strong> pre[] </strong> ,这样的话区间  [  l  ,  r  ]  的异或和成就变成了 <strong><br>pre[r]^pre[l-1] </strong></p><p>现在问题就变成了序列中选取两个元素异或结果小于K的方案数有多少了</p><p>如果是 <strong> 等于k </strong> 的话 相信大家都会做了,但是要小于k怎么处理呢 ,<br>其实一样的 ,只是在计算等于K的过程中进行统计,对于k当前二进制位下为1的时候我们就记录下和当前位异或为0的组合有多少 ,然后遍历下去重复此过程就好了,</p><p><strong> 注意要把pre[0]先插入字典树,这样才能统计区间  [  1  (  数  字  )  ,  r  ]  的结果 </strong></p><p>附本题代码<br>————————————————————————————————————————————</p><pre><code>#include &lt;bits/stdc++.h&gt;typedef long long int LL ;using namespace std;const int N   = 1e5+7;const int MOD = 1000000007;/*******************************************************/int trie[N*20][2],val[N*20],cnt;int _,n,k;void insert(int a){    int now = 0,bt;    for(int i=20;i&gt;=0;i--){        bt = (a&amp;(1&lt;&lt;i))?1:0;        if(!trie[now][bt])   trie[now][bt]=++cnt;        now = trie[now][bt];        val[now]++;    }}LL query(int a){    LL ans = 0;    int now = 0,bt,bk;    for(int i=20;i&gt;=0;i--){        bk = (k&amp;(1&lt;&lt;i))?1:0;        bt = (a&amp;(1&lt;&lt;i))?1:0;        if(bk){            ans+=val[trie[now][bt]];            if(!trie[now][1-bt]) break;            now = trie[now][1-bt];        }        else {            if(!trie[now][bt]) break;            now = trie[now][bt];        }    }    return ans;}int a[N];void init(){    cnt = 0;a[0]=0;    memset(trie,0,sizeof(trie));    memset(val,0,sizeof(val));}int main(){//    printf(&quot;%d\n&quot;,1&lt;&lt;20);    scanf(&quot;%d&quot;,&amp;_);    while(_--){        init();LL ans = 0;        scanf(&quot;%d%d&quot;,&amp;n,&amp;k);        insert(0);                               //!!!!!!!        for(int i=1;i&lt;=n;i++){            scanf(&quot;%d&quot;,&amp;a[i]);            a[i]^=a[i-1];            ans+=query(a[i]);            insert(a[i]);        }//        for(int i=1;i&lt;=n;i++)printf(&quot;%d%c&quot;,a[i],(i==n)?&#39;\n&#39;:&#39; &#39;);        printf(&quot;%lld\n&quot;,ans);    }    return 0;}/***15 24 1 3 2 7*/</code></pre>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 思维 </tag>
            
            <tag> SPOJ </tag>
            
            <tag> 位运算 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  ZOJ 3772 Calculate the Function [线段树+矩阵乘法]【思维？】</title>
      <link href="/2017/03/21/64432631/"/>
      <url>/2017/03/21/64432631/</url>
      
        <content type="html"><![CDATA[<h1 id="ZOJ-3772-Calculate-the-Function-线段树-矩阵乘法-【思维？】"><a href="#ZOJ-3772-Calculate-the-Function-线段树-矩阵乘法-【思维？】" class="headerlink" title="ZOJ 3772 Calculate the Function [线段树+矩阵乘法]【思维？】"></a>ZOJ 3772 Calculate the Function [线段树+矩阵乘法]【思维？】</h1><p>2017年03月21日 08:02:33  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：492</p><hr><p> 博客爬取于<code>2019-04-18 17:17:18</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/64432631" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/64432631</a></p><p>题目链接： <a href="http://acm.zju.edu.cn/onlinejudge/showProblem.do?problemCode=3772" target="_blank" rel="noopener"> http://acm.zju.edu.cn/onlinejudge/showProblem.do?problemCode=3772</a><br>————————————————————————————————————————————<br>Calculate the Function</p><hr><p>Time Limit: 2 Seconds Memory Limit: 65536 KB</p><hr><p>You are given a list of numbers A1 A2 .. AN and M queries. For the i-th query:</p><p>The query has two parameters Li and Ri.<br>The query will define a function Fi(x) on the domain [Li, Ri] ∈ Z.<br>Fi(Li) = ALi<br>Fi(Li + 1) = A(Li + 1)<br>for all x &gt;= Li + 2, Fi(x) = Fi(x - 1) + Fi(x - 2) × Ax</p><p>You task is to calculate Fi(Ri) for each query. Because the answer can be very<br>large, you should output the remainder of the answer divided by 1000000007.</p><p>Input<br>There are multiple test cases. The first line of input is an integer T<br>indicates the number of test cases. For each test case:</p><p>The first line contains two integers N, M (1 &lt;= N, M &lt;= 100000). The second<br>line contains N integers A1 A2 .. AN (1 &lt;= Ai &lt;= 1000000000).</p><p>The next M lines, each line is a query with two integer parameters Li, Ri (1<br>&lt;= Li &lt;= Ri &lt;= N).</p><p>Output<br>For each test case, output the remainder of the answer divided by 1000000007.</p><p>Sample Input<br>1<br>4 7<br>1 2 3 4<br>1 1<br>1 2<br>1 3<br>1 4<br>2 4<br>3 4<br>4 4</p><p>Sample Output<br>1<br>2<br>5<br>13<br>11<br>4<br>4<br>————————————————————————————————————————————<br>题目大意:</p><p>给一段序列 对于每一段查询区间,序列的值为<br>F  i  (  x  )  =  ⎧  ⎩  ⎨  ⎪  ⎪  A  L  i  A  L  i  +  1  F  i  (  x  −  1  )<br>+  F  i  (  x  −  2  )  ×  A  x  x  =  L  i  x  =  L  i  +  1  x  &gt; =  L  i<br>+  2</p><p>解题思路:</p><p>训练的时候一直想 会有什么技巧/黑科技一类的将其转化成一个O(1)查询的问题</p><p>最后还是没有想出来,最后看了题解 才知道这是一个线段树+矩阵乘法的</p><p>跟那个博主一样进入了 矩阵一定是求高次幂的误区</p><p>这题就是fibonacci数列<br>[  F  i  (  x  +  1  )  0  F  i  (  x  )  0  ]  ×  [  1  A  x  +  2  1  0  ]<br>=  [  F  i  (  x  +  2  )  0  F  i  (  x  +  1  )  0  ]</p><p>我们只要用线段树处理出一段区间的右矩阵的乘积就好了</p><p>查询就变成了  O  (  (  log  2  (  n  )  ∗  2  )  3  )</p><p>附本题代码<br>———————————————————————————————————————————</p><pre><code>#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long int LL;const int N   = 100000+7;const int M   = 2;const int MOD = 1e9+7;struct Matrix{    LL m[M][M];    void clear0(){        for(int i=0;i&lt;M;i++)            for(int j=0;j&lt;M;j++)                m[i][j]=0;    }    void clearE(){        for(int i=0;i&lt;M;i++)            for(int j=0;j&lt;M;j++)                m[i][j]=(i==j);    }};Matrix operator * (Matrix a,Matrix b){    Matrix c;    c.clear0();    for(int k=0;k&lt;M;k++){        for(int i=0;i&lt;M;i++){            for(int j=0;j&lt;M;j++){                c.m[i][j]=(c.m[i][j]+a.m[i][k]*b.m[k][j]+MOD)%MOD;            }        }    }    return c;}struct node{    Matrix a;    int l,r;}tree[N&lt;&lt;2];int w[N];#define ll (rt&lt;&lt;1)#define rr (rt&lt;&lt;1|1)#define mid  ((r+l)&gt;&gt;1)void pushup(int rt){    tree[rt].a=tree[ll].a*tree[rr].a;}void build(int rt,int l,int r){    tree[rt].l=l,tree[rt].r=r;    if(l==r){        tree[rt].a.m[0][0]=1   ,tree[rt].a.m[0][1]=1;        tree[rt].a.m[1][0]=w[l],tree[rt].a.m[1][1]=0;        return ;    }    build(ll,l,mid);    build(rr,mid+1,r);    pushup(rt);}Matrix query(int rt,int L,int R){    if(L&lt;=tree[rt].l&amp;&amp;tree[rt].r&lt;=R)   return tree[rt].a;    Matrix ans,b;ans.clearE();    int md = (tree[rt].l+tree[rt].r)&gt;&gt;1;    if(L&lt;=md) b=query(ll,L,R),ans=ans*b;    if(R&gt; md) b=query(rr,L,R),ans=ans*b;    return ans;}Matrix a,b;void ask(int l,int r){    if(l==r||l+1==r){        printf(&quot;%d\n&quot;,w[r]);        return ;    }    a.m[0][0]=w[l+1],a.m[0][1]=w[l];    a.m[1][0]=0     ,a.m[1][1]=0;    b=query(1,l+2,r);    b=a*b;    printf(&quot;%d\n&quot;,b.m[0][0]);    return  ;}int main(){    int _;    scanf(&quot;%d&quot;,&amp;_);    while(_--){        int n,m;        scanf(&quot;%d%d&quot;,&amp;n,&amp;m);        for(int i=1;i&lt;=n;i++){            scanf(&quot;%d&quot;,&amp;w[i]);        }        build(1,1,n);        int l,r;        while(m--){            scanf(&quot;%d%d&quot;,&amp;l,&amp;r);            ask(l,r);        }    }    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  玲珑OJ 1109 Niro plays with snow [递推+预处理矩阵乘法]【数学】</title>
      <link href="/2017/03/20/64124556/"/>
      <url>/2017/03/20/64124556/</url>
      
        <content type="html"><![CDATA[<h1 id="玲珑OJ-1109-Niro-plays-with-snow-递推-预处理矩阵乘法-【数学】"><a href="#玲珑OJ-1109-Niro-plays-with-snow-递推-预处理矩阵乘法-【数学】" class="headerlink" title="玲珑OJ 1109 Niro plays with snow [递推+预处理矩阵乘法]【数学】"></a>玲珑OJ 1109 Niro plays with snow [递推+预处理矩阵乘法]【数学】</h1><p>2017年03月20日 13:37:14  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：263</p><hr><p> 博客爬取于<code>2019-04-18 17:17:19</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/64124556" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/64124556</a></p><p>题目链接: <a href="http://www.ifrog.cc/acm/problem/1109" target="_blank" rel="noopener"> http://www.ifrog.cc/acm/problem/1109</a><br>————————————————————————————————————————————<br>1109 - Niro plays with snow<br>Time Limit：2s Memory Limit：128MByte</p><p>Submissions：50Solved：8</p><p>DESCRIPTION<br>Ah, it snows.</p><p>Niro picks up a snowflake. It grows every second. At every second, each of the<br>smallest triangles splits and one of the two rotates by 180 degrees. The<br>process is shown below. In the picture, blue represents the areas that are one<br>layer thick, red two layers thick, yellow three layers thick, and green four<br>layers thick.</p><p><img src="http://www.ifrog.cc/uploads/2017/12d3.png" alt></p><p>Now let  F  (  n  )  be the number of smallest triangles that are one layers<br>thick at order  n  , and  G  (  n  )  be the number of smallest triangles thar<br>are three layers thick at order  n  . For example,  F  (  1  )  =  1  ,  G  (<br>1  )  =  0  ,  F  (  2  )  =  6  ,  G  (  2  )  =  0  ,  F  (  3  )  =  30  ,<br>G  (  3  )  =  6  ,  F  (  4  )  =  138  ,  G  (  4  )  =  78.</p><p>Given  n  , can you tell Niro  F  (  n  )  and  G  (  n  )  modulo 1234321237?</p><p>INPUT<br>T+1 lines.<br>The first line contains one integer T, the number of test cases.<br>Each of the following T lines contains one integer n.</p><p>OUTPUT<br>T lines.<br>Each line contains two integers,  F  (  n  )  mod  1234321237  and  G  (  n  )<br>mod  1234321237  for each query.</p><p>SAMPLE INPUT<br>5<br>3<br>4<br>5<br>52<br>100</p><p>SAMPLE OUTPUT<br>30 6<br>138 78<br>606 654<br>540534048 39147304<br>978578590 88026038</p><p>HINT<br>1  ≤  T  ≤  10  5<br>1  ≤  n  ≤  10  1  8<br>————————————————————————————————————————————<br>题目大意：<br>就是问你 第n个图形中 一层 和三层的三角形有多少个</p><p>解题思路：</p><p>看了看数据范围，想到是个矩阵乘法，也推出了  8  ∗  8  的矩阵乘法<br>⎡  ⎣  ⎢  ⎢  ⎢  ⎢  ⎢  ⎢  ⎢  ⎢  ⎢  ⎢  ⎢  ⎢  ⎢  ⎢  0  0  0  0  0  0  0  0  6  3<br>1  0  0  0  0  0  0  2  2  0  0  0  0  0  0  0  1  3  0  0  0  0  0  1  2  3<br>0  0  0  0  0  0  0  0  6  3  1  0  0  0  0  0  0  2  2  0  0  0  0  0  0  0<br>1  3  ⎤  ⎦  ⎥  ⎥  ⎥  ⎥  ⎥  ⎥  ⎥  ⎥  ⎥  ⎥  ⎥  ⎥  ⎥  ⎥  ×  ⎡  ⎣  ⎢  ⎢  ⎢  ⎢  ⎢<br>⎢  ⎢  ⎢  ⎢  ⎢  ⎢  ⎢  ⎢  ⎢  F  0  (  i  )  F  1  (  i  )  F  2  (  i  )  F  3<br>(  i  )  G  0  (  i  )  G  1  (  i  )  G  2  (  i  )  G  3  (  i  )  ⎤  ⎦  ⎥<br>⎥  ⎥  ⎥  ⎥  ⎥  ⎥  ⎥  ⎥  ⎥  ⎥  ⎥  ⎥  ⎥  =  ⎡  ⎣  ⎢  ⎢  ⎢  ⎢  ⎢  ⎢  ⎢  ⎢  ⎢  ⎢<br>⎢  ⎢  ⎢  ⎢  F  0  (  i  +  1  )  F  1  (  i  +  1  )  F  2  (  i  +  1  )<br>F  3  (  i  +  1  )  G  0  (  i  +  1  )  G  1  (  i  +  1  )  G  2  (  i<br>+  1  )  G  3  (  i  +  1  )  ⎤  ⎦  ⎥  ⎥  ⎥  ⎥  ⎥  ⎥  ⎥  ⎥  ⎥  ⎥  ⎥  ⎥  ⎥  ⎥</p><p>-其中  F  i  (  )  表示三角形三边中有  i  条变邻近红色(两层)<br>-其中  G  i  (  )  表示三角形三边中有  i  条变邻近红色(两层) </p><p>然而交上去就TLE了,,,,<br>复杂度  O  (  T  ×  log  3  2  (  n  )  )  …..</p><p>然后听了 <strong> Q </strong> 的说法 预处理出所有的A矩阵的  2  i  次幂 然后在计算的时候只要用向量乘上矩阵就好了 复杂度就变成了  O  (  T<br>×  log  2  2  (  n  )  )  然后就过了</p><p>然而当时听说还有用4*4的矩阵过得..<br>最后看了题解 ,真是玄妙无比啊.. <a href="http://www.ifrog.cc/acm/solution/17" target="_blank" rel="noopener"> 有兴趣的戳一下题解的传送阵 </a></p><p>附本题代码<br>————————————————————————————————————————————</p><pre><code>#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long int LL;#define abs(x) ((x)&gt;0?(x):-(x))const int MOD =  1234321237;const int N   =  1e5+7 ;const int M   =  8 ;/********************************************/struct Matrix{    LL m[M][M];    void clearO(){        for(int i=0; i&lt;M; i++) //初始化矩阵            for(int j=0; j&lt;M; j++)                m[i][j]= 0;    }    void clearE(){        for(int i=0; i&lt;M; i++) //初始化矩阵            for(int j=0; j&lt;M; j++)                m[i][j]= (i==j);    }    void display(){        for(int i=0; i&lt;M; i++){            for(int j=0; j&lt;M; j++)                printf(&quot;%d &quot;,m[i][j]);            puts(&quot;&quot;);        }        puts(&quot;-----&quot;);    }};Matrix operator * (Matrix &amp;a,Matrix &amp;b){    Matrix c;    c.clearO();    for(int k=0; k&lt;M; k++)        for(int i=0; i&lt;M; i++){ //实现矩阵乘法            if(a.m[i][k] &lt;= 0)  continue;            for(int j=0; j&lt;M; j++){                if(b.m[k][j] &lt;= 0)    continue;                c.m[i][j]=(c.m[i][j]+a.m[i][k]*b.m[k][j]+MOD)%MOD;            }        }    return c;}Matrix operator ^ (Matrix &amp;a,LL b){    Matrix c;    c.clearE();    while(b){        if(b&amp;1) c= c * a ;        b &gt;&gt;= 1;        a = a * a ;    }    return c;}Matrix a[100];void init(){    a[0].m[0][1]=6;    a[0].m[1][1]=3,a[0].m[1][2]=2,a[0].m[1][4]=1;    a[0].m[2][1]=1,a[0].m[2][2]=2,a[0].m[2][3]=1,a[0].m[2][4]=2;    a[0].m[3][1]=0,a[0].m[3][2]=0,a[0].m[3][3]=3,a[0].m[3][4]=3;    a[0].m[4][5]=6;    a[0].m[5][5]=3,a[0].m[5][6]=2;    a[0].m[6][5]=1,a[0].m[6][6]=2,a[0].m[6][7]=1;    a[0].m[7][5]=0,a[0].m[7][6]=0,a[0].m[7][7]=3;    for(int i=1;(1ll&lt;&lt;i)&lt;=1e18;i++)    a[i]=a[i-1]*a[i-1];}int main(){    init();    int _;    Matrix b,c,d;    LL n ;    scanf(&quot;%d&quot;,&amp;_);    for(int i=1;i&lt;=_;i++){        scanf(&quot;%lld&quot;,&amp;n);n--;        b.clearO();        b.m[0][0]=1;//        b.display();        for(int i=0;(1ll&lt;&lt;i)&lt;=n;i++){            if(n&amp;(1ll&lt;&lt;i)){                for(int j=0;j&lt;M;j++){                    for(int k=0;k&lt;M;k++){                        b.m[1][j]=(b.m[1][j]+b.m[0][k]*a[i].m[k][j]+MOD)%MOD;                    }                }                for(int j=0;j&lt;M;j++){                    b.m[0][j]=b.m[1][j];                    b.m[1][j]=0;                }            }        }        printf(&quot;%lld &quot; ,((b.m[0][0]+b.m[0][1])%MOD+(b.m[0][2]+b.m[0][3])%MOD)%MOD);        printf(&quot;%lld\n&quot;,((b.m[0][4]+b.m[0][5])%MOD+(b.m[0][6]+b.m[0][7])%MOD)%MOD);    }    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  Codeforces Round</title>
      <link href="/2017/03/16/62418811/"/>
      <url>/2017/03/16/62418811/</url>
      
        <content type="html"><![CDATA[<h1 id="Codeforces-Round-404-Div-2"><a href="#Codeforces-Round-404-Div-2" class="headerlink" title="Codeforces Round #404 (Div. 2)"></a>Codeforces Round #404 (Div. 2)</h1><p>2017年03月16日 11:12:44  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：337<br>标签：  <a href="https://so.csdn.net/so/search/s.do?q=c语言&amp;t=blog" target="_blank" rel="noopener"> c语言 </a> <a href="https://so.csdn.net/so/search/s.do?q=codeforces&amp;t=blog" target="_blank" rel="noopener"> codeforces</a></p><p>个人分类：  <a href="https://blog.csdn.net/qq_33184171/article/category/6235560" target="_blank" rel="noopener"> codeforces</a> <a href="https://blog.csdn.net/qq_33184171/article/category/6822765" target="_blank" rel="noopener"> 套题</a></p><hr><p> 博客爬取于<code>2019-04-18 17:17:20</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/62418811" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/62418811</a></p><h1 id="A-Anton-and-Polyhedrons"><a href="#A-Anton-and-Polyhedrons" class="headerlink" title=" A Anton and Polyhedrons "></a><a href="http://codeforces.com/contest/785/problem/A" target="_blank" rel="noopener"> A Anton and Polyhedrons </a></h1><p>————————————————————————————————————————————<br>傻逼题不解释</p><h1 id="B-Anton-and-Classes"><a href="#B-Anton-and-Classes" class="headerlink" title=" B Anton and Classes "></a><a href="http://codeforces.com/contest/785/problem/B" target="_blank" rel="noopener"> B Anton and Classes </a></h1><p>————————————————————————————————————————————<br>傻逼题不解释</p><h1 id="C-Anton-and-Fairy-Tale"><a href="#C-Anton-and-Fairy-Tale" class="headerlink" title=" C Anton and Fairy Tale "></a><a href="http://codeforces.com/contest/785/problem/C" target="_blank" rel="noopener"> C Anton and Fairy Tale </a></h1><p>————————————————————————————————————————————<br>就是给你仓库的容积N,最开始每天运来M,但仓库里至多有N,第  i  天被鸟吃  i  ,问你至多撑几天,使得仓库里面不为  0<br>,(先被吃,在运,如果吃完就成  0  了,那么就已经算撑不住了)</p><p>首先考虑  n  &lt; =  m  的情况，最多撑n天，没有问题。</p><p>然后考虑其他情况，</p><p>开始几天，鸟吃的没有运来的多，所以相当于没有变化，<br>那么m天后，相当于每天减少1,2,3,4,······。<br>那么就是 (1+ans)*ans/2&gt;=n-m</p><p>最后的结果就是ans+m<br>计算那个式子可以用不等式开根号，也可以二分，注意下二分的时候别溢出就行了。</p><h1 id="D-Anton-and-School-2"><a href="#D-Anton-and-School-2" class="headerlink" title=" D Anton and School - 2 "></a><a href="http://codeforces.com/contest/785/problem/D" target="_blank" rel="noopener"> D Anton and School - 2 </a></h1><p>————————————————————————————————————————————<br>给你一个字符串，问你字串中前半段为’(‘,后半段为’)’的子串有多少个，子串不要求必须连续。</p><p>很明显，我们可以枚举每一个’(‘,来计算以这个为前半段结尾的子串有多少个,<br>首先预处理出前缀’(‘的个数和后缀’)’的个数,<br>在遍历一遍母串，每当到’(‘的时候我们就计算以这个跟为前半段结尾的子串有多少个,</p><p>因为前半段的最后一个’(‘是固定的,所有我们要求<br>∑  n  i  =  1  C  (  n  −  1  ,  i  −  1  )  ×  C  (  m  ,  i  )</p><p>然后推导了半天还是不会,最后 <strong> Q </strong> 给了个公式</p><blockquote><p>w  h  e  n  (  n  ≤  m  )  ,  ∑  n  i  =  1  C  (  n  ,  i  )  ∗  C  (  m  ,<br>i  )  =  ∑  n  i  =  1  C  (  n  ,  i  )  ∗  C  (  m  ,  m  −  i  )  =  C  (<br>n  +  m  ,  m  )  =  (  n  +  m  )  !  (  n  )  !  ×  (  m  )  !</p></blockquote><p>然后我们就可以计算了.</p><p>a  n  s  =  ∑  n  i  =  1  C  (  n  −  1  ,  i  −  1  )  ×  C  (  m  ,  i  )<br>=  ∑  n  i  =  1  [  C  (  n  ,  i  )  −  C  (  n  −  1  ,  i  )  ]  ×  C  (<br>m  ,  i  )  =  ∑  n  i  =  1  C  (  n  ,  i  )  ×  C  (  m  ,  i  )  −  ∑  n<br>i  =  1  C  (  n  −  1  ,  i  )  ×  C  (  m  ,  i  )  =  C  (  n  +  m  ,  m<br>)  −  C  (  n  −  1  +  m  ,  m  )  =  (  n  +  m  )  !  (  n  )  !  ×  (  m<br>)  !  −  (  n  +  m  −  1  )  !  (  n  −  1  )  !  ×  (  m  )  !</p><h1 id="E-Anton-and-Permutation"><a href="#E-Anton-and-Permutation" class="headerlink" title=" E Anton and Permutation "></a><a href="http://codeforces.com/contest/785/problem/E" target="_blank" rel="noopener"> E Anton and Permutation </a></h1><p>————————————————————————————————————————————</p><p>不会，待补</p>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c语言 </tag>
            
            <tag> codeforces </tag>
            
            <tag> 套题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  第四届山东省赛 J Boring Counting [主席树]【数据结构】</title>
      <link href="/2017/03/15/62213988/"/>
      <url>/2017/03/15/62213988/</url>
      
        <content type="html"><![CDATA[<h1 id="第四届山东省赛-J-Boring-Counting-主席树-【数据结构】"><a href="#第四届山东省赛-J-Boring-Counting-主席树-【数据结构】" class="headerlink" title="第四届山东省赛 J Boring Counting [主席树]【数据结构】"></a>第四届山东省赛 J Boring Counting [主席树]【数据结构】</h1><p>2017年03月15日 07:46:22  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：406<br>标签：  <a href="https://so.csdn.net/so/search/s.do?q=数据结构&amp;t=blog" target="_blank" rel="noopener"> 数据结构 </a></p><p>个人分类：  <a href="https://blog.csdn.net/qq_33184171/article/category/6134085" target="_blank" rel="noopener"> hrbust </a><br><a href="https://blog.csdn.net/qq_33184171/article/category/6362428" target="_blank" rel="noopener"> ==== 数据结构 ==== </a></p><hr><p> 博客爬取于<code>2019-04-18 17:17:21</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/62213988" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/62213988</a></p><p>题目链接 <a href="http://acm.hrbust.edu.cn/index.php?m=ProblemSet&amp;a=showProblem&amp;problem_id=2054" target="_blank" rel="noopener"><br>http://acm.hrbust.edu.cn/index.php?m=ProblemSet&amp;a=showProblem&amp;problem_id=2054 </a><br>——————————————————————————————————————————<br>Boring Counting<br>Time Limit: 3000 MS Memory Limit: 32768 K<br>Total Submit: 70(22 users) Total Accepted: 6(6 users) Rating: Special Judge:<br>No</p><p>Description<br>In this problem you are given a number sequence P consisting of N integer and<br>Pi is the ith element in the sequence. Now you task is to answer a list of<br>queries, for each query, please tell us among [L, R], how many Pi is not less<br>than A and not greater than B( L&lt;= i &lt;= R). In other words, your task is to<br>count the number of Pi (L &lt;= i &lt;= R, A &lt;= Pi &lt;= B).</p><p>Input<br>In the first line there is an integer T (1 &lt; T &lt;= 50), indicates the number of<br>test cases.</p><p>For each case, the first line contains two numbers N and M (1 &lt;= N, M &lt;=<br>50000), the size of sequence P, the number of queries. The second line<br>contains N numbers Pi(1 &lt;= Pi &lt;= 10^9), the number sequence P. Then there are<br>M lines, each line contains four number L, R, A, B(1 &lt;= L, R &lt;= n, 1 &lt;= A, B<br>&lt;= 10^9)</p><p>Output<br>For each case, at first output a line ‘Case #c:’, c is the case number start<br>from 1. Then for each query output a line contains the answer.</p><p>Sample Input<br>1<br>13 5<br>6 9 5 2 3 6 8 7 3 2 5 1 4<br>1 13 1 10<br>1 13 3 6<br>3 6 3 6<br>2 8 2 8<br>1 9 1 9</p><p>Sample Output<br>Case #1:<br>13<br>7<br>3<br>6<br>9</p><p>——————————————————————————————————————————</p><p>解题思路:</p><p>其实就是一个简单的主席树入门,奈何练习赛的时候刚学主席树不到2天,还没理解主席树.于是GG了</p><p>其实仔细想想啊,其实 和 SPOJ DQUERY 一样,而且更简单一点,<br>我们不需要删除操作,只需要保存所有的历史版本,然后找  r  t  [  l  ]  −  r  t  [  r  ]  之间在  [  A  ,  B<br>]  区间的数的个数就行了</p><p>只需要离散化后,一次向树上更新即可,</p><p>但要注意查询的时候,<br>离散化A是<strong>大于等于</strong>A的第一个元素<br>离散化B是<strong>小于等于</strong>B的最后一个元素</p><p>附本题代码<br>————————————————————————————————————————————</p><pre><code>#include &lt;bits/stdc++.h&gt;using namespace std;inline int read(){    int x=0,f=1;char ch=getchar();    while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;){if(ch==&#39;-&#39;)f=-1;ch=getchar();}    while(&#39;0&#39;&lt;=ch&amp;&amp;ch&lt;=&#39;9&#39;){x=(x&lt;&lt;3)+(x&lt;&lt;1)+ch-&#39;0&#39;;ch=getchar();}    return x*f;}/************************************************/const int N = 5e4+7;int a[N],b[N],sz;int rt[N],ls[N*40],rs[N*40],sum[N*40],tot;void build(int &amp;rt,int l,int r){    rt=++tot;    sum[rt]=0;    if(l&gt;=r)return;    int m=((r-l)&gt;&gt;1)+l;    build(ls[rt],l  ,m);    build(rs[rt],m+1,r);}void update(int &amp;rt,int l,int r,int last,int pos){    rt=++tot;    ls[rt]=ls[last];    rs[rt]=rs[last];    sum[rt]=sum[last]+1;    if(l&gt;=r)return;    int m=((r-l)&gt;&gt;1)+l;    if(pos&lt;=m) update(ls[rt],l  ,m,ls[last],pos);    else       update(rs[rt],m+1,r,rs[last],pos);}int query(int rt,int last,int l,int r,int L,int R){    if(L&gt;R)return 0;    if(L&lt;=l&amp;&amp;r&lt;=R)return sum[rt]-sum[last];    int m=((r-l)&gt;&gt;1)+l;    int ans=0;    if(L&lt;=m) ans+=query(ls[rt],ls[last],l  ,m,L,R);    if(R&gt; m) ans+=query(rs[rt],rs[last],m+1,r,L,R);    return ans;}int lb(int x){    return lower_bound(b+1,b+sz+1,x)-b;}map&lt;int,int&gt;mmp;int main(){    int _ = 1,kcase = 0,l,r,L,R,flag;    scanf(&quot;%d&quot;,&amp;_);    while(_--){        tot=0;mmp.clear();        int n=read(),m=read();        for(int i=1;i&lt;=n;i++) b[i]=a[i]=read(),mmp[a[i]]=1;        sort(b+1,b+n+1);        sz = unique(b+1,b+n+1)-(b+1);//        printf(&quot;sz = %d\n&quot;,sz);//        for(int i=1;i&lt;=sz;i++) printf(&quot;b[%d]=%d &quot;,i,b[i]);puts(&quot;&quot;);        build(rt[0],1,sz);        for(int i=1;i&lt;=n;i++)a[i]=lb(a[i]);        for(int i=1;i&lt;=n;i++)update(rt[i],1,sz,rt[i-1],a[i]);//        printf(&quot;%d\n&quot;,lb(0));        printf(&quot;Case #%d:\n&quot;,++kcase);        while(m--){            l=read(),r=read(),L=read(),R=read();            if(L&gt;R){puts(&quot;0&quot;);continue; }            flag=0;            if(!mmp[R])flag=1;            if(R&lt;b[1]) R=-1;    else R = lb(R)-flag;            if(L&gt;b[sz])L=1e9+77;else L = lb(L);//            printf(&quot;%d  %d\n&quot;,L,R);            printf(&quot;%d\n&quot;,query(rt[r],rt[l-1],1,sz,L,R));        }    }    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> hrbust </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  玲珑OJ 1098 &amp;&amp; Round</title>
      <link href="/2017/03/14/62040995/"/>
      <url>/2017/03/14/62040995/</url>
      
        <content type="html"><![CDATA[<h1 id="玲珑OJ-1098-amp-amp-Round-11-C-萌萌哒的第三题-并查集-思维-【数据结构】"><a href="#玲珑OJ-1098-amp-amp-Round-11-C-萌萌哒的第三题-并查集-思维-【数据结构】" class="headerlink" title="玲珑OJ 1098 &amp;&amp; Round #11 C 萌萌哒的第三题 [并查集+思维]【数据结构】"></a>玲珑OJ 1098 &amp;&amp; Round #11 C 萌萌哒的第三题 [并查集+思维]【数据结构】</h1><p>2017年03月14日 12:37:34  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：680</p><p>个人分类：  <a href="https://blog.csdn.net/qq_33184171/article/category/6253262" target="_blank" rel="noopener"> 思维 </a> <a href="https://blog.csdn.net/qq_33184171/article/category/6362428" target="_blank" rel="noopener"><br>==== 数据结构 ==== </a></p><hr><p> 博客爬取于<code>2019-04-18 17:17:23</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/62040995" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/62040995</a></p><p>题目链接： <a href="http://www.ifrog.cc/acm/problem/1098" target="_blank" rel="noopener"> http://www.ifrog.cc/acm/problem/1098</a><br>————————————————————————————————————————————<br>DESCRIPTION</p><p>按顺序把一个1～n的排列插入一棵原来是空的排序二叉树，求所有节点的高度的和以及积（其中跟节点的高度算为1），这个结果可能有点大，所以你只需要输出和以及积对1<br>0^9+7求与的结果。<br><img src="http://www.ifrog.cc/uploads/2017/4841.png" alt><br>INPUT<br>输入数据第一行一个整数T(&lt;=15)表示数据组数。<br>接下来每组数据一行四个整数，n（1&lt;=n&lt;=1000000)、a、b、c(1&lt;=a,b,c&lt;=10^9)，然后利用下面一段程序生成插入排序二叉树的排列。</p><p>（注意：此处应有代码，两段代码放于描述图中，请仔细观看，代码贴于下方网站）<br><a href="http://paste.ubuntu.com/24106406/" target="_blank" rel="noopener"> http://paste.ubuntu.com/24106406/ </a></p><p>运行make_data得到的num数组就是插入的排列。</p><p>OUTPUT</p><p>每组数据输出一行两个数，分别表示所有节点的高度之和对10^9+7求余以及高度之积对10^9+7求余的结果。</p><p>SAMPLE INPUT<br>2<br>3 4 5 6<br>4 1 5 9<br>SAMPLE OUTPUT<br>6 6<br>8 12<br>HINT<br>提示：两个样例生成的排列分别为<br>3 1 2<br>2 3 1 4<br>————————————————————————————————————————————<br>解题思路:</p><p>其实这题很容易就想到了  O  (  T  ×  n  ×  log  n  )  的做法,</p><p>我们只要用一个树状数组维护,再加上一个二分,<br>每次将一个元素插入到树中,那么对于待插得元素,它一定是在树中元素中比它大的最小元素或比它小的最大元素的下面,并且一定是其中深度大的那个点的孩子,</p><p>那么我们很容易用二分和树状数组维护处待插元素的父节点,</p><p>但是交上去T了 ,然后看群里讨论,说可以去掉  log</p><p>先附上  O  (  T  ×  n  ×  log  n  )  的代码</p><pre><code>int n,a,b,c;int sum[N];#define lowbit(x) (x&amp;(-x))void update(int index,int val){    for(int i=index;i&lt;=n;i+=lowbit(i))sum[i]+=val;}int getSum(int index){    int ans = 0;    for(int i=index;i&gt;0;i-=lowbit(i))ans+=sum[i];    return ans;}int Bsearch(int x){    int l=0,r=n,ans=0,mid;    while(l&lt;=r){        mid=(l+r)&gt;&gt;1;        if(getSum(mid)&gt;=x){            ans = mid;            r=mid-1;        }        else l=mid+1;    }    return ans;}int h[N],ind[N];int main(){    int _;    scanf(&quot;%d&quot;,&amp;_);    while(_--){        scanf(&quot;%d%d%d%d&quot;,&amp;n,&amp;a,&amp;b,&amp;c);        make_data(n,a,b,c);        for(int i=0;i&lt;=n;i++)sum[i]=0,ind[i]=0,h[i]=0;        //for(int i=0;i&lt;n;i++)printf(&quot;%d &quot;,num[i]);puts(&quot;&quot;);        h[0]=1;update(num[0],1);ind[num[0]]=0;        LL ji=1,he=0;        for(int i=1,pre,id1,id2;i&lt;n;i++){            pre=getSum(num[i]);            update(num[i],1);            ind[num[i]]=i;           // printf(&quot;%d  &quot;,pre);            id1 = Bsearch(pre);            id2 = Bsearch(pre+1);           // printf(&quot;%d %d  &quot;,id1,id2);            if(id1==0){                id1 = ind[id1];                h[i]=h[id1]+1;                continue;            }            if(id2==0){                id2 = ind[id2];                h[i]=h[id2]+1;                continue;            }            id1 = ind[id1];            id2 = ind[id2];           // printf(&quot;%d %d\n&quot;,id1,id2);            h[i]=(h[id1]&gt;h[id2]?h[id1]:h[id2])+1;        }        for(int i=0;i&lt;n;i++){            //printf(&quot;%d &quot;,h[i]);            he+=h[i];            he = (he&gt;MOD)?(he-MOD):he;            ji*=h[i];            ji%=MOD;        }        //puts(&quot;&quot;);        printf(&quot;%lld %lld\n&quot;,he,ji);    }    return 0;}</code></pre><p>然后冥思苦想 ,有意识的倒过来插元素,但却不知道怎么维护, 知道比赛后看到题解说用并查集维护</p><p><strong> 官方题解: </strong></p><blockquote><p>第三题、当一课排序二叉树建立起来之后我们可以发现，从某个点x往上走，第一个往左的节点的值是在x前插入的小于x的最大值，第一个往右的值是在x前插入的大于x<br>的最小值，所以x所在的层数就是在插入x之前比x大的最小值的层数和比x小的最大值的层数中，较大值加一，若把问题反过来看，不是插入而是从二叉树中把一个个点拿走，<br>那么可以很简单地用并查集找到上述的两个值。</p></blockquote><p>但是本菜真的想不出如何用并查集进行维护,</p><p>直到今天向格格姐姐要来了标程…</p><p>虽然还不是特别懂,但也感受到了这个姿势的妙&lt;</p><p>正常的并查集仅仅是单一的维护父节点,再简单点就是堆与堆之间的关系,<br>这个则不同,不仅开了两个并查集维护左边和右边的关系,<br>同事每个并查集都用了一个pair,来维护<br>一边维护左边的,一边维护了右边的关系,使得确保我在记录每个节点的左父节点和右父节点(大概可以这么理解)的关系时能做到  O  (  1  )  .</p><p>附本题代码(我写的太丑了 还是贴标程吧)<br>————————————————————————————————————————————</p><pre><code>#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;math.h&gt;#include &lt;assert.h&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;queue&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;stack&gt;using namespace std;#define foreach(it, s) for(__typedef(s.begin()) it = s.begin();it != s.end();it++)#define sgn(x) ((x)&lt;-eps?-1:(x)&gt;eps)typedef long long LL;typedef pair&lt;int, int&gt; pii;const int maxn = 1000000 + 10;int n, num[maxn];int ans[maxn];pii fal[maxn], far[maxn];int Left[maxn], Right[maxn];const int Mod = 1000000000 + 7;void rd(int Left, int Right, int a, int b, int c) {    int len = Right - Left;    long long rnum = b;    for (int i=Left;i&lt;Right;i++) {        swap(num[i], num[i + rnum % len]);        rnum = (rnum * a + b) % c;        len--;    }}void make_data(int n, int a, int b, int c) {        for (int i=0;i&lt;n;i++) num[i] = i + 1;        int Left = 0, Right = min(110, n);        for (;;) {            rd(Left, Right, a, b, c);            Left += 100;            Right += 100;            if (Left &gt;= n) break;            if (Right &gt;= n) Right = n;        }}int getfal(int r) {    if (fal[r].first &lt; 0) return r;    return fal[r].first = getfal(fal[r].first);}int getfar(int r) {    if (far[r].first &lt; 0) return r;    return far[r].first = getfar(far[r].first);}int main() {    int T;    int cas = 0;    scanf(&quot;%d&quot;, &amp;T);    while (T--) {        int a, b, c;        scanf(&quot;%d%d%d%d&quot;, &amp;n, &amp;a, &amp;b, &amp;c);        make_data(n, a, b, c);        for (int i=0;i&lt;=n+1;i++) {            fal[i] = pii(-1, i);            far[i] = pii(-1, i);            ans[i] = -1;            Left[i] = Right[i] = 0;        }        int fl, fr;        for (int j=n-1;j&gt;=0;j--) {            int i = num[j];            Left[i] = fal[getfal(i - 1)].second;            Right[i] = far[getfar(i + 1)].second;            fl = getfal(i - 1);            fr = getfal(i);            if (fal[fl].first &gt; fal[fr].first) swap(fl, fr);            fal[fl].first += fal[fr].first;            fal[fr].first = fl;            fal[fl].second = min(fal[fl].second, fal[fr].second);            fl = getfar(i);            fr = getfar(i + 1);            if (far[fl].first &gt; far[fr].first) swap(fl, fr);            far[fl].first += far[fr].first;            far[fr].first = fl;            far[fl].second = max(far[fl].second, far[fr].second);        }        LL Y = 1, Z = 1;        ans[num[0]] = 1;        for (int i=1;i&lt;n;i++) {            ans[num[i]] = max(ans[Left[num[i]]], ans[Right[num[i]]]) + 1;            Y = (Y + ans[num[i]]) % Mod;            Z = Z * ans[num[i]] % Mod;        }        printf(&quot;%d %d\n&quot;, int(Y), int(Z));    }    return 0;}</code></pre><p>我抄来的 <a href="http://paste.ubuntu.com/24174975/" target="_blank" rel="noopener"> 代码 </a></p>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 思维 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  Codeforces Round</title>
      <link href="/2017/03/13/61929040/"/>
      <url>/2017/03/13/61929040/</url>
      
        <content type="html"><![CDATA[<h1 id="Codeforces-Round-402-Div-2"><a href="#Codeforces-Round-402-Div-2" class="headerlink" title="Codeforces Round #402 (Div. 2)"></a>Codeforces Round #402 (Div. 2)</h1><p>2017年03月13日 21:19:02  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：200<br>标签：  <a href="https://so.csdn.net/so/search/s.do?q=codeforces&amp;t=blog" target="_blank" rel="noopener"> codeforces </a></p><p>个人分类：  <a href="https://blog.csdn.net/qq_33184171/article/category/6235560" target="_blank" rel="noopener"> codeforces</a> <a href="https://blog.csdn.net/qq_33184171/article/category/6822765" target="_blank" rel="noopener"> 套题</a></p><hr><p> 博客爬取于<code>2019-04-18 17:17:24</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/61929040" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/61929040</a></p><p><strong> Virtual Contest 4AC GG E题根本读不懂啊… </strong><br><img src="https://img-blog.csdn.net/20170313212118930?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzMxODQxNzE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>读题太慢,傻逼题还错,难题还不会, 总结就是 <strong> 菜 </strong> !!</p><h1 id="A-Pupils-Redistribution"><a href="#A-Pupils-Redistribution" class="headerlink" title="A Pupils Redistribution"></a>A Pupils Redistribution</h1><p>——————————————————————————————————<br>日常傻逼题：<br>给你两个只含有{1,2,3,4,5}序列，让你使其平衡，就是两边1的个数,2的个数…5的个数相同,</p><p>问你最少交换几次, 不能输出-1;</p><pre><code>#include &lt;bits/stdc++.h&gt;#define abs(x) ((x)&gt;0?(x):-(x))using namespace std;int a[10],b[10];int main(){    int n;    scanf(&quot;%d&quot;,&amp;n);    for(int i=0,x;i&lt;n;i++) {        scanf(&quot;%d&quot;,&amp;x);        a[x]++,b[x]++;    }    for(int i=0,x;i&lt;n;i++) {        scanf(&quot;%d&quot;,&amp;x);        a[x]++;    }    for(int i=1;i&lt;=5;i++){        if(a[i]&amp;1) return 0*puts(&quot;-1&quot;);    }    int sum = 0;    for(int i=1;i&lt;=5;i++){        sum+=abs(a[i]/2-b[i]);    }    printf(&quot;%d\n&quot;,sum/2);    return 0;}</code></pre><h1 id="B-Weird-Rounding"><a href="#B-Weird-Rounding" class="headerlink" title="B Weird Rounding"></a>B Weird Rounding</h1><p>————————————————————————————————————————————<br>日常傻逼题2:给你一个数,问你最少删除几位使得这个数能被  10  k  整除</p><p>字符串模拟做即可 ,注意 如果是 100 要被  10  100  整除,那么只能变成0,那么删除的是 <strong> 2 </strong> 位,而不仅仅是 <strong> 1 </strong><br>这一位.</p><pre><code>#include &lt;bits/stdc++.h&gt;#define abs(x) ((x)&gt;0?(x):-(x))using namespace std;int main(){    string s;    int k;    cin&gt;&gt;s&gt;&gt;k;//    cout&lt;&lt;s&lt;&lt;&quot; &quot;&lt;&lt;k;    int mx = s.size();    for(int i=s.size()-1;i&gt;=0;i--){        if(s[i]==&#39;0&#39;) {mx --;break;}    }    int m = 0,mm=0;    for(int i=s.size()-1;i&gt;=0;i--){        if(s[i]==&#39;0&#39;)m++;        else mm++;        if(m&gt;=k) {break;}        if(!i) {mm=10000;}    }//    printf(&quot;%d %d\n&quot;,mx,mm);    printf(&quot;%d\n&quot;,min(mx,mm));    return 0;}</code></pre><h1 id="C-Dishonest-Sellers"><a href="#C-Dishonest-Sellers" class="headerlink" title="C Dishonest Sellers"></a>C Dishonest Sellers</h1><p>————————————————————————————————————————————<br>贪心题:<br>给你n个商品的两种价格，一种是现在的价格，一种是过几天的价格，今天最少买k个，问你最后每个商品买一次，最少的总花费。</p><p>排序，先买现在的价格-过几天价格的差大的。现在买的话 至少买k个或者买现在便宜的 剩下的都过几天买就好了</p><pre><code>#include &lt;bits/stdc++.h&gt;#define abs(x) ((x)&gt;0?(x):-(x))using namespace std;const int N = 2e5+7;struct node {    int now,week;}a[N];bool cmp(node A,node B){    return A.week-A.now&gt;B.week-B.now;}int main(){    int n,k;    scanf(&quot;%d%d&quot;,&amp;n,&amp;k);    for(int i=1;i&lt;=n;i++)scanf(&quot;%d&quot;,&amp;a[i].now);    for(int i=1;i&lt;=n;i++)scanf(&quot;%d&quot;,&amp;a[i].week);    sort(a+1,a+n+1,cmp);    int sum = 0;    for(int i=1;i&lt;=n;i++){        if(i&lt;=k||a[i].week&gt;a[i].now)sum+=a[i].now;        else    sum+=a[i].week;    }    printf(&quot;%d\n&quot;,sum);    return 0;}</code></pre><h1 id="D-String-Game"><a href="#D-String-Game" class="headerlink" title="D String Game"></a>D String Game</h1><p>————————————————————————————————————————————<br>就是在  t  字符串上按顺序依次删除第  a  i  个字符串,问你最多删除几次,能保证在省下的字符串中能找到字符串  p</p><p>很明显  |  t  |  ,  |  p  |  ∈  [  1  ,  2  e  5  ]  是不能  O  (  n  2  )  的</p><p>但是我们可以发现，在答案位置左边，一定是 <strong> 不能 </strong> 找到字符串  p  得，右边一定是 <strong> 能 </strong> 找到字符串  p  得，</p><p>那么根据这个 我们可以对答案进行二分，最后复杂度  O  (  n  log  n  )</p><pre><code>#include &lt;bits/stdc++.h&gt;#define abs(x) ((x)&gt;0?(x):-(x))using namespace std;const int N = 2e5+7;int a[N],tz,pz;string p,t;bool check(int x){    string tt=&quot;&quot;,ttt;    ttt=t;    for(int u=1;u&lt;=x;u++) ttt[a[u]-1]=&#39;0&#39;;    for(int u=0;u&lt;tz;u++){        if(ttt[u]==&#39;0&#39;)continue;        tt+=ttt[u];    }    int i,j;    for(i=0,j=0;i&lt;tt.size()&amp;&amp;j&lt;pz;i++){        if(p[j]==tt[i])j++;    }//    cout&lt;&lt;x &lt;&lt;&quot; &quot;&lt;&lt;t&lt;&lt;&quot; &quot;&lt;&lt;tt&lt;&lt;&quot; &quot;&lt;&lt;ttt&lt;&lt;endl;//    cout&lt;&lt;ans&lt;&lt;endl;    if(j==p.size()) return true;    return false;}int main(){    cin&gt;&gt;t&gt;&gt;p;    tz=t.size();    pz=p.size();    for(int i=1;i&lt;=tz;i++) cin&gt;&gt;a[i];    int l=1,r=tz,mid,ans = 0;;    while(l&lt;=r){        mid = (r+l)&gt;&gt;1;        if(check(mid)) ans=mid,l=mid+1;        else r=mid-1;    }    cout&lt;&lt;ans&lt;&lt;endl;    return 0;}</code></pre><h1 id="E-Bitwise-Formula"><a href="#E-Bitwise-Formula" class="headerlink" title="E. Bitwise Formula"></a>E. Bitwise Formula</h1><p>————————————————————————————————————————————<br>待补</p><h1 id="F-Peterson-Polyglot"><a href="#F-Peterson-Polyglot" class="headerlink" title="F. Peterson Polyglot"></a>F. Peterson Polyglot</h1><p>————————————————————————————————————————————<br>待补</p>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> codeforces </tag>
            
            <tag> 套题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  HDU 5919 Sequence II [主席树]【数据结构】</title>
      <link href="/2017/03/13/61923707/"/>
      <url>/2017/03/13/61923707/</url>
      
        <content type="html"><![CDATA[<h1 id="HDU-5919-Sequence-II-主席树-【数据结构】"><a href="#HDU-5919-Sequence-II-主席树-【数据结构】" class="headerlink" title="HDU 5919 Sequence II [主席树]【数据结构】"></a>HDU 5919 Sequence II [主席树]【数据结构】</h1><p>2017年03月13日 18:16:52  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：345</p><hr><p> 博客爬取于<code>2019-04-18 17:17:25</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/61923707" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/61923707</a></p><p>题目链接： <a href="http://acm.hdu.edu.cn/showproblem.php?pid=5919" target="_blank" rel="noopener"> http://acm.hdu.edu.cn/showproblem.php?pid=5919</a><br>——————————————————————————————————————<br>Sequence II</p><p>Time Limit: 9000/4500 MS (Java/Others) Memory Limit: 131072/131072 K<br>(Java/Others)<br>Total Submission(s): 1654 Accepted Submission(s): 420</p><p>Problem Description<br>Mr. Frog has an integer sequence of length n, which can be denoted as  a  1  ,<br>a  2  ,  ⋯  ,  a  n  There are m queries.</p><p>In the  i  −  t  h  query, you are given two integers  l  i  and  r  i  .<br>Consider the subsequence  a  l  i  ,  a  l  i  +  1  ,  a  l  i  +  2  ,  ⋯<br>,  a  r  i  .</p><p>We can denote the positions(the positions according to the original sequence)<br>where an integer appears first in this subsequence as  p  (  i  )  1  ,  p  (<br>i  )  2  ,  ⋯  ,  p  (  i  )  k  i  (in ascending order, i.e.,  p  (  i  )  1<br>&lt; p  (  i  )  2  &lt; ⋯  &lt; p  (  i  )  k  i  )  .</p><p>Note that ki is the number of different integers in this subsequence. You<br>should output p(i)⌈ki2⌉for the i-th query.</p><p>Input<br>In the first line of input, there is an integer T  (  T  ≤  2  )  denoting the<br>number of test cases.</p><p>Each test case starts with two integers n  (  n  ≤  2  ×  10  5  )  and m  (<br>m  ≤  2  ×  10  5  )  . There are n integers in the next line, which indicate<br>the integers in the sequence(i.e.,  a  1  ,  a  2  ,  ⋯  ,  a  n  ,  0  ≤  a<br>i  ≤  2  ×  10  5  ).</p><p>There are two integers  l  i  and  r  i  in the following  m  lines.</p><p>However, Mr. Frog thought that this problem was too young too simple so he<br>became angry. He modified each query to  l  ‘  i  ,  r  ‘  i  (  1  ≤  l  ‘  i<br>≤  n  ,  1  ≤  r  ‘  i  ≤  n  )  .  As a result, the problem became more<br>exciting.</p><p>We can denote the answers as  a  n  s  1  ,  a  n  s  2  ,  ⋯  ,  a  n  s  m<br>. Note that for each test case  a  n  s  0  =  0  .</p><p>You can get the correct input li,ri from what you read (we denote them as  l<br>‘  i  ,  r  ‘  i  )by the following formula:<br>l  i  =  m  i  n  (  l  ‘  i  +  a  n  s  i  −  1  )  mod  n  +  1  ,  (  r<br>‘  i  +  a  n  s  i  −  1  )  mod  n  +  1</p><p>r  i  =  m  a  x  (  l  ‘  i  +  a  n  s  i  −  1  )  mod  n  +  1  ,  (  r<br>‘  i  +  a  n  s  i  −  1  )  mod  n  +  1</p><p>Output<br>You should output one single line for each test case.</p><p>For each test case, output one line “Case #x:  p  1  ,  p  2  ,  ⋯  ,  p  m<br>”, where  x  is the case number (starting from 1) and  p  1  ,  p  2  ,  ⋯  ,<br>p  m  is the answer.</p><p>Sample Input<br>2<br>5 2<br>3 3 1 5 4<br>2 2<br>4 4<br>5 2<br>2 5 2 1 2<br>2 3<br>2 4</p><p>Sample Output<br>Case #1: 3 3<br>Case #2: 3 1</p><p><strong> Hint </strong><br><img src="http://acm.hdu.edu.cn/data/images/C728-1009-1.jpg" alt></p><p>————————————————————————————————————————————</p><p>题目大意:<br>给定一个长度为n的序列，然后有m个查询，问你在  [  l  ,  r  ]<br>区间中所有不相同元素第一次出现的位置，按这个位置升序以后的中间（向上取整）的那个位置是多少(这个位置指的是原序列)？</p><p>解题思路:<br>因为这个题对  l  ,  r  的限制,这题强制在线,就不能离线树状数组做了,只能主席树做了,</p><p>然后他说在询问区间,不相同元素第一次出现的位置的中间那个,<br>如果是从正序挂到主席树上的话 确实不好维护,<br>考虑倒叙插入到主席树上,那么每次都只会记录最左边的数,更新的时候如过当前数出现过就删去之前的那个,<br>就不需要排序过程了,只需要在区间内找第中间的那个就行了<br>查询的时候我们只要对rt[l]进行查找就行了<br>于是就变成了找区间内不同数的个数,<br>然后找区间内第k大的问题,</p><p>这样的话就是主席树的基本操作了,</p><p>总体复杂度  O  (  n  log  n  )</p><p>附本题代码<br>——————————————————————————————————————————————</p><pre><code>#include &lt;bits/stdc++.h&gt;using namespace std;/**********************************/const int N = 2e5+7;int n,m,ans;int a[N],vis[N];void so(int &amp;l,int &amp;r){    int tem=(l+ans)%n+1;    int tmp=(r+ans)%n+1;    l=(tem&lt;tmp)?tem:tmp;    r=(tem&gt;tmp)?tem:tmp;}int rt[N],ls[N*40],rs[N*40],sum[N*40],tot;void build(int&amp; rt,int l,int r){    rt=++tot;    sum[rt]=0;    if(l&gt;=r)return;    int m=((r-l)&gt;&gt;1)+l;    build(ls[rt],l  ,m);    build(rs[rt],m+1,r);}void update(int&amp; rt,int l,int r,int last,int pos,int v){    rt=++tot;    ls[rt]=ls[last];    rs[rt]=rs[last];    sum[rt]=sum[last]+v;    if(l&gt;=r)return;    int m=((r-l)&gt;&gt;1)+l;    if(pos&lt;=m) update(ls[rt],l  ,m,ls[last],pos,v);    else       update(rs[rt],m+1,r,rs[last],pos,v);}int query_num(int rt,int l,int r,int L,int R){    if(L&lt;=l&amp;&amp;r&lt;=R) return sum[rt];    int m=((r-l)&gt;&gt;1)+l;    int ans=0;    if(L&lt;=m) ans+=query_num(ls[rt],l  ,m,L,R);    if(R&gt; m) ans+=query_num(rs[rt],m+1,r,L,R);    return ans;}int query_id(int rt,int l,int r,int k){    if(l&gt;=r)return l;    int m=((r-l)&gt;&gt;1)+l;    int cnt = sum[ls[rt]];    if(k&lt;=cnt) return query_id(ls[rt],l  ,m,k);    else       return query_id(rs[rt],m+1,r,k-cnt);}int main(){    int _=1,kcase=0;    scanf(&quot;%d&quot;,&amp;_);    while(_--){        memset(vis,0,sizeof(vis));        ans = 0;        scanf(&quot;%d%d&quot;,&amp;n,&amp;m);        for(int i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;a[i]);        tot = 0;        build(rt[n+1],1,n);        for(int i=n,tem;i;i--){            tem=rt[i+1];            if(vis[a[i]])update(tem,1,n,rt[i+1],vis[a[i]],-1);            update(rt[i],1,n,tem,i,1);            vis[a[i]]=i;        }        printf(&quot;Case #%d:&quot;,++kcase);        for(int i=1,l,r,id;i&lt;=m;i++){            scanf(&quot;%d%d&quot;,&amp;l,&amp;r);            so(l,r);//            printf(&quot;[%d,%d]&quot;,l,r);            id = query_num(rt[l],1,n,l,r);//            printf(&quot; %d&lt;=&quot;,id);            id =(id+1)&gt;&gt;1;            ans=query_id(rt[l],1,n,id);            printf(&quot; %d&quot;,ans);        }        puts(&quot;&quot;);    }    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  51nod 1255 字典序最小的子序列 []【贪心】</title>
      <link href="/2017/03/13/61912463/"/>
      <url>/2017/03/13/61912463/</url>
      
        <content type="html"><![CDATA[<h1 id="51nod-1255-字典序最小的子序列-【贪心】"><a href="#51nod-1255-字典序最小的子序列-【贪心】" class="headerlink" title="51nod 1255 字典序最小的子序列 []【贪心】"></a>51nod 1255 字典序最小的子序列 []【贪心】</h1><p>2017年03月13日 08:56:49  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：465</p><hr><p> 博客爬取于<code>2019-04-18 17:17:26</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/61912463" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/61912463</a></p><p>题目链接： <a href="http://www.51nod.com/onlineJudge/questionCode.html#!problemId=1255" target="_blank" rel="noopener"> http://www.51nod.com/onlineJudge/questionCode.html#!problemId=1255</a></p><p>————————————————————————————————————————————<br>1255 字典序最小的子序列<br>题目来源： 天津大学OJ<br>基准时间限制：1 秒 空间限制：131072 KB 分值: 40 难度：4级算法题 收藏 关注<br>给出一个由a-z组成的字符串S，求他的一个子序列，满足如下条件：</p><p>1、包含字符串中所有出现过的字符各1个。<br>2、是所有满足条件1的串中，字典序最小的。</p><p>例如：babbdcc，出现过的字符为：abcd，而包含abcd的所有子序列中，字典序最小的为abdc。<br>Input<br>输入1行字符串S，所有字符均为小写，字符串的长度为L。(1 &lt;= L &lt;= 100000)。<br>Output<br>输出包含S中所有出现过的字符，每个字符各1个，并且字典序最小的S的子序列。<br>Input示例<br>babbdcc<br>Output示例<br>abdc</p><p>————————————————————————————————————————————————</p><p>解题思路：<br>我们贪心做这道题</p><p>既然他让我们找包含所有出现过的字符的字典序最小的子串，</p><p>那么对于左右出现过的字符是很好判定的，没出现过 就加进去就好了</p><p>问题是怎么找字典序最小的，</p><p>我们可以维护一个待定的子串，<br>首先将没有出现过的字符加进去<br>但加进去的同时呢，判断下待定子串的尾字符和当前待加进去的字符那个大，<br>如果尾字符大，并且这个尾字符在后面还有出现，我们就把尾字符删除，<br>这样维护下来，我们得到的一定是字典序最小的</p><p>复杂度是  O  (  n  )  的</p><p>附本题代码<br>——————————————————————————————————————————————</p><pre><code>#include &lt;bits/stdc++.h&gt;using namespace std;/**********************************/int  vis[30],h[30];char mystack[100000+7];char str[100000+7];int  len=0;int main(){    scanf(&quot;%s&quot;,str);    int sz = strlen(str);    for(int i=0;i&lt;sz;i++)    h[str[i]-&#39;a&#39;]++;    for(int i=0;i&lt;sz;i++){        h[str[i]-&#39;a&#39;]--;        if(!vis[str[i]-&#39;a&#39;]){            while(len){                if(!h[mystack[len]-&#39;a&#39;] ||  mystack[len]&lt;str[i]) break;                vis[mystack[len]-&#39;a&#39;]=0;len--;            }            vis[str[i]-&#39;a&#39;]=1;            mystack[++len]=str[i];        }    }    for(int i=1;i&lt;=len;i++)printf(&quot;%c&quot;,mystack[i]);puts(&quot;&quot;);    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  SPOJ - COT Count on a tree [LCA+主席树]【数据结构】</title>
      <link href="/2017/03/12/61631979/"/>
      <url>/2017/03/12/61631979/</url>
      
        <content type="html"><![CDATA[<h1 id="SPOJ-COT-Count-on-a-tree-LCA-主席树-【数据结构】"><a href="#SPOJ-COT-Count-on-a-tree-LCA-主席树-【数据结构】" class="headerlink" title="SPOJ - COT Count on a tree [LCA+主席树]【数据结构】"></a>SPOJ - COT Count on a tree [LCA+主席树]【数据结构】</h1><p>2017年03月12日 20:26:05  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：662</p><hr><p> 博客爬取于<code>2019-04-18 17:17:27</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/61631979" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/61631979</a></p><p>题目链接： <a href="http://www.spoj.com/problems/COT/en/" target="_blank" rel="noopener"> http://www.spoj.com/problems/COT/en/</a><br>——————————————————————————————————————<br>COT - Count on a tree  </p><p>#tree<br>You are given a tree with N nodes.The tree nodes are numbered from 1 to N.Each<br>node has an integer weight.</p><p>We will ask you to perform the following operation:</p><p>u v k : ask for the kth minimum weight on the path from node u to node v</p><p>Input</p><p>In the first line there are two integers N and M.(N,M&lt;=100000)</p><p>In the second line there are N integers.The ith integer denotes the weight of<br>the ith node.</p><p>In the next N-1 lines,each line contains two integers u v,which describes an<br>edge (u,v).</p><p>In the next M lines,each line contains three integers u v k,which means an<br>operation asking for the kth minimum weight on the path from node u to node v.</p><p>Output</p><p>For each operation,print its result.</p><p>Example</p><p>Input:<br>8 58 5<br>105 2 9 3 8 5 7 7<br>1 2<br>1 3<br>1 4<br>3 5<br>3 6<br>3 7<br>4 8<br>2 5 1<br>2 5 2<br>2 5 3<br>2 5 4<br>7 8 2<br>Output:<br>2<br>8<br>9<br>105<br>7<br>Submit solution!</p><p>——————————————————————————————————————<br>题目大意:<br>就是求在树上 (u,v)的路上的第K小的权值</p><p>解题思路:<br>首先对于求第K小的问题 我们可以用主席树搞 ,没有问题,<br>但是对于一个树形结构,我们需要将其转化为线性,然后需要树剖才能做.</p><p>然后考虑链上的第k值怎么维护 ,<br>发现如果树剖计算的话 维护不了啊<br>因为(u,v)的路 可能在很多个链上,那么不能对每个求第K值,这样明显是错误的啊,</p><p>然后我们知道主席树其实就是维护了一个前缀和</p><p>那么我们可以对每一个节点到根节点建立前缀和,就能找任意一个节点到根节点的第K值,<br>那么根据主席树的性质,我们就能够计算(u,v)的路上的第K值了<br>只要在查询的时候稍改变一下就行了</p><pre><code>cnt = sum[ls[u]]+sum[ls[v]]-sum[ls[lca(u,v)]]-sum[ls[fa[lca(u,v)]]];</code></pre><p>不理解其实可以将主席树画出来 思考下 挺好理解的.</p><p>附本题代码<br>——————————————————————————————————————</p><pre><code>#pragma comment(linker, &quot;/STACK:1024000000,1024000000&quot;)#include&lt;bits/stdc++.h&gt;using namespace std;typedef unsigned long long int LL;inline int read(){    int x=0,f=1;char ch = getchar();    while(&#39;0&#39;&gt;ch||ch&gt;&#39;9&#39;){if(&#39;-&#39;==ch)f=-1;ch=getchar();}    while(&#39;0&#39;&lt;=ch&amp;&amp;ch&lt;=&#39;9&#39;){x=(x&lt;&lt;3)+(x&lt;&lt;1)+ch-&#39;0&#39;;ch=getchar();}    return x*f;}#define abs(x) ((x&gt;0)?x:(-x))/********************************/const int N = 100000+7;int n,m,w[N],b[N];struct node{    int to,next;}G[N&lt;&lt;1];int head[N],tot;/**ChairTree begin*/int rt[N],ls[N*20],rs[N*20],sum[N*20],chairtree,siz;void build(int &amp;rt,int l,int r){    rt=++chairtree;    sum[rt]=0;    if(l&gt;=r)return ;    int m =((r-l)&gt;&gt;1)+l;    build(ls[rt],l,m);    build(rs[rt],m+1,r);}void update(int&amp; rt,int l,int r,int last,int pos){    rt=++chairtree;    ls[rt]=ls[last];    rs[rt]=rs[last];    sum[rt]=sum[last]+1;    if(l&gt;=r) return ;    int m=((r-l)&gt;&gt;1)+l;    if(pos&lt;=m) update(ls[rt],l  ,m,ls[last],pos);    else       update(rs[rt],m+1,r,rs[last],pos);}int query(int rt,int l,int r,int last,int lca,int flca,int k){    if(l&gt;=r) return l;    int m=((r-l)&gt;&gt;1)+l;    int cnt=sum[ls[rt]]+sum[ls[last]]-sum[ls[lca]]-sum[ls[flca]];    if(k&lt;=cnt) query(ls[rt],l  ,m,ls[last],ls[lca],ls[flca],k);    else       query(rs[rt],m+1,r,rs[last],rs[lca],rs[flca],k-cnt);}void dfs(int rt,int l,int r){    int m = ((r-l)&gt;&gt;1)+l;    printf(&quot;%d&quot;,sum[rt]);    if(l&gt;=r) return ;printf(&quot;( &quot;);    dfs(ls[rt],l,m);printf(&quot;_%*d,&quot;,2,ls[rt]);    dfs(rs[rt],m+1,r);printf(&quot;_%*d )&quot;,2,rs[rt]);}/**ChairTree end*/void add(int u,int v){    G[++tot].to=v,G[tot].next=head[u],head[u]=tot;    G[++tot].to=u,G[tot].next=head[v],head[v]=tot;}int dep[N],fa[N],sz[N],son[N];void dfs1(int u,int f,int d){    dep[u]=d,fa[u]=f,sz[u]=1,son[u]=0;    for(int i=head[u],to;i;i=G[i].next){        to=G[i].to;        if(to==f)continue;        dfs1(to,u,d+1);        sz[u]+=sz[to];        if(sz[son[u]]&lt;sz[to])son[u]=to;    }}int tree[N],top[N],pre[N],cnt;void dfs2(int u,int tp){    top[u]=tp,tree[u]=++cnt,pre[tree[u]]=u;    update(rt[u],1,siz,rt[fa[u]],w[u]);    if(!son[u])return;    dfs2(son[u],tp);    for(int i=head[u],to;i;i=G[i].next){        to=G[i].to;        if(to==fa[u]||to==son[u])continue;        dfs2(to,to);    }}int Lca(int x,int y){    int fx=top[x],fy=top[y];    while(fx!=fy){        if(dep[fx]&lt;dep[fy])swap(x,y),swap(fx,fy);        x=fa[fx],fx=top[x];    }    if(dep[x]&gt;dep[y])swap(x,y);    return x;}int main(){    n=read(),m=read();    for(int i=1;i&lt;=n;i++) w[i]=read(),b[i]=w[i];    for(int i=1;i&lt; n;i++) add(read(),read());    fa[1]=0;    sort(b+1,b+n+1);    siz = unique(b+1,b+n+1)-(b+1);    for(int i=1;i&lt;=n;i++) w[i]=lower_bound(b+1,b+siz+1,w[i])-b;    build(rt[0],1,siz);    dfs1(1,0,1),dfs2(1,1);    while(m--){        int u,v,k;        u=read(),v=read(),k=read();        int lca=Lca(u,v);        printf(&quot;%d\n&quot;,(b[query(rt[u],1,siz,rt[v],rt[lca],rt[fa[lca]],k)]));    }    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  第四届山东省赛 A^X mod P [预处理]【思维】</title>
      <link href="/2017/03/12/61466246/"/>
      <url>/2017/03/12/61466246/</url>
      
        <content type="html"><![CDATA[<h1 id="第四届山东省赛-A-X-mod-P-预处理-【思维】"><a href="#第四届山东省赛-A-X-mod-P-预处理-【思维】" class="headerlink" title="第四届山东省赛 A^X mod P [预处理]【思维】"></a>第四届山东省赛 A^X mod P [预处理]【思维】</h1><p>2017年03月12日 00:03:17  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：174</p><hr><p> 博客爬取于<code>2019-04-18 17:17:28</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/61466246" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/61466246</a></p><p>题目链接： <a href="http://acm.upc.edu.cn/problem.PHP?id=2219" target="_blank" rel="noopener"> http://acm.upc.edu.cn/problem.PHP?id=2219</a><br>————————————————————————————————————<br>2219: A^X mod P<br>Time Limit: 5 Sec Memory Limit: 128 MB<br>Submit: 142 Solved: 28<br>[Submit][Status][Web Board]<br>Description<br>It’s easy for ACMer to calculate A^X mod P. Now given seven integers n, A, K,<br>a, b, m, P, and a function f(x) which defined as following.<br>f(x) = K, x = 1<br>f(x) = (a*f(x-1) + b)%m , x &gt; 1</p><p>Now, Your task is to calculate<br>( A^(f(1)) + A^(f(2)) + A^(f(3)) + …… + A^(f(n)) ) modular P.<br>Input<br>In the first line there is an integer T (1 &lt; T &lt;= 40), which indicates the<br>number of test cases, and then T test cases follow. A test case contains seven<br>integers n, A, K, a, b, m, P in one line.<br>1 &lt;= n &lt;= 10^6<br>0 &lt;= A, K, a, b &lt;= 10^9<br>1 &lt;= m, P &lt;= 10^9<br>Output<br>For each case, the output format is “Case #c: ans”.<br>c is the case number start from 1.<br>ans is the answer of this problem.<br>Sample Input<br>2<br>3 2 1 1 1 100 100<br>3 15 123 2 3 1000 107<br>Sample Output<br>Case #1: 14<br>Case #2: 63</p><p>————————————————————————————————————</p><p>题目大意：<br>就是给你7个数:<br>n  ,  A  ,  K  ,  a  ,  b  ,  m  ,  P<br>一个公式:<br>f  (  x  )  =  {  K  (  a  ∗  f  (  x  −  1  )  +  b  )  %  m  ,  x  =  1  ,<br>x  &gt; 1</p><p>问：<br>(  A  f  (  1  )  +  A  f  (  2  )  +  A  f  (  3  )  +  .  .  .  .  .  .<br>+  A  f  (  n  )  )  mod  P  .</p><p>解题思路:<br>其实思路很好构建 ,<br>只要求出  f  (  i  )  然后  O  (  n  log  n  )  的快速幂就能求解</p><p>但是这题卡了  log  ,所以不能快速幂</p><p>对于求一次幂 用快速幂会非常快 但是求多次就不是很快了</p><p>我们要先预处理出所有  {  A  x  |  x  ∈  [  1  ,  P  ]  }</p><p>发现根本存不下 ，  P  ≤  10  9  ，<br>但是我们可以预处理出<br>{  A  x  |  x  ∈  [  1  ,  P  −  −  √  ]  }<br>和<br>{  (  A  P  √  )  x  |  x  ∈  [  1  ,  P  −  −  √  ]  }<br>这样我们就可以通过一次相乘,开快速求出  Z  ∈  {  A  x  |  x  ∈  [  1  ,  P  ]  }  了</p><p>这样下来复杂度就变成了  O  (  T  n  )</p><p>附本题代码</p><p>——————————————————————————————————————————————————————————————</p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long int LL;/********************************/LL Ai[100005];LL A1e5i[100005];int main(){    int _ = 1,kcase = 0;    scanf(&quot;%d&quot;,&amp;_);    while(_--){        int n, A, K, a, b, m, P;        scanf(&quot;%d%d%d%d%d%d%d&quot;,&amp;n, &amp;A, &amp;K, &amp;a, &amp;b, &amp;m, &amp;P);        Ai[0]=1;        Ai[1]=A;        for(int i=1;i&lt;=100000;i++){            Ai[i]=Ai[i-1]*A%P;        }        A1e5i[0]=1;        A1e5i[1]=Ai[100000];        for(int i=2;i&lt;=100000;i++){            A1e5i[i]=A1e5i[1]*A1e5i[i-1]%P;        }        LL ans =0,tmp=K;        for(int i=1;i&lt;=n;i++){            ans+=Ai[tmp%100000]*A1e5i[tmp/100000];            (ans&gt;P)?ans%=P:true;            tmp=tmp*a+b,tmp%=m;        }        printf(&quot;Case #%d: &quot;,++kcase);        printf(&quot;%lld\n&quot;,ans);    }    return 0;} </code></pre>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  第四届山东省赛 A-Number and B-Number [数位dp+二分答案]【动态规划】</title>
      <link href="/2017/03/11/61441552/"/>
      <url>/2017/03/11/61441552/</url>
      
        <content type="html"><![CDATA[<h1 id="第四届山东省赛-A-Number-and-B-Number-数位dp-二分答案-【动态规划】"><a href="#第四届山东省赛-A-Number-and-B-Number-数位dp-二分答案-【动态规划】" class="headerlink" title="第四届山东省赛 A-Number and B-Number [数位dp+二分答案]【动态规划】"></a>第四届山东省赛 A-Number and B-Number [数位dp+二分答案]【动态规划】</h1><p>2017年03月11日 23:13:13  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：342</p><hr><p> 博客爬取于<code>2019-04-18 17:17:29</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/61441552" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/61441552</a></p><p>题目链接： <a href="http://acm.hrbust.edu.cn/index.php?m=ProblemSet&amp;a=showProblem&amp;problem_id=2053" target="_blank" rel="noopener"> hrbust的oj上有题目 </a></p><p>————————————————————————————————<br>A-Number and B-Number<br>Time Limit: 1000 MS Memory Limit: 32768 K<br>Total Submit: 22(8 users) Total Accepted: 5(5 users) Rating: Special Judge: No<br>Description<br>Tom is very interested in number problem. Nowadays he is thinking of a problem<br>about A-number and B-number.</p><p>A-number is a positive integer whose decimal form contains 7 or it can be<br>divided by 7. We can write down the first 10 A-number ( a[i] is the ith<br>A-number)</p><p>{a[1]=7,a[2]=14,a[3]=17,a[4]=21,a[5]=27,a[6]=28,a[7]=35,a[8]=37,a[9]=42,a[10]=<br>47};</p><p>B-number is Sub-sequence of A-number which contains all A-number but a[k] (<br>that k is a A-number.) Like 35, is the 7th A-number and 7 is also an A-number<br>so the 35 ( a[7] ) is not a B-number. We also can write down the first 10<br>B-number.</p><p>{b[1]=7,b[2]=14,b[3]=17,b[4]=21,b[5]=27,b[6]=28,b[7]=37,b[8]=42,b[9]=47,b[10]=<br>49};</p><p>Now Given an integer N, please output the Nth B-number.</p><p>Input<br>The input consists of multiple test cases.</p><p>For each test case, there will be a positive integer N as the description.  (<br>0  &lt; N  &lt; 2  63  −  1  )</p><p>Output<br>For each test case, output an integer indicating the Nth B-number.</p><p>You can assume the result will be no more then 2^63-1.</p><p>Sample Input<br>1<br>7<br>100<br>Sample Output<br>7<br>37<br>470</p><p>——————————————————————————————————</p><p>题目大意:<br>A数组就是民间游戏”敲七”的序列<br>B数组就是  {  x  ∣  ∣  x  i  ∈  {  A  }  且  i  ∉  {  A  }  }<br>然后输出B数组中第n个元素即:  B  n</p><p>解题思路:</p><p>如果直接求第i个元素的话 无论是A数组还是B数组都不能求(反正我不会)</p><p>但是他求得是第  i  个元素 我们可以换一个角度来思考</p><p>首先我们可以用一个入门级别的数位dp来统计小于  n  的元素个数,</p><p>那么反过来 [1,n]中 最小的有x个元素的n 就是第x个元素</p><p>那么我们就可以用二分答案来统计了</p><p>对于A数组我们很好数位dp<br>但是对于B数组我们不能直接求出来</p><p>但是考虑A与B数组的关系,发现,只要对cal(x)统计的结果ans在统计一下相减即可;</p><p>即:</p><pre><code>A = cal(x);B = A - cal(A);</code></pre><p>注意<br>二分溢出的问题<br>最大值要(1&lt;&lt;63)-1,</p><p>附本题代码<br>——————————————————————————————————————————————</p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long int LL;/********************************/int num[20];LL dp[20][8][2];LL dfs(int pos,int mod,int limit,int status){    if(pos&lt;0) return (status||mod%7==0);    if(dp[pos][mod][status]!=-1&amp;&amp;!limit) return dp[pos][mod][status]; //忘写 limit  懵逼1000天有没有    int endi=9;    if(limit) endi=num[pos];    LL res = 0;    for(int i=0;i&lt;=endi;i++)        res+=dfs(pos-1,(mod*10+i)%7,limit&amp;&amp;i==endi,i==7||status);    if(!limit) dp[pos][mod][status] = res;    return res;}LL cal(LL x){    if(!x) return 0;    int len=0;    while(x)   num[len++]=x%10,x/=10;    return dfs(len-1,0,1,0)-1;}void solve(LL x){    LL l=7,r=(1ll&lt;&lt;63)-1,mid,ans=-1;  //r写成1e18 wa懵逼有没有,,,,    while(l&lt;=r){        mid=((r-l)&gt;&gt;1)+l;        LL tmp = cal(mid);        tmp -= cal(tmp);        if(tmp&gt;=x)ans=mid,r=mid-1;        else l=mid+1;    }    printf(&quot;%lld\n&quot;,ans);}int main(){//    printf(&quot;%lld\n&quot;,~(1ll&lt;&lt;63));    memset(dp,-1,sizeof(dp));    LL n;    while(~scanf(&quot;%lld&quot;,&amp;n)) solve(n);    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  SPOJ DQUERY - D-query [树状数组+离线 || 主席树 ]【数据结构】</title>
      <link href="/2017/03/11/61416622/"/>
      <url>/2017/03/11/61416622/</url>
      
        <content type="html"><![CDATA[<h1 id="SPOJ-DQUERY-D-query-树状数组-离线-主席树-【数据结构】"><a href="#SPOJ-DQUERY-D-query-树状数组-离线-主席树-【数据结构】" class="headerlink" title="SPOJ DQUERY - D-query [树状数组+离线 || 主席树 ]【数据结构】"></a>SPOJ DQUERY - D-query [树状数组+离线 || 主席树 ]【数据结构】</h1><p>2017年03月11日 14:18:35  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：252</p><hr><p> 博客爬取于<code>2019-04-18 17:17:30</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/61416622" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/61416622</a></p><p>题目连接: <a href="http://www.spoj.com/problems/DQUERY/" target="_blank" rel="noopener"> http://www.spoj.com/problems/DQUERY/</a></p><p>——————————————————————————————————————————<br>DQUERY - D-query  </p><p>#sorting #tree<br>English Vietnamese<br>Given a sequence of n numbers a1, a2, …, an and a number of d-queries. A<br>d-query is a pair (i, j) (1 ≤ i ≤ j ≤ n). For each d-query (i, j), you have to<br>return the number of distinct elements in the subsequence ai, ai+1, …, aj.</p><p>Input</p><p>Line 1: n (1 ≤ n ≤ 30000).<br>Line 2: n numbers a1, a2, …, an (1 ≤ ai ≤ 106).<br>Line 3: q (1 ≤ q ≤ 200000), the number of d-queries.<br>In the next q lines, each line contains 2 numbers i, j representing a d-query<br>(1 ≤ i ≤ j ≤ n).<br>Output</p><p>For each d-query (i, j), print the number of distinct elements in the<br>subsequence ai, ai+1, …, aj in a single line.<br>Example</p><p>Input<br>5<br>1 1 2 1 3<br>3<br>1 5<br>2 4<br>3 5</p><p>Output<br>3<br>2<br>3<br>——————————————————————————————————————————<br>题目大意：<br>就是给你一个序列 ，和q次询问，<br>询问  [  l  ,  r  ]  区间不同元素的个数</p><p>解题思路：<br>本来是做的主席树专题 ，然而主席树怎么做 还不会，</p><p>于是就用离线树状数组的做法水了一发</p><p>主要就是对询问的r值 排序。<br>然后遍历一遍序列，<br>每次对在树状数组上更新  a  i  最后一次出现的位置,如果已经出现了 就将之前出现过的删掉就好了</p><p>每次维护查询 就是计算  [  l  ,  r  ]  区间标记的个数</p><p>============== 主席树的做法 Update===================</p><p>仔细想了想主席树的做法，<br>其实思路上和离线的树状数组并没有什么区别，<br>但是因为主席树的特性，我们可以维护一颗颗树，所以能拿到线上解决这个问题</p><p>在一颗颗树进行更新的时候,当这个值出现过,我们就将之前的删去,然后在更新,就好了</p><p>对树的维护和线段树基本相同,不赘述了</p><p>但是在处理的时候发现一个问题</p><pre><code>int tem;for(int i=1;i&lt;=n;i++){    tem=rt[i-1];    if(vis[a[i]])update(tem,1,n,rt[i-1],vis[a[i]],-1);    update(rt[i],1,n,tem,i,1);    vis[a[i]]=i;}</code></pre><p>上面的能AC 而下面的却不能</p><pre><code>for(int i=1;i&lt;=n;i++){    if(vis[a[i]])update(rt[i],1,n,rt[i-1],vis[a[i]],-1);    update(rt[i],1,n,rt[i],i,1);    vis[a[i]]=i;}</code></pre><p>最后也没弄明白怎么回事</p><p>附本题代码<br>——————————————————————————————————————————</p><pre><code>/***树状数组离线*/int n,Q;int a[30007],vis[1000007];struct node{    int l, r,id;}q[200007];int ans[200007];bool cmp(node A,node B){    if(A.r==B.r) return A.l&lt;B.l;    return A.r&lt;B.r;}int sum[1000007];#define lowbit(x) (x&amp;-x)void update(int i,int v){for(;i&lt;=n;i+=lowbit(i))sum[i]+=v;}int getSum(int i){int ans=0;for(;i;i-=lowbit(i))ans+=sum[i];return ans;}int main(){    scanf(&quot;%d&quot;,&amp;n);    for(int i=1;i&lt;=n;i++)   scanf(&quot;%d&quot;,&amp;a[i]);    scanf(&quot;%d&quot;,&amp;Q);    for(int i=1;i&lt;=Q;i++)   scanf(&quot;%d%d&quot;,&amp;q[i].l,&amp;q[i].r),q[i].id=i;    sort(q+1,q+1+Q,cmp);    for(int i=1,j=1;i&lt;=n&amp;&amp;j&lt;=Q;i++){        if(vis[a[i]]) update(vis[a[i]],-1);        vis[a[i]]=i;  update(i,1);        while(j&lt;=Q&amp;&amp;q[j].r&lt;=i){            ans[q[j].id]=getSum(q[j].r)-getSum(q[j].l-1);            j++;        }    }    for(int i=1;i&lt;=Q;i++)printf(&quot;%d\n&quot;,ans[i]);    return 0;}/**主席树*/#pragma comment(linker, &quot;/STACK:1024000000,1024000000&quot;)#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long int LL;const int    INF = (~(1&lt;&lt;31));const int    N   = 30000+7;const double eps = 1e-7;inline int read(){    int x=0,f=1;char ch = getchar();    while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;){if(ch==&#39;-&#39;)f=-1;ch=getchar();}    while(&#39;0&#39;&lt;=ch&amp;&amp;ch&lt;=&#39;9&#39;){x=(x&lt;&lt;3)+(x&lt;&lt;1)+ch-&#39;0&#39;;ch=getchar();}    return x*f;}/****************************************************/int ls[N*20],rs[N*20],sum[N*20],rt[N],tot,vis[N];int n,q,ql,qr,x,a[N],b[N];void build(int &amp;rt,int l,int r){    rt=++tot;    sum[rt]=0;    if(l==r) return ;    int m = (r+l)&gt;&gt;1;    build(ls[rt],l,m);    build(rs[rt],m+1,r);}void update(int &amp;rt,int l,int r,int last,int pos,int v){    rt = ++tot;    ls[rt] =ls[last];    rs[rt] =rs[last];    sum[rt]=sum[last]+v;    if(l==r) return ;    int m = (r+l)&gt;&gt;1;    if(pos&lt;=m) update(ls[rt],l  ,m,ls[last],pos,v);    else       update(rs[rt],m+1,r,rs[last],pos,v);}int query(int ss,int tt,int l,int r,int L,int R){    if(L&lt;=l&amp;&amp;r&lt;=R) return sum[tt]-sum[ss];    int m = (l+r)&gt;&gt;1;    int ans = 0;    if(L&lt;=m)  ans+=query(ls[ss],ls[tt],l  ,m,L,R);    if(R&gt; m)  ans+=query(rs[ss],rs[tt],m+1,r,L,R);    return ans ;}int main(){    while(~scanf(&quot;%d&quot;,&amp;n)){        tot=0;        memset(vis,0,sizeof(vis));        memset(rt,0,sizeof(rt));        for(int i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,a+i),b[i]=a[i];        sort(b+1,b+n+1);        int sz=unique(b+1,b+n+1)-(b+1);        for(int i=0;i&lt;=n;i++) vis[i]=0;        tot = 0;        build(rt[0],1,n);        for(int i=1;i&lt;=n;i++) a[i]=lower_bound(b+1,b+sz+1,a[i])-b;//        for(int i=1;i&lt;=n;i++) printf(&quot;%d%c&quot;,b[i],(i==n)?&#39;\n&#39;:&#39; &#39;);//        for(int i=1;i&lt;=n;i++) printf(&quot;%d%c&quot;,a[i],(i==n)?&#39;\n&#39;:&#39; &#39;);        int tem;        for(int i=1;i&lt;=n;i++){            tem=rt[i-1];            if(vis[a[i]])update(tem,1,n,rt[i-1],vis[a[i]],-1);            update(rt[i],1,n,tem,i,1);            vis[a[i]]=i;        }        scanf(&quot;%d&quot;,&amp;q);        while(q--){            scanf(&quot;%d%d&quot;,&amp;ql,&amp;qr);            printf(&quot;%d\n&quot;,query(rt[ql-1],rt[qr],1,n,ql,qr));        }    }    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  POJ 2104 K-th Number [主席树入门]【数据结构】</title>
      <link href="/2017/03/10/61209605/"/>
      <url>/2017/03/10/61209605/</url>
      
        <content type="html"><![CDATA[<h1 id="POJ-2104-K-th-Number-主席树入门-【数据结构】"><a href="#POJ-2104-K-th-Number-主席树入门-【数据结构】" class="headerlink" title="POJ 2104 K-th Number [主席树入门]【数据结构】"></a>POJ 2104 K-th Number [主席树入门]【数据结构】</h1><p>2017年03月10日 21:51:50  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：404</p><hr><p> 博客爬取于<code>2019-04-18 17:17:31</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/61209605" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/61209605</a></p><p>题目链接: <a href="http://poj.org/problem?id=2104" target="_blank" rel="noopener"> http://poj.org/problem?id=2104 </a><br>————————————————————————————————————————————————<br>K-th Number<br>Time Limit: 20000MS Memory Limit: 65536K<br>Total Submissions: 53824 Accepted: 18506<br>Case Time Limit: 2000MS<br>Description</p><p>You are working for Macrohard company in data structures department. After<br>failing your previous task about key insertion you were asked to write a new<br>data structure that would be able to return quickly k-th order statistics in<br>the array segment.<br>That is, given an array a[1…n] of different integer numbers, your program must<br>answer a series of questions Q(i, j, k) in the form: “What would be the k-th<br>number in a[i…j] segment, if this segment was sorted?”<br>For example, consider the array a = (1, 5, 2, 6, 3, 7, 4). Let the question be<br>Q(2, 5, 3). The segment a[2…5] is (5, 2, 6, 3). If we sort this segment, we<br>get (2, 3, 5, 6), the third number is 5, and therefore the answer to the<br>question is 5.<br>Input</p><p>The first line of the input file contains n — the size of the array, and m —<br>the number of questions to answer (1 &lt;= n &lt;= 100 000, 1 &lt;= m &lt;= 5 000).<br>The second line contains n different integer numbers not exceeding 109 by<br>their absolute values — the array for which the answers should be given.<br>The following m lines contain question descriptions, each description consists<br>of three numbers: i, j, and k (1 &lt;= i &lt;= j &lt;= n, 1 &lt;= k &lt;= j - i + 1) and<br>represents the question Q(i, j, k).<br>Output</p><p>For each question output the answer to it — the k-th number in sorted a[i…j]<br>segment.<br>Sample Input</p><p>7 3<br>1 5 2 6 3 7 4<br>2 5 3<br>4 4 1<br>1 7 3<br>Sample Output</p><p>5<br>6<br>3<br>Hint</p><p>This problem has huge input,so please use c-style input(scanf,printf),or you<br>may got time limit exceed.</p><p>——————————————————————————————————————————————————————</p><p>题目大意：<br>求区间第k大的数值</p><p>解题思路:<br>算法不用想 妥妥的主席树啊</p><p>之前一直没有学习主席树,就是理解不了主席树,<br>今天找到了一个很好的<br><a href="http://www.cnblogs.com/zyf0163/p/4749042.html" target="_blank" rel="noopener"> 博客1 </a><br><a href="http://blog.csdn.net/metalseed/article/details/8045038" target="_blank" rel="noopener"> 博客2 </a></p><p>算是明白了什么是主席树,</p><p>主席树为了保存历史版本的状态 ,于是在每次更新的时候都在开出一条链来代表新建出来的节点,</p><p><img src="https://img-blog.csdn.net/20170310214521801?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzMxODQxNzE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="此处应该有图"></p><p>这样就不用每次在建一颗树了</p><p>其实主席树是一种 <strong> 函数式 </strong> 线段树</p><p>寻找  [  l  ,  r  ]  区间的值其实也就成了找 第  R  个版本-第  l  −  1  个版本 就是我们要查询的值了</p><p>附本题代码<br>——————————————————————————————————————————————————</p><pre><code>#pragma comment(linker, &quot;/STACK:1024000000,1024000000&quot;)//#include&lt;bits/stdc++.h&gt;#include &lt;stdio.h&gt;#include &lt;algorithm&gt;using namespace std;typedef long long int LL;const int    INF = (~(1&lt;&lt;31));const int    N   = 100000+7;const double eps = 1e-7;inline int read(){    int x=0,f=1;char ch = getchar();    while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;){if(ch==&#39;-&#39;)f=-1;ch=getchar();}    while(&#39;0&#39;&lt;=ch&amp;&amp;ch&lt;=&#39;9&#39;){x=(x&lt;&lt;3)+(x&lt;&lt;1)+ch-&#39;0&#39;;ch=getchar();}    return x*f;}/****************************************************/int rt[N*20],ls[N*20],rs[N*20],sum[N*20],tot;int n,q,ql,qr,x,a[N],b[N],sz;void build(int &amp;rt,int l,int r){    rt=++tot;    sum[rt]=0;    if(l==r) return ;    int m = (r+l)&gt;&gt;1;    build(ls[rt],l,m);    build(rs[rt],m+1,r);}void update(int &amp;rt,int l,int r,int last,int pos){    rt = ++tot;    ls[rt]=ls[last];    rs[rt]=rs[last];    sum[rt]=sum[last]+1;    if(l==r) return ;    int m = (r+l)&gt;&gt;1;    if(pos&lt;=m) update(ls[rt],l,m,ls[last],pos);    else       update(rs[rt],m+1,r,rs[last],pos);}int query(int ss,int tt,int l,int r,int k){    if(l==r)return l;    int m = (l+r)&gt;&gt;1;    int cnt=sum[ls[tt]]-sum[ls[ss]];    if(k&lt;=cnt)return query(ls[ss],ls[tt],l,m,k);    else  return query(rs[ss],rs[tt],m+1,r,k-cnt);}void qq(){    scanf(&quot;%d%d%d&quot;,&amp;ql,&amp;qr,&amp;x);    printf(&quot;%d\n&quot;,b[query(rt[ql-1],rt[qr],1,sz,x)]);}int main(){    while(~scanf(&quot;%d%d&quot;,&amp;n,&amp;q)){        for(int i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,a+i),b[i]=a[i];        sort(b+1,b+n+1);        sz=unique(b+1,b+n+1)-(b+1);        tot = 0;        build(rt[0],1,sz);        for(int i=1;i&lt;=n;i++)a[i]=lower_bound(b+1,b+sz+1,a[i])-b;        for(int i=1;i&lt;=n;i++)update(rt[i],1,sz,rt[i-1],a[i]);        while(q--)qq();    }    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  hdu 5416 CRB and Tree [思维]【树】</title>
      <link href="/2017/03/10/61023246/"/>
      <url>/2017/03/10/61023246/</url>
      
        <content type="html"><![CDATA[<h1 id="hdu-5416-CRB-and-Tree-思维-【树】"><a href="#hdu-5416-CRB-and-Tree-思维-【树】" class="headerlink" title="hdu 5416 CRB and Tree [思维]【树】"></a>hdu 5416 CRB and Tree [思维]【树】</h1><p>2017年03月10日 00:33:47  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：203</p><hr><p> 博客爬取于<code>2019-04-18 17:17:32</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/61023246" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/61023246</a></p><p>题目连接： <a href="http://acm.hdu.edu.cn/showproblem.php?pid=5416" target="_blank" rel="noopener"> http://acm.hdu.edu.cn/showproblem.php?pid=5416</a><br>————————————————————————————————<br>CRB and Tree</p><p>Time Limit: 8000/4000 MS (Java/Others) Memory Limit: 65536/65536 K<br>(Java/Others)<br>Total Submission(s): 2145 Accepted Submission(s): 648</p><p>Problem Description<br>CRB has a tree, whose vertices are labeled by 1, 2, …, N. They are connected<br>by N – 1 edges. Each edge has a weight.<br>For any two vertices u and v(possibly equal), f(u,v) is xor(exclusive-or) sum<br>of weights of all edges on the path from u to v.<br>CRB’s task is for given s, to calculate the number of unordered pairs (u,v)<br>such that f(u,v) = s. Can you help him?</p><p>Input<br>There are multiple test cases. The first line of input contains an integer T,<br>indicating the number of test cases. For each test case:<br>The first line contains an integer N denoting the number of vertices.<br>Each of the next N - 1 lines contains three space separated integers a, b and<br>c denoting an edge between a and b, whose weight is c.<br>The next line contains an integer Q denoting the number of queries.<br>Each of the next Q lines contains a single integer s.<br>1 ≤ T ≤ 25<br>1 ≤ N ≤ 105<br>1 ≤ Q ≤ 10<br>1 ≤ a, b ≤ N<br>0 ≤ c, s ≤ 105<br>It is guaranteed that given edges form a tree.</p><p>Output<br>For each query, output one line containing the answer.</p><p>Sample Input<br>1<br>3<br>1 2 1<br>2 3 2<br>3<br>2<br>3<br>4</p><p>Sample Output<br>1<br>1<br>0<br>Hint</p><p>For the first query, (2, 3) is the only pair that f(u, v) = 2.<br>For the second query, (1, 3) is the only one.<br>For the third query, there are no pair (u, v) such that f(u, v) = 4.</p><p>————————————————————————————————<br>题目大意：<br>在一棵n个节点的生成树树上,每个边有一个边权<br>就是定义f(u,v)为树上u-&gt;v路径上边权的异或和 ,<br>有q次查询,每次问你在这棵树上,f()=s的情况有多少种</p><p>解题思路:<br>这其实是一个思维题<br>通过遍历我们能够知道每一个点到根节点路径上的异或和<br>因为异或运算满足消去律,所以f(1,u)^f(1,v)=f(u,v);</p><p>通过这些我们就好计算了, 只要一遍dfs预处理出每个点到根节点的f(),hash一下 ,<br>最后计算就行</p><p>注意一下 0的情况就行了</p><p>附本题代码<br>—————————————————————————————————————————————————</p><pre><code>#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long int LL;const int    INF = (~(1&lt;&lt;31));const int    N   = 100000+7;const double eps = 1e-7;inline int read(){    int x=0,f=1;char ch = getchar();    while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;){if(ch==&#39;-&#39;)f=-1;ch=getchar();}    while(&#39;0&#39;&lt;=ch&amp;&amp;ch&lt;=&#39;9&#39;){x=(x&lt;&lt;3)+(x&lt;&lt;1)+ch-&#39;0&#39;;ch=getchar();}    return x*f;}/****************************************************/struct edge{    int to,next,w;}T[N&lt;&lt;1];int head[N],tot;int xt[N],mx;int cnt[N&lt;&lt;1];void add(int u,int v,int w){    T[tot].w=w,T[tot].to=v,T[tot].next=head[u],head[u]=tot++;    T[tot].w=w,T[tot].to=u,T[tot].next=head[v],head[v]=tot++;}void dfs(int u,int fa,int xr){    xt[u]=xr,cnt[xr]++;    mx=(mx&gt;xr)?mx:xr;    for(int i=head[u],to;i!=-1;i=T[i].next){        to=T[i].to;        if(to==fa) continue;        dfs(to,u,xr^T[i].w);    }}int main(){    int _;    scanf(&quot;%d&quot;,&amp;_);    while(_--){        mx = tot = 0;        memset(cnt,0,sizeof(cnt));        memset(head,-1,sizeof(head));        int n;        scanf(&quot;%d&quot;,&amp;n);        for(int i=1,u,v,w;i&lt;n;i++){            scanf(&quot;%d%d%d&quot;,&amp;u,&amp;v,&amp;w);            add(u,v,w);        }        dfs(1,-1,0);        int q,x;        scanf(&quot;%d&quot;,&amp;q);        while(q--){            scanf(&quot;%d&quot;,&amp;x);            LL ans = 0ll;            for(int i=1;i&lt;=n;i++){                //if((xt[i]^i)&gt;mx) continue;                ans+=cnt[x^xt[i]];            }            if(!x) ans+=n;            ans&gt;&gt;=1;            printf(&quot;%I64d\n&quot;,ans);        }    }    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  POJ 2763 Housewife Wind [树链剖分(边权)+树状数组]【数据结构】</title>
      <link href="/2017/03/09/60982742/"/>
      <url>/2017/03/09/60982742/</url>
      
        <content type="html"><![CDATA[<h1 id="POJ-2763-Housewife-Wind-树链剖分-边权-树状数组-【数据结构】"><a href="#POJ-2763-Housewife-Wind-树链剖分-边权-树状数组-【数据结构】" class="headerlink" title="POJ 2763 Housewife Wind [树链剖分(边权)+树状数组]【数据结构】"></a>POJ 2763 Housewife Wind [树链剖分(边权)+树状数组]【数据结构】</h1><p>2017年03月09日 22:59:37  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：236</p><hr><p> 博客爬取于<code>2019-04-18 17:17:34</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/60982742" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/60982742</a></p><p>题目连接： <a href="http://poj.org/problem?id=2763" target="_blank" rel="noopener"> http://poj.org/problem?id=2763 </a><br>————————————————————————–.<br>Housewife Wind<br>Time Limit: 4000MS Memory Limit: 65536K<br>Total Submissions: 10703 Accepted: 2969<br>Description</p><p>After their royal wedding, Jiajia and Wind hid away in XX Village, to enjoy<br>their ordinary happy life. People in XX Village lived in beautiful huts. There<br>are some pairs of huts connected by bidirectional roads. We say that huts in<br>the same pair directly connected. XX Village is so special that we can reach<br>any other huts starting from an arbitrary hut. If each road cannot be walked<br>along twice, then the route between every pair is unique.</p><p>Since Jiajia earned enough money, Wind became a housewife. Their children<br>loved to go to other kids, then make a simple call to Wind: ‘Mummy, take me<br>home!’</p><p>At different times, the time needed to walk along a road may be different. For<br>example, Wind takes 5 minutes on a road normally, but may take 10 minutes if<br>there is a lovely little dog to play with, or take 3 minutes if there is some<br>unknown strange smell surrounding the road.</p><p>Wind loves her children, so she would like to tell her children the exact time<br>she will spend on the roads. Can you help her?<br>Input</p><p>The first line contains three integers n, q, s. There are n huts in XX<br>Village, q messages to process, and Wind is currently in hut s. n &lt; 100001 , q<br>&lt; 100001.</p><p>The following n-1 lines each contains three integers a, b and w. That means<br>there is a road directly connecting hut a and b, time required is w. 1&lt;=w&lt;=<br>10000.</p><p>The following q lines each is one of the following two types:</p><p>Message A: 0 u<br>A kid in hut u calls Wind. She should go to hut u from her current position.<br>Message B: 1 i w<br>The time required for i-th road is changed to w. Note that the time change<br>will not happen when Wind is on her way. The changed can only happen when Wind<br>is staying somewhere, waiting to take the next kid.<br>Output</p><p>For each message A, print an integer X, the time required to take the next<br>child.<br>Sample Input</p><p>3 3 1<br>1 2 1<br>2 3 2<br>0 2<br>1 2 3<br>0 3<br>Sample Output</p><p>1<br>3<br>————————————————————————–.<br>题目大意：<br>一颗n个节点的生成树，有边权，一个人开始在s位置，有两种操作，<br>1） 0 a 从s走到n 输出路径长度<br>2） 1 a b 将第a条边的权值变成b</p><p>解题思路：<br>这题就是基于边权的树链剖分。找路径的和我们可以采用树状数组维护</p><p>其实边权对于点权来说，基本一样，我们只要将u-&gt;v的权值给u，v中距离根节点远的就行了<br>然后查找的时候再讲lca(u,v)这个点的权值减去 得到的就是u-&gt;v的路径长度</p><p>注意下本题卡时间卡的非常紧<br>vector是不行的 要用前向星 .</p><p>附本题代码<br>————————————————————————–.</p><pre><code>#include &lt;stdio.h&gt;#include &lt;vector&gt;using namespace std;typedef long long int LL;const int    INF = (~(1&lt;&lt;31));const int    N   = 100000+7;const double eps = 1e-7;inline int read(){    int x=0,f=1;char ch = getchar();    while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;){if(ch==&#39;-&#39;)f=-1;ch=getchar();}    while(&#39;0&#39;&lt;=ch&amp;&amp;ch&lt;=&#39;9&#39;){x=(x&lt;&lt;3)+(x&lt;&lt;1)+ch-&#39;0&#39;;ch=getchar();}    return x*f;}/****************************************************/int n,q,s;int head[N],tot;struct edge{    int to,next;}G[N*10];int temp;void myswap(int &amp;a,int &amp;b){    temp=a;    a=b;    b=temp;}void add(int u,int v){    G[tot].to=v;G[tot].next=head[u];head[u]=tot++;    G[tot].to=u;G[tot].next=head[v];head[v]=tot++;}int dep[N],fa[N],sz[N],son[N];int top[N],tree[N],cnt;void dfs1(int u,int ff,int deep){    son[u]=0;fa[u]=ff;sz[u]=1;dep[u]=deep;    for(int i=head[u];i!=-1;i=G[i].next){        int v=G[i].to;        if(v==ff) continue;        dfs1(v,u,deep+1);        sz[u]+=sz[v];        if(sz[v]&gt;sz[son[u]]) son[u]=v;    }}void dfs2(int u,int ff){    tree[u]=++cnt;top[u]=ff;    if(son[u]) dfs2(son[u],ff);    else return ;    for(int i=head[u];i!=-1;i=G[i].next){        int v=G[i].to;        if(v!=fa[u]&amp;&amp;v!=son[u]) dfs2(v,v);    }}int sum[N];#define lowbit(x) (x&amp;-x)void update(int i,int val){    for(;i&amp;&amp;i&lt;=n;i+=lowbit(i))        sum[i]+=val;}int getSum(int i){    int ans=0;    for(;i;i-=lowbit(i))ans+=sum[i];    return ans;}int findi(int x,int y){    int fx=top[x],fy=top[y];    int ans = 0;    while(fx!=fy){        if(dep[fx]&lt;dep[fy]) myswap(x,y),myswap(fx,fy);        ans+=getSum(tree[x])-getSum(tree[fx]-1);        x=fa[fx],fx=top[x];    }    if(dep[x]&gt;dep[y]) myswap(x,y);    if(x!=y) ans+=getSum(tree[y])-getSum(tree[x]);    return ans ;}void init(){    for(int i=0;i&lt;=n;i++) son[i]=0;    cnt=tot=0;    for(int i=0;i&lt;=n;i++) head[i]=-1;}int u[N],v[N],w[N];int main(){    while(~scanf(&quot;%d%d%d&quot;,&amp;n,&amp;q,&amp;s)){        init();        for(int i=1;i&lt;n;i++){            u[i]=read(),v[i]=read(), w[i]=read();            add(u[i], v[i]);        }        dfs1(1,0,1);        dfs2(1,1);        for(int i=1;i&lt;n;i++){            if(fa[ u[i]]== v[i]) myswap( u[i], v[i]);            update(tree[ v[i]], w[i]);        }        int op,id,ww,b;        while(q--){            op=read();            if(op){                id=read(),ww=read();                update(tree[v[id]],ww-w[id]);                w[id]=ww;            }            else {                b=read();                printf(&quot;%d\n&quot;,findi(s,b));                s=b;            }        }        for(int i=0;i&lt;=n;i++) sum[i]=0;    }    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  HDU 3966 Aragorn&#39;s Story [树链剖分(点权)+树状数组]【数据结构】</title>
      <link href="/2017/03/09/60957820/"/>
      <url>/2017/03/09/60957820/</url>
      
        <content type="html"><![CDATA[<h1 id="HDU-3966-Aragorn’s-Story-树链剖分-点权-树状数组-【数据结构】"><a href="#HDU-3966-Aragorn’s-Story-树链剖分-点权-树状数组-【数据结构】" class="headerlink" title="HDU 3966 Aragorn’s Story [树链剖分(点权)+树状数组]【数据结构】"></a>HDU 3966 Aragorn’s Story [树链剖分(点权)+树状数组]【数据结构】</h1><p>2017年03月09日 12:32:57  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：380</p><hr><p> 博客爬取于<code>2019-04-18 17:17:35</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/60957820" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/60957820</a></p><p>题目连接： <a href="http://acm.hdu.edu.cn/showproblem.php?pid=3966" target="_blank" rel="noopener"> http://acm.hdu.edu.cn/showproblem.php?pid=3966</a></p><p>——————————————————————————-.<br>Aragorn’s Story</p><p>Time Limit: 10000/3000 MS (Java/Others) Memory Limit: 32768/32768 K<br>(Java/Others)<br>Total Submission(s): 10824 Accepted Submission(s): 2838</p><p>Problem Description<br>Our protagonist is the handsome human prince Aragorn comes from The Lord of<br>the Rings. One day Aragorn finds a lot of enemies who want to invade his<br>kingdom. As Aragorn knows, the enemy has N camps out of his kingdom and M<br>edges connect them. It is guaranteed that for any two camps, there is one and<br>only one path connect them. At first Aragorn know the number of enemies in<br>every camp. But the enemy is cunning , they will increase or decrease the<br>number of soldiers in camps. Every time the enemy change the number of<br>soldiers, they will set two camps C1 and C2. Then, for C1, C2 and all camps on<br>the path from C1 to C2, they will increase or decrease K soldiers to these<br>camps. Now Aragorn wants to know the number of soldiers in some particular<br>camps real-time.</p><p>Input<br>Multiple test cases, process to the end of input.</p><p>For each case, The first line contains three integers N, M, P which means<br>there will be N(1 ≤ N ≤ 50000) camps, M(M = N-1) edges and P(1 ≤ P ≤ 100000)<br>operations. The number of camps starts from 1.</p><p>The next line contains N integers A1, A2, …AN(0 ≤ Ai ≤ 1000), means at first<br>in camp-i has Ai enemies.</p><p>The next M lines contains two integers u and v for each, denotes that there is<br>an edge connects camp-u and camp-v.</p><p>The next P lines will start with a capital letter ‘I’, ‘D’ or ‘Q’ for each<br>line.</p><p>‘I’, followed by three integers C1, C2 and K( 0≤K≤1000), which means for camp<br>C1, C2 and all camps on the path from C1 to C2, increase K soldiers to these<br>camps.</p><p>‘D’, followed by three integers C1, C2 and K( 0≤K≤1000), which means for camp<br>C1, C2 and all camps on the path from C1 to C2, decrease K soldiers to these<br>camps.</p><p>‘Q’, followed by one integer C, which is a query and means Aragorn wants to<br>know the number of enemies in camp C at that time.</p><p>Output<br>For each query, you need to output the actually number of enemies in the<br>specified camp.</p><p>Sample Input<br>3 2 5<br>1 2 3<br>2 1<br>2 3<br>I 1 3 5<br>Q 2<br>D 1 2 2<br>Q 1<br>Q 3</p><p>Sample Output<br>7<br>4<br>8<br>Hint</p><p>1.The number of enemies may be negative.</p><p>2.Huge input, be careful.</p><p>————————————————————————-.</p><p>题目大意：<br>给一棵树 ，n个节点，m条变，q个操作，<br>操作有三种，<br>1） I C1 C2 K 将点c1 到点c2的每个点 权值+k<br>2） D C1 C2 K 将点c1 到点c2的每个点 权值-k<br>3） Q C 查询当前点C的权值</p><p>解题思路：<br>还是树链剖分的入门 ，</p><p>但是这题简单在 只要用树状数组维护就行了，</p><p>坑比的我居然折在了输入上，</p><p>也后输入字符一论用  字  符  串  输入 ，</p><p>附本题代码<br>—————————————————————————.</p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long int LL;const int    INF = (~(1&lt;&lt;31));const int    N   = 50000+7;const double eps = 1e-7;inline int read(){    int x=0,f=1;char ch = getchar();    while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;){if(ch==&#39;-&#39;)f=-1;ch=getchar();}    while(&#39;0&#39;&lt;=ch&amp;&amp;ch&lt;=&#39;9&#39;){x=(x&lt;&lt;3)+(x&lt;&lt;1)+ch-&#39;0&#39;;ch=getchar();}    return x*f;}/****************************************************/int w[N],n,m,q;vector&lt;int &gt;G[N];void add(int u,int v){    G[u].push_back(v);    G[v].push_back(u);}int fa[N],dep[N],son[N],sz[N];void dfs1(int u,int f,int d){    fa[u]=f,dep[u]=d,sz[u]=1;    int gz=G[u].size();    for(int to,i=0;i&lt;gz;i++){        to=G[u][i];        if(to==f) continue;        dfs1(to,u,d+1);        sz[u]+=sz[to];        if(sz[son[u]]&lt;sz[to])son[u]=to;    }}int top[N],tree[N],pre[N],cnt;void dfs2(int u,int tp){    top[u]=tp,tree[u]=++cnt,pre[tree[u]]=u;    if(son[u]) dfs2(son[u],tp);    int gz=G[u].size();    for(int to,i=0;i&lt;gz;i++){        to=G[u][i];        if(to==son[u]||to==fa[u])continue;        dfs2(to,to);    }}int sum[N];#define lowbit(x)  (x&amp;-x)void update(int index,int val){    for(int i=index;i&lt;=n;i+=lowbit(i))sum[i]+=val;}int getSum(int index){    int ans = 0;    for(int i=index;i;i-=lowbit(i)) ans+=sum[i];    return ans;}int update(int x,int y,int k){    int fx=top[x],fy=top[y];    while(fx!=fy){        if(dep[fx]&lt;dep[fy])swap(x,y),swap(fx,fy);        update(tree[fx],k),update(tree[x]+1,-k);        x=fa[fx],fx=top[x];    }    if(dep[x]&gt;dep[y])swap(x,y);    update(tree[x],k),update(tree[y]+1,-k);}void init(){    cnt = 0;    for(int i=0;i&lt;=n;i++)son[i]=0;}int main(){    while(~scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;q)){        memset(sum,0,sizeof(sum));        for(int i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;w[i]);        for(int i=1,u,v;i&lt;=m;i++){            scanf(&quot;%d%d&quot;,&amp;u,&amp;v);            add(u,v);        }        init();        dfs1(1,0,1);        dfs2(1,1);        for(int i=1;i&lt;=n;i++)update(tree[i],w[i]),update(tree[i]+1,-w[i]);        char ch,s[10];        int a,b,k;        while(q--){            scanf(&quot;%s&quot;,s);            ch=s[0];            if(ch==&#39;Q&#39;){                scanf(&quot;%d&quot;,&amp;a);                printf(&quot;%d\n&quot;,getSum(tree[a]));            }            else {                scanf(&quot;%d%d%d&quot;,&amp;a,&amp;b,&amp;k);                if(ch==&#39;D&#39;) k=-k;                update(a,b,k);            }        }        for(int i=1;i&lt;=n;i++)G[i].clear();    }    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  BZOJ 1036 树的统计Count [树链剖分(点权)]【数据结构】</title>
      <link href="/2017/03/09/60953673/"/>
      <url>/2017/03/09/60953673/</url>
      
        <content type="html"><![CDATA[<h1 id="BZOJ-1036-树的统计Count-树链剖分-点权-【数据结构】"><a href="#BZOJ-1036-树的统计Count-树链剖分-点权-【数据结构】" class="headerlink" title="BZOJ 1036 树的统计Count [树链剖分(点权)]【数据结构】"></a>BZOJ 1036 树的统计Count [树链剖分(点权)]【数据结构】</h1><p>2017年03月09日 08:47:18  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：234</p><hr><p> 博客爬取于<code>2019-04-18 17:17:36</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/60953673" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/60953673</a></p><p>题目连接: <a href="http://www.lydsy.com/JudgeOnline/problem.php?id=1036" target="_blank" rel="noopener"> http://www.lydsy.com/JudgeOnline/problem.php?id=1036</a></p><p>————————————————————————————-.<br>1036: [ZJOI2008]树的统计Count</p><p>Time Limit: 10 Sec Memory Limit: 162 MB<br>Submit: 15527 Solved: 6328<br>[Submit][Status][Discuss]<br>Description</p><p>一棵树上有n个节点，编号分别为1到n，每个节点都有一个权值w。我们将以下面的形式来要求你对这棵树完成<br>一些操作： I. CHANGE u t : 把结点u的权值改为t II. QMAX u v: 询问从点u到点v的路径上的节点的最大权值 I<br>II. QSUM u v: 询问从点u到点v的路径上的节点的权值和 注意：从点u到点v的路径上的节点包括u和v本身</p><p>Input</p><p>输入的第一行为一个整数n，表示节点的个数。接下来n – 1行，每行2个整数a和b，表示节点a和节点b之间有<br>一条边相连。接下来n行，每行一个整数，第i行的整数wi表示节点i的权值。接下来1行，为一个整数q，表示操作<br>的总数。接下来q行，每行一个操作，以“CHANGE u t”或者“QMAX u v”或者“QSUM u v”的形式给出。<br>对于100％的数据，保证1&lt;=n&lt;=30000，0&lt;=q&lt;=200000；中途操作中保证每个节点的权值w在-30000到30000之间。</p><p>Output</p><p>对于每个“QMAX”或者“QSUM”的操作，每行输出一个整数表示要求输出的结果。</p><p>Sample Input</p><p>4</p><p>1 2</p><p>2 3</p><p>4 1</p><p>4 2 1 3</p><p>12</p><p>QMAX 3 4</p><p>QMAX 3 3</p><p>QMAX 3 2</p><p>QMAX 2 3</p><p>QSUM 3 4</p><p>QSUM 2 1</p><p>CHANGE 1 5</p><p>QMAX 3 4</p><p>CHANGE 3 6</p><p>QMAX 3 4</p><p>QMAX 2 4</p><p>QSUM 3 4<br>Sample Output</p><p>4</p><p>1</p><p>2</p><p>2</p><p>10</p><p>6</p><p>5</p><p>6</p><p>5</p><p>16</p><p>—————————————————————————————–.</p><p>解题大意：</p><p>就是裸的 <strong> 树链剖分 </strong></p><p>树链剖分其实和dfs序一样，都是将 <strong> 树形 </strong> 结构转化为 <strong> 线性 </strong> 结构，然后借用线段树维护的东西。</p><p>dfs序转化的线性结构是能查询节点的 <strong> 子树 </strong> 中的什么什么值，</p><p>而树链剖分就是对树进行链的分割，然后求解某两个节点间的什么什么值</p><p>主要思想就是对树丛根节点开始对分出一个个重链来，然后编号。<br>通过两遍dfs ，第一遍求出重儿子，第二遍进行标号，将树转化成线性，使得每条链上的节点在线段树中是连续的</p><p>附本题代码<br>—————————————————————————-。</p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long int LL;const int    INF = (~(1&lt;&lt;31));const int    N   = 30000+7;const double eps = 1e-7;inline int read(){    int x=0,f=1;char ch = getchar();    while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;){if(ch==&#39;-&#39;)f=-1;ch=getchar();}    while(&#39;0&#39;&lt;=ch&amp;&amp;ch&lt;=&#39;9&#39;){x=(x&lt;&lt;3)+(x&lt;&lt;1)+ch-&#39;0&#39;;ch=getchar();}    return x*f;}inline int gmax(int &amp;x,int y){if(y&gt;x)x=y;}inline int gmin(int &amp;x,int y){if(y&lt;x)x=y;}inline int mmax(int  x,int y){if(y&gt;x)x=y;return x; }inline int mmin(int  x,int y){if(y&lt;x)x=y;return x; }/****************************************************/int w[N],n;vector&lt;int &gt;G[N];/***tree cut*/int dep[N],fa[N],sz[N],son[N];void dfs1(int u,int f,int d){    dep[u]=d,fa[u]=f,sz[u]=1;    int gz=G[u].size();    for(int to,i=0;i&lt;gz;i++){        to=G[u][i];        if(to==f)continue;        dfs1(to,u,d+1);        sz[u]+=sz[to];        if(!son[u]||sz[to]&gt;sz[son[u]]) son[u]=to;    }}int top[N],tree[N],pre[N],cnt;void dfs2(int u,int rt){    top[u]=rt,tree[u]=++cnt,pre[tree[u]]=u;    if(!son[u])return ;    dfs2(son[u],rt);    int gz=G[u].size();    for(int i=0,to;i&lt;gz;i++){        to=G[u][i];        if(to==son[u]||to==fa[u]) continue;        dfs2(to,to);    }}void init(int n){    cnt = 0;    for(int i=0;i&lt;=n;i++) son[i]=0;}void add(int u,int v){    G[u].push_back(v);    G[v].push_back(u);}/***Segmeng begin*/int mx[N&lt;&lt;2],sum[N&lt;&lt;2];#define ll   (rt&lt;&lt;1)#define rr   (rt&lt;&lt;1|1)#define lson (rt&lt;&lt;1),l,mid#define rson (rt&lt;&lt;1|1),(mid+1),r#define mid  ((l+r)&gt;&gt;1)void pushup(int rt){    sum[rt]=sum[ll]+sum[rr];    mx[rt]=mmax(mx[ll],mx[rr]);}void build(int rt,int l,int r){    if(l==r){        sum[rt]=mx[rt]=w[pre[l]];        return;    }    build(lson);    build(rson);    pushup(rt);}void update(int rt,int l,int r,int pos,int val){    if(l==r){        sum[rt]=mx[rt]=val;        return ;    }    if(pos&lt;=mid) update(lson,pos,val);    else         update(rson,pos,val);    pushup(rt);    return ;}int query_max(int rt,int l,int r,int L,int R){    if(L&lt;=l&amp;&amp;r&lt;=R)   return mx[rt];    int ans=-INF;    if(L&lt;=mid) gmax(ans,query_max(lson,L,R));    if(R&gt; mid) gmax(ans,query_max(rson,L,R));    return ans;}int query_sum(int rt,int l,int r,int L,int R){    if(L&lt;=l&amp;&amp;r&lt;=R)   return sum[rt];    int ans=0;    if(L&lt;=mid) ans+=query_sum(lson,L,R);    if(R&gt; mid) ans+=query_sum(rson,L,R);    return ans;}/****Segment end;*/int find_max(int x,int y){    int ans = -INF;    int fx=top[x],fy=top[y];//    printf(&quot;%d %d\n&quot;,fx,fy);    while(fx!=fy){        if(dep[fx]&lt;dep[fy]) swap(fx,fy),swap(x,y);        gmax(ans,query_max(1,1,n,tree[fx],tree[x]));        x=fa[fx];fx=top[x];    }    if(dep[x]&gt;dep[y]) swap(x,y);    gmax(ans,query_max(1,1,n,tree[x],tree[y]));    return ans;}int find_sum(int x,int y){    int ans = 0;    int fx=top[x],fy=top[y];    while(fx!=fy){        if(dep[fx]&lt;dep[fy]) swap(fx,fy),swap(x,y);        ans+=query_sum(1,1,n,tree[fx],tree[x]);        x=fa[fx];fx=top[x];    }    if(dep[x]&gt;dep[y]) swap(x,y);    ans+=query_sum(1,1,n,tree[x],tree[y]);    return ans;}void print(){    puts(&quot;i : &quot;);for(int i=1;i&lt;=n;i++) printf(&quot;%d &quot;,i);puts(&quot;&quot;);    puts(&quot;w[i]: &quot;);for(int i=1;i&lt;=n;i++) printf(&quot;%d &quot;,w[i]);puts(&quot;&quot;);    puts(&quot;dep[i]: &quot;);for(int i=1;i&lt;=n;i++) printf(&quot;%d &quot;,dep[i]);puts(&quot;&quot;);    puts(&quot;tree[i]: &quot;);for(int i=1;i&lt;=n;i++) printf(&quot;%d &quot;,tree[i]);puts(&quot;&quot;);    puts(&quot;tree_w_max[i]: &quot;);for(int i=1;i&lt;=n;i++) printf(&quot;%d &quot;,query_max(1,1,n,i,i));puts(&quot;&quot;);    puts(&quot;tree_w_min[i]: &quot;);for(int i=1;i&lt;=n;i++) printf(&quot;%d &quot;,query_sum(1,1,n,i,i));puts(&quot;&quot;);//    for(int i=1;i&lt;=n;i++) printf(&quot;%d &quot;,i);//    for(int i=1;i&lt;=n;i++) printf(&quot;%d &quot;,i);//    for(int i=1;i&lt;=n;i++) printf(&quot;%d &quot;,i);}int main(){    scanf(&quot;%d&quot;,&amp;n);    for(int i=1,u,v;i&lt;n;i++){        scanf(&quot;%d%d&quot;,&amp;u,&amp;v);        add(u,v);    }    for(int i=1;i&lt;=n;i++)    scanf(&quot;%d&quot;,&amp;w[i]);    init(n);    dfs1(1,0,1),dfs2(1,1);    build(1,1,n);//    print();//    printf(&quot;%d\n&quot;,query_sum(1,1,n,1,3));//    printf(&quot;%d\n&quot;,query_sum(1,1,n,4,4));    int q,a,b;    char str[10];    scanf(&quot;%d&quot;,&amp;q);    while(q--){        scanf(&quot;%s %d %d&quot;,str,&amp;a,&amp;b);        if(str[0]==&#39;C&#39;){            update(1,1,n,tree[a],b);            w[a]=b;        }        else if(str[1]==&#39;M&#39;){            printf(&quot;%d\n&quot;,find_max(a,b));        }        else {            printf(&quot;%d\n&quot;,find_sum(a,b));        }    }    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  51nod 算法马拉松22 完全图的最小生成树计数 【Trie树+图论】</title>
      <link href="/2017/03/06/60594774/"/>
      <url>/2017/03/06/60594774/</url>
      
        <content type="html"><![CDATA[<h1 id="51nod-算法马拉松22-完全图的最小生成树计数-【Trie树-图论】"><a href="#51nod-算法马拉松22-完全图的最小生成树计数-【Trie树-图论】" class="headerlink" title="51nod 算法马拉松22 完全图的最小生成树计数 【Trie树+图论】"></a>51nod 算法马拉松22 完全图的最小生成树计数 【Trie树+图论】</h1><p>2017年03月06日 20:44:59  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：983</p><hr><p> 博客爬取于<code>2019-04-18 17:17:37</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/60594774" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/60594774</a></p><p>题目连接： <a href="http://www.51nod.com/contest/problem.html#!problemId=1601" target="_blank" rel="noopener"> http://www.51nod.com/contest/problem.html#!problemId=1601</a></p><p>——————————————————————————.<br>完全图的最小生成树计数<br>SkyDec (命题人)<br>基准时间限制：1 秒 空间限制：131072 KB 分值: 160</p><p>给定一个长度为n的数组a[1..n]，有一幅完全图，满足(u,v)的边权为a[u] xor a[v]<br>求边权和最小的生成树，你需要输出边权和还有方案数对1e9+7取模的值<br>注意边权和是不需要取模的<br>注意边权和是不需要取模的<br>注意边权和是不需要取模的<br>（重要的事情要说三遍）</p><p>Input<br>第一行一个正整数n<br>第二行n个整数表示a[1..n]<br>1&lt;=n&lt;=10^5<br>0&lt;=a[i]&lt;2^30</p><p>Output<br>第一行输出边权和<br>第二行输出方案数</p><p>Input示例<br>5<br>2 2 3 4 5</p><p>Output示例<br>8<br>6</p><p>——————————————————————————–.<br>解题思路：</p><p>首先对于最小生成树来说边一定是最小了,<br>那么 我们只要将 树分成两个,使得一颗子树的高位为  1  ,另一颗为  0<br>,显然最好仅用一条边将这两颗子树连接起来能使得最后的权值和最小，那么对于这两颗子树分别递归的用这种方法求解得到就一定是最小生成树了。</p><p>那么对于  x  o  r  很容易想到  01  字典树，</p><p>然后我们发现  01  字典树的左右儿子就是我们需要分开的两颗子树,</p><p>那么我们只要对字典树树进行dfs遍历,然后遇到同时存在左右儿子的就去计算一下选择哪条边且有多少种选法,我们就能知道结果了</p><p>计算选择哪条边的时候,我们可以枚举一棵子树的每个叶子节点,然后通过字典树在另一颗子树中查找与其异或值最小的,然后记录就行了.</p><p><strong> 然后注意的是: </strong><br><strong> 1. 本题需要读入优化 </strong><br><strong> 2. 位运算括起来,因为优先级地 </strong><br><strong> 3. 枚举节点的时候最好用启发式选择,选择叶子节点少的枚举. </strong><br><strong> 4. 然后注意的是 点值相同的完全图共有  n  n  −  2  颗生成树 </strong></p><p>附本题代码<br>——————————————————————————————————</p><pre><code>#include &lt;bits/stdc++.h&gt;using namespace std;#define INF        (~(1&lt;&lt;31))#define INFLL      (~(1ll&lt;&lt;63))#define pb         push_back#define mp         make_pair#define abs(a)     ((a)&gt;0?(a):-(a))#define min(a,b)    ((a)&lt;(b)?(a):(b))#define lalal      puts(&quot;*******&quot;);#define s1(x)      scanf(&quot;%d&quot;,&amp;x)#define Rep(a,b,c) for(int a=(b);a&lt;=(c);a++)#define Per(a,b,c) for(int a=(b);a&gt;=(c);a--)typedef long long int LL ;typedef unsigned long long int uLL ;const int    N   = 1e5+7;const int    MOD = 1e9+7;const double eps = 1e-8;const double Pi  = acos(-1.0);const double E   = exp(1.0);inline int read(){    int x=0,f=1;char ch=getchar();    while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;){if(ch==&#39;-&#39;)f=-1;ch=getchar();}    while(ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;){x=(x&lt;&lt;3)+(x&lt;&lt;1)+ch-&#39;0&#39;;ch=getchar();}    return x*f;}void fre(){    freopen(&quot;in.txt&quot;,&quot;r&quot;,stdin);    freopen(&quot;out.txt&quot;,&quot;w&quot;,stdout);}template&lt;typename T&gt;inline T _gcd(T a,T b){return (b==0)?a:_gcd(b,a%b);}template&lt;typename T&gt;inline T _lcm(T a,T b){return        a/_gcd(a,b)*b;}LL qmod(LL a,LL b,LL c){LL ret=1ll;while(b){if(b&amp;1)ret=ret*a%c;b&gt;&gt;=1,a=a*a%c;}return ret;}/***********************************************************************/int trie[N*40][3],sum[N*40],val[N*40],to[N*40],cnt,weishu = 30-1;LL ans,tot,ta,tt;inline void insert(int x){    int now = 0;    for(int i=weishu,bt;i&gt;=0;i--){        bt = 1-(0==(x&amp;(1&lt;&lt;i)));        if(!trie[now][bt]) trie[now][bt]=++cnt;        now = trie[now][bt];        sum[now]++;    }    val[now]=x;}inline int query(int x,int pre){    int now = 0;    for(int i=weishu,bt;i&gt;=0;i--){        bt = 1-(0==(x&amp;(1&lt;&lt;i)));        if(!trie[now][bt]) bt = 1-bt;        if(now == pre) bt = 1-bt;        now = trie[now][bt];    }    return now;}void dfs2(int x,int &amp;pre){    if(trie[x][0]) dfs2(trie[x][0],pre);    if(trie[x][1]) dfs2(trie[x][1],pre);    if(!trie[x][0]&amp;&amp;!trie[x][1]){        int now = query(val[x],pre);        if( ta==(val[now]^val[x])){            tt =(tt+1ll*sum[now]*sum[x]%MOD)%MOD;//            printf(&quot;%d %d  &quot;,sum[now],val[now]^val[x]);//            printf(&quot;%lld %lld&lt;--\n&quot;,ta,tt);        }        if( ta&gt;(val[now]^val[x])){            ta=(val[now]^val[x]);            tt=(1ll*sum[now]*sum[x])%MOD;//            printf(&quot;%d %d  &quot;,sum[now],val[now]^val[x]);//            printf(&quot;%lld %lld&lt;--\n&quot;,ta,tt);        }//        printf(&quot;%d  %d\n&quot;,now,x);    }}void dfs(int x){    if(trie[x][0]) dfs(trie[x][0]);    if(trie[x][1]) dfs(trie[x][1]);    if(trie[x][0]&amp;&amp;trie[x][1]){        ta = INF,tt=0;        if(to[trie[x][1]]&lt;to[trie[x][0]])            dfs2(trie[x][1],x);        else      dfs2(trie[x][0],x);//        puts(&quot;--&quot;);        ans+=ta;        tot=tot*tt%MOD;    }    else if(!trie[x][0]&amp;&amp;!trie[x][1]&amp;&amp;sum[x]&gt;1)        tot=tot*qmod(1ll*sum[x],1ll*sum[x]-2,1ll*MOD)%MOD;}int dfs1(int x){    if(!trie[x][0]&amp;&amp;!trie[x][1])        return to[x]=1;    if(trie[x][0]) to[x]+=dfs1(trie[x][0]);    if(trie[x][1]) to[x]+=dfs1(trie[x][1]);    return to[x];}int main(){    int n;    while(~scanf(&quot;%d&quot;,&amp;n)){//        memset(trie,0,sizeof(trie));//        memset(sum,0,sizeof(sum));        cnt = 0;        ans = 0ll,tot=1ll;        for(int i=1,x;i&lt;=n;i++){            x=read();            insert(x);        }//        puts(&quot;No.:&quot;);for(int i=0;i&lt;=cnt;i++)  printf(&quot;%2d &quot;,i);puts(&quot;&quot;);//        puts(&quot;tot:&quot;);for(int i=0;i&lt;=cnt;i++)  printf(&quot;%2d &quot;,sum[i]);puts(&quot;&quot;);//        puts(&quot;val:&quot;);for(int i=0;i&lt;=cnt;i++)  printf(&quot;%2d &quot;,val[i]);puts(&quot;&quot;);//        puts(&quot;lson&quot;);for(int i=0;i&lt;=cnt;i++)  printf(&quot;%2d &quot;,trie[i][0]);puts(&quot;&quot;);//        puts(&quot;rson&quot;);for(int i=0;i&lt;=cnt;i++)  printf(&quot;%2d &quot;,trie[i][1]);puts(&quot;&quot;);////        printf(&quot;%lld\n&quot;,qmod(sum[30],sum[30]-2,MOD));        dfs1(0);        dfs(0);        printf(&quot;%lld\n%lld\n&quot;,ans,tot);    }    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  UVA 10951 - Polynomial GCD []【数论】</title>
      <link href="/2017/03/03/60145283/"/>
      <url>/2017/03/03/60145283/</url>
      
        <content type="html"><![CDATA[<h1 id="UVA-10951-Polynomial-GCD-【数论】"><a href="#UVA-10951-Polynomial-GCD-【数论】" class="headerlink" title="UVA 10951 - Polynomial GCD []【数论】"></a>UVA 10951 - Polynomial GCD []【数论】</h1><p>2017年03月03日 19:21:28  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：321</p><hr><p> 博客爬取于<code>2019-04-18 17:17:38</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/60145283" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/60145283</a></p><p>题目链接: <a href="https://vjudge.net/problem/UVA-10951" target="_blank" rel="noopener"> https://vjudge.net/problem/UVA-10951</a><br>———————————————————————–.</p><p>UVA的都是pdf ,复制粘贴不方便 去 <a href="https://vjudge.net/problem/UVA-10951" target="_blank" rel="noopener"> https://vjudge.net/problem/UVA-10951</a> 看吧</p><p>————————————————————————.</p><p>题目大意:<br>就是给你两个多项式,让你求解两个多项式的gcd ,其中系数对n去摸,且最高次幂的系数为1.</p><p>解题思路;<br>还是当做正常的gcd来做,这样的话,还是经典的欧几里得算法</p><pre><code>template&lt;typename T&gt;inline T _gcd(T a,T b){    return (b==0)?a:_gcd(b,a%b);}</code></pre><p>那么这个问题就转化为如何对多项式取模。<br>这个很容易了,注意其中用逆元来计算除法就行了</p><p>多项式取模</p><p>附本题代码<br>—————————————————————-。</p><pre><code>#include &lt;bits/stdc++.h&gt;using namespace std;#define INF        (~(1&lt;&lt;31))#define INFLL      (~(1ll&lt;&lt;63))#define pb         push_back#define mp         make_pair#define abs(a)     ((a)&gt;0?(a):-(a))#define lalal      puts(&quot;*******&quot;);#define s1(x)      scanf(&quot;%d&quot;,&amp;x)#define Rep(a,b,c) for(int a=(b);a&lt;=(c);a++)#define Per(a,b,c) for(int a=(b);a&gt;=(c);a--)typedef long long int LL ;typedef unsigned long long int uLL ;const int    N   = 50000+7;const int    MOD = 1e9+7;const double eps = 1e-7;const double Pi  = acos(-1.0);const double E   = exp(1.0);inline int read(){    int x=0,f=1;char ch=getchar();    while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;){if(ch==&#39;-&#39;)f=-1;ch=getchar();}    while(ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;){x=x*10+ch-&#39;0&#39;;ch=getchar();}    return x*f;}void fre(){    freopen(&quot;in.txt&quot;,&quot;r&quot;,stdin);    freopen(&quot;out.txt&quot;,&quot;w&quot;,stdout);}template&lt;typename T&gt;inline T _gcd(T a,T b){return (b==0)?a:_gcd(b,a%b);}template&lt;typename T&gt;inline T _lcm(T a,T b){return        a/_gcd(a,b)*b;}LL qmod(LL a,LL b,LL c){LL ret=1ll;while(b){if(b&amp;1)ret=ret*a%c;b&gt;&gt;=1,a=a*a%c;}return ret;}/***********************************************************************/#define vi vector&lt;int&gt;int n;int inv(int x){    return qmod(x,n-2,n);}vi vimod(vi f,vi g){    int fz = f.size(),gz = g.size();    for(int i=0;i&lt;fz;i++){        if(fz-i-gz &lt; 0) break;        int a=f[i]*inv(g[0])%n;        for(int j=0;j&lt;gz;j++){            int now=i+j;            f[now]=((f[now]-a*g[j]%n)%n+n)%n;        }    }    vi ans;    int p=-1;    for(int i=0;i&lt;fz;i++)if(f[i]!=0){p=i;break;}    if(p&gt;=0) for(int i=p;i&lt;fz;i++)ans.pb(f[i]);    return ans;}vi gcd(vi f,vi g){    if(g.size()==0) return f;    return  gcd(g,vimod(f,g));}vi f,g;int main(){    int kcase = 0;    while(~scanf(&quot;%d&quot;,&amp;n)&amp;&amp;n){        f.clear(),g.clear();        int d,x;        scanf(&quot;%d&quot;,&amp;d);        for(int i=0;i&lt;=d;i++){            scanf(&quot;%d&quot;,&amp;x);            f.pb(x);        }        scanf(&quot;%d&quot;,&amp;d);        for(int i=0;i&lt;=d;i++){            scanf(&quot;%d&quot;,&amp;x);            g.pb(x);        }        vi ans = gcd(f,g);        int tmp = inv(ans[0]);        printf(&quot;Case %d: %d&quot;,++kcase,ans.size()-1);        for(int i=0;i&lt;ans.size();i++){            printf(&quot; %d&quot;,ans[i]*tmp%n);        }        puts(&quot;&quot;);    }    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  HDU 4366 Successor [树形转线形+线段树]【数据结构+技巧】</title>
      <link href="/2017/03/03/60141601/"/>
      <url>/2017/03/03/60141601/</url>
      
        <content type="html"><![CDATA[<h1 id="HDU-4366-Successor-树形转线形-线段树-【数据结构-技巧】"><a href="#HDU-4366-Successor-树形转线形-线段树-【数据结构-技巧】" class="headerlink" title="HDU 4366 Successor [树形转线形+线段树]【数据结构+技巧】"></a>HDU 4366 Successor [树形转线形+线段树]【数据结构+技巧】</h1><p>2017年03月03日 16:05:08  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：231</p><hr><p> 博客爬取于<code>2019-04-18 17:17:39</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/60141601" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/60141601</a></p><p>题目链接： <a href="http://acm.hdu.edu.cn/showproblem.php?pid=4366" target="_blank" rel="noopener"> http://acm.hdu.edu.cn/showproblem.php?pid=4366</a><br>—————————————————————————————————————.</p><p>Successor</p><p>Time Limit: 2000/1000 MS (Java/Others) Memory Limit: 65536/65536 K<br>(Java/Others)<br>Total Submission(s): 4173 Accepted Submission(s): 1032</p><p>Problem Description<br>Sean owns a company and he is the BOSS.The other Staff has one Superior.every<br>staff has a loyalty and ability.Some times Sean will fire one staff.Then one<br>of the fired man’s Subordinates will replace him whose ability is higher than<br>him and has the highest loyalty for company.Sean want to know who will replace<br>the fired man.</p><p>Input<br>In the first line a number T indicate the number of test cases. Then for each<br>case the first line contain 2 numbers n,m (2&lt;=n,m&lt;=50000),indicate the company<br>has n person include Sean ,m is the times of Sean’s query.Staffs are numbered<br>from 1 to n-1,Sean’s number is 0.Follow n-1 lines,the i-th(1&lt;=i&lt;=n-1) line<br>contains 3 integers a,b,c(0&lt;=a&lt;=n-1,0&lt;=b,c&lt;=1000000),indicate the i-th staff’s<br>superior Serial number,i-th staff’s loyalty and ability.Every staff ‘s Serial<br>number is bigger than his superior,Each staff has different loyalty.then<br>follows m lines of queries.Each line only a number indicate the Serial number<br>of whom should be fired.</p><p>Output<br>For every query print a number:the Serial number of whom would replace the<br>losing job man,If there has no one to replace him,print -1.</p><p>Sample Input<br>1<br>3 2<br>0 100 99<br>1 101 100<br>1<br>2</p><p>Sample Output<br>2<br>-1 </p><p>Author<br>FZU</p><p>Source<br>2012 Multi-University Training Contest 7</p><p>—————————————————————————————————————-.<br>题目大意：<br>给一个公司的上下级关系图，每个员工有一个上级，一个忠诚度，一个能力值，<br>现在老板（0），要开除一个员工，然后在这个员工的直接或间接能力值大于这个员工下级中找忠诚度最大的人来代替这个员工，如果有输出代替的员工的编号，没有输出-1</p><p>解题思路:</p><p>首先，要明白如何将一个数形转化为线形</p><blockquote><p>其实就是从根节点进行搜索，<br>然后向下dfs遍历树，依次进行编号，<br>同时能保证子树的编号一定大于父节点的编号，</p></blockquote><blockquote></blockquote><blockquote><p>同时借用两个数组，  L  [  _  ]  ,  R  [  _  ]<br>分别表示这个节点  u  的子树的节点编号在  (  L  [  u  ]  ,  R  [  u  ]  )  ,  开  区  间  内。</p></blockquote><blockquote></blockquote><blockquote><p>这样在进行对子树 进行的操作的时候 可以借助数据结构 对区间进行查找，</p></blockquote><p>然后将员工按能力值排序，</p><p>依次将一个个员工插入到线段树中，单点更新即可，<br>找这个员工下属忠诚度的最大的，直接区间查询就行了，<br>因为我们已经将树形转化成了线形，所以能够确保结果的正确性</p><p>然后注意下代码细节就好了。</p><p>操他妈的 两处笔误,卡了2个小时<br>1 sort (+1,+n <del> +1 </del> )<br>2 j打成i<br>怎么这么菜！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！<br>！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！</p><p>附本题代码<br>—————————————————————————————————————-.</p><pre><code>#include &lt;bits/stdc++.h&gt;using namespace std;#define pb         push_backconst int    N   = 50000+7;/***********************************************************************/struct Node{    int l,r;    int val;    int len(){return (r-l+1);}    int md(){return (r+l)&gt;&gt;1;}}tree[N&lt;&lt;2];#define ll  (rt&lt;&lt;1)#define rr  (rt&lt;&lt;1|1)#define mid (tree[rt].md())void pushup(int rt){    tree[rt].val = max(tree[ll].val,tree[rr].val);}void build(int rt,int l,int r){    tree[rt].l=l,tree[rt].r=r;    tree[rt].val=-1;    if(l==r)return ;    build(ll,l,mid);    build(rr,mid+1,r);    return ;}void update(int rt,int pos,int val){    if(tree[rt].l==tree[rt].r){        tree[rt].val = val;        return ;    }    if(pos&lt;=mid) update(ll,pos,val);    else         update(rr,pos,val);    pushup(rt);}int query(int rt,int L,int R){    if(L&gt;R) return -1;    if(L&lt;=tree[rt].l&amp;&amp;tree[rt].r&lt;=R){        return tree[rt].val;    }    int ans = -1;    if(L&lt;=mid) ans = max(ans,query(ll,L,R));    if(R&gt; mid) ans = max(ans,query(rr,L,R));    return ans;}/***********以上是 segment tree**************/struct node {    int Superior,loyalty ,ability;    int id;}p[N];int L[N],R[N],ans[N];vector &lt;int &gt;G[N];map&lt;int ,int &gt;mmp;bool cmp(node a,node b){    return a.ability&gt;b.ability;}int cnt ;void dfs(int u){    L[u]=cnt++;    int sz=G[u].size();    for(int i=0;i&lt;sz;i++){        int v=G[u][i];        dfs(v);    }    R[u]=cnt;}int main(){    int _;    scanf(&quot;%d&quot;,&amp;_);    while(_--){        int n,m;        scanf(&quot;%d%d&quot;,&amp;n,&amp;m);        for(int i=0;i&lt;=n;i++)G[i].clear();mmp.clear();        for(int i=1;i&lt;n;i++){            scanf(&quot;%d %d %d&quot;,&amp;p[i].Superior,&amp;p[i].loyalty,&amp;p[i].ability);            p[i].id=i;            G[p[i].Superior].pb(i);            mmp[p[i].loyalty]=i;        }        sort(p+1,p+n,cmp);        cnt=0,dfs(0);        build(1,0,cnt-1);        memset(ans,-1,sizeof(ans));        for(int i=1,j,id,res;i&lt;n;i=j){            for(j=i;j&lt;n&amp;&amp;p[i].ability==p[j].ability;){                id = p[j++].id;                res = query(1,L[id]+1,R[id]-1);                ans[id] = (res==-1)?-1:mmp[res];            }            for(j=i;j&lt;n&amp;&amp;p[i].ability==p[j].ability;){                id = p[j].id;                update(1,L[id],p[j++].loyalty);            }        }        int x;        while(m--){            scanf(&quot;%d&quot;,&amp;x);            printf(&quot;%d\n&quot;,ans[x]);        }    }    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  51nod 1163 最高的奖励 [贪心]【杂类】</title>
      <link href="/2017/03/02/59488912/"/>
      <url>/2017/03/02/59488912/</url>
      
        <content type="html"><![CDATA[<h1 id="51nod-1163-最高的奖励-贪心-【杂类】"><a href="#51nod-1163-最高的奖励-贪心-【杂类】" class="headerlink" title="51nod 1163 最高的奖励 [贪心]【杂类】"></a>51nod 1163 最高的奖励 [贪心]【杂类】</h1><p>2017年03月02日 12:40:48  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：207</p><hr><p> 博客爬取于<code>2019-04-18 17:17:41</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/59488912" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/59488912</a></p><p>题目连接: <a href="http://www.51nod.com/onlineJudge/questionCode.html#!problemId=1163" target="_blank" rel="noopener"> http://www.51nod.com/onlineJudge/questionCode.html#!problemId=1163</a><br>———————————————————————————————–.<br>1163 最高的奖励<br>基准时间限制：1 秒 空间限制：131072 KB 分值: 20 难度：3级算法题 收藏 关注<br>有N个任务，每个任务有一个最晚结束时间以及一个对应的奖励。在结束时间之前完成该任务，就可以获得对应的奖励。完成每一个任务所需的时间都是1个单位时间。有时候完<br>成所有任务是不可能的，因为时间上可能会有冲突，这需要你来取舍。求能够获得的最高奖励。<br>Input<br>第1行：一个数N，表示任务的数量(2 &lt;= N &lt;= 50000)<br>第2 - N + 1行，每行2个数，中间用空格分隔，表示任务的最晚结束时间E[i]以及对应的奖励W[i]。(1 &lt;= E[i] &lt;= 10^9，1 &lt;=<br>W[i] &lt;= 10^9)<br>Output<br>输出能够获得的最高奖励。<br>Input示例<br>7<br>4 20<br>2 60<br>4 70<br>3 40<br>1 30<br>4 50<br>6 10<br>Output示例<br>230<br>————————————————————————————————.<br>解题思路:</p><p>本题看别人的思路都是贪心+优先队列</p><blockquote><p>按照题意，可以从最晚结束时间和完成任务奖励分别展开求解。<br>从最晚结束时间考虑贪心策略的话，那么应该将最晚结束时间升序排序。<br>具体(PS):<br>用贪心思想，从0开始，每完成一件任务，消耗时间为1，按最晚时间递增，第n个任务如果最晚时间大于已消耗掉时间量，则可算入总和，若不大于已耗时间量，<br>则可以替换掉总和里最小奖励的一个任务(如果当前任务的奖励更多的话)。<br>这个过程可以用堆维护。nlog(n);</p></blockquote><p>然而我是贪心+双数组</p><p>定义h[]数组,表示  h  i  时刻内做没有做任务<br>定义m[]数组,表示一个”指针”，指向距离  m  i  时间点最近的没有做任务的时间点  (  m  i  ≤  i  )  。 <del><br>其实这一步有点像并查集 </del></p><p>排序的时候以w递减，e没什么所谓。<br>然后一次遍历，判断这个任务能不能做，能做就计算上。</p><p>排序是  O  (  n  log  (  n  )  )  的,在统计的时候确实  O  (  n  )  的</p><p>贪心+优先队列<br>————————————————————————————————.</p><pre><code>#include&quot;stdio.h&quot;  #include&quot;algorithm&quot;  #include&quot;queue&quot;  using namespace std;  const int maxn=5e4+5;  struct task{      int times;      int cost;  }t[maxn];  bool cmp(const task a,const task b)  {      if(a.times&lt;b.times) return true;      return false;  }  int main()  {      int n;      scanf(&quot;%d&quot;,&amp;n);      for(int i=0;i&lt;n;i++)      {          scanf(&quot;%d%d&quot;,&amp;t[i].times,&amp;t[i].cost);      }      sort(t,t+n,cmp);      priority_queue&lt;int ,vector&lt;int &gt;,greater&lt;int&gt; &gt;pq;      long long  ans=0;      for(int i=0;i&lt;n;i++)      {          int k=t[i].cost;          if(t[i].times&gt;pq.size()) //pq.size这里理解代表时间点          {              ans+=k;              pq.push(k);          }          else//时间点有冲突，把cost最小删除           {              ans+=k;              pq.push(k);              int minn=pq.top();              ans-=minn;              pq.pop();//删除           }          }      printf(&quot;%lld\n&quot;,ans);      return 0;  }</code></pre><p>贪心+加上双数组<br>————————————————————————————————.</p><pre><code>struct node {    int e,w;}a[N];bool cmp(node A,node B){    //if(A.w==B.w)return A.e&lt;B.e;    return A.w&gt;B.w;}int m[N];  //指针，指向距离当前时间点最近的没有做任务的时间点。bool h[N]; //判断当前时间点有没有做任务。int main(){    int n;    scanf(&quot;%d&quot;,&amp;n);    h[0]=1;    for(int i=1;i&lt;=n;i++){        scanf(&quot;%d%d&quot;,&amp;a[i].e,&amp;a[i].w);        h[i]=0;        m[i]=i;    }    sort(a+1,a+n+1,cmp);    LL ans = 0;    //lalal;    for(int i=1;i&lt;=n;i++){        //printf(&quot;%d %d\n&quot;,a[i].e,a[i].w);        int now = m[a[i].e];        while(h[now]&amp;&amp;now&gt;0){            now = m[now-1]; //切记要减1            //printf(&quot;%d %d   %d %d\n&quot;,now,m[now],h[now],h[m[now]]);        }        if(now&lt;0)now=0;        m[a[i].e]=now;        if(!h[m[a[i].e]]){            ans+=a[i].w;            h[m[a[i].e]]=1;            m[a[i].e]--;            //printf(&quot;---\n&quot;);        }        //for(int i=1;i&lt;=n;i++)  printf(&quot;%d%c&quot;,h[i],(i==n)?&#39;\n&#39;:&#39; &#39;);        //for(int i=1;i&lt;=n;i++)  printf(&quot;%d%c&quot;,m[i],(i==n)?&#39;\n&#39;:&#39; &#39;);    }    printf(&quot;%lld\n&quot;,ans);    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  51nod 1383&amp;1048 整数分解为2的幂 [递推]【数学】</title>
      <link href="/2017/03/02/59480949/"/>
      <url>/2017/03/02/59480949/</url>
      
        <content type="html"><![CDATA[<h1 id="51nod-1383-amp-1048-整数分解为2的幂-递推-【数学】"><a href="#51nod-1383-amp-1048-整数分解为2的幂-递推-【数学】" class="headerlink" title="51nod 1383&amp;1048 整数分解为2的幂 [递推]【数学】"></a>51nod 1383&amp;1048 整数分解为2的幂 [递推]【数学】</h1><p>2017年03月02日 09:28:49  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：444</p><hr><p> 博客爬取于<code>2019-04-18 17:17:42</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/59480949" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/59480949</a></p><p>题目连接: <a href="http://www.51nod.com/onlineJudge/questionCode.html#!problemId=1048" target="_blank" rel="noopener"> http://www.51nod.com/onlineJudge/questionCode.html#!problemId=1048</a></p><p>————————————————————————————————————-.<br>整数分解为2的幂</p><p>基准时间限制：3 秒 空间限制：131072 KB 分值: 1280 难度：9级算法题</p><p>任何正整数都能分解成2的幂，给定整数N，求N的此类划分方法的数量！<br>比如N = 7时，共有6种划分方法。</p><p>7=1+1+1+1+1+1+1<br>=1+1+1+1+1+2<br>=1+1+1+2+2<br>=1+2+2+2<br>=1+1+1+4<br>=1+2+4</p><p>Input<br>输入N（1 &lt;= N &lt;= 10^30)</p><p>Output<br>划分方法的数量</p><p>Input示例</p><p>7</p><p>Output示例</p><p>6<br>————————————————————————————————————-.</p><p>首先能够dp</p><p>设dp[i][j]表示组成的数是  i  ，方案中最大的数是  2  j  的方案数。<br>为了避免重复，dp[i][j]转移时枚举下一个数必须大于等于  2  j<br>那么可以得出：  d  p  [  i  ]  [  j  ]  =  ∑  j  k  =  0  d  p  [  i  −  2  j  ]  [<br>k  ]</p><p>能够做到  O  (  n  log  (  n  )  )  的复杂度</p><p>通过打表找规律等 ，可以递推得到如下规律</p><p>d  p  [  i  ]  =  d  p  [  i  −  2  ]  +  d  p  [  i  /  2  ]  ,  i  为  偶  数<br>d  p  [  i  ]  =  d  p  [  i  −  1  ]  ,  i  为  奇  数</p><p>这样的话复杂度就是  O  (  n  )</p><p>然而对于51nod 1383 这个复杂度就够用了，但是对于1048的  n  (  10  30  )  ,就完全不够用了,</p><p>如果n很大怎么办？<br>那样就要挖掘一下分解方案的性质了。</p><p>1.对于一个数n，假设它二进制下有m个1，分别是第  a  1  ,  a  2  …  a  m<br>位。对于n的任意一种分解方案，把所有2的幂升序排序，然后可以划分成m段，其中第i段的和是  2  a  i<br>2.对于一个数  2  i  的一种划分方案，如果不是只有它本身一个数，一定可以把这些2的幂升序排序，然后分成两段，每一段的和都是  2  i  −  1</p><p>证明并不难。有了这些性质，就可以设新的状态了。</p><p>首先设g[i][j]表示做完了前i段（即n二进制下的前i个1位），最大的数是  2  j  ，方案数是多少。<br>再设一个辅助数组f[i][j]，表示组成  2  i  ，最大的数是  2  j  的方案数。<br>接下来枚举第  i  −  1  段的最大数是多少，假设是  2  k  ，那么  g  [  i  ]  [  j  ]  =  ∑  j  k  =<br>0  g  [  i  −  1  ]  [  k  ]  ∗  f  [  i  −  k  ]  [  j  −  k  ]<br>其中  i  −  k  ,  j  −  k  的意义在于：要控制后面的数都大于等于  2  k  ，每个数都要除掉  2  k  ，那么就不会算重了。<br>f[i][j]的转移类似</p><p>时间复杂度  O  (  log  3  (  n  )  ∗  高  精  度  )</p><p><a href="http://blog.csdn.net/worldwide_d/article/details/54091940" target="_blank" rel="noopener"> 转(chao)自(xi) </a></p><p>附本题代码<br>———————————————————————————-.</p><p>O  (  n  )</p><pre><code>int dp[N];int main(){    int n;    scanf(&quot;%d&quot;,&amp;n);    dp[0]=1;    for(int i=1;i&lt;=n;i++){        if(i&amp;1){            dp[i]=dp[i-1];        }        else {            dp[i]=dp[i-1]+dp[i/2];        }        if(dp[i]&gt;MOD) dp[i]-=MOD;    }    printf(&quot;%d\n&quot;,dp[n]);    return 0;}</code></pre><p>O  (  log  3  (  n  )  ∗  高  精  度  )</p><pre><code>#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int N=99,M=170,mo=1e9;typedef long long LL;char c[N];int tot;struct num{    int w,a[M];}f[N+5][N+5],ans,n,p,t,s[N+5],g[N+5][N+5];num operator + (const num &amp;a,const num &amp;b){    t.w=max(a.w,b.w);    //t.a[1]=0;    memset(t.a,0,sizeof(t.a));    for (int i=1;i&lt;=t.w;i++)    {        t.a[i]+=a.a[i]+b.a[i];        if (t.a[i]&gt;=mo)        {            t.a[i+1]=1;            t.a[i]-=mo;        }//else t.a[i+1]=0;    }    if (t.a[t.w+1]&gt;0) t.w++;    //memset(t.a+t.w+1,0,sizeof(t.a+t.w+1));    return t;}num operator * (const num &amp;a,const num &amp;b){    memset(t.a,0,sizeof(t.a));    for (int i=1;i&lt;=a.w;i++)    {        for (int j=1;j&lt;=b.w;j++)        {            t.a[i+j]+=(t.a[i+j-1]+(LL)a.a[i]*b.a[j])/mo;            t.a[i+j-1]=(t.a[i+j-1]+(LL)a.a[i]*b.a[j])%mo;        }    }    for (t.w=a.w+b.w;t.w&gt;1 &amp;&amp; t.a[t.w]==0;t.w--);    return t;}int main(){    freopen(&quot;data.out&quot;,&quot;w&quot;,stdout);    scanf(&quot;%s&quot;,c+1);    int l=strlen(c+1);    n.w=l/9+1;    for (int i=1;i&lt;=l;i++)    {        int j=(l-i)/9;        n.a[j+1]=n.a[j+1]*10+c[i]-48;    }    f[0][0].w=f[0][0].a[1]=1;    for (int i=1;i&lt;=N;i++)    {        for (int j=0;j&lt;i;j++)        {            for (int k=0;k&lt;=j;k++)            {                f[i][j]=f[i][j]+f[i-1][k]*f[i-1-k][j-k];            }        }        f[i][i].w=f[i][i].a[1]=1;    }    tot=0;    for (int i=0;i&lt;=N;i++)    {        if (n.a[1]&amp;1)        {            tot++;            if (tot==1)            {                for (int j=0;j&lt;=i;j++) g[1][j]=f[i][j];            }else            {                for (int j=0;j&lt;=i;j++)                {                    for (int k=0;k&lt;=j;k++)                    {                        g[tot][j]=g[tot][j]+g[tot-1][k]*f[i-k][j-k];                    }                }            }        }        int r=0;        for (int j=n.w;j;j--)        {            int t=n.a[j];            n.a[j]=((LL)r*mo+t)/2;            r=((LL)r*mo+t)%2;        }    }    for (int i=0;i&lt;=N;i++) ans=ans+g[tot][i];    printf(&quot;%d&quot;,ans.a[ans.w]);    for (int i=ans.w-1;i;i--)    {        for (int j=1e8;j;j/=10)        {            printf(&quot;%d&quot;,ans.a[i]/j);            ans.a[i]%=j;        }    }    printf(&quot;\n&quot;);    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  SPOJ PGCD - Primes in GCD Table [莫比乌斯反演＋分段+求和优化]【组合数学】</title>
      <link href="/2017/02/14/55106268/"/>
      <url>/2017/02/14/55106268/</url>
      
        <content type="html"><![CDATA[<h1 id="SPOJ-PGCD-Primes-in-GCD-Table-莫比乌斯反演＋分段-求和优化-【组合数学】"><a href="#SPOJ-PGCD-Primes-in-GCD-Table-莫比乌斯反演＋分段-求和优化-【组合数学】" class="headerlink" title="SPOJ PGCD - Primes in GCD Table [莫比乌斯反演＋分段+求和优化]【组合数学】"></a>SPOJ PGCD - Primes in GCD Table [莫比乌斯反演＋分段+求和优化]【组合数学】</h1><p>2017年02月14日 21:02:29  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：572</p><hr><p> 博客爬取于<code>2019-04-18 17:17:44</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/55106268" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/55106268</a></p><p>题目连接: <a href="https://vjudge.net/problem/10581/origin" target="_blank" rel="noopener"> https://vjudge.net/problem/10581/origin</a></p><p>——————————————————————————————–.<br>PGCD - Primes in GCD Table</p><p>Johnny has created a table which encodes the results of some operation – a<br>function of two arguments. But instead of a boring multiplication table of the<br>sort you learn by heart at prep-school, he has created a GCD (greatest common<br>divisor) table! So he now has a table (of height a and width b), indexed from<br>(1,1) to (a,b), and with the value of field (i,j) equal to gcd(i,j). He wants<br>to know how many times he has used prime numbers when writing the table.</p><p>Input</p><p>First, t ≤ 10, the number of test cases. Each test case consists of two<br>integers, 1 ≤ a,b &lt; 10^7.</p><p>Output</p><p>For each test case write one number - the number of prime numbers Johnny wrote<br>in that test case.</p><p>Example</p><p>Input:<br>2<br>10 10<br>100 100</p><p>Output:<br>30<br>2791</p><p>——————————————————————————————–.</p><p>题目大意:<br>问你在  {  gcd  (  x  ,  y  )  ∣  ∣  x  ∈  [  1  ,  n  ]  ,  y  ∈  [  1  ,  m  ]<br>}  中素数的个数.</p><p>解题思路:<br>很好想到<br>设  f  (  d  )  =  ∑  n  x  =  1  ∑  m  y  =  1  [  gcd  (  x  ,  y  )  =  p  ]<br>(其中P为素数,[] 括号内式子成立为1,否则0)<br>设  F  (  d  )  =  ∑  n  x  =  1  ∑  m  y  =  1  [  d  |  gcd  (  x  ,  y  )  ]<br>同  时  F  (  d  )  =  [  n  d  ]  [  m  d  ]</p><p>显然  F  (  n  )  =  ∑  d  |  n  f  (  d  )</p><p>两种形式反演后得到<br>f  (  d  )  =  ∑  d  |  n  μ  (  n  d  )  F  (  d  )  (1)<br>f  (  n  )  =  ∑  d  |  n  μ  (  d  )  F  (  n  d  )  (2)</p><p>我们取(1)式<br>f  (  d  )  =  ∑  d  |  n  μ  (  n  d  )  [  n  d  ]  [  m  d  ]  (1)</p><p>最终结果就是</p><p>a  n  s  =  ∑  m  i  n  (  n  ,  m  )  p  f  (  p  )  =  ∑  m  i  n  (  n  ,<br>m  )  p  ∑  m  i  n  (  n  ,  m  )  /  p  d  =  1  μ  (  d  )  [  n  /  p  d<br>]  [  m  /  p  d  ]</p><p>直接计算复杂度太高 显然不可取。</p><p>令t = pk；<br>∑  m  i  n  (  n  ,  m  )  p  ∑  m  i  n  (  n  ,  m  )  /  p  d  =  1  μ  (<br>d  )  [  n  t  ]  [  m  t  ]  =  ∑  m  i  n  (  n  ,  m  )  t  =  1  ∑  p  ∣<br>∣  p  &lt; =  n  ,  p  |  t  ,  p  为  素  数  μ  (  t  p  )  [  n  t  ]  [  m  t  ]</p><p>其中对于  ∑  p  ∣  ∣  p  &lt; =  n  ,  p  |  t  ,  p  为  素  数  μ  (  t  p  )<br>我们可以在线性筛中预处理出来,然后求其前缀和</p><p>最后通过分段优化一下即可,</p><p><a href="http://blog.csdn.net/tc_to_top/article/details/47804647" target="_blank" rel="noopener"> 参考 </a></p><p><del> 难死了，看了好久都不是很懂、，(Ps:线性筛真TM强大) </del></p><p>附本题代码<br>——————————————————————————————–.</p><pre><code>int const MAX = 1e7 + 5;int mob[MAX], p[MAX], g[MAX], sum[MAX];bool noprime[MAX];int Mobius(){    mob[1] = 1;    int pnum = 0;    for(int i = 2; i &lt; MAX; i++)    {        if(!noprime[i])        {            p[pnum ++] = i;            mob[i] = -1;            g[i] = 1;        }        for(int j = 0; j &lt; pnum &amp;&amp; i * p[j] &lt; MAX; j++)        {            noprime[i * p[j]] = true;            if(i % p[j] == 0)            {                mob[i * p[j]] = 0;                g[i * p[j]] = mob[i];                break;             }            mob[i * p[j]] = -mob[i];            g[i * p[j]] = mob[i] - g[i];        }        sum[i] = sum[i - 1] + g[i];    }}ll cal(int l, int r){    ll ans = 0;    if(l &gt; r)        swap(l, r);    for(int i = 1, last = 0; i &lt;= l; i = last + 1)    {        last = min(l / (l / i), r / (r / i));        ans += (ll) (l / i) * (r / i) * (sum[last] - sum[i - 1]);    }    return ans;}int main(){    Mobius();    int T;    scanf(&quot;%d&quot;, &amp;T);    while(T--)    {        int l, r;        scanf(&quot;%d %d&quot;, &amp;l, &amp;r);        printf(&quot;%lld\n&quot;, cal(l, r));    }  }</code></pre>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  BZOJ 1257 [CQOI2007]余数之和sum [分块]【数学】</title>
      <link href="/2017/02/13/55060453/"/>
      <url>/2017/02/13/55060453/</url>
      
        <content type="html"><![CDATA[<h1 id="BZOJ-1257-CQOI2007-余数之和sum-分块-【数学】"><a href="#BZOJ-1257-CQOI2007-余数之和sum-分块-【数学】" class="headerlink" title="BZOJ 1257: [CQOI2007]余数之和sum [分块]【数学】"></a>BZOJ 1257: [CQOI2007]余数之和sum [分块]【数学】</h1><p>2017年02月13日 22:59:18  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：230</p><hr><p> 博客爬取于<code>2019-04-18 17:17:45</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/55060453" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/55060453</a></p><p>题目连接： <a href="https://vjudge.net/problem/HYSBZ-1257" target="_blank" rel="noopener"> https://vjudge.net/problem/HYSBZ-1257</a></p><p>———————————————————————————————————-.<br>1257: [CQOI2007]余数之和sum</p><p>Time Limit: 5 Sec Memory Limit: 162 MB<br>Description</p><p>给出正整数n和k，计算j(n, k)=k mod 1 + k mod 2 + k mod 3 + … + k mod n的值，其中k mod<br>i表示k除以i的余数。例如j(5, 3)=3 mod 1 + 3 mod 2 + 3 mod 3 + 3 mod 4 + 3 mod<br>5=0+1+0+3+3=7</p><p>Input</p><p>输入仅一行，包含两个整数n, k。</p><p>Output</p><p>输出仅一行，即j(n, k)。</p><p>Sample Input</p><p>5 3</p><p>Sample Output</p><p>7</p><p>HINT</p><p>50%的数据满足：1&lt;=n, k&lt;=1000<br>100%的数据满足：1&lt;=n ,k&lt;=10^9<br>———————————————————————————————————–.</p><p>暴力来看就是 <code>for(int i=1;i&lt;=n;i++) ans += k%i;</code><br>对于i&gt;k的时候结果都是0,所以开始是 <code>ans+=(a-b)*b,a=b;</code></p><p>然后就是计算  ∑  k  i  =  1  k  mod  i  ∑  i  =  1  k  k  mod  i</p><p>然后我们可以发现  {  k  i  ∣  ∣  i  ∈  [  1  ,  k  ]  }  {  k  i  |  i  ∈  [  1  ,  k<br>]  }  的集合中只有  k  −  −  √  k  个元素, <del> 测试发现其实应该是  2  ×  k  −  −  √  2  ×  k<br>个 </del></p><p>对于  k  i  k  i  相等的集合中  k  mod  i  k  mod  i  的解是呈等差数列的,所以可以将 <code>for(inti=1;i&lt;=k;i++) ans += k%i;</code> 分成求解  k  −  −  √  k  个等差数列的和,这就是 <strong> 分段 </strong></p><p>附本题代码<br>———————————————————————————————————–.</p><p>​<br>    LL a,b,ans;</p><pre><code>void work(){    ans = 0;    cin&gt;&gt;a&gt;&gt;b;    if(a&gt;b) ans +=(a-b)*b,a=b;    for(int i=1,j;i&lt;=a;i=j+1){        j=b/(b/i);        if(j&gt;=a) j=a;        ans+=(LL)(j-i+1)*b-(LL)(j-i+1)*(i+j)/2*(b/i); //i~j就是一个块     }    cout&lt;&lt;ans&lt;&lt;endl;}int main(){    work();    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  BZOJ1853 [Scoi2010]幸运数字 [容斥原理]【组合数学】</title>
      <link href="/2017/02/13/xing-yun-shu-zi/"/>
      <url>/2017/02/13/xing-yun-shu-zi/</url>
      
        <content type="html"><![CDATA[<h1 id="BZOJ1853-Scoi2010-幸运数字-容斥原理-【组合数学】"><a href="#BZOJ1853-Scoi2010-幸运数字-容斥原理-【组合数学】" class="headerlink" title="BZOJ1853 [Scoi2010]幸运数字 [容斥原理]【组合数学】"></a>BZOJ1853 [Scoi2010]幸运数字 [容斥原理]【组合数学】</h1><p>2017年02月13日 22:15:06  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：568</p><hr><p> 博客爬取于<code>2019-04-18 17:17:46</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/55058123" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/55058123</a></p><p>题目连接： [ <a href="https://vjudge.net/problem/HYSBZ-1853" target="_blank" rel="noopener">https://vjudge.net/problem/HYSBZ-1853</a></p><p>](<a href="https://vjudge.net/problem/HYSBZ-1853" target="_blank" rel="noopener">https://vjudge.net/problem/HYSBZ-1853</a>)<br>————————————————————————————————————.<br>1853: [Scoi2010]幸运数字</p><p>Time Limit: 2 Sec Memory Limit: 64 MB<br>Submit: 2284 Solved: 834<br>[Submit][Status][Discuss]<br>Description</p><p>在中国，很多人都把6和8视为是幸运数字！lxhgww也这样认为，于是他定义自己的“幸运号码”是十进制表示中只包含数字6和8的那些号码，比如68，666，88<br>8都是“幸运号码”！但是这种“幸运号码”总是太少了，比如在[1,100]的区间内就只有6个（6，8，66，68，86，88），于是他又定义了一种“近似幸运号<br>码”。lxhgww规定，凡是“幸运号码”的倍数都是“近似幸运号码”，当然，任何的“幸运号码”也都是“近似幸运号码”，比如12，16，666都是“近似幸运号码<br>”。 现在lxhgww想知道在一段闭区间[a, b]内，“近似幸运号码”的个数。<br>Input</p><p>输入数据是一行，包括2个数字a和b<br>Output</p><p>输出数据是一行，包括1个数字，表示在闭区间[a, b]内“近似幸运号码”的个数<br>Sample Input</p><p>【样例输入1】</p><p>1 10</p><p>【样例输入2】</p><p>1234 4321</p><p>Sample Output</p><p>【样例输出1】</p><p>2</p><p>【样例输出2】</p><p>809</p><p>HINT</p><p>【数据范围】<br>对于30%的数据，保证1 &lt; =a &lt; =b &lt; =1000000<br>对于100%的数据，保证1 &lt; =a &lt; =b &lt; =10000000000</p><p>————————————————————————————————————.</p><p>首处理出所有的幸运数字,<br>只有  2  10  个.<br>然后找到这些数中的”幸运素数”(就是这些数组成的序列中不能被其他元素整除的数 <del> (类似线性基?!) </del> )</p><p>找到这些数,那么 其实就把这个问题就是成求[a,b]内那些”幸运素数”的倍数有多少个就好了.</p><p>答案就是  c  a  l  c  (  b  )  −  c  a  l  c  (  a  −  1  )</p><p>很明显的一个容斥原理,<br>c  a  l  c  (  x  )  =  a  n  s  =  [  x  一  个  幸  运  素  数  的  积  ]  −  [  x<br>两  个  幸  运  素  数  的  积  ]  +  [  x  三  个  幸  运  素  数  的  积  ]  −  .  .  .  .</p><p>上述问题很容易 不再赘述</p><p>附本题代码<br>————————————————————————————————————.</p><p>​    </p><pre class=" language-cpp"><code class="language-cpp">LL l<span class="token punctuation">,</span>r<span class="token punctuation">,</span>a<span class="token punctuation">[</span><span class="token number">10000</span><span class="token punctuation">]</span><span class="token punctuation">,</span>cnt<span class="token punctuation">,</span>ans<span class="token punctuation">;</span>vector<span class="token operator">&lt;</span>LL<span class="token operator">></span>b<span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">dfs1</span><span class="token punctuation">(</span>LL x<span class="token punctuation">,</span><span class="token keyword">int</span> bit<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>bit<span class="token operator">></span><span class="token number">10</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span> a<span class="token punctuation">[</span><span class="token operator">++</span>cnt<span class="token punctuation">]</span> <span class="token operator">=</span> x<span class="token punctuation">;</span>    <span class="token function">dfs1</span><span class="token punctuation">(</span>x<span class="token operator">*</span><span class="token number">10</span><span class="token operator">+</span><span class="token number">6</span><span class="token punctuation">,</span>bit<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">dfs1</span><span class="token punctuation">(</span>x<span class="token operator">*</span><span class="token number">10</span><span class="token operator">+</span><span class="token number">8</span><span class="token punctuation">,</span>bit<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    cnt<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token function">dfs1</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//printf("%I64d\n",cnt);</span>    <span class="token function">sort</span><span class="token punctuation">(</span>a<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>a<span class="token operator">+</span>cnt<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>cnt<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>j<span class="token operator">&lt;</span>i<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">&amp;&amp;</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">%</span>a<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>b<span class="token punctuation">.</span><span class="token function">pb</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span>LL <span class="token function">dfs2</span><span class="token punctuation">(</span><span class="token keyword">int</span> pos<span class="token punctuation">,</span><span class="token keyword">bool</span> flag <span class="token punctuation">,</span>LL val<span class="token punctuation">,</span>LL <span class="token operator">&amp;</span>x<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>pos<span class="token operator">&lt;</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    LL ans <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    ans<span class="token operator">+</span><span class="token operator">=</span><span class="token function">dfs2</span><span class="token punctuation">(</span>pos<span class="token number">-1</span><span class="token punctuation">,</span>flag<span class="token punctuation">,</span>val<span class="token punctuation">,</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>    LL g <span class="token operator">=</span> <span class="token function">_gcd</span><span class="token punctuation">(</span>val<span class="token punctuation">,</span>b<span class="token punctuation">[</span>pos<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>val<span class="token operator">/</span>g <span class="token operator">&lt;=</span> x<span class="token operator">/</span>b<span class="token punctuation">[</span>pos<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        g <span class="token operator">=</span> val<span class="token operator">/</span>g<span class="token operator">*</span>b<span class="token punctuation">[</span>pos<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>flag<span class="token punctuation">)</span> ans <span class="token operator">+</span><span class="token operator">=</span> x<span class="token operator">/</span>g<span class="token punctuation">;</span>        <span class="token keyword">else</span>     ans <span class="token operator">-</span><span class="token operator">=</span> x<span class="token operator">/</span>g<span class="token punctuation">;</span>        ans<span class="token operator">+</span><span class="token operator">=</span><span class="token function">dfs2</span><span class="token punctuation">(</span>pos<span class="token number">-1</span><span class="token punctuation">,</span><span class="token operator">!</span>flag<span class="token punctuation">,</span>g<span class="token punctuation">,</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> ans<span class="token punctuation">;</span><span class="token punctuation">}</span>LL <span class="token function">calc</span><span class="token punctuation">(</span>LL x<span class="token punctuation">)</span><span class="token punctuation">{</span>    ans <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> id <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span>sz<span class="token operator">=</span>b<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>id<span class="token operator">&lt;</span>sz <span class="token operator">&amp;&amp;</span> b<span class="token punctuation">[</span>id<span class="token punctuation">]</span><span class="token operator">&lt;=</span>x<span class="token punctuation">)</span> id<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token function">dfs2</span><span class="token punctuation">(</span>id<span class="token number">-1</span><span class="token punctuation">,</span><span class="token boolean">true</span><span class="token punctuation">,</span><span class="token number">1ll</span><span class="token punctuation">,</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">work</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    cin<span class="token operator">>></span>l<span class="token operator">>></span>r<span class="token punctuation">;</span>    cout<span class="token operator">&lt;&lt;</span><span class="token function">calc</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span><span class="token operator">-</span><span class="token function">calc</span><span class="token punctuation">(</span>l<span class="token number">-1</span><span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">work</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  BZOJ1853 [Scoi2010]幸运数字 [容斥原理]【组合数学】</title>
      <link href="/2017/02/13/55058123/"/>
      <url>/2017/02/13/55058123/</url>
      
        <content type="html"><![CDATA[<h1 id="BZOJ1853-Scoi2010-幸运数字-容斥原理-【组合数学】"><a href="#BZOJ1853-Scoi2010-幸运数字-容斥原理-【组合数学】" class="headerlink" title="BZOJ1853 [Scoi2010]幸运数字 [容斥原理]【组合数学】"></a>BZOJ1853 [Scoi2010]幸运数字 [容斥原理]【组合数学】</h1><p>2017年02月13日 22:15:06  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：568</p><hr><p> 博客爬取于<code>2019-04-18 17:17:46</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/55058123" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/55058123</a></p><p>题目连接： <a href="https://vjudge.net/problem/HYSBZ-1853" target="_blank" rel="noopener"> https://vjudge.net/problem/HYSBZ-1853</a><br>————————————————————————————————————.<br>1853: [Scoi2010]幸运数字</p><p>Time Limit: 2 Sec Memory Limit: 64 MB<br>Submit: 2284 Solved: 834<br>[Submit][Status][Discuss]<br>Description</p><p>在中国，很多人都把6和8视为是幸运数字！lxhgww也这样认为，于是他定义自己的“幸运号码”是十进制表示中只包含数字6和8的那些号码，比如68，666，88<br>8都是“幸运号码”！但是这种“幸运号码”总是太少了，比如在[1,100]的区间内就只有6个（6，8，66，68，86，88），于是他又定义了一种“近似幸运号<br>码”。lxhgww规定，凡是“幸运号码”的倍数都是“近似幸运号码”，当然，任何的“幸运号码”也都是“近似幸运号码”，比如12，16，666都是“近似幸运号码<br>”。 现在lxhgww想知道在一段闭区间[a, b]内，“近似幸运号码”的个数。<br>Input</p><p>输入数据是一行，包括2个数字a和b<br>Output</p><p>输出数据是一行，包括1个数字，表示在闭区间[a, b]内“近似幸运号码”的个数<br>Sample Input</p><p>【样例输入1】</p><p>1 10</p><p>【样例输入2】</p><p>1234 4321</p><p>Sample Output</p><p>【样例输出1】</p><p>2</p><p>【样例输出2】</p><p>809</p><p>HINT</p><p>【数据范围】<br>对于30%的数据，保证1 &lt; =a &lt; =b &lt; =1000000<br>对于100%的数据，保证1 &lt; =a &lt; =b &lt; =10000000000</p><p>————————————————————————————————————.</p><p>首处理出所有的幸运数字,<br>只有  2  10  个.<br>然后找到这些数中的”幸运素数”(就是这些数组成的序列中不能被其他元素整除的数 <del> (类似线性基?!) </del> )</p><p>找到这些数,那么 其实就把这个问题就是成求[a,b]内那些”幸运素数”的倍数有多少个就好了.</p><p>答案就是  c  a  l  c  (  b  )  −  c  a  l  c  (  a  −  1  )</p><p>很明显的一个容斥原理,<br>c  a  l  c  (  x  )  =  a  n  s  =  [  x  一  个  幸  运  素  数  的  积  ]  −  [  x<br>两  个  幸  运  素  数  的  积  ]  +  [  x  三  个  幸  运  素  数  的  积  ]  −  .  .  .  .</p><p>上述问题很容易 不再赘述</p><p>附本题代码<br>————————————————————————————————————.</p><p>​    </p><pre class=" language-cpp"><code class="language-cpp">LL l<span class="token punctuation">,</span>r<span class="token punctuation">,</span>a<span class="token punctuation">[</span><span class="token number">10000</span><span class="token punctuation">]</span><span class="token punctuation">,</span>cnt<span class="token punctuation">,</span>ans<span class="token punctuation">;</span>vector<span class="token operator">&lt;</span>LL<span class="token operator">></span>b<span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">dfs1</span><span class="token punctuation">(</span>LL x<span class="token punctuation">,</span><span class="token keyword">int</span> bit<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>bit<span class="token operator">></span><span class="token number">10</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span> a<span class="token punctuation">[</span><span class="token operator">++</span>cnt<span class="token punctuation">]</span> <span class="token operator">=</span> x<span class="token punctuation">;</span>    <span class="token function">dfs1</span><span class="token punctuation">(</span>x<span class="token operator">*</span><span class="token number">10</span><span class="token operator">+</span><span class="token number">6</span><span class="token punctuation">,</span>bit<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">dfs1</span><span class="token punctuation">(</span>x<span class="token operator">*</span><span class="token number">10</span><span class="token operator">+</span><span class="token number">8</span><span class="token punctuation">,</span>bit<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    cnt<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token function">dfs1</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//printf("%I64d\n",cnt);</span>    <span class="token function">sort</span><span class="token punctuation">(</span>a<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>a<span class="token operator">+</span>cnt<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>cnt<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>j<span class="token operator">&lt;</span>i<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">&amp;&amp;</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">%</span>a<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>b<span class="token punctuation">.</span><span class="token function">pb</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span>LL <span class="token function">dfs2</span><span class="token punctuation">(</span><span class="token keyword">int</span> pos<span class="token punctuation">,</span><span class="token keyword">bool</span> flag <span class="token punctuation">,</span>LL val<span class="token punctuation">,</span>LL <span class="token operator">&amp;</span>x<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>pos<span class="token operator">&lt;</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    LL ans <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    ans<span class="token operator">+</span><span class="token operator">=</span><span class="token function">dfs2</span><span class="token punctuation">(</span>pos<span class="token number">-1</span><span class="token punctuation">,</span>flag<span class="token punctuation">,</span>val<span class="token punctuation">,</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>    LL g <span class="token operator">=</span> <span class="token function">_gcd</span><span class="token punctuation">(</span>val<span class="token punctuation">,</span>b<span class="token punctuation">[</span>pos<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>val<span class="token operator">/</span>g <span class="token operator">&lt;=</span> x<span class="token operator">/</span>b<span class="token punctuation">[</span>pos<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        g <span class="token operator">=</span> val<span class="token operator">/</span>g<span class="token operator">*</span>b<span class="token punctuation">[</span>pos<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>flag<span class="token punctuation">)</span> ans <span class="token operator">+</span><span class="token operator">=</span> x<span class="token operator">/</span>g<span class="token punctuation">;</span>        <span class="token keyword">else</span>     ans <span class="token operator">-</span><span class="token operator">=</span> x<span class="token operator">/</span>g<span class="token punctuation">;</span>        ans<span class="token operator">+</span><span class="token operator">=</span><span class="token function">dfs2</span><span class="token punctuation">(</span>pos<span class="token number">-1</span><span class="token punctuation">,</span><span class="token operator">!</span>flag<span class="token punctuation">,</span>g<span class="token punctuation">,</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> ans<span class="token punctuation">;</span><span class="token punctuation">}</span>LL <span class="token function">calc</span><span class="token punctuation">(</span>LL x<span class="token punctuation">)</span><span class="token punctuation">{</span>    ans <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> id <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span>sz<span class="token operator">=</span>b<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>id<span class="token operator">&lt;</span>sz <span class="token operator">&amp;&amp;</span> b<span class="token punctuation">[</span>id<span class="token punctuation">]</span><span class="token operator">&lt;=</span>x<span class="token punctuation">)</span> id<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token function">dfs2</span><span class="token punctuation">(</span>id<span class="token number">-1</span><span class="token punctuation">,</span><span class="token boolean">true</span><span class="token punctuation">,</span><span class="token number">1ll</span><span class="token punctuation">,</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">work</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    cin<span class="token operator">>></span>l<span class="token operator">>></span>r<span class="token punctuation">;</span>    cout<span class="token operator">&lt;&lt;</span><span class="token function">calc</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span><span class="token operator">-</span><span class="token function">calc</span><span class="token punctuation">(</span>l<span class="token number">-1</span><span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">work</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  [HYSBZ/BZOJ2301]Problem b [莫比乌斯反演+分块] 【组合数学】</title>
      <link href="/2017/02/12/55006530/"/>
      <url>/2017/02/12/55006530/</url>
      
        <content type="html"><![CDATA[<h1 id="HYSBZ-BZOJ2301-Problem-b-莫比乌斯反演-分块-【组合数学】"><a href="#HYSBZ-BZOJ2301-Problem-b-莫比乌斯反演-分块-【组合数学】" class="headerlink" title="[HYSBZ/BZOJ2301]Problem b [莫比乌斯反演+分块] 【组合数学】"></a>[HYSBZ/BZOJ2301]Problem b [莫比乌斯反演+分块] 【组合数学】</h1><p>2017年02月12日 22:06:35  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：533</p><hr><p> 博客爬取于<code>2019-04-18 17:17:47</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/55006530" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/55006530</a></p><p>题目连接： <a href="https://vjudge.net/problem/HYSBZ-2301" target="_blank" rel="noopener"> https://vjudge.net/problem/HYSBZ-2301</a></p><p>————————————————————————————————————–.<br>2301: [HAOI2011]Problem b</p><p>Time Limit: 50 Sec<br>Memory Limit: 256 MB</p><p>Description</p><p>对于给出的n个询问，每次求有多少个数对(x,y)，满足a≤x≤b，c≤y≤d，且gcd(x,y) = k，gcd(x,y)函数为x和y的最大公约数。</p><p>Input<br>第一行一个整数n，接下来n行每行五个整数，分别表示a、b、c、d、k</p><p>Output<br>共n行，每行一个整数表示满足要求的数对(x,y)的个数</p><p>Sample Input</p><p>2<br>2 5 1 5 1<br>1 5 1 5 2</p><p>Sample Output</p><p>14<br>3</p><p>HINT</p><p>100%的数据满足：1≤n≤50000，1≤a≤b≤50000，1≤c≤d≤50000，1≤k≤50000</p><p>————————————————————————————————————–.</p><p>解题思路:<br>对于求  (  a  ,  c  )  (  b  ,  d  )  区间内的解 我们可以用容斥原理解决<br>c  a  l  c  (  b  ,  d  )  −  c  a  l  c  (  a  −  1  ,  d  )  −  c  a  l  c<br>(  b  ,  c  −  1  )  +  c  a  l  c  (  a  −  1  ,  c  −  1  )</p><p>那么对于求每一个  c  a  l  c  (  x  ,  y  )  ;  时首先要明确的是求  gcd  (  x  ,  y  )  =  k<br>就是求  gcd  (  x  /  k  ,  y  /  k  )  =  1  的解,</p><blockquote><p>证明 :<br>a  ×  x  +  b  ×  y  =  k  a  ×  x  k  +  b  ×  y  k  =  1  a  ×  x  k  +<br>b  ×  y  k  =  1<br>——证毕</p></blockquote><p>然后设  f  (  i  )  为  g  c  d  (  x  ,  y  )  =  i  时  (  x  ,  y  )  的  对  数  ，<br>F  (  i  )  表  示  满  足  i  |  g  c  d  (  x  ,  y  )  的  (  x  ,  y  )  的  对<br>数  ，  显  然  F  (  i  )  =  ⌊  n  i  ⌋  ⌊  m  i  ⌋</p><p>然后根据莫比乌斯反演公式的到<br>F  (  n  )  =  ∑  i  |  n  f  (  i  )  =  &gt; f  (  d  )  =  ∑  i  |  d  μ  (  d<br>i  )  ×  F  (  d  )  =  ∑  i  |  d  μ  (  d  i  )  ×  ⌊  n  i  ⌋  ⌊  m  i  ⌋</p><p>当i=1时，  f  (  1  )  =  ∑  m  i  n  (  n  ,  m  )  d  =  1  μ  (  d  )  ⌊  n  ⌋<br>⌊  m  ⌋</p><p>由于  ⌊  n  i  ⌋  的取值最多只有  2  n  −  −  √  个（这个很容易证明:在  n  n  −  −  √  +  1  &lt; i<br>&lt; =  n  时，  y  =  ⎧  ⎩  ⎨  ⎪  ⎪  ⎪  ⎪  ⎪  ⎪  ⎪  ⎪  ⎪  ⎪  1  2  .  .  .  .  .<br>.  n  −  −  √  n  2  &lt; i  &lt; =  n  n  3  &lt; i  &lt; =  n  2  n  n  √  +  1  &lt; i  &lt;<br>=  n  n  √  ，到这里已经有sqrt(n)个取值了，还有  n  −  −  √  个i，即使每一个i都对应一个不同的  ⌊  n  i  ⌋<br>，也只有  n  −  −  √  个取值），我们算出μ的前缀和sum,然后只需要  O  (  2  (  n  −  −  √  +  m  −  −<br>√  )  )  的时间（即分块优化）回答每次询问。</p><p><a href="http://blog.csdn.net/outer_form/article/details/50590197" target="_blank" rel="noopener"> 参(chao)考(xi)于此 </a></p><p>但是有一个奇怪的地方，就是我用%I64d输出 显示PE %lld输出 显示WA 用%d输出就AC了。。。。醉了。。。</p><p>附本题代码<br>————————————————————————————————————–.</p><pre><code>int a,b,c,d,k;int prime[N],pre[N],mu[N],kp;bool Is_or[N];void Prime(){    kp = 0;    memset(Is_or,true,sizeof(Is_or));    Is_or[0]=Is_or[1]=0;    mu[1]=pre[1]=1;    for(int i=2;i&lt;=50000;i++){        if(Is_or[i]) mu[i]=-1,prime[kp++]=i;        for(int j=0;j&lt;kp&amp;&amp;prime[j]*i&lt;=50000;j++){            Is_or[prime[j]*i]=0;            if(0==i%prime[j]) {mu[prime[j]*i]=0;break; }            mu[prime[j]*i] = -mu[i];        }        pre[i]=pre[i-1]+mu[i];    }    return ;}int calc(int x,int y){    x/=k,y/=k;    if(x&gt;y) x^=y,y^=x,x^=y;    int ans = 0;    for(int i=1,pos;i&lt;=x;i=pos+1){//分块优化        pos = min(x/(x/i),y/(y/i));        ans+=(pre[pos]-pre[i-1])*(x/i)*(y/i);    }    return ans ;}void work(){    scanf(&quot;%d%d%d%d%d&quot;,&amp;a,&amp;b,&amp;c,&amp;d,&amp;k);    printf(&quot;%d\n&quot;,calc(b,d)                    -calc(a-1,d)                    -calc(b,c-1)                    +calc(a-1,c-1));}int main(){    Prime();    int _ = 1;    //while(~scanf(&quot;%d&quot;,&amp;_))    scanf(&quot;%d&quot;,&amp;_);    while(_--)   work();    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  容斥原理习题</title>
      <link href="/2017/02/11/54989141/"/>
      <url>/2017/02/11/54989141/</url>
      
        <content type="html"><![CDATA[<h1 id="容斥原理习题"><a href="#容斥原理习题" class="headerlink" title="容斥原理习题"></a>容斥原理习题</h1><p>2017年02月11日 23:09:40  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：823</p><hr><p> 博客爬取于<code>2019-04-18 17:17:49</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/54989141" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/54989141</a></p><p>练习题目VJ: <a href="https://vjudge.net/contest/77876#overview" target="_blank" rel="noopener"> https://vjudge.net/contest/77876#overview</a></p><h1 id="HDU-1796-How-many-integers-can-you-find"><a href="#HDU-1796-How-many-integers-can-you-find" class="headerlink" title="HDU 1796 How many integers can you find"></a>HDU 1796 How many integers can you find</h1><p><a href="http://blog.csdn.net/qq_33184171/article/details/54982226" target="_blank" rel="noopener"> 戳这里 </a></p><h1 id="HDU-1685-Booksort"><a href="#HDU-1685-Booksort" class="headerlink" title="HDU 1685 Booksort"></a>HDU 1685 Booksort</h1><p>这题应该是整错了 不是容斥原理,看题解都是IDA*搜索</p><h1 id="HDU-2204-Eddy’s爱好"><a href="#HDU-2204-Eddy’s爱好" class="headerlink" title="HDU 2204 Eddy’s爱好"></a>HDU 2204 Eddy’s爱好</h1><p><a href="http://blog.csdn.net/qq_33184171/article/details/54982748" target="_blank" rel="noopener"> 戳这里 </a></p><h1 id="HDU-4407-Sum"><a href="#HDU-4407-Sum" class="headerlink" title="HDU 4407 Sum"></a>HDU 4407 Sum</h1><p>对于替换的先不管 最后暴力处理即可,<br>不替换的时候可以分两段处理<br>分别计算[1,a-1]和[a,b]的 然后相减就好了<br>处理先对p素因子分解,然后容斥原理计算,</p><h1 id="HDU-2841-Visible-Trees"><a href="#HDU-2841-Visible-Trees" class="headerlink" title="HDU 2841 Visible Trees"></a>HDU 2841 Visible Trees</h1><p>显然能够知道题目要求的是<br>满足  g  c  d  (  x  ,  y  )  !  =  1  且  x  &lt; =  n  且  y  &lt; =  m  的数量<br>由于数据量不大 ,可以枚举n值然后计算[1,m]中与n不互质的数的个数,然后用m减去即可<br>对于计算[1,m]中与n不互质的数的个数,我们还是要用到容斥原理,</p><p>a  n  s  =  +  最  大  公  约  数  因  子  个  数  为  1  的  −  最  大  公  约  数  因  子  个<br>数  为  2  的  +  最  大  公  约  数  因  子  个  数  为  3  的  −  最  大  公  约  数  因  子  个<br>数  为  4  的  .  .  .  .</p><p>最大公约数因子个数最大也就是8 因为2<em>3</em>5<em>7</em>11<em>13</em>17*19 &gt; 1e6<br>所以爆搜也不会超时</p><h1 id="POJ-3695-Rectangles"><a href="#POJ-3695-Rectangles" class="headerlink" title="POJ 3695 Rectangles"></a>POJ 3695 Rectangles</h1><p>乱搞题，首先居然是想到线段树，要不是做专题就陷进去了。</p><p>然后想到求多个矩形相交面积的方法搞，因为n比较小但(1&lt;&lt; n)远大于1e5,所以不用预处理出所有情况,只要对待查询的情况容斥原理计算就好.</p>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  hdu 2204 Eddy&#39;s爱好 [容斥原理]【组合数学】</title>
      <link href="/2017/02/11/54982748/"/>
      <url>/2017/02/11/54982748/</url>
      
        <content type="html"><![CDATA[<h1 id="hdu-2204-Eddy’s爱好-容斥原理-【组合数学】"><a href="#hdu-2204-Eddy’s爱好-容斥原理-【组合数学】" class="headerlink" title="hdu 2204 Eddy’s爱好 [容斥原理]【组合数学】"></a>hdu 2204 Eddy’s爱好 [容斥原理]【组合数学】</h1><p>2017年02月11日 14:04:07  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：284</p><hr><p> 博客爬取于<code>2019-04-18 17:17:50</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/54982748" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/54982748</a></p><p>题目链接： <a href="http://acm.hdu.edu.cn/showproblem.php?pid=2204" target="_blank" rel="noopener"> http://acm.hdu.edu.cn/showproblem.php?pid=2204</a></p><p>——————————————————————————————————————.<br>2017 口碑商家客流量预测大赛》<br>Eddy’s爱好</p><p>Time Limit: 3000/1000 MS (Java/Others) Memory Limit: 32768/32768 K<br>(Java/Others)<br>Total Submission(s): 2436 Accepted Submission(s): 1118</p><p>Problem Description<br>Ignatius 喜欢收集蝴蝶标本和邮票，但是Eddy的爱好很特别，他对数字比较感兴趣，他曾经一度沉迷于素数，而现在他对于一些新的特殊数比较有兴趣。<br>这些特殊数是这样的：这些数都能表示成M^K，M和K是正整数且K&gt;1。<br>正当他再度沉迷的时候，他发现不知道什么时候才能知道这样的数字的数量，因此他又求助于你这位聪明的程序员，请你帮他用程序解决这个问题。<br>为了简化，问题是这样的：给你一个正整数N，确定在1到N之间有多少个可以表示成M^K（K&gt;1)的数。</p><p>Input<br>本题有多组测试数据，每组包含一个整数N，1&lt;=N&lt;=1000000000000000000(10^18).</p><p>Output<br>对于每组输入，请输出在在1到N之间形式如M^K的数的总数。<br>每组输出占一行。</p><p>Sample Input<br>10<br>36<br>1000000000000000000</p><p>Sample Output<br>4<br>9<br>1001003332</p><p>Author<br>Eddy</p><p>Recommend<br>lcy</p><p>——————————————————————————————————————.<br>题目大意:<br>求在[1,n]中能用  M  K  表示的数的个数,</p><p>解题思路:</p><p>N  ∈  [  1  ,  10  8  ]  ,所以K一定小于60,<br>又因为  x  a  ∗  b  =  x  a  b  ,所以只要求指数为质数的就行了,</p><p>x  p  &lt; =  n  ,即x的就是指数为p的个数</p><p>利用容斥原理,去掉重复的就行了,</p><p>于2^60&gt;10^18，2<em>3</em>5*7&gt;60，所以只要枚举到三即可。</p><p><strong> 注: </strong> 最后一个样例应该有问题, 我的代码和网上代码结果都是 <strong> 1001003331 </strong> ,找了好久的精度…. </p><p>附本题代码<br>——————————————————————————————————————.</p><pre><code>LL n,ans;int prime[100]={2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59};void dfs(int id,bool flag,int val,int cnt){    if(cnt == 0){        LL tmp = pow(n,1.0/val); //指数为val的个数        if(pow(tmp,0.0+val)&gt;n) tmp--;tmp--;        if(tmp&gt;0){            if(flag) ans+=tmp;            else     ans-=tmp;        }        return ;    }    if(id&gt;=17) return ;    if(val*prime[id]&lt;60)    dfs(id+1,flag,val*prime[id],cnt-1);    dfs(id+1,flag,val,cnt);}int main(){    while(~scanf(&quot;%I64d&quot;,&amp;n)){        ans = 0ll;        for(int i=1;i&lt;=3;i++) dfs(0,i&amp;1,1,i);        printf(&quot;%I64d\n&quot;,ans+1);    }    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  HDU 1796 How many integers can you find [容斥定理] 【组合数学】</title>
      <link href="/2017/02/11/54982226/"/>
      <url>/2017/02/11/54982226/</url>
      
        <content type="html"><![CDATA[<h1 id="HDU-1796-How-many-integers-can-you-find-容斥定理-【组合数学】"><a href="#HDU-1796-How-many-integers-can-you-find-容斥定理-【组合数学】" class="headerlink" title="HDU 1796 How many integers can you find [容斥定理] 【组合数学】"></a>HDU 1796 How many integers can you find [容斥定理] 【组合数学】</h1><p>2017年02月11日 12:49:25  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：315<br>标签：  <a href="https://so.csdn.net/so/search/s.do?q=数学&amp;t=blog" target="_blank" rel="noopener"> 数学 </a></p><p>个人分类：  <a href="https://blog.csdn.net/qq_33184171/article/category/6162724" target="_blank" rel="noopener"> 数学 </a> <a href="https://blog.csdn.net/qq_33184171/article/category/6330935" target="_blank" rel="noopener"><br>=== 组合数学 === </a> <a href="https://blog.csdn.net/qq_33184171/article/category/6117382" target="_blank" rel="noopener"><br>hdu </a></p><hr><p> 博客爬取于<code>2019-04-18 17:17:51</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/54982226" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/54982226</a></p><p>题目连接： <a href="http://acm.hdu.edu.cn/showproblem.php?pid=1796" target="_blank" rel="noopener"> http://acm.hdu.edu.cn/showproblem.php?pid=1796</a><br>———————————————————————————————-.<br>看详情——《IJCAI 2017 口碑商家客流量预测大赛》<br>How many integers can you find</p><p>Time Limit: 12000/5000 MS (Java/Others) Memory Limit: 65536/32768 K<br>(Java/Others)<br>Total Submission(s): 7728 Accepted Submission(s): 2281</p><p>Problem Description<br>Now you get a number N, and a M-integers set, you should find out how many<br>integers which are small than N, that they can divided exactly by any integers<br>in the set. For example, N=12, and M-integer set is {2,3}, so there is another<br>set {2,3,4,6,8,9,10}, all the integers of the set can be divided exactly by 2<br>or 3. As a result, you just output the number 7.</p><p>Input<br>There are a lot of cases. For each case, the first line contains two integers<br>N and M. The follow line contains the M integers, and all of them are<br>different from each other. 0&lt; N&lt;2^31,0&lt; M&lt;=10, and the M integer are non-<br>negative and won’t exceed 20.</p><p>Output<br>For each case, output the number.</p><p>Sample Input<br>12 2<br>2 3</p><p>Sample Output<br>7</p><p>Author<br>wangye<br>———————————————————————————————–.<br>题目大意:<br>求小于n的能够被集合中任意数字整除的数的个数</p><p>解题思路:<br>容斥原理入门题,</p><p>a  n  s  =  n  l  c  m  {  一  个  元  素  }  −  n  l  c  m  {  两  个  元  素  }  +<br>n  l  c  m  {  三  个  元  素  }  −  .  .  .  .  n  l  c  m  {  所  有  元  素  }</p><p>实现很好实现 可以状压搞，也可以dfs，但是发现dfs明显要块与状压啊。。</p><p><strong> 附本题代码 </strong><br>———————————————————————————————–.<br>状压枚举形式 655ms；</p><pre><code>int a[100];int main(){    int n,m;    while(~scanf(&quot;%d%d&quot;,&amp;n,&amp;m)){        for(int i=0;i&lt;m;i++) {            scanf(&quot;%d&quot;,&amp;a[i]);            if(a[i]==0) a[i]=INF;        }        sort(a,a+m);        if(a[m-1]==INF) m--;/*        printf(&quot;the numbers of %d  (1&lt;&lt;m) = %d: \n&quot;,m,(1&lt;&lt;m));        for(int i=0;i&lt;m;i++) printf(&quot;%d%c&quot;,a[i],(i==m-1)?&#39;\n&#39;:&#39; &#39;);        lalal;*/        n--;        int ans = 0,num,sum;        for(int i=1;i&lt;(1&lt;&lt;m);i++){            num = 0, sum = 1;            for(int j=0;j&lt;m;j++){                if(i&amp;(1&lt;&lt;j)){                    sum=sum/__gcd(sum,a[j])*a[j];                    num++;                }            }            if(num&amp;1) ans+=n/sum;            else      ans-=n/sum;            //printf(&quot;%d %d\n&quot;,ans,sum);        }        printf(&quot;%d\n&quot;,ans);    }    return 0;}</code></pre><p>dfs形式 202ms</p><pre><code>int n,m;int a[100],ans;inline int gcd(int a,int b){return (!b)?a:gcd(b,a%b);}inline int lcm(int a,int b){return a/gcd(a,b)*b;     }void dfs(int id,bool flag,int cnt){    cnt = lcm(a[id],cnt);    if(flag ) ans += n/cnt;    else      ans -= n/cnt;    for(int i=id+1;i&lt;m;i++)dfs(i,!flag,cnt);}int main(){    while(~scanf(&quot;%d%d&quot;,&amp;n,&amp;m)){        n--;        for(int i=0;i&lt;m;i++) {            scanf(&quot;%d&quot;,&amp;a[i]);            if(a[i]==0) a[i]=INF;        }        sort(a,a+m);        if(a[m-1]==INF) m--;        ans = 0;        for(int i=0;i&lt;m;i++) dfs(i,true,1);        printf(&quot;%d\n&quot;,ans);    }    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hdu </tag>
            
            <tag> 数学 </tag>
            
            <tag> 组合数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  HDU 2222 Keywords Search [AC自动机]【字符串】</title>
      <link href="/2017/02/11/54981815/"/>
      <url>/2017/02/11/54981815/</url>
      
        <content type="html"><![CDATA[<h1 id="HDU-2222-Keywords-Search-AC自动机-【字符串】"><a href="#HDU-2222-Keywords-Search-AC自动机-【字符串】" class="headerlink" title="HDU 2222 Keywords Search [AC自动机]【字符串】"></a>HDU 2222 Keywords Search [AC自动机]【字符串】</h1><p>2017年02月11日 11:49:26  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：144</p><hr><p> 博客爬取于<code>2019-04-18 17:17:52</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/54981815" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/54981815</a></p><p>题目连接： <a href="http://acm.hdu.edu.cn/showproblem.php?pid=2222" target="_blank" rel="noopener"> http://acm.hdu.edu.cn/showproblem.php?pid=2222</a></p><p>——————————————————————————————————-.<br>Keywords Search</p><p>Time Limit: 2000/1000 MS (Java/Others) Memory Limit: 131072/131072 K<br>(Java/Others)<br>Total Submission(s): 59295 Accepted Submission(s): 19490</p><p>Problem Description<br>In the modern time, Search engine came into the life of everybody like Google,<br>Baidu, etc.<br>Wiskey also wants to bring this feature to his image retrieval system.<br>Every image have a long description, when users type some keywords to find the<br>image, the system will match the keywords with description of image and show<br>the image which the most keywords be matched.<br>To simplify the problem, giving you a description of image, and some keywords,<br>you should tell me how many keywords will be match.</p><p>Input<br>First line will contain one integer means how many cases will follow by.<br>Each case will contain two integers N means the number of keywords and N<br>keywords follow. (N &lt;= 10000)<br>Each keyword will only contains characters ‘a’-‘z’, and the length will be not<br>longer than 50.<br>The last line is the description, and the length will be not longer than<br>1000000.</p><p>Output<br>Print how many keywords are contained in the description.</p><p>Sample Input<br>1<br>5<br>she<br>he<br>say<br>shr<br>her<br>yasherhs</p><p>Sample Output<br>3</p><p>——————————————————————————————————–.<br>题目大意:就是有n个单词,问你这n个单词在文本中出现的有几个</p><p>解题思路:<br>AC自动机入门题,<br>多模式匹配</p><p>附本题代码<br>——————————————————————————————————–.</p><pre><code>#include &lt;bits/stdc++.h&gt;using namespace std;const int kind = 26;struct node{    node *fail;    node *next[kind];    int cnt;    node(){        fail = NULL;        cnt = 0;        memset(next,NULL,sizeof(next));    }}*q[500001];char keyword[51];char str[1000001];int head,tail;void insert(char *str,node *root){    node *p =root;    int i = 0,index;    while(str[i]){        index = str[i]-&#39;a&#39;;        if(p-&gt;next[index]==NULL) p-&gt;next[index] = new node();        p = p-&gt;next[index];        i++;    }    p-&gt;cnt++;}void build_ac_automation(node *root){    root-&gt;fail=NULL;    q[head++]=root;    while(head!=tail){        node *temp = q[tail++];        node *p=NULL;        for(int i=0;i&lt;26;i++){            if(temp-&gt;next[i]!=NULL){                if(temp == root) temp-&gt;next[i]-&gt;fail=root;                else {                    p = temp-&gt;fail;                    while(p!=NULL){                        if(p-&gt;next[i]!=NULL){                            temp-&gt;next[i]-&gt;fail=p-&gt;next[i];                            break;                        }                        p = p -&gt; fail;                    }                    if(p==NULL) temp-&gt;next[i]-&gt;fail=root;                }                q[head++] = temp-&gt;next[i];            }        }    }}int query(node *root){    int i=0,cnt=0,index,len=strlen(str);    node *p=root;    while(str[i]){        index=str[i]-&#39;a&#39;;        while(p-&gt;next[index]==NULL &amp;&amp; p!=root) p=p-&gt;fail;        p=p-&gt;next[index];        p=(p==NULL)?root:p;        node *temp = p;        while(temp!=root &amp;&amp; temp-&gt;cnt!=-1){            cnt+=temp-&gt;cnt;            temp-&gt;cnt=-1;            temp=temp-&gt;fail;        }        i++;    }    return cnt;}int main(){    int _ = 1,kcase = 0;    while(~scanf(&quot;%d&quot;,&amp;_)){        while(_--){            head = tail = 0;            node *root = new node();            int n;            scanf(&quot;%d&quot;,&amp;n);            getchar();            for(int i=0;i&lt;n;i++){                gets(str);                insert(str,root);            }            build_ac_automation(root);            scanf(&quot;%s&quot;,str);            printf(&quot;%d\n&quot;,query(root));        }    }    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  “玲珑杯”ACM比赛 Round</title>
      <link href="/2017/02/10/54974236/"/>
      <url>/2017/02/10/54974236/</url>
      
        <content type="html"><![CDATA[<h1 id="“玲珑杯”ACM比赛-Round-9-A-–-Check-in-Problem-因子个数-【数论】"><a href="#“玲珑杯”ACM比赛-Round-9-A-–-Check-in-Problem-因子个数-【数论】" class="headerlink" title="“玲珑杯”ACM比赛 Round #9 A – Check-in Problem [因子个数]【数论】"></a>“玲珑杯”ACM比赛 Round #9 A – Check-in Problem [因子个数]【数论】</h1><p>2017年02月10日 21:31:20  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：409</p><hr><p> 博客爬取于<code>2019-04-18 17:17:53</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/54974236" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/54974236</a></p><p>题目连接: <a href="http://www.ifrog.cc/acm/problem/1084" target="_blank" rel="noopener"> http://www.ifrog.cc/acm/problem/1084</a></p><p>———————————————————————————————————-.<br>A – Check-in Problem<br>Time Limit：5s Memory Limit：128MByte</p><p>Submissions：921 Solved：55</p><p>DESCRIPTION</p><p>A positive integer x is called p-bizarre number if the number of the divisors<br>of x is p exactly.<br>Your task is testing whether the given positive integer n is a p-bizarre<br>number or not.</p><p>INPUT</p><p>The first line contains a positive integer T, which represents there are T<br>test cases.<br>The following is test cases. For each test case:<br>The only one line contains a positive integer n and an odd prime p.<br>1≤T≤10^5,1≤n≤10^18,2&lt; p≤10^9</p><p>OUTPUT</p><p>For each test case, output in one line, print “YES” (without quote) if n is a<br>p-bizarre number, print “NO” (without quote) otherwise.</p><p>SAMPLE INPUT</p><p>3<br>9 3<br>971528476274196481 7<br>150094635296999121 37</p><p>SAMPLE OUTPUT<br>YES<br>NO<br>YES<br>———————————————————————————————————-.<br>题目大意:<br>就是问你n的因子个数是不是p个</p><p>解题思路:<br>对于一个素数n的因子个数 我们可以对n做算术基本定理展开<br>n  =  p  a  1  1  ×  p  a  2  2  ×  p  a  3  3  ×  .  .  .  ×  p  a  r  r</p><p>那么数的因子个数就是  ∑  r  i  =  1  (  a  1  +  1  )  ×  (  a  2  +  1  )  ×  (  a  3<br>+  1  )  ×  .  .  .  ×  (  a  n  +  1  )</p><p>input里面又说<br>The only one line contains a positive integer n and an odd <strong> prime </strong> p.</p><p>那么对于p是素数的情况 只能说明n的质因子只有一种,</p><p>因为上述,所以我想到以对1e6(因为题目说p最小是3,n最大是10^18,所以1e6就够了)内的素数筛法取一遍,然后二分寻找答案即可 <strong> 注意会爆LL</strong> ,但是无论怎么控制溢出,最后代码写成了 <a href="http://paste.ubuntu.com/23966952/" target="_blank" rel="noopener"> 这样 </a> 但是还是WA…心塞…</p><p>献上官方题解</p><blockquote><p>注意到  p  是质数，只有当  n  是质数的  p  −  1  次幂时，  n  的约数才可能恰好有  p  个，所以判定一个正整数  n  是<br>p  −  奇异数，只需检验  p  −  1  n  −  −  √  是整数，且  p  −  1  n  −  −  √  是质数。预处理  10<br>9  −  −  −  √  以内的素数（共  3401  个），进行开根和判断素数即可，时间复杂度  O  (  n  −  −  √  ln  n  )<br>。<br>事实上  p  &gt; 3  的情况很少有解，直接预处理所有有解的情况即可，可以防止写出有问题的开根，而  p  =  3  的判断素数也可以用 Miller-<br>Rabin 算法判定（需要  O  (  1  )  的模乘法）。</p></blockquote><p>改了2个小时的溢出，最后都没签到。。。。。。</p><p>献上标程一枚<br>———————————————————————————————————-.</p><pre><code>#include &lt;cmath&gt;#include &lt;stdio.h&gt;#include &lt;cassert&gt;#include &lt;algorithm&gt;typedef long long LL;const int maxn = 31623, maxm = 17, maxp = 61, maxt = 100001, maxv2 = (int)1e9;const LL maxv = (LL)1e18;int tot, pr[maxn], d[maxn], sz[maxm];LL pp[maxm][maxn];bool isprime(int x){    if(x &lt; 2)    return 0;    if(x &lt; maxn) return d[x] == x;    for(int i = 0; i &lt; tot &amp;&amp; pr[i] * pr[i] &lt;= x; ++i)        if(x % pr[i] == 0)  return 0;    return 1;}int main(){    for(int i = 2; i &lt; maxn; ++i)    {        if(!d[i])            pr[tot++] = d[i] = i;        for(int j = 0, k; (k = i * pr[j]) &lt; maxn; ++j)        {            d[k] = pr[j];            if(d[i] == pr[j])break;        }    }    for(int i = 2; i &lt; maxm; ++i)        for(int j = 0; j &lt; tot; ++j)        {            int rem = pr[i] - 1;            LL val = 1, lim = maxv / pr[j];            for( ; rem &amp;&amp; val &lt;= lim; --rem, val *= pr[j]);            if(rem)     break;            pp[i][sz[i]++] = val;        }    int t;    LL n, p;    assert(scanf(&quot;%d&quot;, &amp;t) == 1    &amp;&amp; 1 &lt;= t &amp;&amp; t &lt; maxt);    while(t--)    {        assert(scanf(&quot;%lld%lld&quot;, &amp;n, &amp;p) == 2        &amp;&amp; 1 &lt;= n &amp;&amp; n &lt;= maxv        &amp;&amp; (p &amp; 1) &amp;&amp; p &lt;= maxv2 &amp;&amp; isprime(p));        if(p &gt;= maxp || d[p] != p)        {            puts(&quot;NO&quot;);            continue;        }        if(p == 3)        {            LL val = (LL)sqrt(n);            for( ; val * val &gt; n; --val);            for( ; (val + 1) * (val + 1) &lt;= n; ++val);            puts(val * val == n &amp;&amp; isprime(val) ? &quot;YES&quot; : &quot;NO&quot;);            continue;        }        for(int i = 2; i &lt; maxm; ++i)            if(pr[i] == p)            {                puts(*std::lower_bound(pp[i], pp[i] + sz[i], n) == n ? &quot;YES&quot; : &quot;NO&quot;);                break;            }    }    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  HUST 1588 辗转数对 []【数学】</title>
      <link href="/2017/02/10/54971709/"/>
      <url>/2017/02/10/54971709/</url>
      
        <content type="html"><![CDATA[<h1 id="HUST-1588-辗转数对-【数学】"><a href="#HUST-1588-辗转数对-【数学】" class="headerlink" title="HUST 1588 辗转数对 []【数学】"></a>HUST 1588 辗转数对 []【数学】</h1><p>2017年02月10日 16:24:08  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：165</p><hr><p> 博客爬取于<code>2019-04-18 17:17:54</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/54971709" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/54971709</a></p><p>题目链接： <a href="https://vjudge.net/problem/HUST-1588" target="_blank" rel="noopener"> https://vjudge.net/problem/HUST-1588</a><br>——————————————————————————————————–.<br>1588 - 辗转数对</p><p>时间限制：1秒 内存限制：128兆<br>139 次提交 23 次通过<br><strong> 题目描述 </strong><br>假设当前有一个数对(a, b)，我们可以通过一步将这个数对变为一个新数对(a + b, b)或者是(a, a + b)。<br>初始的数对为(1, 1)，你的任务是找到一个数字k，即通过最少的步数使得这个数对中至少一个数字等于n。<br><strong> 输入 </strong><br>输入包括多组数据，每组数据包括一行，每行有一个整数n。<br><strong> 输出 </strong><br>每组数据输出一行，每行一个整数n。<br><strong> 样例输入 </strong><br>5<br>3<br><strong> 样例输出 </strong><br>3<br>0<br><strong> 提示 </strong><br>第一个样例的方法是 (1,1)  →  (1,2)  →  (3,2)  →  (5,2)，共3步。<br><strong> 来源 </strong><br>——————————————————————————————————–.<br>解题思路:</p><blockquote><p>这个题不难发现，对于我们累加出来的（a，b）一定是互质的<br>然后想到Gcd（x，y）过程中的x，y就是要保证互质一直处理下去的<br>那么其实就是在问gcd过程中x%y要减多少次<br>那么接下来我们枚举终点（i，n）维护最小值即可</p></blockquote><p>附本题代码<br>——————————————————————————————————–.</p><pre><code>int ans;bool gett(int a,int b){    if(gcd(a,b)!=1) return false;    int res = 1;    while(a!=1||b!=1){        if(a&gt;b) a=a-b;        else    b=b-a;        res++;    }    ans = min(ans,res);    return true;}int main(){    int n;    while(~scanf(&quot;%d&quot;,&amp;n)){        ans = INF;        if(n==1) {puts(&quot;0&quot;);continue; }        if(n==2) {puts(&quot;1&quot;);continue; }        for(int i=1;i&lt;=n;i++)       get(i,n-i);        printf(&quot;%d\n&quot;,ans);    }    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  51nod 序列变换 [容斥原理+莫比乌斯函数]【数论+组合数学】</title>
      <link href="/2017/02/10/54969932/"/>
      <url>/2017/02/10/54969932/</url>
      
        <content type="html"><![CDATA[<h1 id="51nod-序列变换-容斥原理-莫比乌斯函数-【数论-组合数学】"><a href="#51nod-序列变换-容斥原理-莫比乌斯函数-【数论-组合数学】" class="headerlink" title="51nod 序列变换 [容斥原理+莫比乌斯函数]【数论+组合数学】"></a>51nod 序列变换 [容斥原理+莫比乌斯函数]【数论+组合数学】</h1><p>2017年02月10日 14:11:00  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：688</p><hr><p> 博客爬取于<code>2019-04-18 17:17:55</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/54969932" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/54969932</a></p><p>题目连接: <a href="http://www.51nod.com/contest/problem.html#!problemId=1675" target="_blank" rel="noopener"> http://www.51nod.com/contest/problem.html#!problemId=1675</a><br>——————————————————————————————————-.<br>序列变换<br>alpq654321 (命题人)<br>基准时间限制：1 秒 空间限制：131072 KB 分值: 40<br>lyk有两序列a和b。<br>lyk想知道存在多少对x,y，满足以下两个条件。<br>1：gcd(x,y)=1。<br>2： abx = bay 。</p><p>例如若a={1,1,1}，b={1,1,1}。那么存在7对，因为除了x=2,y=2或x=3,y=3外都满足条件。<br>Input<br>第一行一个数n(1&lt;=n&lt;=100000)。<br>接下来一行n个数，表示ai(1&lt;=ai&lt;=n)。<br>接下来一行n个数，表示bi(1&lt;=bi&lt;=n)。<br>Output<br>一行表示答案</p><p>Input示例<br>3<br>1 1 1<br>1 1 1<br>Output示例<br>7<br>——————————————————————————————————-.</p><p>本题是在裸求  a  b  x  =  b  a  y  的基础上加上了  gcd  (  x  ,  y  )  =  1<br>的限制,然后我就不会了,,,,</p><p>最后看了题解发现是同容斥原理来解决,<br>结果来说,<br>a  n  s  [  gcd  (  x  ,  y  )  =  1  ]  −  a  n  s  [  gcd  (  x  ,  y  )  !<br>=  1  ]</p><p>然后就引入了莫比乌斯反演<br>当x,y均满足题意的时候<br>f(k) 表示gcd(x,y) == k的个数<br>F(k) 表示gcd(x,y) == k的倍数 的个数</p><p>f  (  k  )  =  ∑  n  d  =  1  μ  (  d  )  ×  F  (  d  )</p><p>那么系数也就是莫比乌斯函数了</p><p>附本题代码<br>——————————————————————————————————-.</p><pre><code>int n;int prime[N],kp;int Is_or[N],mu[N];void Prime(){    int x;    mu[1]=1;    memset(Is_or,true,sizeof(Is_or));    for(int i=2;i&lt;=n;i++){        if(Is_or[i]) prime[kp++]=i,mu[i]=-1;        for(int j=0;j&lt;kp&amp;&amp;i*prime[j]&lt;=n;j++){            x = i*prime[j];            Is_or[x]=false;            if(0==i%prime[j]) break;            mu[x] = -mu[i];        }    }    return ;}int a[N],b[N];int cnt [N];LL calc(int t){    LL ans = 0;    for(int i=t;i&lt;=n;i+=t) cnt[a[b[i]]]++;    for(int i=t;i&lt;=n;i+=t) ans+=cnt[b[a[i]]];    for(int i=t;i&lt;=n;i+=t) cnt[a[b[i]]]--;    return ans ;}int main(){    n = read();    Prime();    Rep(i,1,n) a[i]=read(),cnt[i]=0;    Rep(i,1,n) b[i]=read();    LL ans = 0;    Rep(i,1,n) if(mu[i]) ans += 1ll*calc(i)*mu[i];    printf(&quot;%I64d\n&quot;,ans);    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  Codeforces 766E Mahmoud and a xor trip [二进制,]【数学+思维】</title>
      <link href="/2017/02/09/54935260/"/>
      <url>/2017/02/09/54935260/</url>
      
        <content type="html"><![CDATA[<h1 id="Codeforces-766E-Mahmoud-and-a-xor-trip-二进制-【数学-思维】"><a href="#Codeforces-766E-Mahmoud-and-a-xor-trip-二进制-【数学-思维】" class="headerlink" title="Codeforces 766E Mahmoud and a xor trip [二进制,]【数学+思维】"></a>Codeforces 766E Mahmoud and a xor trip [二进制,]【数学+思维】</h1><p>2017年02月09日 00:22:39  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：654</p><hr><p> 博客爬取于<code>2019-04-18 17:17:56</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/54935260" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/54935260</a></p><p>题目连接: <a href="http://codeforces.com/contest/766/problem/E" target="_blank" rel="noopener"> http://codeforces.com/contest/766/problem/E</a><br>——————————————————————————.<br>——————————————————————————.<br>题目大意:<br>就是在一个生成树上求任意两点的距离的和,距离定义为两点间路上所有点权值的异或和,</p><p>解题思路:</p><p>想法就是将结果的异或和拆分成每一位的,就是对于二进制数上对于第i位,有多少个距离为1的路径,然后在总结果上  +  路  径  数  (  1  &lt; &lt;<br>i  )  即可,这样最多按二进制位数个的搜索一遍树就行了.<br>cnt[][0]是以u为根0的个数,cnt[][1]同理.</p><p>听闻这题还有树分治和树dp的做法,有兴趣可以百度一发.</p><p>附本题代码<br>——————————————————————————.</p><pre><code>int a[N],b[N],cnt[N][2];vector&lt;int &gt;E[N];LL sum ;void dfs(int u,int fa){    cnt[u][0]=cnt[u][1]=0;    cnt[u][b[u]]++;    sum+=b[u];    int v;    for(int i=0;i&lt;E[u].size();i++){        v = E[u][i];        if(v==fa) continue;        dfs(v,u);        sum+=cnt[u][0]*cnt[v][1]+cnt[u][1]*cnt[v][0];        cnt[u][b[u]]+=cnt[v][0];        cnt[u][b[u]^1]+=cnt[v][1];    }}int main(){    int n,u,v;    n = read();    Rep(i,1,n) a[i]=read(),E[i].clear();    Rep(i,2,n){        u=read(),v=read();        E[u].pb(v);        E[v].pb(u);    }    LL ans = 0ll;    Rep(i,0,20){        Rep(j,1,n){            if(a[j]&amp;(1&lt;&lt;i)) b[j]=1;            else b[j]=0;        }        sum = 0ll;        dfs(1,-1);        ans += sum*(1&lt;&lt;i);    }    printf(&quot;%I64d\n&quot;,ans);    return 0;}</code></pre><p>对于对树、图进行dfs的要好好练练 总是搜不明白.</p>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  codeforces766D Mahmoud and a Dictionary [并查集]【数据结构】</title>
      <link href="/2017/02/08/54934767/"/>
      <url>/2017/02/08/54934767/</url>
      
        <content type="html"><![CDATA[<h1 id="codeforces766D-Mahmoud-and-a-Dictionary-并查集-【数据结构】"><a href="#codeforces766D-Mahmoud-and-a-Dictionary-并查集-【数据结构】" class="headerlink" title="codeforces766D Mahmoud and a Dictionary [并查集]【数据结构】"></a>codeforces766D Mahmoud and a Dictionary [并查集]【数据结构】</h1><p>2017年02月08日 23:55:44  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：521</p><hr><p> 博客爬取于<code>2019-04-18 17:17:57</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/54934767" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/54934767</a></p><p>题目连接： <a href="http://codeforces.com/contest/766/problem/D" target="_blank" rel="noopener"> http://codeforces.com/contest/766/problem/D</a></p><p>—————————————————————————————-.<br>D. Mahmoud and a Dictionary<br>time limit per test4 seconds<br>memory limit per test256 megabytes<br>inputstandard input<br>outputstandard output<br>Mahmoud wants to write a new dictionary that contains n words and relations<br>between them. There are two types of relations: synonymy (i. e. the two words<br>mean the same) and antonymy (i. e. the two words mean the opposite). From time<br>to time he discovers a new relation between two words.</p><p>He know that if two words have a relation between them, then each of them has<br>relations with the words that has relations with the other. For example, if<br>like means love and love is the opposite of hate, then like is also the<br>opposite of hate. One more example: if love is the opposite of hate and hate<br>is the opposite of like, then love means like, and so on.</p><p>Sometimes Mahmoud discovers a wrong relation. A wrong relation is a relation<br>that makes two words equal and opposite at the same time. For example if he<br>knows that love means like and like is the opposite of hate, and then he<br>figures out that hate means like, the last relation is absolutely wrong<br>because it makes hate and like opposite and have the same meaning at the same<br>time.</p><p>After Mahmoud figured out many relations, he was worried that some of them<br>were wrong so that they will make other relations also wrong, so he decided to<br>tell every relation he figured out to his coder friend Ehab and for every<br>relation he wanted to know is it correct or wrong, basing on the previously<br>discovered relations. If it is wrong he ignores it, and doesn’t check with<br>following relations.</p><p>After adding all relations, Mahmoud asked Ehab about relations between some<br>words based on the information he had given to him. Ehab is busy making a<br>Codeforces round so he asked you for help.</p><p>Input<br>The first line of input contains three integers n, m and q (2 ≤ n ≤ 105, 1 ≤<br>m, q ≤ 105) where n is the number of words in the dictionary, m is the number<br>of relations Mahmoud figured out and q is the number of questions Mahmoud<br>asked after telling all relations.</p><p>The second line contains n distinct words a1, a2, …, an consisting of small<br>English letters with length not exceeding 20, which are the words in the<br>dictionary.</p><p>Then m lines follow, each of them contains an integer t (1 ≤ t ≤ 2) followed<br>by two different words xi and yi which has appeared in the dictionary words.<br>If t = 1, that means xi has a synonymy relation with yi, otherwise xi has an<br>antonymy relation with yi.</p><p>Then q lines follow, each of them contains two different words which has<br>appeared in the dictionary. That are the pairs of words Mahmoud wants to know<br>the relation between basing on the relations he had discovered.</p><p>All words in input contain only lowercase English letters and their lengths<br>don’t exceed 20 characters. In all relations and in all questions the two<br>words are different.</p><p>Output<br>First, print m lines, one per each relation. If some relation is wrong (makes<br>two words opposite and have the same meaning at the same time) you should<br>print “NO” (without quotes) and ignore it, otherwise print “YES” (without<br>quotes).</p><p>After that print q lines, one per each question. If the two words have the<br>same meaning, output 1. If they are opposites, output 2. If there is no<br>relation between them, output 3.</p><p>See the samples for better understanding.</p><p>Examples<br>input<br>3 3 4<br>hate love like<br>1 love like<br>2 love hate<br>1 hate like<br>love like<br>love hate<br>like hate<br>hate like<br>output<br>YES<br>YES<br>NO<br>1<br>2<br>2<br>2<br>input<br>8 6 5<br>hi welcome hello ihateyou goaway dog cat rat<br>1 hi welcome<br>1 ihateyou goaway<br>2 hello ihateyou<br>2 hi goaway<br>2 hi hello<br>1 hi hello<br>dog cat<br>dog hi<br>hi hello<br>ihateyou goaway<br>welcome ihateyou<br>output<br>YES<br>YES<br>YES<br>YES<br>NO<br>YES<br>3<br>3<br>1<br>1<br>2</p><p>—————————————————————————————-.<br>题目大意:<br>就是有n个单词,有m个关系,q个查询,<br><strong> 关系 </strong> 是两个单词是同义词还是反义词,对于当前的这条关系如果与前述关系不符则忽略,<br><strong> 查询 </strong> 是两个单词之间的关系是 <strong> 同义词 </strong> 还是 <strong> 反义词 </strong> 还是 <strong> 未知 </strong> . </p><p>解题思路:<br>很好想到并查集来维护同义词,然后用另一个数组怎样的表示两堆之间的反义词关系,</p><p><del> 最开始是想对每堆进行染色,两个堆中一个染成+n,另一个染成-n,加和为零表示敌对关系,然后可以在维护一个并查集或者怎样 ,但是最后GG了<br></del></p><p>看了题解 发现用另一个数组来维护本堆的反义词的堆是哪一个，真是奥妙重重。666</p><p>这样的话 这个题目就简单清晰多了，直接维护就行了。</p><p>注意对于m条关系的判定时的细节就好了，详见代码。</p><p><a href="http://blog.csdn.net/zjznku/article/details/54928787" target="_blank" rel="noopener"> 借(chao)鉴(xi)这里&lt;–戳戳戳 </a></p><p>附本题代码<br>—————————————————————————————-.</p><pre><code>int n,m,q,op;string str,str1,str2;map&lt;string,int&gt;mmp;int pre[N],opp[N];int findi(int x){    int r = x;    while(r != pre[r]) r=pre[r];    int i=x,j;    while(i!=j){        j=pre[i];        pre[i]=r;        i=j;    }    return r;}void init(){    mmp.clear();    Rep(i,0,n) pre[i]=i,opp[i]=0;}int main(){    while(cin&gt;&gt;n&gt;&gt;m&gt;&gt;q){        init();        Rep(i,1,n) cin&gt;&gt;str,mmp[str]=i;        Rep(i,1,m){            cin&gt;&gt;op&gt;&gt;str1&gt;&gt;str2;            int x = mmp[str1],y = mmp[str2];            int u = findi(x),v = findi(y);            int uu= findi(opp[u]),vv= findi(opp[v]);            if(op==1){                if(uu!=v){                    puts(&quot;YES&quot;);                    pre[u]=v;                    if(uu&amp;&amp;vv) pre[uu]=vv;                    if(!vv)  opp[v]=uu;                }                else puts(&quot;NO&quot;);            }            else {                if(u!=v) {                    puts(&quot;YES&quot;);                    if(uu) pre[v]=uu;                    else   opp[u]=v;                    if(vv) pre[u]=vv;                    else   opp[v]=u;                }                else puts(&quot;NO&quot;);            }        }        Rep(i,1,q){            cin&gt;&gt;str1&gt;&gt;str2;            int x = mmp[str1],y = mmp[str2];            int u = findi(x),v = findi(y);            int uu= findi(opp[u]),vv= findi(opp[v]);            if (u==v) puts(&quot;1&quot;);            else  {                if (uu==v||vv==u) puts(&quot;2&quot;);                else puts(&quot;3&quot;);            }        }    }    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  codeforces 766 C Mahmoud and a Message [基础DP]【动态规划】</title>
      <link href="/2017/02/08/54934055/"/>
      <url>/2017/02/08/54934055/</url>
      
        <content type="html"><![CDATA[<h1 id="codeforces-766-C-Mahmoud-and-a-Message-基础DP-【动态规划】"><a href="#codeforces-766-C-Mahmoud-and-a-Message-基础DP-【动态规划】" class="headerlink" title="codeforces 766 C Mahmoud and a Message [基础DP]【动态规划】"></a>codeforces 766 C Mahmoud and a Message [基础DP]【动态规划】</h1><p>2017年02月08日 22:42:09  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：461</p><hr><p> 博客爬取于<code>2019-04-18 17:17:58</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/54934055" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/54934055</a></p><p>题目连接： <a href="http://codeforces.com/contest/766/problem/C" target="_blank" rel="noopener"> http://codeforces.com/contest/766/problem/C</a></p><p>———————————————————————–.<br>C. Mahmoud and a Message<br>time limit per test2 seconds<br>memory limit per test256 megabytes<br>inputstandard input<br>outputstandard output<br>Mahmoud wrote a message s of length n. He wants to send it as a birthday<br>present to his friend Moaz who likes strings. He wrote it on a magical paper<br>but he was surprised because some characters disappeared while writing the<br>string. That’s because this magical paper doesn’t allow character number i in<br>the English alphabet to be written on it in a string of length more than ai.<br>For example, if a1 = 2 he can’t write character ‘a’ on this paper in a string<br>of length 3 or more. String “aa” is allowed while string “aaa” is not.</p><p>Mahmoud decided to split the message into some non-empty substrings so that he<br>can write every substring on an independent magical paper and fulfill the<br>condition. The sum of their lengths should be n and they shouldn’t overlap.<br>For example, if a1 = 2 and he wants to send string “aaa”, he can split it into<br>“a” and “aa” and use 2 magical papers, or into “a”, “a” and “a” and use 3<br>magical papers. He can’t split it into “aa” and “aa” because the sum of their<br>lengths is greater than n. He can split the message into single string if it<br>fulfills the conditions.</p><p>A substring of string s is a string that consists of some consecutive<br>characters from string s, strings “ab”, “abc” and “b” are substrings of string<br>“abc”, while strings “acb” and “ac” are not. Any string is a substring of<br>itself.</p><p>While Mahmoud was thinking of how to split the message, Ehab told him that<br>there are many ways to split it. After that Mahmoud asked you three questions:</p><p>How many ways are there to split the string into substrings such that every<br>substring fulfills the condition of the magical paper, the sum of their<br>lengths is n and they don’t overlap? Compute the answer modulo 109 + 7.<br>What is the maximum length of a substring that can appear in some valid<br>splitting?<br>What is the minimum number of substrings the message can be spit in?<br>Two ways are considered different, if the sets of split positions differ. For<br>example, splitting “aa|a” and “a|aa” are considered different splittings of<br>message “aaa”.</p><p>Input<br>The first line contains an integer n (1 ≤ n ≤ 103) denoting the length of the<br>message.</p><p>The second line contains the message s of length n that consists of lowercase<br>English letters.</p><p>The third line contains 26 integers a1, a2, …, a26 (1 ≤ ax ≤ 103) — the<br>maximum lengths of substring each letter can appear in.</p><p>Output<br>Print three lines.</p><p>In the first line print the number of ways to split the message into<br>substrings and fulfill the conditions mentioned in the problem modulo 109  +<br>7.</p><p>In the second line print the length of the longest substring over all the<br>ways.</p><p>In the third line print the minimum number of substrings over all the ways.</p><p>Examples<br>input<br>3<br>aab<br>2 3 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1<br>output<br>3<br>2<br>2<br>input<br>10<br>abcdeabcde<br>5 5 5 5 4 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1<br>output<br>401<br>4<br>3<br>Note<br>In the first example the three ways to split the message are:</p><p>a|a|b<br>aa|b<br>a|ab<br>The longest substrings are “aa” and “ab” of length 2.</p><p>The minimum number of substrings is 2 in “a|ab” or “aa|b”.</p><p>Notice that “aab” is not a possible splitting because the letter ‘a’ appears<br>in a substring of length 3, while a1 = 2.<br>———————————————————————–.<br>题目大意:<br>一个长度为n的仅含26小字母的字符串,要将其按要求分割成几段,其中26种字母只能在长度为Ax的字串中,问你划分的种类数是多少,字串的长度最长是多少,划分出来<br>的字符串个数最少是多少,</p><p>解题思路:<br>还是dp</p><p>对于子串中以第i个字符为止时,我们可以将其划分到  ∈  [  i  −  A  i  +  1  ,  i  ]<br>的位置上,我们从这个位置向前寻找,一次次判断就行了..</p><p>同时就能维护字串的最长长度了</p><p>字串的最少个数在一次次向前找中,维护最小值即可.</p><p>详见代码及注释</p><p>附本题代码<br>———————————————————————–.</p><pre><code>int a[30];int dp[3][1010];/**dp[0][i]  截止到第i个字符为止的划分方案数 dp[1][i]  一个个的维护可划分的最大长度   ，dp[2][i]  前一个的划分点转移到i，值+1，  （划分个数最少 自然是长度越长越好）*/string str;int main(){    int n;    cin&gt;&gt;n;    cin&gt;&gt;str;    for(int i=0;i&lt;26;i++) cin&gt;&gt;a[i];    dp[0][0] = 1;    for(int i = 1; i &lt;= n; ++i){        int len  =  INF;        dp[1][i] = -INF;        dp[2][i] =  INF;        for(int j = i - 1; j &gt;= 0; --j){            len = min(len, a[str[j] - &#39;a&#39;]);            if(len &lt; i - j) break;                         //因为A_j有它的范围 ,不能超过            dp[0][i] = (dp[0][i] + dp[0][j]) % MOD;        //划分方案数，            dp[1][i] = max(dp[1][i], max(i - j, dp[1][j]));//就是维护最大值            dp[2][i] = min(dp[2][i], dp[2][j] + 1);        //最少的划分个数，        }    }    cout &lt;&lt; dp[0][n] &lt;&lt; endl;    cout &lt;&lt; dp[1][n] &lt;&lt; endl;    cout &lt;&lt; dp[2][n] &lt;&lt; endl;    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  The 9th Zhejiang Provincial Collegiate Programming Contest</title>
      <link href="/2017/02/08/54924305/"/>
      <url>/2017/02/08/54924305/</url>
      
        <content type="html"><![CDATA[<h1 id="The-9th-Zhejiang-Provincial-Collegiate-Programming-Contest"><a href="#The-9th-Zhejiang-Provincial-Collegiate-Programming-Contest" class="headerlink" title="The 9th Zhejiang Provincial Collegiate Programming Contest"></a>The 9th Zhejiang Provincial Collegiate Programming Contest</h1><p>2017年02月08日 10:59:08  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：245</p><p>个人分类：  <a href="https://blog.csdn.net/qq_33184171/article/category/6362379" target="_blank" rel="noopener"> ===== 各OJ =====</a></p><hr><p> 博客爬取于<code>2019-04-18 17:17:59</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/54924305" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/54924305</a></p><p>题目读的懵逼，。。。水题还卡,难题不会。。。。GG</p><h3 id="Taxi-Fare"><a href="#Taxi-Fare" class="headerlink" title="Taxi Fare"></a>Taxi Fare</h3><p>水签到题，<br>注意等时计费是要转化为每分钟几毛钱计算</p><h3 id="Unrequited-Love"><a href="#Unrequited-Love" class="headerlink" title="Unrequited Love"></a>Unrequited Love</h3><p>首先明确题意,然后用set暴力来就行了</p><h3 id="Count-the-Trees"><a href="#Count-the-Trees" class="headerlink" title="Count the Trees"></a>Count the Trees</h3><p>其实就是树的同构,但是实在不知道该如何判断,<br>最后看了题解发现,hash每棵树就好了,将每一样的数用一个整数表示出来,两遍dfs就好.<br><a href="http://www.cnblogs.com/Griselda/archive/2012/09/11/2680515.html" target="_blank" rel="noopener"> 详解戳这里 </a></p><h3 id="Draw-Something-Cheat"><a href="#Draw-Something-Cheat" class="headerlink" title="Draw Something Cheat"></a>Draw Something Cheat</h3><p>D题也是签到题<br>注意数组开大些就好了</p><h3 id="Tunnel-Network"><a href="#Tunnel-Network" class="headerlink" title="Tunnel Network"></a>Tunnel Network</h3><p>这道题有点复杂，单开了一贴<br><a href="http://blog.csdn.net/qq_33184171/article/details/54914010" target="_blank" rel="noopener"> 请戳这里 </a></p><h3 id="Find-the-Marble"><a href="#Find-the-Marble" class="headerlink" title="Find the Marble"></a>Find the Marble</h3><p>只知道dp能做,但是dp废….来日再补…</p><h3 id="Lazy-Salesgirl"><a href="#Lazy-Salesgirl" class="headerlink" title="Lazy Salesgirl"></a>Lazy Salesgirl</h3><p>好难想啊 ,最开始真的想二分了,,,最后看了题解才知道是个线段树…..<br><a href="http://www.cnblogs.com/wuyiqi/archive/2012/04/28/2474672.html" target="_blank" rel="noopener"> 详解链接戳这里 </a></p><h3 id="Lazier-Salesgirl"><a href="#Lazier-Salesgirl" class="headerlink" title="Lazier Salesgirl"></a>Lazier Salesgirl</h3><p>这是上一题的简化版本,因为数据量太小直接枚举既可,</p><p><del> 一套题出这样的两道题是要闹哪样…. </del></p><h3 id="Signal-Detection"><a href="#Signal-Detection" class="headerlink" title="Signal Detection"></a>Signal Detection</h3><p>未补待续</p><h3 id="Modular-Inverse"><a href="#Modular-Inverse" class="headerlink" title="Modular Inverse"></a>Modular Inverse</h3><p>就是求a对m的逆元<br>入门难度题,注意逆元不要为0就好了</p><h3 id="Yet-Another-Story-of-Rock-paper-scissors"><a href="#Yet-Another-Story-of-Rock-paper-scissors" class="headerlink" title="Yet Another Story of Rock-paper-scissors"></a>Yet Another Story of Rock-paper-scissors</h3><p>签到题,<br>明确题意,枚举3中情况就好了</p><h2 id="————————————————————————————————–"><a href="#————————————————————————————————–" class="headerlink" title="————————————————————————————————–"></a>————————————————————————————————–</h2><p>不是题目太难，只是自己太菜，路漫漫，加油吧，，，</p>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 各OJ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  ZOJ 3604 Tunnel Network [Prüfer编码与Cayley公式] 【树】</title>
      <link href="/2017/02/07/54914010/"/>
      <url>/2017/02/07/54914010/</url>
      
        <content type="html"><![CDATA[<h1 id="ZOJ-3604-Tunnel-Network-Prufer编码与Cayley公式-【树】"><a href="#ZOJ-3604-Tunnel-Network-Prufer编码与Cayley公式-【树】" class="headerlink" title="ZOJ 3604 Tunnel Network [Prüfer编码与Cayley公式] 【树】"></a>ZOJ 3604 Tunnel Network [Prüfer编码与Cayley公式] 【树】</h1><p>2017年02月07日 18:40:56  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：267</p><hr><p> 博客爬取于<code>2019-04-18 17:18:00</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/54914010" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/54914010</a></p><p>!!!! <a href="http://ltoz.blog.163.com/blog/static/205378152201233022424128/" target="_blank" rel="noopener"> 摘自 </a></p><p>题目链接 <a href="http://acm.zju.edu.cn/onlinejudge/showProblem.do?problemCode=3604" target="_blank" rel="noopener"> http://acm.zju.edu.cn/onlinejudge/showProblem.do?problemCode=3604</a></p><p>—————————————————————————————————.<br>Tunnel Network</p><hr><p>Time Limit: 2 Seconds Memory Limit: 65536 KB</p><hr><p>Country Far-Far-Away is a big country with N cities. But it is now under a<br>civil war. The rebel uses the ancient tunnel network which connects all N<br>cities with N-1 inter-city tunnels for transportation. The government army<br>want to destroy these tunnels one by one. After several months fighting, some<br>tunnels have been destoryed. According to the intel, the tunnel network have<br>excatly S connected components now. And what government army further knows is<br>that city 1, 2, … , S belong to each of the S connected components. Since the<br>government have little knowledge about the remaining tunnels, they ask you to<br>calculate the number of possible networks of remaining tunnels.</p><p>Input<br>There are multiple test cases. The first line of input contains an integer T<br>(T ≤ 500) indicating the number of test cases. Then T test cases follow.</p><p>Each case contains one line containing two integer N (2 ≤ N ≤ 2000) and S (2 ≤<br>S ≤ N), as described above.</p><p>Output<br>The number of possible networks now. Since the number might be very large, you<br>should output the answer after modulo 1000000007.</p><p>Sample Input<br>4<br>3 2<br>4 2<br>5 3<br>100 50</p><p>Sample Output<br>2<br>8<br>15<br>113366355</p><p>—————————————————————————————————.<br>题目大意:n个城市（标记1…n）由n-<br>1条通道组成，其中的一些通道已经被破坏了，已知现有s个联通，城市1…s分别属于第1…s个联通，想要知道剩下通道网络可能的数目。</p><p>解题思路:<br><a href="http://www.matrix67.com/blog/archives/682" target="_blank" rel="noopener"> Prüfer编码与Cayley公式 from matrix67 </a><br>明确了上述公式就简单了.</p><p>首先要知道Prufer sequence.这是一个双射，能把一棵节点为n个的标号树树唯一映射成一个n-2的序列，反之一个n-<br>2的序列能唯一映射成一个树。这题求树的形态数目可以转化为求序列的数目。<br>因为是要得到s棵树，所以可以增加一个节点0，让1…s的父节点都为0。Prufer seq是每次找最小的标号，这里每次找最大的标号，本质一样的。<br>然后就是构造将s+1…n添加到1…s之后的事情。构造如下的图的树：<br><img src="http://img0.ph.126.net/OyH6VBTkwcAUQA4TzDa20Q==/593630725900240900.jpg" alt><br>但是要如何保证构造出来的序列能映射成根为0，第一层为1…s ， 剩下的为 s+1…n 呢？<br>1、序列最后s-1个数字为0,<br>2、倒数第s个数字在1…s之间<br>第一个理由是很容易想的。因为我们构造的Prufer<br>seq每次找最大标号的叶子（度为1）节点，所以在第一层的叶子被消去之前第一层以下的所有节点一定会被消去。而1…s的父节点都是0<br>第二个的话要一点证明：<br>假如第一层存在一个最大值x（x&gt;s）,那么第一层一下存在一个y（1&lt;=y&lt;=s）。<br>因为最后s-1个数字都为0，所以x是在y之后被消去的。<br>假如y的父节点是x：<br>因为y比第一层之下所有节点标号都大，所以必定是第一层一下所有节点中最后消去的，所以序列倒数第s个数字为x，大于s<br>假如y的父节点不是x：<br>那么第一层一下最后一个消去的节点还是x的子节点（条件1）。所以倒数第s个数字还是x，大于s<br>结论： 若第一层中存在最大数字x大于s，则序列的倒数第s个数字必定为x。<br>所以第二条也是成立的。<br>然后构造序列就很简单了最后s-1个数字都为0，倒数第s个为1…s，剩下为1…n。<br>公式 ： s*n^(n-s-1)<br>不过当s=n的时候答案为1要另外处理，因为第一层下面没有东西了。</p><p>附本题代码<br>—————————————————————————————————.</p><pre><code>LL qmod(LL a,LL b){    LL res=1ll;    while(b){        if(b&amp;1) res=res*a%MOD;        b&gt;&gt;=1;      a=a*a%MOD;    }    return res ;}int n,s;LL solve(){    if(n==s) return 1ll;    return 1ll*s*qmod(n,n-s-1)%MOD;}int main(){    int _ = 1,kcase = 0;    while(~scanf(&quot;%d&quot;,&amp;_)){        while(_--){            scanf(&quot;%d%d&quot;,&amp;n,&amp;s);            printf(&quot;%lld\n&quot;,solve());  //在zoj不知为什么 %I64d 会出现PE的情况        }    }    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  The 10th Zhejiang Provincial Collegiate Programming Contest</title>
      <link href="/2017/02/06/54897814/"/>
      <url>/2017/02/06/54897814/</url>
      
        <content type="html"><![CDATA[<h1 id="The-10th-Zhejiang-Provincial-Collegiate-Programming-Contest"><a href="#The-10th-Zhejiang-Provincial-Collegiate-Programming-Contest" class="headerlink" title="The 10th Zhejiang Provincial Collegiate Programming Contest"></a>The 10th Zhejiang Provincial Collegiate Programming Contest</h1><p>2017年02月06日 22:31:40  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：206</p><hr><p> 博客爬取于<code>2019-04-18 17:18:01</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/54897814" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/54897814</a></p><p>题目连接： <a href="http://acm.zju.edu.cn/onlinejudge/showContestProblems.do?contestId=347" target="_blank" rel="noopener"> http://acm.zju.edu.cn/onlinejudge/showContestProblems.do?contestId=347</a></p><blockquote><p>套题是真TM酸爽。  193  ∗  47  ∗  887  ∗  29</p></blockquote><h3 id="A-Applications"><a href="#A-Applications" class="headerlink" title="A Applications"></a>A Applications</h3><p>英语题 特别复杂的模拟 注意细节 细节 细节 细节 细节 。。。。</p><h3 id="B-Break-Standard-Weight"><a href="#B-Break-Standard-Weight" class="headerlink" title="B Break Standard Weight"></a>B Break Standard Weight</h3><p>签到题 直接暴力就好了</p><h3 id="C-Calculate-Prime-S"><a href="#C-Calculate-Prime-S" class="headerlink" title="C Calculate Prime S"></a>C Calculate Prime S</h3><p>理解题意，首先x很明显要求个逆元,因为m不是素数,所以只好用扩展欧几里德求了,<br>对于S[n] 是很明显的fibonacci数列(S[n]=fib[n+2] ),枚举两个就出来了,别忘了还有空集..</p><p>然后就不会了,<br>最后才知道fibonacci的一个性质</p><blockquote><p>1. <strong> g  c  d  (  f  i  b  (  n  )  ,  f  i  b  (  m  )  )  =  f  i  b  (<br>g  c  d  (  n  ,  m  )  )  </strong><br>证明：可以通过反证法先证fibonacci数列的任意相邻两项一定互素，然后可证  n  &gt; m  时  g  c  d  (  f  i  b  (  n<br>)  ,  f  i  b  (  m  )  )  =  g  c  d  (  f  i  b  (  n  −  m  )  ,  f  i  b<br>(  m  )  )  ，递归可求  g  c  d  (  f  i  b  (  n  )  ,  f  i  b  (  m  )  )  =  g<br>c  d  (  f  i  b  (  k  )  ,  f  i  b  (  l  )  )  ，最后  k  =  l  ，不然继续递归。  K<br>是通过展转相减法求出，易证  k  =  g  c  d  (  n  ,  m  )  ，所以  g  c  d  (  f  i  b  (  n  )<br>,  f  i  b  (  m  )  )  =  f  i  b  (  g  c  d  (  n  ,  m  )  )  。</p></blockquote><p>所以只有当 gcd(n,m)=1或2时(fib[1]==fib[2]==1) fib[n]与fib[m]互质<br>所以若S[n] 要是一个 PrimeS<br>则n+2必须是一个质数或者4 ，自己画画就知道为什么4是特殊的了<br>所以构造一个特殊的素数表<br>P[i] 3 4 5 7 11 13……………….<br>所以第K个PrimeS 就是fib[P[k]]</p><blockquote><p>还有一个结论：<br>计算  (  a  /  b  )  %  c  其中b能整除a<br>如果b与c互素，则  (  a  /  b  )  %  c  =  a  ∗  b  p  h  i  (  c  )  −  1<br>如果b与c不互素，则  (  a  /  b  )  %  c  =  (  a  %  b  c  )  /  b<br>对于b与c互素和不互素都有  (  a  /  b  )  %  c  =  (  a  %  b  c  )  /  b  成立</p></blockquote><p>就是枚举出能够整除x的PrimeS 用快速幂求取PrimeS<br>最后计算 就好了 注意下可能会爆int就好了</p><h3 id="D-Density-of-Power-Network"><a href="#D-Density-of-Power-Network" class="headerlink" title="D Density of Power Network"></a>D Density of Power Network</h3><p>明白题意让求的是去掉平行线后,线与节点数的比值就好了<br>签到题 暴力做</p><h3 id="E-Egg-Painting"><a href="#E-Egg-Painting" class="headerlink" title="E Egg Painting"></a>E Egg Painting</h3><p>不会 还找不到题解…</p><h3 id="F-Friends"><a href="#F-Friends" class="headerlink" title="F Friends"></a>F Friends</h3><p>这个题比较6<br>确定题意后,直接暴力加边就好了,直到不能在加边为止</p><h3 id="G-Give-Me-Your-Hand"><a href="#G-Give-Me-Your-Hand" class="headerlink" title="G Give Me Your Hand"></a>G Give Me Your Hand</h3><p>看题解是个dp 然而dp废。。。。<br>来日在补</p><h3 id="H-Hard-to-Play"><a href="#H-Hard-to-Play" class="headerlink" title="H Hard to Play"></a>H Hard to Play</h3><p>签到题 明白题意直接做就好了,</p><h3 id="I-In-7-bit"><a href="#I-In-7-bit" class="headerlink" title="I In 7-bit"></a>I In 7-bit</h3><p>阅读题 明白题意 直接处理就好了</p><h3 id="J-Java-Beans"><a href="#J-Java-Beans" class="headerlink" title="J Java Beans"></a>J Java Beans</h3><p>签到题 找环上和最大的长度为k的连续区间, 前缀和处理然后枚举即可.</p><h3 id="K-Kindergarten-Election"><a href="#K-Kindergarten-Election" class="headerlink" title="K Kindergarten Election"></a>K Kindergarten Election</h3><p>题面比较有意思,一群幼儿园同学要投票选个老大，（不能选自己），每个人都有一个心仪的老大目标，然后1号小朋友要当老大，可以拿糖贿赂其他小朋友来确保自己当老大。<br>问1号小朋友最少需要多少个糖果能确保自己当上老大。</p><p>枚举加贪心,</p><p>枚举1号小朋友当上老大时的票数，然后贪心选择贿赂谁，维护下结果的就行了。</p><p>题目不难，就是不好想到枚举，想直接进行贪心，然后就会各种GG</p><h2 id="—————————————————————————————"><a href="#—————————————————————————————" class="headerlink" title="—————————————————————————————-"></a>—————————————————————————————-</h2><p>最后发现这套题是之前省选训练过的题..</p><p>总结:<br>英语读题水平太菜,<br>模拟水平太差,<br>代码能力有待加强</p><p>思维不够开阔,胆子不够大,至少暴力的想法是有的 但是却不敢写.<br>写代码的速度可以放慢些,写快了细节上出错率大.</p>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  codeforces 763B. Timofey and rectangles [思维]【智商】</title>
      <link href="/2017/02/06/54885329/"/>
      <url>/2017/02/06/54885329/</url>
      
        <content type="html"><![CDATA[<h1 id="codeforces-763B-Timofey-and-rectangles-思维-【智商】"><a href="#codeforces-763B-Timofey-and-rectangles-思维-【智商】" class="headerlink" title="codeforces 763B. Timofey and rectangles [思维]【智商】"></a>codeforces 763B. Timofey and rectangles [思维]【智商】</h1><p>2017年02月06日 00:21:44  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：563<br>标签：  <a href="https://so.csdn.net/so/search/s.do?q=codeforces&amp;t=blog" target="_blank" rel="noopener"> codeforces </a></p><p>个人分类：  <a href="https://blog.csdn.net/qq_33184171/article/category/6235560" target="_blank" rel="noopener"> codeforces</a> <a href="https://blog.csdn.net/qq_33184171/article/category/6253262" target="_blank" rel="noopener"> 思维</a></p><hr><p> 博客爬取于<code>2019-04-18 17:18:02</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/54885329" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/54885329</a></p><p>题目连接: <a href="http://codeforces.com/problemset/problem/763/B" target="_blank" rel="noopener"> http://codeforces.com/problemset/problem/763/B</a></p><p>——————————————————————————————-.<br>time limit per test2 seconds<br>memory limit per test256 megabytes</p><p>inputstandard input<br>outputstandard output</p><p>One of Timofey’s birthday presents is a colourbook in a shape of an infinite<br>plane. On the plane n rectangles with sides parallel to coordinate axes are<br>situated. All sides of the rectangles have odd length. Rectangles cannot<br>intersect, but they can touch each other.</p><p>Help Timofey to color his rectangles in 4 different colors in such a way that<br>every two rectangles touching each other by side would have different color,<br>or determine that it is impossible.</p><p>Two rectangles intersect if their intersection has positive area. Two<br>rectangles touch by sides if there is a pair of sides such that their<br>intersection has non-zero length</p><p>The picture corresponds to the first example<br>Input<br>The first line contains single integer n (1 ≤ n ≤ 5·105) — the number of<br>rectangles.</p><p>n lines follow. The i-th of these lines contains four integers x1, y1, x2 and<br>y2 ( - 109 ≤ x1 &lt; x2 ≤ 109,  - 109 ≤ y1 &lt; y2 ≤ 109), that means that points<br>(x1, y1) and (x2, y2) are the coordinates of two opposite corners of the i-th<br>rectangle.</p><p>It is guaranteed, that all sides of the rectangles have odd lengths and<br>rectangles don’t intersect each other.</p><p>Output<br>Print “NO” in the only line if it is impossible to color the rectangles in 4<br>different colors in such a way that every two rectangles touching each other<br>by side would have different color.</p><p>Otherwise, print “YES” in the first line. Then print n lines, in the i-th of<br>them print single integer ci (1 ≤ ci ≤ 4) — the color of i-th rectangle.</p><p>Example</p><p>input</p><p>8<br>0 0 5 3<br>2 -1 5 0<br>-3 -4 2 -1<br>-1 -1 2 0<br>-3 0 0 5<br>5 2 10 3<br>7 -3 10 2<br>4 -2 7 -1</p><p>output</p><p>YES<br>1<br>2<br>2<br>3<br>2<br>2<br>4<br>1</p><p>——————————————————————————————-.<br>题目大意:<br>就是在一个二维平面上有n个矩形,现在让你给这n个矩形4种涂色之一,使得相邻的矩形颜色不同.<br><strong> (矩形的两条边都是整数) </strong><br>解题思路:</p><p>我这种智障是做不出来的,本来并不想写题解,但是无意中看了Tutorial中的discuss发现一个特别容易理解的.</p><blockquote><p>We may assume that our rectangles are drawn on an infinite sheet of squared<br>paper. Divide it into squares 2 × 2 and mark the cells in each square by 1, 2,<br>3, 4 clockwise starting from the upper left corner. Since both sides of each<br>rectangle are of odd length, its corner cells are marked by the same number.<br>Let us number four different colors by 1, 2, 3, 4 and paint each rectangle<br>with the color whose number marks the corner cells. It is readily seen that<br>the numbers in the corners of any two adjacent rectangles are distinct.<br>我们可能会认为我们的矩形被画在无限平方的纸。将纸分成一个个2×2方块,然后从左上角顺时针方向开始标上1,2,3,4(代表颜色)。由于每个矩形的两边都是奇数长<br>度，所以它的所有格子标记为相同的数。让我们用1，2，3，4个不同的颜色编号，并绘制每个矩形的颜色的数字标记的格子。很容易看出，任何两个相邻矩形的角的数是不同<br>的。<br>(基本是机翻……可以自己画一画就容易理解了,Orz)</p></blockquote><p><strong> 附本题代码 </strong><br>——————————————————————————————-.</p><pre><code>int main(){    int x1,x2,y1,y2;    int n ;    s1(n);puts(&quot;YES&quot;);    Rep(i,1,n){        s1(x1),s1(x2),s1(y1),s1(y2);        x1=(x1%2+2)%2;        x2=(x2%2+2)%2;        printf(&quot;%d\n&quot;,x1+x2*2+1);    }    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 思维 </tag>
            
            <tag> codeforces </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  浪费生命啊</title>
      <link href="/2017/02/02/54838954/"/>
      <url>/2017/02/02/54838954/</url>
      
        <content type="html"><![CDATA[<h1 id="浪费生命啊"><a href="#浪费生命啊" class="headerlink" title="浪费生命啊"></a>浪费生命啊</h1><p>2017年02月02日 23:26:20  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：224</p><hr><p> 博客爬取于<code>2019-04-18 17:18:03</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/54838954" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/54838954</a></p><p>浪费生命 啊</p><p>以后还是消停的一套一套的套题起刷吧 ， 盲目刷题起得那是反作用啊。</p>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  HDU 5818 Joint Stacks [栈]【模拟】</title>
      <link href="/2017/02/01/54809490/"/>
      <url>/2017/02/01/54809490/</url>
      
        <content type="html"><![CDATA[<h1 id="HDU-5818-Joint-Stacks-栈-【模拟】"><a href="#HDU-5818-Joint-Stacks-栈-【模拟】" class="headerlink" title="HDU 5818 Joint Stacks [栈]【模拟】"></a>HDU 5818 Joint Stacks [栈]【模拟】</h1><p>2017年02月01日 16:40:41  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：192</p><hr><p> 博客爬取于<code>2019-04-18 17:18:04</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/54809490" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/54809490</a></p><p>题目链接: <a href="http://acm.hdu.edu.cn/showproblem.php?pid=5818" target="_blank" rel="noopener"> http://acm.hdu.edu.cn/showproblem.php?pid=5818</a></p><p>—————————————————————————.<br>I 2017 口碑商家客流量预测大赛》<br>Joint Stacks</p><p>Time Limit: 8000/4000 MS (Java/Others) Memory Limit: 65536/65536 K<br>(Java/Others)<br>Total Submission(s): 1522 Accepted Submission(s): 709</p><p>Problem Description<br>A stack is a data structure in which all insertions and deletions of entries<br>are made at one end, called the “top” of the stack. The last entry which is<br>inserted is the first one that will be removed. In another word, the<br>operations perform in a Last-In-First-Out (LIFO) manner.<br>A mergeable stack is a stack with “merge” operation. There are three kinds of<br>operation as follows:</p><ul><li>push A x: insert x into stack A </li><li>pop A: remove the top element of stack A </li><li>merge A B: merge stack A and B </li></ul><p>After an operation “merge A B”, stack A will obtain all elements that A and B<br>contained before, and B will become empty. The elements in the new stack are<br>rearranged according to the time when they were pushed, just like repeating<br>their “push” operations in one stack. See the sample input/output for further<br>explanation.<br>Given two mergeable stacks A and B, implement operations mentioned above.</p><p>Input<br>There are multiple test cases. For each case, the first line contains an<br>integer N(0&lt; N≤105), indicating the number of operations. The next N lines,<br>each contain an instruction “push”, “pop” or “merge”. The elements of stacks<br>are 32-bit integers. Both A and B are empty initially, and it is guaranteed<br>that “pop” operation would not be performed to an empty stack. N = 0 indicates<br>the end of input.</p><p>Output<br>For each case, print a line “Case #t:”, where t is the case number (starting<br>from 1). For each “pop” operation, output the element that is popped, in a<br>single line.</p><p>Sample Input<br>4<br>push A 1<br>push A 2<br>pop A<br>pop A<br>9<br>push A 0<br>push A 1<br>push B 3<br>pop A<br>push A 2<br>merge A B<br>pop A<br>pop A<br>pop A<br>9<br>push A 0<br>push A 1<br>push B 3<br>pop A<br>push A 2<br>merge B A<br>pop B<br>pop B<br>pop B<br>0</p><p>Sample Output<br>Case #1:<br>2<br>1<br>Case #2:<br>1<br>2<br>3<br>0<br>Case #3:<br>1<br>2<br>3<br>0</p><p>—————————————————————————.<br><strong> 题目大意 </strong></p><p>就是有三种操作,<br>1. push A x: insert x into stack A ————————— 将x插入到栈A<br>2. pop A: remove the top element of stack A ————– 将栈A的栈顶出栈并输出.<br>3. merge A B: merge stack A and B ————————- 将栈B合并到栈A中，按照时间戳的顺序来。<br><strong> 解题思路 </strong><br>首先就是一个模拟，我们可以多引用一个栈C，来存储所有栈中的数据，但是注意只能在合并的时候将数据合并存储到栈C中，切莫直接合并到栈C中，其中的某些数据可能，在<br>之前就已经出栈了。在合并的时候和marge_sort差不多，用时间戳比较就行了。</p><p>对于pop的时候直接pop当前栈就行了，如果栈是空的话 那么我们就对栈C<br>pop就行了。因为输入数据均为合法数据，不会对空栈进行pop操作，所以正确性是有保证的。</p><p>最后注意一下输入就行了。</p><p><strong> 附本题代码 </strong><br>—————————————————————————.</p><pre><code>char op[20],ch,hc;struct node {    int val,id;}a[N],b[N];int c[N];int x,sa,sb,sc;int main(){    //fre();    int n = 1,kcase = 0;    while(~scanf(&quot;%d&quot;,&amp;n)&amp;&amp;n){        printf(&quot;Case #%d:\n&quot;,++kcase);        sa=sb=sc=0;        for(int i=1;i&lt;=n;i++){            //printf(&quot;%d\n&quot;,i);            //if(i==n) printf(&quot;%d  &quot;,n),lalal;            scanf(&quot;%s %c &quot;,op,&amp;ch);            //puts(op);            if(op[1]==&#39;u&#39;){                scanf(&quot;%d&quot;,&amp;x);                if(&#39;A&#39;==ch)  a[++sa].val=x,a[sa].id=i;                else         b[++sb].val=x,b[sb].id=i;            }            else if(op[1]==&#39;o&#39;){                bool flag = true;                if(&#39;A&#39;==ch){                    if(sa) printf(&quot;%d\n&quot;,a[sa--].val),flag=false;                }                else {                    if(sb) printf(&quot;%d\n&quot;,b[sb--].val),flag=false;                }                if(flag&amp;&amp;sc)   printf(&quot;%d\n&quot;,c[sc--]);            }            else {                scanf(&quot;%c&quot;,&amp;ch);                //printf(&quot;%d %d\n&quot;,sa,sb);                int saa=1,sbb=1;                while(saa&lt;=sa&amp;&amp;sbb&lt;=sb){                    if(a[saa].id&lt;b[sbb].id)c[++sc]=a[saa++].val;                    else  c[++sc]=b[sbb++].val;                }                while(saa&lt;=sa) c[++sc] = a[saa++].val;                while(sbb&lt;=sb) c[++sc] = b[sbb++].val;                //printf(&quot;%d\n&quot;,sc);                //for(int i=1;i&lt;=sc;i++) printf(&quot;%d &quot;,c[i]);puts(&quot;&quot;);                sa=sb=0;            }        }    }    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  HDU 5869 Different GCD Subarray Query [区间gcd预处理+离线]【数据结构】</title>
      <link href="/2017/01/29/54780836/"/>
      <url>/2017/01/29/54780836/</url>
      
        <content type="html"><![CDATA[<h1 id="HDU-5869-Different-GCD-Subarray-Query-区间gcd预处理-离线-【数据结构】"><a href="#HDU-5869-Different-GCD-Subarray-Query-区间gcd预处理-离线-【数据结构】" class="headerlink" title="HDU 5869 Different GCD Subarray Query [区间gcd预处理+离线]【数据结构】"></a>HDU 5869 Different GCD Subarray Query [区间gcd预处理+离线]【数据结构】</h1><p>2017年01月29日 23:14:26  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：211</p><hr><p> 博客爬取于<code>2019-04-18 17:18:05</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/54780836" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/54780836</a></p><p>题目链接: <a href="http://acm.hdu.edu.cn/showproblem.php?pid=5869" target="_blank" rel="noopener"> http://acm.hdu.edu.cn/showproblem.php?pid=5869</a></p><p>———————————————————————————————————.<br>Different GCD Subarray Query</p><p>Time Limit: 6000/3000 MS (Java/Others) Memory Limit: 65536/65536 K<br>(Java/Others)<br>Total Submission(s): 1172 Accepted Submission(s): 444</p><p>Problem Description<br>This is a simple problem. The teacher gives Bob a list of problems about GCD<br>(Greatest Common Divisor). After studying some of them, Bob thinks that GCD is<br>so interesting. One day, he comes up with a new problem about GCD. Easy as it<br>looks, Bob cannot figure it out himself. Now he turns to you for help, and<br>here is the problem:</p><p>Given an array a of N positive integers a1,a2,⋯aN−1,aN; a subarray of a is<br>defined as a continuous interval between a1 and aN. In other words,<br>ai,ai+1,⋯,aj−1,aj is a subarray of a, for 1≤i≤j≤N. For a query in the form<br>(L,R), tell the number of different GCDs contributed by all subarrays of the<br>interval [L,R].</p><p>Input<br>There are several tests, process till the end of input.</p><p>For each test, the first line consists of two integers N and Q, denoting the<br>length of the array and the number of queries, respectively. N positive<br>integers are listed in the second line, followed by Q lines each containing<br>two integers L,R for a query.</p><p>You can assume that</p><pre><code>1≤N,Q≤100000 </code></pre><p>1≤ai≤1000000</p><p>Output<br>For each query, output the answer in one line.</p><p>Sample Input<br>5 3<br>1 3 4 6 9<br>3 5<br>2 5<br>1 5</p><p>Sample Output<br>6<br>6<br>6</p><p>Source<br>2016 ACM/ICPC Asia Regional Dalian Online</p><p>———————————————————————————————————.<br><strong> 题目大意: </strong><br>给长度为N的序列,M次询问，每次询问【L,R】之间所有子区间的不同GCD有多少个、</p><p><strong> 解题思路: </strong><br>固定左端点，然后 <strong> 离线 </strong> 预处理出结果，用树状数组或者线段树均可。</p><p>首先预处理出每一个查询右区间位置渐近到达1位置的所有gcd的结果,这个结果显然是单调递减的,且不超过<br>O  (  l  o  g  2  a  r  )  个数的, 这个显然很好想….</p><p>然后在采取更新数值,<br>将每一个新旧的gcd更新到树状数组即使的最靠右的位置(+1,-1),即可,每一次查询的时候 就直接在树状数组查询区间里的个数就行了.</p><p>然后vis[1e6]居然RE。。。。最后改了map才过、</p><p>时间复杂度  O  (  N  ∗  l  o  g  2  A  ∗  l  o  g  2  n  )</p><p><strong> 附本题代码 </strong><br>———————————————————————————————————.</p><pre><code>#include &lt;bits/stdc++.h&gt;using namespace std;#define INF        (~(1&lt;&lt;31))#define INFLL      (~(1ll&lt;&lt;63))#define pb         push_back#define mp         make_pair#define abs(a)     ((a)&gt;0?(a):-(a))#define lalal      puts(&quot;*******&quot;);#define s1(x)      scanf(&quot;%d&quot;,&amp;x)#define Rep(a,b,c) for(int a=(b);a&lt;=(c);a++)#define Per(a,b,c) for(int a=(b);a&gt;=(c);a--)#define no         puts(&quot;NO&quot;)typedef long long int LL ;typedef unsigned long long int uLL ;const int    N   = 100000+7;const int    MOD = 1e9+7;const double eps = 1e-6;const double PI  = acos(-1.0);inline int read(){    int x=0,f=1;char ch=getchar();    while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;){if(ch==&#39;-&#39;)f=-1;ch=getchar();}    while(ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;){x=x*10+ch-&#39;0&#39;;ch=getchar();}    return x*f;}void fre(){    freopen(&quot;in.txt&quot;,&quot;r&quot;,stdin);    freopen(&quot;out.txt&quot;,&quot;w&quot;,stdout);}inline int gcd(int a,int b){return (b==0)?a:gcd(b,a%b);}/***********************************************************************/int sum[N];#define lowbit(x) (x&amp;-x)void update(int index,int val){    for(int i=index;i&lt;N;i+=lowbit(i)) sum[i]+=val;}int getSum(int index){    int ans = 0;    for(int i=index;i;i-=lowbit(i)) ans += sum[i];    return ans;}vector&lt;pair&lt;int,int&gt; &gt;E[N];int a[N],ans[N];struct node {    int l,r,id;    bool operator &lt;(const node &amp;p) const{        //if(r==p.r) return l&lt;p.l;        return r&lt;p.r;    }}q[N];map&lt;int,int&gt;vis;int main(){    int n,m;    while(~scanf(&quot;%d %d&quot;,&amp;n,&amp;m)){        memset(sum,0,sizeof(sum));        for(int i=1;i&lt;=n;++i) scanf(&quot;%d&quot;,&amp;a[i]);        for(int i=1;i&lt;=m;++i) scanf(&quot;%d %d&quot;,&amp;q[i].l,&amp;q[i].r),q[i].id=i,ans[i]=0;        sort(q+1,q+m+1);        for(int i=0;i&lt;=n;++i)E[i].clear();        for(int i=1;i&lt;=n;++i){            int x=a[i];            int y=i;            for(int j=0;j&lt;E[i-1].size();++j){                int res=gcd(x,E[i-1][j].first);                if(x!=res){                    E[i].pb(mp(x,y));                    x=res;                    y=E[i-1][j].second;                }            }            E[i].pb(mp(x,y));        }        vis.clear();        for(int R=0,i=1;i&lt;=m;++i){            while(R &lt; q[i].r){                R++;                for(int j=0;j&lt;E[R].size();++j) {                    int res=E[R][j].first;                    int ids=E[R][j].second;                    if(vis[res]) update(vis[res],-1);                    vis[res] = ids;                    update(vis[res],1);                }            }            ans[q[i].id] = getSum(R) - getSum(q[i].l-1);        }        for(int i=1;i&lt;=m;++i)      printf(&quot;%d\n&quot;,ans[i]);    }    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  图论 [未完成 待续~待修改]</title>
      <link href="/2017/01/26/54746580/"/>
      <url>/2017/01/26/54746580/</url>
      
        <content type="html"><![CDATA[<h1 id="图论-未完成-待续-待修改"><a href="#图论-未完成-待续-待修改" class="headerlink" title="图论 [未完成 待续~待修改]"></a>图论 [未完成 待续~待修改]</h1><p>置顶  2017年01月26日 21:45:01  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：435</p><hr><p> 博客爬取于<code>2019-04-18 17:15:09</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/54746580" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/54746580</a></p><h1 id="图"><a href="#图" class="headerlink" title="图"></a>图</h1><h2 id="图的表示方法"><a href="#图的表示方法" class="headerlink" title="图的表示方法"></a>图的表示方法</h2><h3 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h3><p>二维数组 map[i][j] 表示i到j的边 值为边得大小 ,定义一个值代表不存在这条边 一般为0<br>空间复杂度  O  (  n  2  )</p><h3 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h3><p>vectorG[N];<br>G[i][j] 表示有一条i-&gt;j的有向边</p><pre><code>void add(int u,int v){    G[u].push_back(v);}</code></pre><p>空间复杂度  O  (  e  )</p><h3 id="前向星"><a href="#前向星" class="headerlink" title="前向星"></a>前向星</h3><pre><code>struct edge{    int to,next,w;}G[N&lt;&lt;1];int head[N],tot;void add(int u,int v,int w){    G[tot].w=w,G[tot].to=v,G[tot].next=head[u],head[u]=tot++;}</code></pre><p>空间复杂度  O  (  e  )</p><h2 id="最短路"><a href="#最短路" class="headerlink" title="最短路"></a>最短路</h2><h3 id="floyd"><a href="#floyd" class="headerlink" title="floyd"></a>floyd</h3><p>不解释</p><h3 id="dijkstra"><a href="#dijkstra" class="headerlink" title="dijkstra"></a>dijkstra</h3><pre><code>vector&lt;pair&lt;int ,int &gt; &gt;G[N];int d[N];int main(){    while(~scanf(&quot;%d%d&quot;,&amp;m,&amp;n)){        for(int i=1;i&lt;=n;i++)d[i]=2e9+7,G[i].clear();        d[n]=0;        for(int i=1,u,v,w;i&lt;=m;i++){            scanf(&quot;%d%d%d&quot;,&amp;u,&amp;v,&amp;w);            G[u].push_back(make_pair(v,w));            G[v].push_back(make_pair(u,w));        }        priority_queue&lt;pair&lt;int ,int&gt; &gt;q;        q.push(make_pair(-d[n],n));        while(!q.empty()){            int u =q.top().second;q.pop();            for(int i=0,v;i&lt;G[u].size();i++){                v=G[u][i].first;                if(d[v]&gt;d[u]+G[u][i].second){                    d[v]=d[u]+G[u][i].second;                    q.push(make_pair(-d[v],v));                }            }        }        if(d[n]==2e9+7) puts(&quot;-1&quot;);        else            printf(&quot;%d\n&quot;,d[1]);    }    return 0;}</code></pre><h3 id="SPFA"><a href="#SPFA" class="headerlink" title="SPFA"></a>SPFA</h3><pre><code>LL d[N];int inq[N],n,m,q;LL spfa(int s,int t){    for(int i=1;i&lt;=n;i++) d[i]=2e14+7,inq[i]=0;    queue&lt;int &gt;q;    q.push(s);d[s]=0,inq[s]=1;    while(!q.empty()){        int u =q.front();q.pop();        inq[u]=0;        for(int i=head[u],v;i!=-1;i=G[i].next){            v=G[i].to;            if(d[v]&gt;d[u]+G[i].w){                d[v]=d[u]+G[i].w;                if(inq[v]==1) continue;                inq[v]=1;                q.push(v);            }        }    }    return d[t];}</code></pre><h2 id="强连通"><a href="#强连通" class="headerlink" title="强连通"></a>强连通</h2><pre><code>vector&lt;int&gt;G[N];vector&lt;pair&lt;int,int&gt; &gt;G2[N];int low[N],dfn[N],w[N],d[N];int vis[N],val[N];int color[N],cnt,tot;int mystack[N],len;void dfs(int u){vis[u]=1;    dfn[u]=low[u]=++cnt;    mystack[++len]=u;    int gz=G[u].size();    for(int to,i=0;i&lt;gz;i++){        to=G[u][i];        if(vis[to]==0) dfs(to);        if(vis[to]==1) low[u]=min(low[u],low[to]);    }    if(dfn[u]==low[u]){        ++tot;        do{            val[tot]+=w[mystack[len]];            color[mystack[len]]=tot;            vis[mystack[len]]=2;        }while(mystack[len--]!=u);    }}int n,m;int main(){    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);    cnt=tot=len=0;    for(int i=1;i&lt;=n;i++)    scanf(&quot;%d&quot;,&amp;w[i]);    for(int i=1,u,v;i&lt;=m;i++){        scanf(&quot;%d%d&quot;,&amp;u,&amp;v);        G[u].push_back(v); //看是有向图还是无向图    }    //缩点    for(int i=1;i&lt;=n;i++)   if(vis[i]==0)dfs(i);    //建新图    for(int i=1,gz;i&lt;=n;i++){vis[i]=0,d[i]=0;        gz=G[i].size();        for(int j=0,to;j&lt;gz;j++){            to=G[i][j];            if(color[i]!=color[to])                G2[color[i]].push_back(make_pair(val[color[to]],color[to]));        }    }    return 0;}</code></pre><h2 id="二分图匹配"><a href="#二分图匹配" class="headerlink" title="二分图匹配"></a>二分图匹配</h2><p><a href="http://blog.csdn.net/pi9nc/article/details/11848327" target="_blank" rel="noopener"> 算法介绍 </a><br><strong> 最大匹配数 </strong> ：最大匹配的匹配边的数目<br><strong> 最小点覆盖数 </strong> ：选取最少的点，使任意一条边至少有一个端点被选择<br><strong> 最大独立数 </strong> ：选取最多的点，使任意所选两点均不相连<br>最小路径覆盖数：对于一个 DAG（有向无环图），选取最少条路径，使得每个顶点属于且仅属于一条路径。路径长可以为 0（即单个点）。</p><p>定理1：最小点覆盖数 = 最大匹配数（这是 Konig 定理）<br>定理2：最大独立数 = 顶点数 - 最大匹配数<br>定理3：最小路径覆盖数 = 顶点数 - 最大匹配数</p><p>匈牙利算法求解二分图匹配问题</p><pre><code>int k,n,m;int match[N];int vis[N];vector&lt;int &gt;G[N];int tot,a;int col[N];//二分图染色  用来判断是不是二分图bool color(int s){    queue&lt;int&gt;q;    q.push(s);col[s]=1;    while(!q.empty()){        int u = q.front();q.pop();        tot++;        if(col[u]==1) a++;        int gz=G[u].size();        for(int i=0,to;i&lt;gz;i++){            to=G[u][i];            if(col[to]==0){                col[to]=3-col[u];                q.push(to);            }            else if(col[to]==col[u])                return false;        }    }    return true;}bool findi(int u){    for(int i=0;i&lt;G[u].size();i++){        int v=G[u][i];        if(vis[v]==0){            vis[v]=1;            if(match[v]==-1||findi(match[v])){                match[v]=u;                return true;            }        }    }    return false;}void init(){    memset(match,-1,sizeof(match));    for(int i=1;i&lt;=n;i++) G[i].clear(),col[i]=vis[i]=0;}void add(int u,int v){    G[u].push_back(v);    G[v].push_back(u); //无向图才需要}int maxMATCH(){    int ans = 0;  //ans 是最大匹配数,    for(int i=1;i&lt;=n;i++){        memset(vis,0,sizeof(vis));        if(findi(i)) ans++;    }    ans/=2;   //对于无向图的话 需要ans/=2;    return ans ;}bool perfectMATCH(){    if(maxMATCH()==n) return true;    else              return false;}int main(){    int _;    scanf(&quot;%d&quot;,&amp;_);    while(_--){        scanf(&quot;%d%d&quot;,&amp;n,&amp;m);        init();a=0;        for(int i=1,u,v;i&lt;=m;i++){            scanf(&quot;%d%d&quot;,&amp;u,&amp;v);            add(u,v);        }        /****        根据题意进行balabala        */    }    return 0;}</code></pre><h2 id="2-SAT"><a href="#2-SAT" class="headerlink" title="2-SAT"></a>2-SAT</h2><p><a href="http://www.cnblogs.com/shu-xiaohao/p/3537347.html" target="_blank" rel="noopener"> 强连通分支及其应用（2-SAT）总结 </a></p><blockquote><p>2-SAT</p></blockquote><blockquote></blockquote><blockquote><p>强联通分量一个很重要的用途就是解布尔方程可满足性问题（SAT）。需要学习这一部分知识我们需要一点布尔代数的知识。</p></blockquote><blockquote></blockquote><blockquote><p>下文中我们约定（^表示交v表示并）</p></blockquote><blockquote></blockquote><blockquote><p>例如：（a v b v …）^（c v d v …）^…</p></blockquote><blockquote></blockquote><blockquote><p>这样的我们叫做合取范式。其中（a v b v …）这样的叫做子句。类似a，b…叫做文字。</p></blockquote><blockquote></blockquote><blockquote><p>我们把合取范式中一个子句中包含文字不超过两个的问题成为2-SAT问题。在SAT问题中只有这一类我们可以用线性时间内得出答案。</p></blockquote><blockquote></blockquote><blockquote><p>最常规的2-SAT题目分为大致两种，一种是让你判断有没有解，另一种是让你输出一组解。针对这两种给出模版。</p></blockquote><blockquote></blockquote><blockquote><p>在这之前先来介绍一下2-SAT题目的大致解题步骤：</p></blockquote><blockquote></blockquote><blockquote><p>对于2-SAT问题我们需要构建一张有向图每个文字拆为两个节点 例如 a 变为 a， !a</p></blockquote><blockquote></blockquote><blockquote><p>首先我们从题目中总结出来的都是一些比较杂乱的逻辑表达式，不过一般都是两两之间的关系，我们需要做的第一步是化简成用^连接。然后对于每个子句建边。</p></blockquote><blockquote></blockquote><blockquote><p>建边的规则是这样的 a -&gt; b那么在有向图中建一条a到b的边</p></blockquote><blockquote></blockquote><blockquote><p>我们可能得到的子句有：</p></blockquote><blockquote></blockquote><blockquote><p>a v b 我们可以化简 !a-&gt;b ^ !b-&gt;a</p></blockquote><blockquote></blockquote><blockquote><p>a -&gt; b 直接连边</p></blockquote><blockquote></blockquote><blockquote><p>a 转化为!a -&gt; a</p></blockquote><blockquote></blockquote><blockquote><p>其中每个文字及其的非对应相应的结点，若是出现在文字前有非的关系例如 !a v b 那么变通一下 就化成 a -&gt; b ^ !b -&gt; !a就可以了。</p></blockquote><blockquote></blockquote><blockquote><p>到这里我们要做的事（建图）就完成了，接下来交给模版，我们来看一下模版做了什么：</p></blockquote><blockquote></blockquote><blockquote><p>首先我们对建完的有向图求强连通分支，若是出现有一个逻辑变量和他的反在同一个联通分之内就无解，否则有解。</p></blockquote><blockquote></blockquote><blockquote><p>若a所在的强连通分支的拓扑序在!a之后a为真，否则为反。怎么样很简单吧。</p></blockquote><pre><code>vector&lt;int&gt; G[N];vector&lt;int&gt; G2[N];vector&lt;int&gt; S;int vis[N] ;  //标记数组int sccno[N]; //记录数组 sccno[i] 记录  i属于哪个联通分支int scc_cnt;  int n;void dfs1(int u){    if(vis[u]) return ;    vis[u] = true;    for(int i = 0; i &lt; G[u].size(); i++){        dfs1(G[u][i]);    }    S.push_back(u);}void dfs2(int u){    if(sccno[u]) return;    sccno[u] = scc_cnt;    for(int i = 0; i &lt; G2[u].size(); i++){        dfs2(G2[u][i]);    }}void find_scc(int n){    scc_cnt = 0;    S.clear();    memset(vis , 0 , sizeof(vis));    memset(sccno , 0 , sizeof(sccno));    for(int i = 0; i &lt; n; i++) dfs1(i);    for(int i = n - 1; i &gt;= 0; i--) if(!sccno[S[i]]){        scc_cnt++;        dfs2(S[i]);    }}void AddEdge(int u , int v) {    G[u].push_back(v);    G2[v].push_back(u);}int main(){    /***    输入数据    */    /***    加边  边未两者不能匹配的      example ：    {u,v}  当选择u的时候一定不能选择v ,需要选择v&#39;;    */    find_scc(2 * n);  //注意x2    for(int i = 0; i &lt; n; i++){        if(sccno[i] == sccno[i + n]){            //如果有x与x&#39;同时被取或者未取，则匹配失败            puts(&quot;NO&quot;);            return 0;        }    }    puts(&quot;YES&quot;);    for(int i = 0; i &lt; n; i++){        if(sccno[i] &gt; sccno[i + n]){            //相关 i;        }        else {            //相关 i&#39;;        }    }    return 0;}/********************************************************//****************************************     2-SAT kosaraju算法             By 小豪                *****************************************/const int LEN = 200000+10;vector&lt;int&gt; Map[LEN], rMap[LEN], vs;int n, m, vis[LEN], sccn[LEN];void dfs(int v){    vis[v] = 1;    for(int i=0; i&lt;Map[v].size(); i++)        if(!vis[Map[v][i]]) dfs(Map[v][i]);    vs.PB(v);}void rdfs(int v, int f){    vis[v] = 1;    sccn[v] = f;    for(int i=0; i&lt;rMap[v].size(); i++)        if(!vis[rMap[v][i]]) rdfs(rMap[v][i], f);}int scc(){     memset(vis, 0, sizeof vis);     vs.clear();     for(int i=0; i&lt;2*n; i++) if(!vis[i]) dfs(i);     memset(vis, 0, sizeof vis);     int k = 0;     for(int i = vs.size()-1; i&gt;=0; i--) if(!vis[vs[i]]) rdfs(vs[i], k++);     return k;}void addedge(int a, int b){    Map[a].PB(b);    rMap[b].PB(a);}void solve(){    scc();    for(int i=0; i&lt;2*n; i+=2)        if(sccn[i] == sccn[i+1]){                //printf(&quot;No solution.\n&quot;);        　　　　 //无解            return ;        }    for(int i=0; i&lt;n; i++){        if(sccn[i*2] &gt; sccn[i*2+1]) printf(&quot;Yes\n&quot;);        else printf(&quot;No\n&quot;);    }}</code></pre><h2 id="网络流"><a href="#网络流" class="headerlink" title="网络流"></a>网络流</h2><p><a href="http://blog.csdn.net/u013368721/article/details/39716401" target="_blank" rel="noopener"> 网络流各种骚操作 </a></p><h4 id="dinic-没有当前弧优化"><a href="#dinic-没有当前弧优化" class="headerlink" title="dinic(没有当前弧优化"></a>dinic(没有当前弧优化</h4><pre><code>const int MAXN = 210;const int MAXM = 210*210;const int INF = 0x3f3f3f3f;struct Edge {    int v, f;    int next;} edge[MAXM];int n, m;int cnt;int head[MAXN], level[MAXN];int q[MAXN];void read_graph(int u, int v, int f) {    edge[cnt].v = v, edge[cnt].f = f;    edge[cnt].next = head[u], head[u] = cnt++;    edge[cnt].v = u, edge[cnt].f = 0;  //增加一条反向弧，容量为0    edge[cnt].next = head[v], head[v] = cnt++;}//BFS构建层次网络：int bfs(int s, int t) { //构建层次网络    memset(level, 0, sizeof(level));    level[s] = 1;    int front = 0, rear = 1;    q[front] = s;    while(front &lt; rear) {        int x = q[front++];        if(x == t) return 1;        for(int e = head[x]; e != -1; e = edge[e].next) {            int v = edge[e].v, f = edge[e].f;            if(!level[v] &amp;&amp; f) {                level[v] = level[x] + 1;                q[rear++] = v;            }        }    }    return 0;}//DFS找寻增广路：int dfs(int u, int maxf, int t) {    if(u == t) return maxf;    int ret = 0;    for(int e = head[u]; e != -1; e = edge[e].next) {        int v = edge[e].v, f = edge[e].f;        if(level[u] + 1 == level[v] &amp;&amp; f) {            int Min = min(maxf-ret, f);            f = dfs(v, Min, t);            edge[e].f -= f;            edge[e^1].f += f;            ret += f;            if(ret == maxf) return ret;        }    }    return ret;}int Dinic(int s, int t) { //Dinic    int ans = 0;    while(bfs(s, t)) ans += dfs(s, INF, t);    return ans;}int main() {    while(~scanf(&quot;%d%d&quot;,&amp;m,&amp;n)){        cnt = 0;        memset(head, -1, sizeof(head));        for(int x,y,v;m--;){            scanf(&quot;%d%d%d&quot;,&amp;x,&amp;y,&amp;v);            read_graph(x,y,v);        }        printf(&quot;%d\n&quot;,Dinic(1,n));    }    return 0;}</code></pre><h1 id="树"><a href="#树" class="headerlink" title="树"></a>树</h1><blockquote><p>树被定义为没有圈的连通图，具有以下几个性质：<br>1. 在树中去掉一条边后所得的图是不连通的。<br>2. 在树中添加一条边后所得的图一定存在圈。<br>3. 树的每一对顶点 U 和 V 之间有且仅有一条路径。</p></blockquote><h2 id="树的直径"><a href="#树的直径" class="headerlink" title="树的直径"></a>树的直径</h2><p>树的直径(Diameter)是指树上的最长简单路。</p><blockquote><p>直径的求法：两遍搜索 (BFS or DFS)<br>任选一点w为起点，对树进行搜索，找出离w最远的点u。<br>以u为起点，再进行搜索，找出离u最远的点v。则u到v的路径长度即为树的直径。</p></blockquote><h2 id="树的重心"><a href="#树的重心" class="headerlink" title="树的重心"></a>树的重心</h2><blockquote><p>树的重心：找到一个点，其所有的子树中最大的子树节点数最少,那么这个点就是这棵树的重心,删去重心后，生成的多棵树尽可能平衡。<br>树的重心可以通过简单的两次搜索求出，第一遍搜索求出每个结点的子结点数量son[u]，第二遍搜索找出使max{son[u],n-son[u]-1}最小的结点。<br>实际上这两步操作可以在一次遍历中解决。对结点u的每一个儿子v，递归的处理v，求出son[v]，然后判断是否是结点数最多的子树，处理完所有子结点后，判断u是否<br>为重心。</p></blockquote><pre><code>例题 1655int n;vector&lt;int &gt;G[N];void add(int u,int v){G[u].push_back(v);}int sz[N],siz,zx;void dfs(int u,int f=0){    sz[u]=1;int mx=0;    int gz=G[u].size();    for(int i=0,to;i&lt;gz;i++){        to = G[u][i];        if(to == f) continue;        dfs(to,u);        sz[u]+=sz[to];        mx=max(mx,sz[to]);    }    mx=max(mx,n-sz[u]);    if(mx==siz&amp;&amp;u&lt;zx) zx=u;    if(mx&lt;siz) zx=u,siz=mx;}int main(){    int _;    for(scanf(&quot;%d&quot;,&amp;_);_--;){        scanf(&quot;%d&quot;,&amp;n);        for(int i=1,u,v;i&lt;n;i++){            scanf(&quot;%d%d&quot;,&amp;u,&amp;v);            add(u,v);add(v,u);        }        siz = n*10; dfs(1);        printf(&quot;%d %d\n&quot;,zx,siz);        for(int i=1;i&lt;=n;i++) G[i].clear();    }    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  HDU 5943 Kingdom of Obsession [素数间隔+二分图匹配]【数论+图论】</title>
      <link href="/2017/01/26/54746352/"/>
      <url>/2017/01/26/54746352/</url>
      
        <content type="html"><![CDATA[<h1 id="HDU-5943-Kingdom-of-Obsession-素数间隔-二分图匹配-【数论-图论】"><a href="#HDU-5943-Kingdom-of-Obsession-素数间隔-二分图匹配-【数论-图论】" class="headerlink" title="HDU 5943 Kingdom of Obsession [素数间隔+二分图匹配]【数论+图论】"></a>HDU 5943 Kingdom of Obsession [素数间隔+二分图匹配]【数论+图论】</h1><p>2017年01月26日 21:31:23  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：164</p><hr><p> 博客爬取于<code>2019-04-18 17:18:06</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/54746352" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/54746352</a></p><p>题目连接： <a href="http://acm.hdu.edu.cn/showproblem.php?pid=5943" target="_blank" rel="noopener"> http://acm.hdu.edu.cn/showproblem.php?pid=5943</a><br>————————————————————————————–.<br>Kingdom of Obsession</p><p>Time Limit: 2000/1000 MS (Java/Others) Memory Limit: 65536/32768 K<br>(Java/Others)<br>Total Submission(s): 789 Accepted Submission(s): 215</p><p>Problem Description<br>There is a kindom of obsession, so people in this kingdom do things very<br>strictly.</p><p>They name themselves in integer, and there are n people with their id<br>continuous (s+1,s+2,⋯,s+n) standing in a line in arbitrary order, be more<br>obsessively, people with id x wants to stand at yth position which satisfy</p><p>xmody=0</p><p>Is there any way to satisfy everyone’s requirement?</p><p>Input<br>First line contains an integer T, which indicates the number of test cases.</p><p>Every test case contains one line with two integers n, s.</p><p>Limits<br>1≤T≤100.<br>1≤n≤109.<br>0≤s≤109.</p><p>Output<br>For every test case, you should output ‘Case #x: y’, where x indicates the<br>case number and counts from 1 and y is the result string.</p><p>If there is any way to satisfy everyone’s requirement, y equals ‘Yes’,<br>otherwise y equals ‘No’.</p><p>Sample Input<br>2<br>5 14<br>4 11</p><p>Sample Output<br>Case #1: No<br>Case #2: Yes</p><p>Source<br>2016年中国大学生程序设计竞赛（杭州）</p><p>————————————————————————————–.<br>题目大意:<br>现在有N个人分别标号为  {  S  +  1  ,  S  +  2  ,  ,  ,  ,  S  +  N  }  现在要在  [  1  ,<br>N  ]  这些位置上按照下列要求给这N个人串个座位,使得每个人的座位号整除标号.问你有没有可行方案.</p><p>解题思路:<br>很明显,  {  S  +  1  ,  S  +  2  ,  ,  ,  ,  S  +  N  }<br>区间中只能有一个素数,要坐在1的位置上,其余地方都不行.<br>然后查了一下素数间隔,最大的素数间隔只有777.那么就是N&gt;777的时候都是NO,<br>这样的话就可以大数据直接NO,小数据在考虑了,</p><p>特别考虑的就是当S&lt; N的时候  {  S  +  1  ,  S  +  2  ,  ,  ,  ,  N  }  可以直接放到本位置，那么只需要考虑<br>{  N  +  1  ,  N  +  2  ,  ,  ,  ,  S  +  N  }  这些数就好了，将S，N互换一下即可。</p><p>每个标号能做的位置是固定的,那么将人和位置分开就是一个二分图了,接着对二分图进行 <strong> 完美匹配 </strong> 就好了.</p><p>附本题代码<br>————————————————————————————–.</p><pre><code>#include &lt;bits/stdc++.h&gt;using namespace std;#define INF        (~(1&lt;&lt;31))#define INFLL      (~(1ll&lt;&lt;63))#define pb         push_back#define mp         make_pair#define abs(a)     ((a)&gt;0?(a):-(a))#define lalal      puts(&quot;*******&quot;);#define s1(x)      scanf(&quot;%d&quot;,&amp;x)#define Rep(a,b,c) for(int a=(b);a&lt;=(c);a++)#define Per(a,b,c) for(int a=(b);a&gt;=(c);a--)#define no         puts(&quot;NO&quot;)typedef long long int LL ;typedef unsigned long long int uLL ;const int    N   = 1000000+7;const int    MOD = 1e9+7;const double eps = 1e-6;const double PI  = acos(-1.0);inline int read(){    int x=0,f=1;char ch=getchar();    while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;){if(ch==&#39;-&#39;)f=-1;ch=getchar();}    while(ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;){x=x*10+ch-&#39;0&#39;;ch=getchar();}    return x*f;}void fre(){    freopen(&quot;in.txt&quot;,&quot;r&quot;,stdin);    freopen(&quot;out.txt&quot;,&quot;w&quot;,stdout);}inline int gcd(int a,int b){return (b==0)?a:gcd(b,a%b);}/***********************************************************************/int match[2000];int vis[2000];vector&lt;int &gt;mmp[2000];int find(int u){    for(int i=0;i&lt;mmp[u].size();i++){        int v=mmp[u][i];        if(vis[v]==0){            vis[v]=1;            if(match[v]==-1||find(match[v])){                match[v]=u;                return 1;            }        }    }    return 0;}bool prime(int x){    if(x==0||x==1)return false;    if(x==2) return true;    if(x%2==0) return false;    for(int i=3;i*i&lt;=x;i+=2)        if(x%i==0) return false;    return true;}int main(){    int _,kcase;    while(~s1(_)){        kcase = 0;        while(_--){            int n,s;            s1(n),s1(s);            printf(&quot;Case #%d: &quot;,++kcase);            if(s&lt;n) s^=n,n^=s,s^=n;            if(n&gt;777) puts(&quot;No&quot;);            else {                int num = 0;                for(int i=1;i&lt;=n&amp;&amp;num&lt;=2;i++)                    if(prime(s+i)) num++;                if(num&gt;1) {puts(&quot;No&quot;);continue; }                memset(match,-1,sizeof(match));                for(int i=1;i&lt;=n+n;i++) mmp[i].clear();                for(int i=1;i&lt;=n;i++)                    for(int j=1;j&lt;=n;j++)                        if((s+i)%j==0) mmp[i].pb(j+n),mmp[j+n].pb(i);                int ans = 0;                for(int i=1;i&lt;=n;i++){                    memset(vis,0,sizeof(vis));                    if(find(i)) ans++;                }                if(ans==n) puts(&quot;Yes&quot;);                else    puts(&quot;No&quot;);            }        }    }    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  HDU 5726 GCD [ST表+暴力二分]【数据结构|杂类】</title>
      <link href="/2017/01/24/54709231/"/>
      <url>/2017/01/24/54709231/</url>
      
        <content type="html"><![CDATA[<h1 id="HDU-5726-GCD-ST表-暴力二分-【数据结构-杂类】"><a href="#HDU-5726-GCD-ST表-暴力二分-【数据结构-杂类】" class="headerlink" title="HDU 5726 GCD [ST表+暴力二分]【数据结构|杂类】"></a>HDU 5726 GCD [ST表+暴力二分]【数据结构|杂类】</h1><p>2017年01月24日 17:26:37  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：274</p><hr><p> 博客爬取于<code>2019-04-18 17:18:07</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/54709231" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/54709231</a></p><p>题目连接: <a href="http://acm.hdu.edu.cn/showproblem.php?pid=5726" target="_blank" rel="noopener"> http://acm.hdu.edu.cn/showproblem.php?pid=5726</a><br>———————————————————————–.<br>GCD</p><p>Time Limit: 10000/5000 MS (Java/Others) Memory Limit: 65536/65536 K<br>(Java/Others)<br>Total Submission(s): 3164 Accepted Submission(s): 1146</p><p>Problem Description<br>Give you a sequence of N(N≤100,000) integers : a1,…,an(0 &lt; ai≤1000,000,000).<br>There are Q(Q≤100,000) queries. For each query l,r you have to calculate<br>gcd(al,,al+1,…,ar) and count the number of pairs(l′,r′)(1≤l&lt; r≤N)such that<br>gcd(al′,al′+1,…,ar′) equal gcd(al,al+1,…,ar).</p><p>Input<br>The first line of input contains a number T, which stands for the number of<br>test cases you need to solve.</p><p>The first line of each case contains a number N, denoting the number of<br>integers.</p><p>The second line contains N integers, a1,…,an( 0 &lt; ai ≤ 1000,000,000).</p><p>The third line contains a number Q, denoting the number of queries.</p><p>For the next Q lines, i-th line contains two number , stand for the li,ri,<br>stand for the i-th queries.</p><p>Output<br>For each case, you need to output “Case #:t” at the beginning.(with quotes, t<br>means the number of the test case, begin from 1).</p><p>For each query, you need to output the two numbers in a line. The first number<br>stands for gcd(al,al+1,…,ar) and the second number stands for the number of<br>pairs(l′,r′) such that gcd(al′,al′+1,…,ar′) equal gcd(al,al+1,…,ar).</p><p>Sample Input<br>1<br>5<br>1 2 4 6 7<br>4<br>1 5<br>2 4<br>3 4<br>4 4</p><p>Sample Output<br>Case #1:<br>1 8<br>2 4<br>2 4<br>6 1</p><p>Author<br>HIT<br>———————————————————————–.<br><strong> 题目大意: </strong><br>有一个长度为N的序列,Q次查询,每次查询需求解出  g  c  d  {  A  }  ,  A  =  {  a  i  |  i  ∈  [  l  ,<br>r  ]  }  及与区间gcd值相同的区间有多少个.</p><p><strong> 解题思路 </strong><br>首先对与区间gcd 我们可以用线段树或者ST表预处理下,因为没有元素更改,相比之下后者更好(复杂度上,代码量上)</p><p>然后就是如何就解 <strong> 与区间gcd值相同的区间有多少个. </strong><br>这个我们只能枚举一端,然后向右找,然后用个map来存储结果,这样的话复杂度是  O  (  n  2  )  ,显然不可取.<br>但是对于一个区间上的gcd来说一定是 <strong> 不增 </strong><br>的.这样就有了单调性,我们就可以二分做了,但这样需要三层循环解决.,而且在枚举不同端点的时候还会有重复统计的情况.<br>然后考虑,一个gcd的递减的过程最多也就这能递减 <strong> 因子数个 </strong> ,那么我们每一次记录的就是一种gcd值的区间,然后接下来串过来就好了,</p><p>最后的复杂度就是  O  (  n  ∗  因  子  个  数  ∗  二  分  )</p><p>附本题代码<br>———————————————————————–.</p><pre><code>#include &lt;bits/stdc++.h&gt;using namespace std;#define INF        (~(1&lt;&lt;31))#define INFLL      (~(1ll&lt;&lt;63))#define pb         push_back#define mp         make_pair#define abs(a)     ((a)&gt;0?(a):-(a))#define lalal      puts(&quot;*******&quot;);#define s1(x)      scanf(&quot;%d&quot;,&amp;x)#define Rep(a,b,c) for(int a=(b);a&lt;=(c);a++)#define Per(a,b,c) for(int a=(b);a&gt;=(c);a--)#define no         puts(&quot;NO&quot;)typedef long long int LL ;typedef unsigned long long int uLL ;const int    N   = 100000+7;const int    MOD = 1e9+7;const double eps = 1e-6;const double PI  = acos(-1.0);inline int read(){    int x=0,f=1;char ch=getchar();    while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;){if(ch==&#39;-&#39;)f=-1;ch=getchar();}    while(ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;){x=x*10+ch-&#39;0&#39;;ch=getchar();}    return x*f;}void fre(){    freopen(&quot;in.txt&quot;,&quot;r&quot;,stdin);    freopen(&quot;out.txt&quot;,&quot;w&quot;,stdout);}inline int gcd(int a,int b){return (b==0)?a:gcd(b,a%b);}/***********************************************************************/int n;int a[N];int st[N][20],mm[N];void ST(){    for(int j=1;(1&lt;&lt;j)&lt;=n; j++)        for(int i=1; i+(1&lt;&lt;j)-1&lt;=n; i++)            st[i][j]=gcd(st[i][j-1],st[i+(1&lt;&lt;(j-1))][j-1]);}void initrmp(int x){    mm[0]=-1;    for(int i=1;i&lt;=x;i++)    mm[i]=((i&amp;(i-1))==0)?mm[i-1]+1:mm[i-1];}int getST(int l,int r){    int k=mm[r-l+1];    return gcd(st[l][k],st[r-(1&lt;&lt;k)+1][k]);}map&lt;int ,LL&gt; ans;int main(){    initrmp(100000);    int _,kcase;    while(~scanf(&quot;%d&quot;,&amp;_)){        kcase = 0;        while(_--){            ans.clear();            n=read();            for(int i=1;i&lt;=n;i++)    a[i]=read(),st[i][0]=a[i];            ST();            for(int i=1;i&lt;=n;i++){                int cur = i , gc = a[i];                while( cur &lt;= n ){                    int l = cur , r = n;                    while( l &lt; r ){                        int mid = l + r + 1 &gt;&gt; 1;                        if(getST(i,mid)==gc) l = mid ;                        else r = mid - 1;                    }                    if(ans.count(gc)) ans[gc] +=(l-cur+1);                    else ans[gc]=(l-cur+1);                    cur = l + 1 , gc = gcd( gc , a[l + 1] );                }            }            int q;            q=read();            printf(&quot;Case #%d:\n&quot;,++kcase);            while(q--){                int l=read(),r=read(),g=getST(l,r);                printf(&quot;%d %I64d\n&quot;,g,ans[g]);            }        }    }    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  hdu 5724 Chess [状压+SG函数]【博弈】</title>
      <link href="/2017/01/24/54707350/"/>
      <url>/2017/01/24/54707350/</url>
      
        <content type="html"><![CDATA[<h1 id="hdu-5724-Chess-状压-SG函数-【博弈】"><a href="#hdu-5724-Chess-状压-SG函数-【博弈】" class="headerlink" title="hdu 5724 Chess [状压+SG函数]【博弈】"></a>hdu 5724 Chess [状压+SG函数]【博弈】</h1><p>2017年01月24日 13:51:16  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：237</p><hr><p> 博客爬取于<code>2019-04-18 17:18:08</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/54707350" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/54707350</a></p><p>题目连接: <a href="http://acm.hdu.edu.cn/showproblem.php?pid=5724" target="_blank" rel="noopener"> http://acm.hdu.edu.cn/showproblem.php?pid=5724</a><br>———————————————————————————–.<br>Chess</p><p>Time Limit: 2000/1000 MS (Java/Others) Memory Limit: 65536/65536 K<br>(Java/Others)<br>Total Submission(s): 2320 Accepted Submission(s): 985</p><p>Problem Description<br>Alice and Bob are playing a special chess game on an n × 20 chessboard. There<br>are several chesses on the chessboard. They can move one chess in one turn. If<br>there are no other chesses on the right adjacent block of the moved chess,<br>move the chess to its right adjacent block. Otherwise, skip over these chesses<br>and move to the right adjacent block of them. Two chesses can’t be placed at<br>one block and no chess can be placed out of the chessboard. When someone can’t<br>move any chess during his/her turn, he/she will lose the game. Alice always<br>take the first turn. Both Alice and Bob will play the game with the best<br>strategy. Alice wants to know if she can win the game.</p><p>Input<br>Multiple test cases.</p><p>The first line contains an integer T(T≤100), indicates the number of test<br>cases.</p><p>For each test case, the first line contains a single integer n(n≤1000), the<br>number of lines of chessboard.</p><p>Then n lines, the first integer of ith line is m(m≤20), indicates the number<br>of chesses on the ith line of the chessboard. Then m integers pj(1≤pj≤20)<br>followed, the position of each chess.</p><p>Output<br>For each test case, output one line of “YES” if Alice can win the game, “NO”<br>otherwise.</p><p>Sample Input<br>2<br>1<br>2 19 20<br>2<br>1 19<br>1 18</p><p>Sample Output<br>NO<br>YES</p><p>Author<br>HIT</p><p>———————————————————————————–.</p><p><strong> 题目大意: </strong><br>就是有n个一维的棋盘,两个人轮流走,每次可以将一个棋子移到距离它最近的右边的空位上。最后谁不能移动棋子了就输了。</p><p><strong> 解题思路 </strong><br>题目中给定的每一维的状态可以用长度为20的二进制数表示，1为有棋子，0为没有棋子。<br>表示出来之后可以转移出每种状态的后继状态求出对应的SG值，最后将N个SG值异或一下就好了。</p><p>在每一次移动的时候对应的二进制数都会变小，所以从1-&gt;(1&lt;&lt;20)预处理一下结果就好了.</p><p>开始写的记忆化搜索的形式怎么都是WA,后来改了一发预处理就AC了.</p><p><strong> 附本题代码 </strong><br>———————————————————————————–.</p><pre><code>#include &lt;bits/stdc++.h&gt;using namespace std;void display_bit(int a){    for(int i=31;i&gt;=0;i--){        if(a&amp;(1&lt;&lt;i)) printf(&quot;1&quot;);        else printf(&quot;0&quot;);    }    printf(&quot; -- %d\n&quot;,a);}/***********************************************************************/int sg[(1&lt;&lt;20)+100],tmp,p;bool h[30];void init(){    sg[0]=0;    for(int i=1;i&lt;(1&lt;&lt;20);i++){        memset(h,false,sizeof(h));        p=-1;        for(int j=0;j&lt;20;j++){            if((i&amp;(1&lt;&lt;j))==0) p=j;            else if(p!=-1){                tmp = i^(1&lt;&lt;j)^(1&lt;&lt;p);                if(sg[tmp]&lt;30) h[sg[tmp]]=true;            }        }        for(int j=0;;j++) if(!h[j]) {sg[i]=j;break; }    }}int main(){    init();    int _;    while(~scanf(&quot;%d&quot;,&amp;_)){        while(_--){            int n;            scanf(&quot;%d&quot;,&amp;n);            int ans = 0,x,y,tem;            for(int i=0;i&lt;n;i++){                scanf(&quot;%d&quot;,&amp;x);                tem = 0;                for(int j=0;j&lt;x;j++){                    scanf(&quot;%d&quot;,&amp;y);                    tem |= (1&lt;&lt;(20-y));                }                ans^=sg[tem];            }            if(ans) puts(&quot;YES&quot;);            else    puts(&quot;NO&quot;);        }    }    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  HDU 3949 XOR [线性基|高斯消元]【数学】</title>
      <link href="/2017/01/23/54695958/"/>
      <url>/2017/01/23/54695958/</url>
      
        <content type="html"><![CDATA[<h1 id="HDU-3949-XOR-线性基-高斯消元-【数学】"><a href="#HDU-3949-XOR-线性基-高斯消元-【数学】" class="headerlink" title="HDU 3949 XOR [线性基|高斯消元]【数学】"></a>HDU 3949 XOR [线性基|高斯消元]【数学】</h1><p>2017年01月23日 21:38:29  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：529</p><hr><p> 博客爬取于<code>2019-04-18 17:18:09</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/54695958" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/54695958</a></p><p>题目连接： <a href="http://acm.hdu.edu.cn/showproblem.php?pid=3949" target="_blank" rel="noopener"> http://acm.hdu.edu.cn/showproblem.php?pid=3949</a><br>——————————————————————————–.<br>碑商家客流量预测大赛》<br><strong> XOR </strong></p><p>Time Limit: 2000/1000 MS (Java/Others) Memory Limit: 32768/32768 K<br>(Java/Others)<br>Total Submission(s): 2533 Accepted Submission(s): 858</p><p><strong> Problem Description </strong><br>XOR is a kind of bit operator, we define that as follow: for two binary base<br>number A and B, let C=A XOR B, then for each bit of C, we can get its value by<br>check the digit of corresponding position in A and B. And for each digit, 1<br>XOR 1 = 0, 1 XOR 0 = 1, 0 XOR 1 = 1, 0 XOR 0 = 0. And we simply write this<br>operator as ^, like 3 ^ 1 = 2,4 ^ 3 = 7. XOR is an amazing operator and this<br>is a question about XOR. We can choose several numbers and do XOR operatorion<br>to them one by one, then we get another number. For example, if we choose 2,3<br>and 4, we can get 2^3^4=5. Now, you are given N numbers, and you can choose<br>some of them(even a single number) to do XOR on them, and you can get many<br>different numbers. Now I want you tell me which number is the K-th smallest<br>number among them.</p><p><strong> Input </strong><br>First line of the input is a single integer T(T&lt;=30), indicates there are T<br>test cases.<br>For each test case, the first line is an integer N(1&lt;=N&lt;=10000), the number of<br>numbers below. The second line contains N integers (each number is between 1<br>and 10^18). The third line is a number Q(1&lt;=Q&lt;=10000), the number of queries.<br>The fourth line contains Q numbers(each number is between 1 and 10^18)<br>K1,K2,……KQ.</p><p><strong> Output </strong><br>For each test case,first output Case #C: in a single line,C means the number<br>of the test case which is from 1 to T. Then for each query, you should output<br>a single line contains the Ki-th smallest number in them, if there are less<br>than Ki different numbers, output -1.</p><p><strong> Sample Input </strong><br>2<br>2<br>1 2<br>4<br>1 2 3 4<br>3<br>1 2 3<br>5<br>1 2 3 4 5</p><p><strong> Sample Output </strong><br>Case #1:<br>1<br>2<br>3<br>-1<br>Case #2:<br>0<br>1<br>2<br>3<br>-1 </p><p><strong> Hint </strong></p><p>If you choose a single number, the result you get is the number you choose.<br>Using long long instead of int because of the result may exceed 2^31-1.</p><p><strong> Author </strong><br>elfness</p><p>——————————————————————————–.<br><strong> 题目大意： </strong><br>就是给你长度为N的学列，有Q次查询，每次查询这写序列中能异或出来的第k小的值</p><p><strong> 解题思路 </strong><br>本题是一个线性基的入门题。<br><a href="http://www.cnblogs.com/vb4896/p/6149022.html" target="_blank" rel="noopener"> 线性基的介绍 </a> 或者参考 <strong><br>2014国家集训队论文《浅谈线性相关》 </strong></p><p>其实线性基的求解过程就是一个高斯消元,它构建了一个二维的空间,N*bits这么大,<br>通过列与列相消,求解出基向量也就是空间的极大无关组,通过这几个元素能得到含盖空间中所有元素的无关组.</p><p>本题求的就是这个无关组能构建出来的第K小的值.</p><p>求这个值我们可以类比最理想情况下的无关组,</p><p>1 0 0 0 0 0 … 0  p  1<br>0 1 0 0 0 0 … 0  p  2<br>0 0 1 0 0 0 … 0  p  3<br>0 0 0 1 0 0 … 0  p  4<br>0 0 0 0 1 0 … 0  p  5<br>0 0 0 0 0 1 … 0  p  6<br>…<br>0 0 0 0 0 0 … 0  p  n</p><p>那么对于第K小的值就是将K二进制展开,第  i  位上为1,就在结果上异或  p  n  −  i  就好了,</p><p>至于为什么对呢?</p><p>因为是将K二进制展开,而  p  i  这种特殊数据下，得出的刚好是K，这显然是正确的。</p><p>但是无关组不可能都是这么理想的</p><p>但这个规律对于普通的情况也是使用的，不太好表述，就是如果其他位上如果有1 的话，对于异或出来的结果的集合中的顺序是不影响的。 可以写两个数据验证一下，，，</p><p><strong> 附本题代码 </strong><br>——————————————————————————–.</p><pre><code>#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long int LL ;const int    N   = 10000+7;/***********************************************************************/int cnt;LL a[N],p[65];void Guass(int n){    memset(p,0,sizeof(p));    for(int i=1;i&lt;=n;i++)        for(int j=63;j&gt;=0;j--)            if ((a[i]&gt;&gt;j)&amp;1){                if (p[j]) a[i]^=p[j];                else {p[j]=a[i]; break;}            }    for(int i=63;i&gt;=0;i--){        if(!p[i]) continue;        for(int j=i+1;j&lt;=62;j++)            if((p[j]&gt;&gt;i)&amp;1) p[j]^=p[i];    }    cnt=0;    for(int j=0;j&lt;=63;j++) if (p[j]) p[cnt++]=p[j];}int main(){    int _ = 1,kcase;    while(~scanf(&quot;%d&quot;,&amp;_)){        kcase = 0;        while(_--){            int n;            scanf(&quot;%d&quot;,&amp;n);            for(int i=1;i&lt;=n;i++)          scanf(&quot;%I64d&quot;,&amp;a[i]);            Guass(n);            printf(&quot;Case #%d:\n&quot;,++kcase);            int q;LL x;            scanf(&quot;%d&quot;,&amp;q);            while(q--){                scanf(&quot;%I64d&quot;,&amp;x);                if(n!=cnt) x--;                if(x&gt;=(1ll&lt;&lt;cnt)) puts(&quot;-1&quot;);                else {                    LL ans = 0;                    for(int i=0;i&lt;=63;i++){                        if((x&gt;&gt;i)&amp;1) ans^=p[i];                    }                    printf(&quot;%I64d\n&quot;,ans);                }            }        }    }    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  codeforces 382B B. Number Busters [二分答案+数学]【思维】</title>
      <link href="/2017/01/22/54668103/"/>
      <url>/2017/01/22/54668103/</url>
      
        <content type="html"><![CDATA[<h1 id="codeforces-382B-B-Number-Busters-二分答案-数学-【思维】"><a href="#codeforces-382B-B-Number-Busters-二分答案-数学-【思维】" class="headerlink" title="codeforces 382B B. Number Busters [二分答案+数学]【思维】"></a>codeforces 382B B. Number Busters [二分答案+数学]【思维】</h1><p>2017年01月22日 13:52:08  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：263<br>标签：  <a href="https://so.csdn.net/so/search/s.do?q=codeforces&amp;t=blog" target="_blank" rel="noopener"> codeforces </a></p><p>个人分类：  <a href="https://blog.csdn.net/qq_33184171/article/category/6235560" target="_blank" rel="noopener"> codeforces</a> <a href="https://blog.csdn.net/qq_33184171/article/category/6162724" target="_blank" rel="noopener"> 数学</a> <a href="https://blog.csdn.net/qq_33184171/article/category/6253262" target="_blank" rel="noopener"> 思维</a></p><hr><p> 博客爬取于<code>2019-04-18 17:18:10</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/54668103" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/54668103</a></p><p>题目链接： <a href="http://codeforces.com/contest/382/problem/B" target="_blank" rel="noopener"> http://codeforces.com/contest/382/problem/B</a></p><p>—————————————————————————————————-.<br>B. Number Busters<br>time limit per test1 second<br>memory limit per test256 megabytes<br>inputstandard input<br>outputstandard output<br>Arthur and Alexander are number busters. Today they’ve got a competition.</p><p>Arthur took a group of four integers a, b, w, x (0 ≤ b &lt; w, 0 &lt; x &lt; w) and<br>Alexander took integer с. Arthur and Alexander use distinct approaches to<br>number bustings. Alexander is just a regular guy. Each second, he subtracts<br>one from his number. In other words, he performs the assignment: c = c - 1.<br>Arthur is a sophisticated guy. Each second Arthur performs a complex<br>operation, described as follows: if b ≥ x, perform the assignment b = b - x,<br>if b &lt; x, then perform two consecutive assignments a = a - 1; b = w - (x - b).</p><p>You’ve got numbers a, b, w, x, c. Determine when Alexander gets ahead of<br>Arthur if both guys start performing the operations at the same time. Assume<br>that Alexander got ahead of Arthur if c ≤ a.</p><p>Input<br>The first line contains integers a, b, w, x, c (1 ≤ a ≤ 2·109, 1 ≤ w ≤ 1000, 0<br>≤ b &lt; w, 0 &lt; x &lt; w, 1 ≤ c ≤ 2·109).</p><p>Output<br>Print a single integer — the minimum time in seconds Alexander needs to get<br>ahead of Arthur. You can prove that the described situation always occurs<br>within the problem’s limits.</p><p>Examples<br>input<br>4 2 3 1 6<br>output<br>2<br>input<br>4 2 3 1 7<br>output<br>4<br>input<br>1 2 3 2 6<br>output<br>13<br>input<br>1 1 2 1 1<br>output<br>0</p><p>—————————————————————————————————-.<br>题目大意:<br>就是两个人,一个人有4个数字  a  ,  b  ,  w  ,  x  ,另一个人有1个数字  c  ,每一秒第二个人的数字减一 <code>c--</code><br>，每一秒第一个人的数字变化如下， <code>if(b&gt;=x) b=b-x;else a--,b=w-(x-b);</code> 现在问你最少多长时间之后a&lt;=c?</p><p>解题思路:<br>很明显的二分答案,但是对于 <code>check</code> 部分还是要推敲一下,<br>首先 <code>if(b&gt;=x) b=b-x;else a--,b=w-(x-b);</code><br>可以改变成 <code>if(b&gt;=x) b=b-x;else a--,b=b-x+w;</code><br>显然就是 在b&lt;0的时候将+w,与此同时a–，<br>那么在c减少n的时候a减少的数m就满足 b=b-n<em>x+m</em>w&amp;&amp;b&gt;0,(m取最小值);</p><p>与此同时注意a,c可能小于0,所以二分答案的边界要大一点.</p><p>附本题代码<br>—————————————————————————————————-.</p><pre><code>#include &lt;bits/stdc++.h&gt;using namespace std;#define abs(x)  (((x)&gt;0)?(x):-(x))const int N = 500000+5;typedef long long int LL;/***************************************/LL ta,tb,tw,tx,tc;bool check(LL n){    LL a=ta,b=tb,w=tw,x=tx,c=tc;    c-=n;    b-=x*n;    LL num = abs(b/w);    b+=num*w;    if(b&gt;=0);    else num++;    a-=num;    if(c&lt;=a) return true;    else return false;}int main(){    ios::sync_with_stdio(false);    cin&gt;&gt;ta&gt;&gt;tb&gt;&gt;tw&gt;&gt;tx&gt;&gt;tc;    LL l=0,r=2e14,mid,ans;    while(l&lt;=r){        mid=(l+r)&gt;&gt;1;        if(check(mid)) ans=mid,r=mid-1;        else l=mid+1;    }    cout&lt;&lt;ans &lt;&lt;endl;    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
            <tag> 思维 </tag>
            
            <tag> codeforces </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  HDU 6012 Lotus and Horticulture [离散化+前缀和处理]【思维】</title>
      <link href="/2017/01/22/54667131/"/>
      <url>/2017/01/22/54667131/</url>
      
        <content type="html"><![CDATA[<h1 id="HDU-6012-Lotus-and-Horticulture-离散化-前缀和处理-【思维】"><a href="#HDU-6012-Lotus-and-Horticulture-离散化-前缀和处理-【思维】" class="headerlink" title="HDU 6012 Lotus and Horticulture [离散化+前缀和处理]【思维】"></a>HDU 6012 Lotus and Horticulture [离散化+前缀和处理]【思维】</h1><p>2017年01月22日 10:51:55  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：306</p><hr><p> 博客爬取于<code>2019-04-18 17:18:12</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/54667131" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/54667131</a></p><p>题目连接： <a href="http://acm.hdu.edu.cn/showproblem.php?pid=6012" target="_blank" rel="noopener"> http://acm.hdu.edu.cn/showproblem.php?pid=6012</a><br>—————————————————————————————-.<br>Lotus and Horticulture Accepts: 91 Submissions: 641<br>Time Limit: 4000/2000 MS (Java/Others) Memory Limit: 262144/262144 K<br>(Java/Others)<br>问题描述<br>这几天Lotus对培养盆栽很感兴趣，于是她想搭建一个温室来满足她的研究欲望。<br>Lotus将所有的nn株盆栽都放在新建的温室里，所以所有盆栽都处于完全相同的环境中。<br>每一株盆栽都有一个最佳生长温度区间  [  l  ,  r  ]<br>，在这个范围的温度下生长会生长得最好，但是不一定会提供最佳的研究价值（Lotus认为研究发育不良的盆栽也是很有研究价值的）。<br>Lotus进行了若干次试验，发现若第  i  株盆栽的生长温度适宜，可以提供  a  i  的研究价值；若生长温度超过了适宜温度的上限，能提供  b  i<br>​的研究价值；若生长温度低于适宜温度的下限，则能提供  c  i  ​  ​​的研究价值。<br>现在通过试验，Lotus已经得知了每一株盆栽的适宜生长温度范围，也知道了它们的a、b、c的值。你需要根据这些信息，给温室选定一个温度（这个温度可以是任意实数<br>），使得Lotus能获得的研究价值最大。<br>输入描述<br>多组数据，第一行一个整数T表示数据组数<br>每组数据第一行一个整数  n  ∈  [  1  ,  50000  ]  ，表示盆栽数量<br>接下来  n  行每行五个整数  l  i  ,  r  i  ,  a  i  ,  b  i  ,  c  i  ∈  [  1  ,  10  9<br>]  .，意义如上所述<br>输出描述<br>每组数据输出一行一个整数表示答案<br>输入样例<br>1<br>5<br>5 8 16 20 12<br>10 16 3 13 13<br>8 11 13 1 11<br>7 9 6 17 5<br>2 11 20 8 5<br>输出样例<br>83<br>—————————————————————————————–.<br><strong> 解题思路: </strong></p><p>最开始的想法是离散化+线段树，后来想到用树状数组就行了，通过离散化后，将区间进行覆盖，至于小数的时间很好处理，只要将维护的区间值均*2操作就行了，比如说<br>[  8  ,  9  ]  那么维护的时候就维护  [  8  ∗  2  ,  9  ∗  2  ]  =  [  16  ,  18  ]<br>这样的话就能空出来一个  8  ∗  2  +  1  =  17  ,这样维护就行了.但是最后居然 <strong> 超时 </strong> 了…..加了读优还是没有过。。。</p><p>然后按照题解的做法写了一发,</p><p>官方题解</p><blockquote><p>首先考虑应该尝试选择哪些点：区间的左右端点、与区间左右端点距离0.5的点，这样就一定可以包括所有情况。<br>为了方便处理与区间左右端点距离0.5的点，只要将所有坐标扩大一倍，然后这些点就变成了“与区间左右端点距离1的点”了 考虑选出这些点后如何进行统计。显然先要将<br>可以选的位置进行离散。假如我们选择的温度一开始是负无穷，这时答案是所有的c之和，考虑选择的温度不断升高，答案会如何变化。<br>每当选定的温度达到一个区间xx的左端点时，答案加上  a  x  −  c  x  ，每当选定温度超过xx的右端点时，答案会加上  b  x  −  a<br>x  。 维护一个数组v，初始全为0。我们在xx的左端点处加上  a  x  −  c  x  在xx的右端点处加上  b  x  −  a  x<br>，然后某个位置的前缀和就是选择这个位置作为最终温度的答案了。</p></blockquote><p><del> 据说这个东西叫做扫描线？！！（我计算几何白学了hhh），学习一波。。。 </del><br>其实就是个前缀和处理，然后从左到右扫描而已。</p><p>但是写出来还是超时了，当时我离散化的方式的map，于是看了别人写的二分，写了一发二分，这样才过了这道题。。最后 <strong> 1912ms </strong> AC。。。。</p><p><strong> 附本题代码 </strong><br>—————————————————————————————–.</p><pre><code>#include &lt;bits/stdc++.h&gt;using namespace std;#define INF        (~(1&lt;&lt;31))#define INFLL      (~(1ll&lt;&lt;63))#define pb         push_back#define mp         make_pair#define abs(a)     ((a)&gt;0?(a):-(a))#define lalal      puts(&quot;*******&quot;);#define s1(x)      scanf(&quot;%d&quot;,&amp;x)#define Rep(a,b,c) for(int a=(b);a&lt;=(c);a++)#define Per(a,b,c) for(int a=(b);a&gt;=(c);a--)#define no         puts(&quot;NO&quot;)typedef long long int LL ;typedef unsigned long long int uLL ;const int    N   = 50000+7;const int    MOD = 1e9+7;const double eps = 1e-6;const double PI  = acos(-1.0);inline int read(){    int x=0,f=1;char ch=getchar();    while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;){if(ch==&#39;-&#39;)f=-1;ch=getchar();}    while(ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;){x=x*10+ch-&#39;0&#39;;ch=getchar();}    return x*f;}void fre(){    freopen(&quot;in.txt&quot;,&quot;r&quot;,stdin);    freopen(&quot;out.txt&quot;,&quot;w&quot;,stdout);}/***********************************************************************/struct input{    int l,r,a,b,c;}a[N];int lr[N&lt;&lt;1],cnt;LL rr[N&lt;&lt;1],ll[N&lt;&lt;1];int h(int x){    int l=0,r=cnt,mid,ans;    while(l&lt;=r){        mid=(l+r)&gt;&gt;1;        if(lr[mid]&lt;=x)ans=mid,l=mid+1;        else r=mid-1;    }    return ans;}int main(){    int _;    s1(_);    while(_--){        int n;        s1(n);        cnt = 0;        Rep(i,1,n) {            a[i].l=read();            a[i].r=read();            a[i].a=read();            a[i].b=read();            a[i].c=read();            lr[++cnt]=a[i].l;            lr[++cnt]=a[i].r;        }        sort(lr+1,lr+n*2+1);        cnt = unique(lr+1,lr+n*2+1)-(lr+1);        //Rep(i,1,cnt){printf(&quot;%d\n&quot;,lr[i]);}        Rep(i,0,cnt)  rr[i]=ll[i]=0ll;        LL ans = 0ll,mx = 0ll;        Rep(i,1,n){            ans+=a[i].c;            rr[h(a[i].l)]+=a[i].a-a[i].c;            ll[h(a[i].r)]+=a[i].b-a[i].a;        }        mx=ans;        Rep(i,1,cnt){            ans+=rr[i];            mx=max(mx,ans);            ans+=ll[i];            mx=max(mx,ans);        }        printf(&quot;%I64d\n&quot;,mx);    }    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  HDU 5923 Prediction [可持久化并查集]【数据结构】</title>
      <link href="/2017/01/21/54646369/"/>
      <url>/2017/01/21/54646369/</url>
      
        <content type="html"><![CDATA[<h1 id="HDU-5923-Prediction-可持久化并查集-【数据结构】"><a href="#HDU-5923-Prediction-可持久化并查集-【数据结构】" class="headerlink" title="HDU 5923 Prediction [可持久化并查集]【数据结构】"></a>HDU 5923 Prediction [可持久化并查集]【数据结构】</h1><p>2017年01月21日 16:26:30  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：857</p><hr><p> 博客爬取于<code>2019-04-18 17:18:13</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/54646369" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/54646369</a></p><p>题目连接： <a href="http://acm.hdu.edu.cn/showproblem.php?pid=5923" target="_blank" rel="noopener"> http://acm.hdu.edu.cn/showproblem.php?pid=5923</a><br>——————————————————————————-.<br>Prediction</p><p>Time Limit: 5000/2500 MS (Java/Others) Memory Limit: 65536/65536 K<br>(Java/Others)<br>Total Submission(s): 693 Accepted Submission(s): 167</p><p>Problem Description<br>There is a graph G=⟨VG,EG⟩ with |VG|=n and |EG|=m, and a magic tree T=⟨VT,ET⟩)<br>rooted at 1, which contains m vertices.</p><p>Each vertex of the magic tree corresponds to an edge in the original graph G<br>and each edge occurs in the magic tree exactly once.</p><p>Each query includes a set S(S⊆VT), and you should tell Mr. Frog the number of<br>components in the modified graph G‘=(VG,E‘G), where E‘G is a set of edges in<br>which every edge corresponds to a vertex v in magic tree T satisfying at least<br>one of the following two conditions：</p><p>∙v∈S.<br>∙v is an ancestor of some vertices in S.</p><p>Note that the queries are independent, and namely one query will not influence<br>another.</p><p>Input<br>The input contains several test cases and the first line of the input data is<br>an integer T, denoting the number of test cases.</p><p>For each test case, the first line contains two integers n and<br>m(1≤n≤500,1≤m≤10000), where n is the number of vertices and m is the number of<br>edges.</p><p>The second line contains m - 1 integers describing the magic tree, i-th<br>integer represents the parent of the (i + 1)-th vertex.</p><p>Then the following m lines describe the edges of the graph G. Each line<br>contains two integers u and v indicating the two ends of the edge.</p><p>The next line contains only one integer q(1≤q≤50000), indicating the number of<br>queries.</p><p>Then the following q lines represent queries, i-th line represents the i-th<br>query, which contains an integer ki followed by ki integers representing the<br>set Si.</p><p>It is guarenteed that  ∑  q  i  =  1  k  i  ≤  300000.</p><p>Output<br>For each case, print a line “Case #x:”, where x is the case number (starting<br>from 1).</p><p>For each query, output a single line containing only one integer representing<br>the answer, namely the number of components.</p><p>Sample Input<br>1<br>5 4<br>1 1 3<br>1 2<br>2 3<br>3 4<br>4 5<br>3<br>1 2<br>2 2 3<br>2 2 4</p><p>Sample Output<br>Case #1:<br>3<br>2<br>1</p><p>Hint</p><p>magic tree and the original graph in the sample are:<br><img src="http://acm.hdu.edu.cn/data/images/C729-1002-1.jpg" alt></p><p>In the first query, S = {2} and the modified graph G’ = 1, 2, 3, 4}, {(1,<br>2), (2, 3), thus the number of the components in the modified graph is 3.<br>In the second query, S = {1, 2, 3}, where 1 is the ancestor of 2 (and 3) in<br>the magic tree, and the modified graph G” = 1, 2, 3,4}, {(1, 2), (2, 3), (3,<br>4),<br>therefore the number of the components in the modified graph is 2.<br>In the third query, S = {1, 2, 3, 4}, where 1 is the ancestor of 2 (and 4), 3<br>is the ancestor of 4, and the modified graph G’ = 1, 2, 3,4}, {(1, 2), (2,<br>3), (3,4), (4, 5),<br>therefore the answer equals to 1.<br>——————————————————————————-.</p><p><strong> 题目大意： </strong><br>就是有一个n个节点，m条边的图和一个m-1个节点的树（根结点是1）。<br>树的每个节点对应图的一个边，<br>每次在树中选中一些节点的集合，就将图中对应集合中所有元素与所有的父节点的边连接起来，问你现在图中有多少个联通块。</p><p><strong> 解题思路： </strong><br>对于每一个节点的父节点我们都可以用并查集来处理，这样就能知道在选边的时候都选哪些边了，但是对于直接处理之后我们不能很好的将父节点和子节点相区分开，所以对于每<br>个点的情况，分别做一个并查集，这样的话就能区分父节点和子节点了。</p><p>之后在对图进行并查集的操作，来统计有几个联通块就行了。</p><p>在处理并查集的时候，对于子节点来说，是满度父节点的集合关系的，所以只要把之前的并查集规则复制一遍，在新处理一下当前节点的就行了。处理过程就是dfs一次树，同<br>时处理并查集 复杂度是  O  (  N  ∗  M  )</p><p>这种算是访问历史版本的并查集应该也算是可持久化并查集了</p><p>在每次查询的时候,我们对每个点均处理依次,也只是将跟节点的在一个集合的点放到一个集合.复杂度是  O  (  ∑  q  i  =  1  k  i  ∗<br>N  )</p><p>总复杂度就是  O  (  N  ∗  M  +  ∑  q  i  =  1  k  i  ∗  N  )</p><p>附本题代码<br>——————————————————————————-.</p><pre><code>#include &lt;bits/stdc++.h&gt;using namespace std;#define INF        (~(1&lt;&lt;31))#define INFLL      (~(1ll&lt;&lt;63))#define pb         push_back#define mp         make_pair#define abs(a)     ((a)&gt;0?(a):-(a))#define lalal      puts(&quot;*******&quot;);#define s1(x)      scanf(&quot;%d&quot;,&amp;x)#define Rep(a,b,c) for(int a=(b);a&lt;=(c);a++)#define Per(a,b,c) for(int a=(b);a&gt;=(c);a--)#define no         puts(&quot;NO&quot;)typedef long long int LL ;typedef unsigned long long int uLL ;const int    N   = 100000+7;const int    MOD = 1e9+7;const double eps = 1e-6;const double PI  = acos(-1.0);inline int read(){    int x=0,f=1;char ch=getchar();    while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;){if(ch==&#39;-&#39;)f=-1;ch=getchar();}    while(ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;){x=x*10+ch-&#39;0&#39;;ch=getchar();}    return x*f;}void fre(){    freopen(&quot;in.txt&quot;,&quot;r&quot;,stdin);    freopen(&quot;out.txt&quot;,&quot;w&quot;,stdout);}</code></pre><p>​<br>​    /<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>***</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong>/<br>​    vector<int>T[10005];//树<br>​    //vector&lt;pair<int ,int> &gt;G;<br>​    int G[10005][2];//图<br>​    int pre[10005][505];//并查集<br>​    int vis[505];//结果<br>​    int n,m;<br>​<br>​    int findi(int x,int y){<br>​        int r=x;<br>​        while(pre[y][r]!=r) r=pre[y][r];<br>​        int i=x,j;<br>​        while(i!=j){<br>​            j=pre[y][i];<br>​            pre[y][i]=r;<br>​            i=j;<br>​        }<br>​        return r;<br>​    }<br>​<br>​    void join(int x,int y,int xy){<br>​        int fx=findi(x,xy),fy=findi(y,xy);<br>​        if(fx!=fy) pre[xy][fx]=fy;<br>​    }<br>​<br>​    void dfs(int x,int fa){<br>​        for(int i=1;i&lt;=n;i++) pre[x][i]=pre[fa][i];<br>​        join(G[x][0],G[x][1],x);<br>​        int len = T[x].size();<br>​        for(int i=0;i&lt;len;i++) dfs(T[x][i],x);<br>​    }<br>​<br>​    int main(){<br>​        int _ = 1,kcase;<br>​        while(~scanf(“%d”,&amp;<em>)){<br>​            kcase = 0;<br>​            while(</em>–){<br>​<br>​                int x,u,v;<br>​                scanf(“%d%d”,&amp;n,&amp;m);<br>​                for(int i=0;i&lt;=n;i++)pre[0][i]=i;<br>​                for(int i=1;i&lt;=m;i++)T[i].clear();<br>​                for(int i=2;i&lt;=m;i++){<br>​                    scanf(“%d”,&amp;x);<br>​                    T[x].pb(i);<br>​                }<br>​    </int></int></p><pre class=" language-cpp"><code class="language-cpp">            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>m<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d%d"</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>u<span class="token punctuation">,</span><span class="token operator">&amp;</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span>                G<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">=</span>u<span class="token punctuation">,</span>G<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">=</span>v<span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">//G.pb(mp(v,u));</span>            <span class="token punctuation">}</span>            <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//puts("------");</span>            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Case #%d:\n"</span><span class="token punctuation">,</span><span class="token operator">++</span>kcase<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> q<span class="token punctuation">,</span>k<span class="token punctuation">;</span>            <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>q<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">while</span><span class="token punctuation">(</span>q<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span> pre<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>i<span class="token punctuation">,</span>vis<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>                <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>k<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>k<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                    <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>j<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                        <span class="token keyword">int</span> ty<span class="token operator">=</span><span class="token function">findi</span><span class="token punctuation">(</span>j<span class="token punctuation">,</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token keyword">if</span><span class="token punctuation">(</span>ty<span class="token operator">!=</span>j<span class="token punctuation">)</span> <span class="token function">join</span><span class="token punctuation">(</span>j<span class="token punctuation">,</span>ty<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>                <span class="token keyword">int</span> ans<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>                <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">//计算联通块</span>                    <span class="token keyword">int</span> tem<span class="token operator">=</span><span class="token function">findi</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>vis<span class="token punctuation">[</span>tem<span class="token punctuation">]</span><span class="token punctuation">)</span> ans<span class="token operator">++</span><span class="token punctuation">;</span>                    vis<span class="token punctuation">[</span>tem<span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span>ans<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  HDU 5269 ZYB loves Xor I [01字典树]【思维】</title>
      <link href="/2017/01/21/54645157/"/>
      <url>/2017/01/21/54645157/</url>
      
        <content type="html"><![CDATA[<h1 id="HDU-5269-ZYB-loves-Xor-I-01字典树-【思维】"><a href="#HDU-5269-ZYB-loves-Xor-I-01字典树-【思维】" class="headerlink" title="HDU 5269 ZYB loves Xor I [01字典树]【思维】"></a>HDU 5269 ZYB loves Xor I [01字典树]【思维】</h1><p>2017年01月21日 11:15:08  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：227</p><p>个人分类：  <a href="https://blog.csdn.net/qq_33184171/article/category/6117382" target="_blank" rel="noopener"> hdu </a> <a href="https://blog.csdn.net/qq_33184171/article/category/6132246" target="_blank" rel="noopener"><br>bestcoder </a> <a href="https://blog.csdn.net/qq_33184171/article/category/6253262" target="_blank" rel="noopener"> 思维</a></p><hr><p> 博客爬取于<code>2019-04-18 17:18:14</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/54645157" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/54645157</a></p><p>题目连接： <a href="http://acm.hdu.edu.cn/showproblem.php?pid=5269" target="_blank" rel="noopener"> http://acm.hdu.edu.cn/showproblem.php?pid=5269</a><br>—————————————————————————————-.<br>ZYB loves Xor I Accepts: 142 Submissions: 696<br>Time Limit: 2000/1000 MS (Java/Others) Memory Limit: 65536/65536 K<br>(Java/Others)<br><strong> 问题描述 </strong><br>ZYB喜欢研究Xor，现在他得到了一个长度为nn的数组A。于是他想知道：对于所有数对  (  i  ,  j  )  (  i  ∈  [  1  ,  n<br>]  ,  j  ∈  [  1  ,  n  ]  )  ，  l  o  w  b  i  t  (  A  i  x  o  r  A  j  )<br>l  o  w  b  i  t  (  A  ​  i  ​  ​  x  o  r  A  ​  j  )<br>之和为多少.由于答案可能过大，你需要输出答案对998244353取模后的值<br>定义  l  o  w  b  i  t  (  x  )  =  2  ​  k<br>​​ ，其中k是最小的满足  (  x  a  n  d  2  k  )  &gt; 0  的数<br>特别地：lowbit(0)=0</p><p><strong> 输入描述 </strong><br>一共  (  T  ≤  10  )  组数据，对于每组数据：<br>第一行一个正整数n，表示数组长度<br>第二行n个非负整数，第  i  个整数为  A  i<br>n  ∈  [  1  ,  5  ∗  10  4  ]  ,  A  i  ∈  [  0  ,  2  29  ]</p><p><strong> 输出描述 </strong><br>每组数据输出一行Case #x: ans。x表示组数编号，从1开始。ans为所求值。</p><p><strong> 输入样例 </strong><br>2<br>5<br>4 0 2 7 0<br>5<br>2 6 5 4 0</p><p><strong> 输出样例 </strong><br>Case #1: 36<br>Case #2: 40<br>—————————————————————————————-.<br>解题思路:</p><p>这道题首先想的是用数组处理二进制每一位的0,1的个数,然后进行统计,在处理一下细节,但是最后发现只有在处理二进制下最后一位为1的数才好统计.于是GG</p><p>最后看了题解,提到了字典树,,,,顿时茅塞顿开,</p><p>我们只要从低位开始插入字典树中,并统计个数,每次统计就是二进制位上和它相反的数的个数*  (  1  &lt; &lt; i  )  ,</p><p>边插入边统计就好了.</p><p>附本题代码<br>—————————————————————————————-.</p><pre><code>#include &lt;bits/stdc++.h&gt;using namespace std;#define INF        (~(1&lt;&lt;31))#define INFLL      (~(1ll&lt;&lt;63))#define pb         push_back#define mp         make_pair#define abs(a)     ((a)&gt;0?(a):-(a))#define lalal      puts(&quot;*******&quot;);#define s1(x)      scanf(&quot;%d&quot;,&amp;x)#define Rep(a,b,c) for(int a=(b);a&lt;=(c);a++)#define Per(a,b,c) for(int a=(b);a&gt;=(c);a--)#define no         puts(&quot;NO&quot;)typedef long long int LL ;typedef unsigned long long int uLL ;const int    MOD = 998244353;const int    N   = 1500000+5;const double eps = 1e-6;const double PI  = acos(-1.0);/***********************************************************************/int trie[N][2],val[N],cnt;void trieinsert(int x){    int now = 0;    for(int i=0;i&lt;30;x&gt;&gt;=1,++i){        if(!trie[now][x%2]) trie[now][x%2]=++cnt;        now = trie[now][x%2];        val[now]++;    }}LL query(int x){    int now = 0;    LL ans =0ll;    for(int i=0;i&lt;30;x&gt;&gt;=1,++i){        if(!trie[now][x%2]) trie[now][x%2]=++cnt;        ans += (2ll&lt;&lt;i)*val[trie[now][1-x%2]];        ans%=MOD;        now = trie[now][x%2];        val[now]++;    }    return ans ;}int main(){    int _ = 1,kcase ;    while(~scanf(&quot;%d&quot;,&amp;_)){        kcase = 0;        while(_--){            int n;            scanf(&quot;%d&quot;,&amp;n);            cnt = 0;            LL x;            LL ans = 0ll;            for(int i=0;i&lt;n;i++){                scanf(&quot;%I64d&quot;,&amp;x);                ans+=query(x);                ans%=MOD;                //printf(&quot;%I64d\n&quot;,ans);                //trieinsert(x);            }            for(int i=0;i&lt;=cnt;i++){                trie[i][0]=trie[i][1]=val[i]=0;            }            printf(&quot;Case #%d: %I64d\n&quot;,++kcase,ans);        }    }    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hdu </tag>
            
            <tag> bestcoder </tag>
            
            <tag> 思维 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  HDU 4417 Super Mario [树状数组+离线操作]【数据结构】</title>
      <link href="/2017/01/18/54602437/"/>
      <url>/2017/01/18/54602437/</url>
      
        <content type="html"><![CDATA[<h1 id="HDU-4417-Super-Mario-树状数组-离线操作-【数据结构】"><a href="#HDU-4417-Super-Mario-树状数组-离线操作-【数据结构】" class="headerlink" title="HDU 4417 Super Mario [树状数组+离线操作]【数据结构】"></a>HDU 4417 Super Mario [树状数组+离线操作]【数据结构】</h1><p>2017年01月18日 16:28:55  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：181</p><hr><p> 博客爬取于<code>2019-04-18 17:18:15</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/54602437" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/54602437</a></p><p>题目连接： <a href="http://acm.hdu.edu.cn/showproblem.php?pid=4417" target="_blank" rel="noopener"> http://acm.hdu.edu.cn/showproblem.php?pid=4417</a><br>——————————————————————————.<br>Super Mario</p><p>Time Limit: 2000/1000 MS (Java/Others) Memory Limit: 32768/32768 K<br>(Java/Others)<br>Total Submission(s): 6059 Accepted Submission(s): 2635</p><p>Problem Description<br>Mario is world-famous plumber. His “burly” figure and amazing jumping ability<br>reminded in our memory. Now the poor princess is in trouble again and Mario<br>needs to save his lover. We regard the road to the boss’s castle as a line<br>(the length is n), on every integer point i there is a brick on height hi. Now<br>the question is how many bricks in [L, R] Mario can hit if the maximal height<br>he can jump is H.</p><p>Input<br>The first line follows an integer T, the number of test data.<br>For each test data:<br>The first line contains two integers n, m (1 &lt;= n &lt;=10^5, 1 &lt;= m &lt;= 10^5), n<br>is the length of the road, m is the number of queries.<br>Next line contains n integers, the height of each brick, the range is [0,<br>1000000000].<br>Next m lines, each line contains three integers L, R,H.( 0 &lt;= L &lt;= R &lt; n 0 &lt;=<br>H &lt;= 1000000000.)</p><p>Output<br>For each case, output “Case X: ” (X is the case number starting from 1)<br>followed by m lines, each line contains an integer. The ith integer is the<br>number of bricks Mario can hit for the ith query.</p><p>Sample Input<br>1<br>10 10<br>0 5 2 7 5 4 3 8 7 7<br>2 8 6<br>3 5 0<br>1 3 1<br>1 9 4<br>0 1 0<br>3 5 5<br>5 5 1<br>4 6 3<br>1 5 7<br>5 7 3</p><p>Sample Output<br>Case 1:<br>4<br>0<br>0<br>3<br>1<br>2<br>0<br>1<br>5<br>1</p><p>Source<br>2012 ACM/ICPC Asia Regional Hangzhou Online<br>——————————————————————————.<br><strong> 题目大意： </strong><br>就是给你长度为N个序列，每个序列由一个高度为  h  i  的木棍,现在有M个询问,问你在[L,R]区间内小于等于H的木棍有多少, <strong> 即 </strong> |  A<br>|  ,  A  =  {  a  i  |  a  i  &lt; =  h  ,  L  &lt; =  i  &lt; =  R  }  。</p><p><strong> 解题思路： </strong></p><p>如果题目中没有要求  &lt; =  h  ,那么可以直接求[L,R]区间内的数就行了，</p><p>很明显，直接 <strong> 在线 </strong> 的话并不能在良好复杂度内解决问题（后来发现是有的只不过我不会。。）， <strong> 离线 </strong> 的话考虑还是很容易的。</p><p>首先题目既然要求比 <strong> h </strong> 小的，那么我们可以对  h  i  从小到大排序,每次都将比查询的 <strong> h </strong><br>小的放入数据结构中,然后在[L,R]查询到的一定满足  h  i  &lt; h  .这个时候我们同样将查询操作，按照 <strong> h </strong><br>操作从大到小排序，每次查询的时候我们都将满足  h  i  &lt; h  的放入数据结构中，这样的话不算查询的复杂度一共是  O  (  N  +  M  )<br>,通过数据结构的优化，查询操作的复杂度就是  O  (  l  o  g  2  N  )  的。综复杂度就是  O  (  N  +  M  ∗  l<br>o  g  2  N  )  ,</p><p>这种查询区间的操作用[树状数组/线段树]都能很好完成,树状数组的话实现相对容易,所以我采用了树状数组.<br>因为每次查询的时候,计算的数都是  &lt; h  的,所以我们不用考虑他的大小,只要在其对应的位置下 <strong> +1 </strong><br>就行了,这样每次查询的时候就是查询其查询区间内有几个1即可,  g  e  t  S  u  m  (  r  )  −  g  e  t  S  u  m<br>(  l  −  1  )  ;  最后用一个数组来记录结果就行了.</p><p>最后的最后!!!!<br>“Case X:”!!!!!!!!!!!<br>它的这里居然没有 <strong> _ “#” _ </strong> 号,我cacacaca,找了800年的bug…….</p><p><strong> 附本题代码 </strong><br>——————————————————————————.</p><pre><code>#include &lt;bits/stdc++.h&gt;using namespace std;const int    N   = 100000+7;/***********************************************************************/struct node1{    int a,id;}aa[N];struct node2{    int l,r,h,id;}bb[N];bool cmp1(node1 A,node1 B){    return A.a&lt;B.a;}bool cmp2(node2 A,node2 B){    return A.h&lt;B.h;}#define lowbit(x) (x&amp;-x)int tree[N];void update(int ind,int val){    for(int i=ind;i&lt;=N;i+=lowbit(i))        tree[i]+=val;}int getSum(int ind){    int ans = 0;    for(int i=ind;i;i-=lowbit(i)) ans+=tree[i];    return ans;}int ans[N];int main(){    int _,kcase=0;    scanf(&quot;%d&quot;,&amp;_);    while(_--){        memset(tree,0,sizeof(tree));        int n,m;        scanf(&quot;%d%d&quot;,&amp;n,&amp;m);        for(int i=1;i&lt;=n;i++){            scanf(&quot;%d&quot;,&amp;aa[i].a);            aa[i].id=i;        }        int l,r,h;        for(int i=1;i&lt;=m;i++){            scanf(&quot;%d%d%d&quot;,&amp;l,&amp;r,&amp;h);            bb[i].l=l+1,bb[i].r=r+1,bb[i].h=h,bb[i].id=i;        }        sort(aa+1,aa+n+1,cmp1);        sort(bb+1,bb+m+1,cmp2);        for(int i=1,j=1;i&lt;=m;i++){            while(j&lt;=n&amp;&amp;bb[i].h&gt;=aa[j].a) update(aa[j++].id,1);            ans[bb[i].id]=getSum(bb[i].r)-getSum(bb[i].l-1);        }        printf(&quot;Case %d:\n&quot;,++kcase);        for(int i=1;i&lt;=m;i++) printf(&quot;%d\n&quot;,ans[i]);    }    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  HDU 4829 Information [带权并查集]【数据结构】</title>
      <link href="/2017/01/17/54585519/"/>
      <url>/2017/01/17/54585519/</url>
      
        <content type="html"><![CDATA[<h1 id="HDU-4829-Information-带权并查集-【数据结构】"><a href="#HDU-4829-Information-带权并查集-【数据结构】" class="headerlink" title="HDU 4829 Information [带权并查集]【数据结构】"></a>HDU 4829 Information [带权并查集]【数据结构】</h1><p>2017年01月17日 18:09:15  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：190</p><hr><p> 博客爬取于<code>2019-04-18 17:18:16</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/54585519" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/54585519</a></p><p>题目连接： <a href="http://acm.hdu.edu.cn/showproblem.php?pid=4829" target="_blank" rel="noopener"> http://acm.hdu.edu.cn/showproblem.php?pid=4829</a><br>——————————————————————————–.<br>Information</p><p>Time Limit: 6000/3000 MS (Java/Others) Memory Limit: 32768/32768 K<br>(Java/Others)<br>Total Submission(s): 367 Accepted Submission(s): 61</p><p>Problem Description<br>军情紧急，我们需要立刻开发出一个程序去处理前线侦察兵发回的情报，并做出相应的分析。现在由你负责其中的一个子模块，你需要根据情报计算出敌方坦克的位置。<br>当敌方坦克静止时，侦察兵会尽力估算出它们之间的位置，而每当敌方坦克移动时，侦察兵都会记录下坦克新的位置并向你报告。每个坦克的位置可以由一个二维整数坐标来描述<br>。<br>前线发回的情报有四种格式：<br>1 A B X Y<br>表示A坦克移动到了与B坦克的相对位置是(X,Y)的地方，即XA = XB + X, YA=YB+Y。<br>2 A X Y<br>表示A坦克移动到了绝对位置是(X,Y)的地方，即XA = X, YA = Y。<br>3 A B X Y<br>表示发现了A坦克与B坦克的相对位置是(X,Y)，即XA = XB + X, YA=YB+Y。<br>4 A X Y<br>表示发现了A坦克的绝对位置是(X,Y)，即XA = X, YA = Y。<br>我们需要你对于如下两种询问及时做出回应：<br>5 A B<br>表示询问A坦克与B坦克的相对位置是多少，即分别求出XA - XB 以及YA -YB。<br>6 A<br>表示询问A坦克的绝对位置是多少，即求出XA 和YA。<br>其中A和B代表的是任意的一个坦克的编号，(X,Y)表示了坦克的二维坐标。你可以假设初始时刻我们对于敌方任何坦克的位置都一无所知，在此之后坦克的每一次移动都被<br>侦察兵侦察到了。<br>请注意两个坦克的坐标有可能相同。</p><p>Input<br>输入的第一行是一个整数T（T &lt; 1000），表示共有T组数据。<br>对于每组数据，第一行有一个整数N，表示这组数据有N次查询。接下来的每行表示一次查询，每次查询第一个数字代表是哪种询问，询问的格式详见上文。<br>数据范围：<br>0 &lt; N &lt;=100000, 0 &lt; A,B&lt;=N 且 A&lt;&gt;B, X和Y都是整数且 0 &lt;=X,Y&lt;=10000 .<br>测试数据中98%的数据N不超过50。</p><p>Output<br>对于每组数据，首先需要输出单独一行”Case #?:”，其中问号处应填入当前的数据组数，组数从1开始计算。<br>对于每一个类型(1)或者(2)的询问，请把它们加入到你的记录中。<br>对于每一个类型(3)或者(4)的询问，如果与之前记录的内容有矛盾，请输出”REJECT”并将这个情报忽略掉，如没有矛盾，请把它们加入到你的记录中。<br>对于每一个类型(5)或者(6)的询问，如果根据之前的记录能推出结论，请输出两个整数X和Y，两个整数之间有一个空格；如果不能推出结论，请输出”UNKNOWN”<br>。输出的所有信息都不包括引号。</p><p>Sample Input<br>2<br>7<br>1 1 2 3 4<br>2 3 4 5<br>3 4 5 2 1<br>4 6 2 2<br>3 2 4 6 2<br>5 4 1<br>6 3<br>6<br>6 3<br>4 3 2 2<br>6 3<br>2 4 2 3<br>5 3 4<br>3 3 4 1 2</p><p>Sample Output<br>Case #1:<br>-9 -6<br>4 5<br>Case #2:<br>UNKNOWN<br>2 2<br>0 -1<br>REJECT</p><p>Source<br>2014年百度之星程序设计大赛 - 初赛（第一轮）</p><p>——————————————————————————–.</p><p>解题思路：</p><p>就是维护一堆数据之间的关系，读完题很容易想到带权并查集，权值为两个点之间的相对距离.但是在维护上不是怎么好维护啊。</p><p>不好维护的地方<br>1坦克移动到(x，y)时,那么之前的位置变化产生的相对关系就错了,但是并查集是不可逆向操作的.<br>2.我们仅表示的相对位置关系,但是对于绝对位置的坐标求解如何考虑.<br>3,一个点的相对位置比如a相对b的位置是[x,y],但是a,b的位置还不知道的情况下,我们怎么处理这个值.</p><p>解决;<br>1,放弃这个点a,在创建一个新的点p来表示a,映射a-&gt;p进行运算即可.<br>2,我们可以多创建一个点来表示原点(是其他所有点的父节点),那么任何一个点的绝对位置都是与原地的相对位置.<br>3,假设存在这样的情况,我们可以假设b的坐标是一个随意的值(0,0)就行.</p><p>解决了上述几个问题,这道题就不难解决了.</p><p>附本题代码<br>—————————————————————.</p><pre><code>#include &lt;bits/stdc++.h&gt;using namespace std;const int    N   = 100000*2+7;/***********************************************************************/int pre[N],h[N],hh;struct node {    int x,y;}p[N];int findi(int x){    if(pre[x]==x) return x;    int r = findi(pre[x]);    p[x].x+=p[pre[x]].x;    p[x].y+=p[pre[x]].y;    pre[x]=r;    return r;}void join(int x,int y,int X,int Y){    int fx = findi(x),fy = findi(y);    pre[fx]=fy;    p[fx].x=p[y].x+X-p[x].x;    p[fx].y=p[y].y+Y-p[x].y;    return ;}void creat(int now){    h[now]=++hh;    pre[hh]=hh;    p[hh].x=0;    p[hh].y=0;}int main(){    int _,n,m,kcase = 0;    scanf(&quot;%d&quot;,&amp;_);    while(_--){        int n;        scanf(&quot;%d&quot;,&amp;n);printf(&quot;Case #%d:\n&quot;,++kcase);        hh=-1;        for(int i=0;i&lt;=n;i++) creat(i),h[i]=i;        for(int i=n+1;i&lt;=(n&lt;&lt;1);i++) p[i].x=p[i].y=0;        int x,y,a,b,op;        for(int i=1;i&lt;=n;i++){            scanf(&quot;%d&quot;,&amp;op);b=0;            if(op==1||op==2){                if(op==1)scanf(&quot;%d%d%d%d&quot;,&amp;a,&amp;b,&amp;x,&amp;y);                else     scanf(&quot;%d%d%d&quot;,&amp;a,&amp;x,&amp;y);                creat(a);                join(h[a],h[b],x,y);            }            else if(op==3||op==4){                if(op==3)scanf(&quot;%d%d%d%d&quot;,&amp;a,&amp;b,&amp;x,&amp;y);                else     scanf(&quot;%d%d%d&quot;,&amp;a,&amp;x,&amp;y);                a=h[a],b=h[b];                if(findi(a)==findi(b)){if(x!=p[a].x-p[b].x||y!=p[a].y-p[b].y)puts(&quot;REJECT&quot;);}                else join(a,b,x,y);            }            else {                if(op==5)scanf(&quot;%d%d&quot;,&amp;a,&amp;b);                else     scanf(&quot;%d&quot;,&amp;a);                a=h[a],b=h[b];                if(findi(a)!=findi(b)) {puts(&quot;UNKNOWN&quot;);continue; }                else printf(&quot;%d %d\n&quot;,p[a].x-p[b].x,p[a].y-p[b].y);            }        }    }    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  双调欧几里得旅行商问题 hdu 2224 |hdu 4824 [动态规划]</title>
      <link href="/2017/01/16/54574086/"/>
      <url>/2017/01/16/54574086/</url>
      
        <content type="html"><![CDATA[<h1 id="双调欧几里得旅行商问题-hdu-2224-hdu-4824-动态规划"><a href="#双调欧几里得旅行商问题-hdu-2224-hdu-4824-动态规划" class="headerlink" title="双调欧几里得旅行商问题 hdu 2224 |hdu 4824 [动态规划]"></a>双调欧几里得旅行商问题 hdu 2224 |hdu 4824 [动态规划]</h1><p>2017年01月16日 14:50:23  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：349</p><hr><p> 博客爬取于<code>2019-04-18 17:18:18</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/54574086" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/54574086</a></p><p><a href="http://www.mamicode.com/info-detail-523965.html" target="_blank" rel="noopener"> 转自这里!!!!!!!!!! </a><br><strong> 欧几里得旅行商问题 </strong> 是对平面上给定的n个点确定一条连接各点的最短闭合旅程的问题。图a给出了7个点问题的解，这个问题的一般形式是NP完全的,故其解需要多于多项式的时间。 </p><p>J.K.Bentley建议通过只考虑双调旅程来简化问题，这种旅程即为从最左点开始，严格从左到最右点，再严格地从最右点回到最左点。图b显示了同样的7个点的问题<br>的最短双调路线，在这种情况下，多项式的时间的算法是有可能的。</p><p>描述一个确定最优双调路线的O（n^2）时间的算法。可以假设任何两点的x坐标都不相同。</p><p>解法：</p><p>读了很多遍这个题，也看了网上好几篇关于这个问题的博客，有很多一部分是错误的却没有更正，于是自己实践整理了一份这个问题的解法。首先最大的疑惑在于理解什么叫做双<br>调（Bitonic），读了很多解释的词条大概了解了双调的用处，我所理解的双调在这道题之中的思路就是将整个闭合的路线一个点展开，因为题中要求的是从左端向右端扫<br>描，再从右端扫描回来。那么不妨将最左端的点作为出发点开始进行计算（从右端完全一致，不再赘述）。</p><p>我们需要一个辅助的矩阵a[iLen+1][iLen+1]，和所有动态规划问题一样矩阵的大小都是问题的规模+1，整个的计算过程是从左端到右端，也就是我们计算的<br>最短路经从左端向右端生长的过程，辅助矩阵a[i][j]指的是p[i]到p[1]和p[1]到p[i-1]“共通”的最短路径，计算过程只利用矩阵的下三角部分，所<br>以使前一个索引小与后一个索引。首先，将iLen个点存储到一个结构体/类数组之中，用来存放所有的点的坐标，记作数组p，p1,p2之间的距离记作dist（p1,<br>p2）。</p><p>核心思想：</p><p>1）（前提）当我们计算第i个点或者将它并入最短路径的时候，前1.2.3…i-1个点已经形成了一条最短路径。</p><p>2）若要计算a[i][j]，新加入的点p[j]的选择分支有三种，也就是路线规划“生长”情况有且只有三种：</p><p>（一）当j-1〉i时，根据第（1）条我们需要做的就是在辅助矩阵中已经形成的子最短路径加上新增的边（按定义必然是先添加在更长的那半部分路线）</p><p>就有 a[i][j]=a[i][j-1]+dist(j-1,j);</p><p>（二）当j-1=i时，就是一次总结前面的子最短路径生成更长的新子最短路径的时候。</p><p>表示为 a[i][j]=min{(a[k][j-1]+dist(k,j)) , (a[k-1][j-1])+dist(k-1,j)….}////k为遍历值</p><p>（三）当j=i 时，将整个图形封闭起来需要最后的两条边，实质上是（二）过程的一个分支</p><p>即 a[i][j]=min{(a[k][j-1]+dist(k,j)+dist(j-1.j))…..}/////////k为遍历值</p><pre><code>#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#define MAX_VALUE 99999class Point{public:    Point(double px=0,double py=0)        :x(px),y(py){}////////Constructor &amp; Default to be Zero    double x;    double y;};double dist(Point p1,Point p2){    return sqrt((p2.x-p1.x)*(p2.x-p1.x)+(p2.y-p1.y)*(p2.y-p1.y));}int main(){    const int iLen=7;    Point p[iLen+1];//// Pointer List    p[1]=Point(0,6);    p[2]=Point(1,0);    p[3]=Point(2,3);    p[4]=Point(5,4);    p[5]=Point(6,1);    p[6]=Point(7,5);    p[7]=Point(8,2);    //////////////To minimize the time of Debugging  We get parameters initialize    double a[iLen+1][iLen+1]={}; ////null-filled    for(int j=3;j&lt;=iLen;j++){        for(int i=1;i&lt;=j-2;i++){            a[i][j]=a[i][j-1]+dist(p[j-1],p[j]);        }        a[j-1][j]=MAX_VALUE;        for(int i=1;i&lt;=j-2;i++){            a[j-1][j]=(a[i][j-1]+dist(p[i],p[j]))&lt;a[j-1][j]?(a[i][j-1]+dist(p[i],p[j])):a[j-1][j];        }    }    double dMin=MAX_VALUE;    for(int i=2;i&lt;=iLen-1;i++){        double tmp=a[i][iLen]+dist(p[i],p[iLen])+dist(p[iLen-1],p[iLen]);        if(tmp&lt;dMin)dMin=tmp;    }    ///////////dMin records the answer    std::cout&lt;&lt;dMin&lt;&lt;std::endl;    return 0;}</code></pre><p>例题<br><a href="http://acm.hdu.edu.cn/showproblem.php?pid=2224" target="_blank" rel="noopener"> hdu 2224 </a></p><pre><code>#include &lt;bits/stdc++.h&gt;using namespace std;#define abs(a)     ((a)&gt;0?(a):-(a))const int    N   = 1000+7;/***********************************************************************/double dp[N][N];  //dp[i][j]为i点到1点，再从1点到j点的最短距离,double d[N][N];   //d[i][j] 为 i-&gt;j的距离struct point{    double x, y;}a[N];double dis(int i, int j){    return(sqrt((a[i].x-a[j].x)*(a[i].x-a[j].x)+(a[i].y-a[j].y)*(a[i].y-a[j].y)));}int main(){    int _,n;    //scanf(&quot;%d&quot;,&amp;_);    while(~scanf(&quot;%d&quot;, &amp;n)){        for(int i = 1; i &lt;= n; i++) scanf(&quot;%lf %lf&quot;, &amp;a[i].x, &amp;a[i].y);        for(int i = 1; i &lt;= n; i++)            for(int j = 1; j &lt;= n; j++)                d[i][j] = dis(i, j);        dp[1][2] = d[1][2];        for(int i = 3; i &lt;= n; i++){            for(int j = 1; j &lt; i-1; j++)                 dp[j][i] = dp[j][i-1] + d[i-1][i];            dp[i-1][i] = 999999999.0;            for(int j = 1; j &lt; i-1; j++){                double sum = dp[j][i-1] + d[j][i];                if(dp[i-1][i] &gt; sum)  dp[i-1][i] = sum;            }        }        dp[n][n] = dp[n-1][n] + d[n-1][n];        printf(&quot;%.2lf\n&quot;, dp[n][n]);    }    return 0;}</code></pre><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=4824" target="_blank" rel="noopener"> hdu 4824 </a></p><pre><code>#include &lt;bits/stdc++.h&gt;using namespace std;#define abs(a)     ((a)&gt;0?(a):-(a))const int    N   = 1000+7;/***********************************************************************/int dp[N][N];  //dp[i][j]为i点到1点，再从1点到j点的最短距离,int d[N][N];   //d[i][j] 为 i-&gt;j的距离struct point{    int x, y;}a[N];int dis(int i, int j){    int p,q;    if(a[i].y&gt;a[j].y)   q=(360+a[j].y-a[i].y)%360;    else          q=(360+a[i].y-a[j].y)%360;    p=abs(a[i].y-a[j].y)&gt;q?q:abs(a[i].y-a[j].y);    return (abs(a[i].x-a[j].x)*400+p);}int main(){    int _,n;    scanf(&quot;%d&quot;,&amp;_);    while(_--){        scanf(&quot;%d&quot;, &amp;n);        a[1].x=0,a[1].y=0;        for(int i = 2; i &lt;= n+1; i++) scanf(&quot;%d %d&quot;, &amp;a[i].x, &amp;a[i].y);        for(int i = 1; i &lt;= n+1; i++)            for(int j = 1; j &lt;= n+1; j++)                d[i][j] = dis(i, j);        dp[1][2] = d[1][2];        for(int i = 3; i &lt;= n+1; i++){            for(int j = 1; j &lt; i-1; j++)                 dp[j][i] = dp[j][i-1] + d[i-1][i];            dp[i-1][i] = 999999999;            for(int j = 1; j &lt; i-1; j++){                int sum = dp[j][i-1] + d[j][i];                if(dp[i-1][i] &gt; sum)  dp[i-1][i] = sum;            }        }        dp[n+1][n+1] = dp[n][n+1] + d[n][n+1];        printf(&quot;%d\n&quot;, dp[n+1][n+1]+10*n);    }    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  HDU 2158 最短区间版大家来找碴 [思维]【杂类】</title>
      <link href="/2017/01/15/54565617/"/>
      <url>/2017/01/15/54565617/</url>
      
        <content type="html"><![CDATA[<h1 id="HDU-2158-最短区间版大家来找碴-思维-【杂类】"><a href="#HDU-2158-最短区间版大家来找碴-思维-【杂类】" class="headerlink" title="HDU 2158 最短区间版大家来找碴 [思维]【杂类】"></a>HDU 2158 最短区间版大家来找碴 [思维]【杂类】</h1><p>2017年01月15日 23:22:04  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：352</p><hr><p> 博客爬取于<code>2019-04-18 17:18:19</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/54565617" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/54565617</a></p><p>题目连接： <a href="http://acm.hdu.edu.cn/showproblem.php?pid=2158" target="_blank" rel="noopener"> http://acm.hdu.edu.cn/showproblem.php?pid=2158</a><br>——————————————————————————–.<br>最短区间版大家来找碴</p><p>Time Limit: 5000/2000 MS (Java/Others) Memory Limit: 32768/32768 K<br>(Java/Others)<br>Total Submission(s): 1173 Accepted Submission(s): 442</p><p>Problem Description<br>给定一个序列，有N个整数，数值范围为[0,N)。<br>有M个询问，每次询问给定Q个整数，可能出现重复值。<br>要求找出一个最短区间，该区间要包含这Q个整数数值。<br>你能找的出来吗？</p><p>Input<br>第一行有两个整数N，M。(N&lt;100000,<br>M&lt;1000)接着一行有N个整数。再有M个询问，每个询问的第一行有一个整数Q(Q&lt;100)，第二行跟着Q个整数。当N,M同时为0时，输入结束。</p><p>Output<br>请输出最短区间的长度。保证有解。</p><p>Sample Input<br>5 2<br>1 2 2 3 1<br>3<br>1 2 3<br>3<br>1 1 3<br>0 0</p><p>Sample Output<br>3<br>2</p><p>Hint</p><p>第二个查询，找到的区间是[4,5]</p><p>Author<br>Wiskey</p><p>Source<br>2008信息工程学院集训队——选拔赛<br>———————————————————————————.</p><p>开始想暴力尺取法但是这样的话的话复杂度就变成了O(N*M) 1e8 不可取..</p><p>然后想来想去,也想不到有什么复杂度上更优的算法,<br>最后百度了一发题解,</p><p>思路 其实没什么难的,就是在细节上做了改善,使运算量减少了一点罢了,</p><p>基本就是先确定一个大概的范围,然后在枚举维护两个区间的界限而已.(心累…)</p><p><a href="http://blog.csdn.net/xingyeyongheng/article/details/9787505" target="_blank" rel="noopener"> 抄了个代码就交了 </a></p><p>附本题代码<br>———————————————————-。</p><pre><code>#include &lt;bits/stdc++.h&gt;using namespace std;const int    N   = 1e5+7;/***********************************************************************/int a[N],num[N],qq[111],pos[N],mark[N];int main(){    int n,m;    while(~scanf(&quot;%d%d&quot;,&amp;n,&amp;m)&amp;&amp;(n||m)){        for(int i=0;i&lt;n;i++) pos[i]=-1,mark[i]=0;        for(int i=0;i&lt;n;i++){            scanf(&quot;%d&quot;,&amp;a[i]);            if(pos[a[i]]==-1) pos[a[i]]=i;        }        int sum,mi,s,q,tem,x;        for(int t=1;t&lt;=m;t++){            sum = s = 0;            int l = n,r=-1;            scanf(&quot;%d&quot;,&amp;q);            for(int i=0;i&lt;q;i++){                scanf(&quot;%d&quot;,&amp;x);                num[x]=0;                mark[x]=t;                if(pos[x]&gt;r)r=pos[x];                if(pos[x]&lt;l)l=pos[x];            }            for(int i=l;i&lt;=r;++i)++num[a[i]];            mi = r-l+1,tem = r-l+1;            while(r&lt;n){                --num[a[l]];                if(num[a[l]] == 0){                    while(++r&lt;n &amp;&amp; a[r] != a[l])++num[a[r]];//维护r时区间[l,r]包含m个数                    num[a[r]]=1;                }                while(++l&lt;=r &amp;&amp; mark[a[l]] != t);//l每次都到下一个输入过的点                if(r&lt;n &amp;&amp; mi&gt;r-l+1)mi=r-l+1;            }            printf(&quot;%d\n&quot;,mi);        }    }    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  hdu 5997 rausen loves cakes [启发式合并+树状数组/线段数]【杂类+数据结构】</title>
      <link href="/2017/01/15/54564954/"/>
      <url>/2017/01/15/54564954/</url>
      
        <content type="html"><![CDATA[<h1 id="hdu-5997-rausen-loves-cakes-启发式合并-树状数组-线段数-【杂类-数据结构】"><a href="#hdu-5997-rausen-loves-cakes-启发式合并-树状数组-线段数-【杂类-数据结构】" class="headerlink" title="hdu 5997 rausen loves cakes [启发式合并+树状数组/线段数]【杂类+数据结构】"></a>hdu 5997 rausen loves cakes [启发式合并+树状数组/线段数]【杂类+数据结构】</h1><p>2017年01月15日 21:48:17  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：238</p><hr><p> 博客爬取于<code>2019-04-18 17:18:20</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/54564954" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/54564954</a></p><p>题目连接： <a href="http://acm.split.hdu.edu.cn/showproblem.php?pid=5997" target="_blank" rel="noopener"> http://acm.split.hdu.edu.cn/showproblem.php?pid=5997</a><br>—————————————————————-.<br>rausen loves cakes</p><p>Time Limit: 2000/1000 MS (Java/Others) Memory Limit: 65536/65536 K<br>(Java/Others)<br>问题描述<br>rausen喜欢吃蛋糕。某天，他买了nn个蛋糕，每个蛋糕都有一个颜色，用\left[1,1000000<br>\right][1,1000000]中的整数来表示。rausen将它们从左到右排成一行，然后准备开始吃。</p><p>在吃之前，rausen想对蛋糕进行qq个操作。</p><p>某些时刻，rausen会把所有颜色为xx的蛋糕替换成颜色为yy的蛋糕。</p><p>另一些时刻，rausen会计算一段区间\left[x,y \right][x,y]内颜色的段数，所谓一段颜色，就是指极长的只有一种颜色的区间。例如1 4 4<br>1 1即为3段颜色。</p><p>然而，rausen发现，他并不会统计区间内的颜色段数，无助的rausen伤心地哭了起来（误）。而你为了安慰他，决定帮他解决这个问题。<br>输入描述<br>输入包含多组数据。第一行有一个整数TT，表示测试数据的组数，对于每组数据：</p><p>第一行输入2个整数nn，qq分别表示蛋糕的数目和操作的数目。</p><p>接下来一行nn个正整数，第ii个正整数{a}_{i}a<br>​i<br>​​ 表示第ii个蛋糕的颜色。</p><p>接下来qq行，每行3个整数op\left(1\leq op\leq 2 \right)op(1≤op≤2)，xx，yy，描述一个操作<br>对于op=1op=1，表示rausen进行替换操作，将颜色为xx的蛋糕替换成颜色为yy的蛋糕，xx、yy满足\left(1\leq x,y\leq<br>1000000 \right)(1≤x,y≤1000000)，请注意xx可能等于yy。</p><p>对于op=2op=2，表示rausen进行计数操作，此时你需要输出区间\left[x,y<br>\right][x,y]内颜色的段数，xx、yy满足\left(1\leq x\leq y\leq n \right)(1≤x≤y≤n)</p><p>\left(1\leq T\leq 5 \right)(1≤T≤5)，\left(1\leq n\leq {10}^{5} \right)(1≤n≤10<br>​5<br>​​ )，\left(1\leq q\leq {10}^{5} \right)(1≤q≤10<br>​5<br>​​ )<br>输出描述<br>对于每组测试数据的每一个计数操作，单独输出一行表示答案。<br>输入样例<br>1<br>5 3<br>1 4 4 10 1<br>2 1 5<br>1 4 10<br>2 3 5<br>输出样例<br>4<br>2<br>—————————————————————-.</p><p>藏了好久终于补了这个，虽然还是感觉有点乱乱的。。。。</p><p>首先考虑暴力的把一种颜色替换成另一种颜色,那么这一部分就是  O  (  n  )<br>那么考虑将每一种颜色所在的位置记录下来,这样的话就能降到  O  (  颜  色  x  的  个  数  )<br>,虽然看着没什么提升,但其实已经提升很大了,<br>但是考虑  颜  色  x  −  &gt; 颜  色  y  如果NUM(x) = n-1,NUM(y)=1,那么直接将x替换为y实在是太浪费了，于是可以将y替<br>换成x，这样的话，运算量将大大减少。而且只需要用一个数组映射就能够实现。（这就是启发式合并了。。。）</p><p>用树状数组来维护拐点（  a  i  !  =  a  i  +  1  那么  a  i  就是一个拐点）<br>那么来统计区间内的颜色段数就是求区间内的拐点个数+左端点是不是拐点。。<br>维护这个就是简单的树状数组的操作了,不再赘述,其实用线段是也可以维护的,但是线段树的代码量…</p><p>代码中有详细点的注释,可以看看..</p><p>附本题代码<br>————————————————————。</p><pre><code>#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long int LL ;/***********************************************************************/const int N = 1000000 + 5;            //数列的大小int ft[N];   //ft[a]=b 是a这个颜色最后一次出现的位置是bint nt[N];   //nt[a]=b 是a这个位置的颜色上一次出现过的地方是b(因为修改 所以可能是乱序的,但是最终都是连在一起的)int u[N];    //ft[],nt[] 维护的是一种颜色链之间的关系,所以我们需要一个u[]来表示在最初的位置int cnt,n,q; //略int f[N];    //f[a]=b ,颜色号为a的颜色 现在代表颜色bint g[N];    //记录这个颜色即时的个数int a[N];    //输入的数组值int sum[N];  //树状数组#define lowbit(x)  (x&amp;(-x))         //lowbit操作void update(int index,int val){     //单点更新  （+val）    for(int i=index;i&lt;=N;i+=lowbit(i))     sum[i]+=val;}int getSum(int index) {             //求解1~index的和    int ans = 0;    for (int i = index; i; i -= lowbit(i)) ans += sum[i];    return ans;}/**用树状数组来维护拐点（a_{i} !=  a_{i+1} 那么a_i就是一个拐点）那么来统计区间内的颜色段数就是求区间内的拐点个数+左端点是不是拐点。。采取启发式合并的方式来减少计算。*/int main(){    int _ = 1;    while(~scanf(&quot;%d&quot;,&amp;_)){        while(_--){            scanf(&quot;%d %d&quot;,&amp;n,&amp;q);            memset(ft,-1,sizeof(ft));            memset(f,0,sizeof(f));            memset(g,0,sizeof(g));            memset(sum,0,sizeof(sum));            cnt=0;a[0]=a[n+1]=-1;            for(int i=1;i&lt;=n;i++){                scanf(&quot;%d&quot;,&amp;a[i]);                f[a[i]]=a[i];g[a[i]]++;u[++cnt]=i;nt[cnt]=ft[a[i]];ft[a[i]]=cnt;                //printf(&quot;i=%d cnt=%d u[%d]=%d nt[%d]=%2d ft[%2d]=%d \n&quot;,i,cnt-1,cnt-1,u[cnt-1],cnt-1,nt[cnt-1],a[i],ft[a[i]]);                if(a[i]!=a[i-1]) update(i,1);            }            int op,x,y;            while(q--){                scanf(&quot;%d%d%d&quot;,&amp;op,&amp;x,&amp;y);                if(1==op){                    if(x==y||!g[f[x]]) continue;                    int s=x,t=y;                    if(g[f[x]]&gt;g[f[y]]) swap(y,x);//将颜色少的改成颜色多的。  这就是启发式合并。。                    x=f[x],y=f[y];                    //printf(&quot;x=%d y=%d\n&quot;,x,y);                    for(int j=ft[x];j!=-1;j=nt[j]){//然后一个一个判断增减。。。。                        if (a[u[j]] != a[u[j] - 1]) update(u[j], -1);                        if (a[u[j]] != a[u[j] + 1]) update(u[j] + 1, -1);                        a[u[j]] = y;                        if (a[u[j]] != a[u[j] - 1]) update(u[j], 1);                        if (a[u[j]] != a[u[j] + 1]) update(u[j] + 1, 1);                        if (nt[j] == -1)  {                            nt[j] = ft[y]; ft[y] = ft[x]; break;  //将两段颜色的链连接起来.                        }                    }                    g[y] += g[x]; g[x] = 0; f[t] = y; f[s] = 0; //这是颜色改变后的x，y的属性，（个数，代表的颜色）。                }                if(2==op)  printf(&quot;%d\n&quot;,getSum(y)-getSum(x-1)+(int)(a[x]==a[x-1]));            }        }    }    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  HDU 4825 Xor Sum [trie]【思维&amp;字符串】</title>
      <link href="/2017/01/15/54562544/"/>
      <url>/2017/01/15/54562544/</url>
      
        <content type="html"><![CDATA[<h1 id="HDU-4825-Xor-Sum-trie-【思维-amp-字符串】"><a href="#HDU-4825-Xor-Sum-trie-【思维-amp-字符串】" class="headerlink" title="HDU 4825 Xor Sum [trie]【思维&amp;字符串】"></a>HDU 4825 Xor Sum [trie]【思维&amp;字符串】</h1><p>2017年01月15日 16:02:25  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：133</p><p>个人分类：  <a href="https://blog.csdn.net/qq_33184171/article/category/6253262" target="_blank" rel="noopener"> 思维 </a> <a href="https://blog.csdn.net/qq_33184171/article/category/6362436" target="_blank" rel="noopener"><br>==== 字符串 ==== </a> <a href="https://blog.csdn.net/qq_33184171/article/category/6121214" target="_blank" rel="noopener"><br>位运算 </a></p><hr><p> 博客爬取于<code>2019-04-18 17:18:21</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/54562544" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/54562544</a></p><p>题目连接： <a href="http://acm.hdu.edu.cn/showproblem.php?pid=4825" target="_blank" rel="noopener"> http://acm.hdu.edu.cn/showproblem.php?pid=4825</a><br>————————————————————————————.<br>Xor Sum</p><p>Time Limit: 2000/1000 MS (Java/Others) Memory Limit: 132768/132768 K<br>(Java/Others)<br>Total Submission(s): 1803 Accepted Submission(s): 773</p><p>Problem Description<br>Zeus 和 Prometheus 做了一个游戏，Prometheus 给 Zeus 一个集合，集合中包含了N个正整数，随后 Prometheus 将向<br>Zeus 发起M次询问，每次询问中包含一个正整数 S ，之后 Zeus 需要在集合当中找出一个正整数 K ，使得 K 与 S<br>的异或结果最大。Prometheus 为了让 Zeus 看到人类的伟大，随即同意 Zeus 可以向人类求助。你能证明人类的智慧么？</p><p>Input<br>输入包含若干组测试数据，每组测试数据包含若干行。<br>输入的第一行是一个整数T（T &lt; 10），表示共有T组数据。<br>每组数据的第一行输入两个正整数N，M（&lt;1=N,M&lt;=100000），接下来一行，包含N个正整数，代表 Zeus<br>的获得的集合，之后M行，每行一个正整数S，代表 Prometheus 询问的正整数。所有正整数均不超过2^32。</p><p>Output<br>对于每组数据，首先需要输出单独一行”Case #?:”，其中问号处应填入当前的数据组数，组数从1开始计算。<br>对于每个询问，输出一个正整数K，使得K与S异或值最大。</p><p>Sample Input<br>2<br>3 2<br>3 4 5<br>1<br>5<br>4 1<br>4 6 5 6<br>3</p><p>Sample Output<br>Case #1:<br>4<br>3<br>Case #2:<br>4</p><p>Source<br>2014年百度之星程序设计大赛 - 资格赛</p><p>————————————————————————————-.</p><p>解题思路：<br>就是用trie树来解决。<br>为了方便寻找最大的数，那么我们按照从高位到低位的顺序将每一个数字的二进制数依次插入到trie树中，</p><p>这样在查询的时候，我们只要按顺序，从高到低依次找就好了，否则我们从低到高实在不好判断这个数是不是最大的。</p><p>查询的时候因为有个异或操作，所以尽可能找的数的每一位与待查找的数是取反关系的，没有这样的数的时候在找相同的。这样下来最终的结果一定是最大的。</p><p>注意题目最后说数不会超过  2  32  ,但是可能等于,所以不能用int,</p><p>附本题代码<br>————————————————————.</p><pre><code>#include &lt;bits/stdc++.h&gt;using namespace std;int trie[3200010][2],kt;void inserttrie(LL x){    int now = 0,bt;    for(int i=31;i&gt;=0;--i){        bt = x&amp;(1ll&lt;&lt;i)?1:0;        if(!trie[now][bt]) trie[now][bt] = ++kt;        now = trie[now][bt];        //val[now] = x;    }}LL findtrie(LL x){    int now = 0,bt;    LL tem = x,ans = 0;    for(int i=31;i&gt;=0;--i){        bt = x&amp;(1ll&lt;&lt;i)?0:1;        if(!trie[now][bt]) bt=1-bt;        now =trie[now][bt];        ans&lt;&lt;=1,ans|=bt;    }    return ans;}int main(){    int _ = 1,kcase;    while(~scanf(&quot;%d&quot;,&amp;_)){        kcase = 0;        while(_--){            kt = 0;            //memset(val,0,sizeof(val));            memset(trie,0,sizeof(trie));            int n,m;            LL tem;            scanf(&quot;%d%d&quot;,&amp;n,&amp;m);            while(n--)  scanf(&quot;%lld&quot;,&amp;tem),inserttrie(tem);            printf(&quot;Case #%d:\n&quot;,++kcase);            while(m--){                scanf(&quot;%lld&quot;,&amp;tem);                printf(&quot;%lld\n&quot;,findtrie(tem));            }        }    }    return false;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 思维 </tag>
            
            <tag> 字符串 </tag>
            
            <tag> 位运算 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  hdu 4609 3-idiots [FFT计数]【数学】</title>
      <link href="/2017/01/14/54427994/"/>
      <url>/2017/01/14/54427994/</url>
      
        <content type="html"><![CDATA[<h1 id="hdu-4609-3-idiots-FFT计数-【数学】"><a href="#hdu-4609-3-idiots-FFT计数-【数学】" class="headerlink" title="hdu 4609 3-idiots [FFT计数]【数学】"></a>hdu 4609 3-idiots [FFT计数]【数学】</h1><p>2017年01月14日 18:08:40  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：385<br>标签：  <a href="https://so.csdn.net/so/search/s.do?q=fft&amp;t=blog" target="_blank" rel="noopener"> fft </a> <a href="https://so.csdn.net/so/search/s.do?q=数学&amp;t=blog" target="_blank" rel="noopener"> 数学</a></p><p>个人分类：  <a href="https://blog.csdn.net/qq_33184171/article/category/6162724" target="_blank" rel="noopener"> 数学 </a> <a href="https://blog.csdn.net/qq_33184171/article/category/6117382" target="_blank" rel="noopener"><br>hdu </a></p><hr><p> 博客爬取于<code>2019-04-18 17:18:22</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/54427994" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/54427994</a></p><p>题目连接： <a href="http://acm.hdu.edu.cn/showproblem.php?pid=4609" target="_blank" rel="noopener"> http://acm.hdu.edu.cn/showproblem.php?pid=4609</a><br>———————————————————–.<br>3-idiots</p><p>Time Limit: 10000/5000 MS (Java/Others) Memory Limit: 32768/32768 K<br>(Java/Others)<br>Total Submission(s): 4437 Accepted Submission(s): 1561</p><p>Problem Description<br>King OMeGa catched three men who had been streaking in the street. Looking as<br>idiots though, the three men insisted that it was a kind of performance art,<br>and begged the king to free them. Out of hatred to the real idiots, the king<br>wanted to check if they were lying. The three men were sent to the king’s<br>forest, and each of them was asked to pick a branch one after another. If the<br>three branches they bring back can form a triangle, their math ability would<br>save them. Otherwise, they would be sent into jail.<br>However, the three men were exactly idiots, and what they would do is only to<br>pick the branches randomly. Certainly, they couldn’t pick the same branch -<br>but the one with the same length as another is available. Given the lengths of<br>all branches in the forest, determine the probability that they would be<br>saved.</p><p>Input<br>An integer T(T≤100) will exist in the first line of input, indicating the<br>number of test cases.<br>Each test case begins with the number of branches N(3≤N≤105).<br>The following line contains N integers a_i (1≤a_i≤105), which denotes the<br>length of each branch, respectively.</p><p>Output<br>Output the probability that their branches can form a triangle, in accuracy of<br>7 decimal places.</p><p>Sample Input<br>2<br>4<br>1 3 3 4<br>4<br>2 3 3 4</p><p>Sample Output<br>0.5000000<br>1.0000000</p><p>Source<br>2013 Multi-University Training Contest 1<br>———————————————————–.<br>题目大意:<br>就是跟你N个数代表长度为  a  i  的木棒,现在问你随便拿出来三个就能构成三角形的概率为多少</p><p>解题思路:<br>首先考虑暴力的<br>就是求  a  i  −  a  j  &lt; k  &lt; a  i  +  a  j<br>满足题意的这样的值有多少个,那么这样的话,我们就需要知道,这N个数两两加的和是什么样的,计算出这个之后,我们在预处理出前缀和之后就可以通过枚举最长边来  O<br>(  n  )  计算三角形的情况数,再除以  C  3  n  =  n  ∗  (  n  −  1  )  ∗  (  n  −  2  )  6<br>就是概率了,</p><p>所以最严重的问题就是如何求这N个数的两两相加.<br>这时候如果把 <strong> 加法 </strong> 换成 <strong> 乘法 </strong> 那么就可以转化为向量相乘，用FFT就可以  o  (  n  l  o  g  2  n  )<br>解决了</p><p>然后我们考虑将加法换成乘法，其实很简单，我们只要将加数代换成幂指数的指数就可以了，<br>a  n  ∗  a  m  =  a  n  +  m</p><p>我们可以用一个hash[a[i]]来记录每个大小的数都有几个<br>那么FFT之后的结果稍加一点简单处理就是两个不同的木棍长度加和wei  [  i  ]  的情况数</p><p>而我们要的就是这个情况数,所以就不需要在继续处理了</p><p>附本题链接<br>———————————————————–.</p><pre><code>#include &lt;bits/stdc++.h&gt;using namespace std;#define INF        (~(1&lt;&lt;31))#define INFLL      (~(1ll&lt;&lt;63))#define pb         push_back#define mp         make_pair#define abs(a)     ((a)&gt;0?(a):-(a))#define lalal      puts(&quot;*******&quot;);#define s1(x)      scanf(&quot;%d&quot;,&amp;x)#define Rep(a,b,c) for(int a=(b);a&lt;=(c);a++)#define Per(a,b,c) for(int a=(b);a&gt;=(c);a--)#define no         puts(&quot;NO&quot;)typedef long long int LL ;typedef unsigned long long int uLL ;const int    MOD = 1e9+7;const int    N   = 264000+5;const double eps = 1e-6;const double PI  = acos(-1.0);inline int read(){    int x=0,f=1;char ch=getchar();    while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;){if(ch==&#39;-&#39;)f=-1;ch=getchar();}    while(ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;){x=x*10+ch-&#39;0&#39;;ch=getchar();}    return x*f;}void fre(){    freopen(&quot;in.txt&quot;,&quot;r&quot;,stdin);    freopen(&quot;out.txt&quot;,&quot;w&quot;,stdout);}/***********************************************************************/struct Complex{    double real, image;    Complex(double _real, double _image){        real = _real;        image = _image;    }    Complex(){}    Complex operator + (const Complex &amp;tmp){        return Complex(real + tmp.real, image + tmp.image);    }    Complex operator - (const Complex &amp;tmp){        return Complex(real - tmp.real, image - tmp.image);    }    Complex operator * (const Complex &amp;tmp){        return Complex(real*tmp.real - image*tmp.image, real*tmp.image + image*tmp.real);    }};int rev(int id, int len){    int ret = 0;    for(int i = 0; (1 &lt;&lt; i) &lt; len; i++){        ret &lt;&lt;= 1;        if(id &amp; (1 &lt;&lt; i)) ret |= 1;    }    return ret;}Complex A[264000];void FFT(Complex *a, int len, int DFT){    for(int i = 0; i &lt; len; i++)        A[rev(i, len)] = a[i];    for(int s = 1; (1 &lt;&lt; s) &lt;= len; s++){        int m = (1 &lt;&lt; s);        Complex wm = Complex(cos(DFT*2*PI/m), sin(DFT*2*PI/m));        for(int k = 0; k &lt; len; k += m){            Complex w = Complex(1, 0);            for(int j = 0; j &lt; (m &gt;&gt; 1); j++){                Complex t = w*A[k + j + (m &gt;&gt; 1)];                Complex u = A[k + j];                A[k + j] = u + t;                A[k + j + (m &gt;&gt; 1)] = u - t;                w = w*wm;            }        }    }    if(DFT == -1) for(int i = 0; i &lt; len; i++) A[i].real /= len, A[i].image /= len;    for(int i = 0; i &lt; len; i++) a[i] = A[i];    return;}int num[100010]，h[200010];Complex a[264000];LL tA[200010]，sum[200010];int main(){    int _, n;    while(~scanf(&quot;%d&quot;, &amp;_))    while(_--)    {        scanf(&quot;%d&quot;, &amp;n);        int mx = 0;        memset(h, 0, sizeof(h));        for(int i = 1; i &lt;= n; i++)        {            scanf(&quot;%d&quot;, &amp;num[i]);            h[num[i]]++;        }        sort(num+1, num + n+1);        mx = num[n];        int len = 1;        while(len &lt;= mx) len &lt;&lt;= 1;  len &lt;&lt;= 1;        for(int i = 0; i &lt; len; i++)  a[i] = Complex((i&lt;=mx)?h[i]:0, 0);        FFT(a, len, 1);        for(int i = 0; i &lt; len; i++)   a[i] = a[i]*a[i];        FFT(a, len, -1);        for(int i = 0; i &lt;= (mx&lt;&lt;1); i++)   tA[i] = (LL)(a[i].real + 0.5);        for(int i=0;i&lt;=n;i++) tA[num[i]&lt;&lt;1]--;        for(int i = 0; i &lt;= (mx&lt;&lt;1); i++)  tA[i] &gt;&gt;=1;        //到现在为止A[i]表示的是去两根不同的branch的长度和为i的组合种数        sum[0] = 0;        for(int i = 1; i &lt;= (mx&lt;&lt;1); i++)  sum[i] = sum[i - 1] + tA[i];        LL ans = 0;        for(int i = 1; i &lt;= n; i++)//以第i根作为边最长的        {            LL tmp = sum[(mx&lt;&lt;1)] - sum[num[i]];//另外两条边长度和要大于branch[i]            tmp -= (LL)(n - i)*(i - 1);//另外两条一条比branch[i]长, 一条不比它长            tmp -= (LL)(n - i)*(n - i - 1) / 2;//两条都比他长            tmp -= n - 1;//另外两条的组合中包括它自己的组合            ans += tmp;        }        printf(&quot;%.7f\n&quot;,ans*6./n/(n - 1)/(n - 2));    }    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hdu </tag>
            
            <tag> 数学 </tag>
            
            <tag> fft </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  HDU 1402 A * B Problem Plus [FFT]【数论】</title>
      <link href="/2017/01/13/54413679/"/>
      <url>/2017/01/13/54413679/</url>
      
        <content type="html"><![CDATA[<h1 id="HDU-1402-A-B-Problem-Plus-FFT-【数论】"><a href="#HDU-1402-A-B-Problem-Plus-FFT-【数论】" class="headerlink" title="HDU 1402 A * B Problem Plus [FFT]【数论】"></a>HDU 1402 A * B Problem Plus [FFT]【数论】</h1><p>2017年01月13日 23:52:02  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：575</p><p>个人分类：  <a href="https://blog.csdn.net/qq_33184171/article/category/6162724" target="_blank" rel="noopener"> 数学 </a> <a href="https://blog.csdn.net/qq_33184171/article/category/6117382" target="_blank" rel="noopener"><br>hdu </a> <a href="https://blog.csdn.net/qq_33184171/article/category/6362367" target="_blank" rel="noopener"> ===== 数论<br>===== </a></p><hr><p> 博客爬取于<code>2019-04-18 17:18:24</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/54413679" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/54413679</a></p><p>题目连接： <a href="http://acm.hdu.edu.cn/showproblem.php?pid=1402" target="_blank" rel="noopener"> http://acm.hdu.edu.cn/showproblem.php?pid=1402</a><br>———————————————————————————.<br>A * B Problem Plus</p><p>Time Limit: 2000/1000 MS (Java/Others) Memory Limit: 65536/32768 K<br>(Java/Others)<br>Total Submission(s): 19099 Accepted Submission(s): 4406</p><p>Problem Description<br>Calculate A * B.</p><p>Input<br>Each line will contain two integers A and B. Process to end of file.</p><p>Note: the length of each integer will not exceed 50000.</p><p>Output<br>For each case, output A * B in one line.</p><p>Sample Input<br>1<br>2<br>1000<br>2</p><p>Sample Output<br>2<br>2000</p><p>Author<br>DOOM III<br>———————————————————————————.</p><p>就是个FFT入门题 。<br>因为题目给的字符串长度达到了  50000  ,如果普通的大数乘法复杂度为  O  (  l  e  n  A  ∗  l  e  n  B  )<br>必定会超时.<br>FFT其实就是一个快速求取卷积的过程.<br>而一个乘法计算其实也就是一个卷积<br>对于个数  a  0  a  1  a  2  a  3  .  .  .  a  n<br>也就是  A  (  x  =  10  )  =  a  0  ∗  x  0  +  a  1  ∗  x  1  +  a  2  ∗  x  2<br>+  a  3  ∗  x  3  +  .  .  .  a  n  ∗  x  n<br>所以这个题就可以用FFT来计算了。。<br>复杂度能降到  O  (  N  l  o  g  2  N  )</p><p>附本题代码<br>—————————————————————-.</p><pre><code>#include &lt;bits/stdc++.h&gt;using namespace std;const int    N   = 50000+5;const double PI  = acos(-1.0);/***********************************************************************/struct Complex{    double real, image;    Complex(double _real, double _image){        real = _real;        image = _image;    }    Complex(){}};Complex *AA = new Complex[N&lt;&lt;2],*BB = new Complex[N&lt;&lt;2];Complex operator + (const Complex &amp;c1, const Complex &amp;c2){    return Complex(c1.real + c2.real, c1.image + c2.image);}Complex operator - (const Complex &amp;c1, const Complex &amp;c2){    return Complex(c1.real - c2.real, c1.image - c2.image);}Complex operator * (const Complex &amp;c1, const Complex &amp;c2){    return Complex(c1.real*c2.real - c1.image*c2.image, c1.real*c2.image + c1.image*c2.real);}int rev(int id, int len){    int ret = 0;    for(int i = 0; (1 &lt;&lt; i) &lt; len; i++){        ret &lt;&lt;= 1;        if(id &amp; (1 &lt;&lt; i)) ret |= 1;    }    return ret;}Complex A[N&lt;&lt;2];void FFT(Complex *a, int len, int DFT){    for(int i = 0; i &lt; len; i++)        A[rev(i, len)] = a[i];    for(int s = 1; (1 &lt;&lt; s) &lt;= len; s++)    {        int m = (1 &lt;&lt; s);        Complex wm = Complex(cos(DFT*2*PI/m), sin(DFT*2*PI/m));        for(int k = 0; k &lt; len; k += m)        {            Complex w = Complex(1, 0);            for(int j = 0; j &lt; (m &gt;&gt; 1); j++)            {                Complex t = w*A[k + j + (m &gt;&gt; 1)];                Complex u = A[k + j];                A[k + j] = u + t;                A[k + j + (m &gt;&gt; 1)] = u - t;                w = w*wm;            }        }    }    if(DFT == -1) for(int i = 0; i &lt; len; i++) A[i].real /= len, A[i].image /= len;    for(int i = 0; i &lt; len; i++) a[i] = A[i];    return;}char a[N],b[N];int ans[N&lt;&lt;2];int main(){    while(~scanf(&quot;%s&quot;,a)){        scanf(&quot;%s&quot;,b);        int la = strlen(a);        int lb = strlen(b);        int sa,sb;        sa=sb=0;        while((1&lt;&lt;sa)&lt;la) sa++;        while((1&lt;&lt;sb)&lt;lb) sb++;        int len = (1&lt;&lt;(max(sa,sb)+1));        for(int i=0;i&lt;len;i++){            AA[i]=Complex(((i&lt;la)?(a[la-i-1]-&#39;0&#39;):0),0);            BB[i]=Complex(((i&lt;lb)?(b[lb-i-1]-&#39;0&#39;):0),0);        }        FFT(AA,len,1);        FFT(BB,len,1);        for(int i=0;i&lt;len;i++)  AA[i]=AA[i]*BB[i],ans[i]=0;        FFT(AA,len,-1);        for(int i=0;i&lt;len  ;i++) ans[i]+=(int)(AA[i].real+0.5);        for(int i=0;i&lt;len-1;i++) ans[i+1]+=ans[i]/10,ans[i]%=10;        bool flag = false;        for(int i=len-1;i&gt;=0;--i){            if(ans[i]) printf(&quot;%d&quot;,ans[i]),flag=true;            else if(flag||0==i) printf(&quot;0&quot;);        }        puts(&quot;&quot;);    }    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hdu </tag>
            
            <tag> 数学 </tag>
            
            <tag> 数论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  LIGHTOJ 1265 - Island of Survival [递推|概率dp]【杂类|动态规划】</title>
      <link href="/2017/01/12/54378682/"/>
      <url>/2017/01/12/54378682/</url>
      
        <content type="html"><![CDATA[<h1 id="LIGHTOJ-1265-Island-of-Survival-递推-概率dp-【杂类-动态规划】"><a href="#LIGHTOJ-1265-Island-of-Survival-递推-概率dp-【杂类-动态规划】" class="headerlink" title="LIGHTOJ 1265 - Island of Survival [递推|概率dp]【杂类|动态规划】"></a>LIGHTOJ 1265 - Island of Survival [递推|概率dp]【杂类|动态规划】</h1><p>2017年01月12日 15:48:15  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：302<br>标签：  <a href="https://so.csdn.net/so/search/s.do?q=动态规划&amp;t=blog" target="_blank" rel="noopener"> 动态规划 </a> <a href="https://so.csdn.net/so/search/s.do?q=lightoj&amp;t=blog" target="_blank" rel="noopener"> lightoj</a></p><p>个人分类：  <a href="https://blog.csdn.net/qq_33184171/article/category/6362438" target="_blank" rel="noopener"> ==== 动态规划 ====</a> <a href="https://blog.csdn.net/qq_33184171/article/category/6362373" target="_blank" rel="noopener"> ===== 杂类 =====</a> <a href="https://blog.csdn.net/qq_33184171/article/category/6162724" target="_blank" rel="noopener"> 数学</a></p><hr><p> 博客爬取于<code>2019-04-18 17:18:26</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/54378682" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/54378682</a></p><p>题目连接： <a href="http://lightoj.com/volume_showproblem.php?problem=1265" target="_blank" rel="noopener"> http://lightoj.com/volume_showproblem.php?problem=1265</a><br>——————————————————————————–.<br>1265 - Island of Survival<br>PDF (English) Statistics Forum<br>Time Limit: 2 second(s) Memory Limit: 32 MB<br>You are in a reality show, and the show is way too real that they threw into<br>an island. Only two kinds of animals are in the island, the tigers and the<br>deer. Though unfortunate but the truth is that, each day exactly two animals<br>meet each other. So, the outcomes are one of the following</p><p>a) If you and a tiger meet, the tiger will surely kill you.<br>b) If a tiger and a deer meet, the tiger will eat the deer.<br>c) If two deer meet, nothing happens.<br>d) If you meet a deer, you may or may not kill the deer (depends on you).<br>e) If two tigers meet, they will fight each other till death. So, both will be<br>killed.</p><p>If in some day you are sure that you will not be killed, you leave the island<br>immediately and thus win the reality show. And you can assume that two animals<br>in each day are chosen uniformly at random from the set of living creatures in<br>the island (including you).</p><p>Now you want to find the expected probability of you winning the game. Since<br>in outcome (d), you can make your own decision, you want to maximize the<br>probability.</p><p>Input<br>Input starts with an integer T (≤ 200), denoting the number of test cases.</p><p>Each case starts with a line containing two integers t (0 ≤ t ≤ 1000) and d (0<br>≤ d ≤ 1000) where t denotes the number of tigers and d denotes the number of<br>deer.</p><p>Output<br>For each case, print the case number and the expected probability. Errors less<br>than 10-6 will be ignored.</p><p>Sample Input</p><p>4<br>0 0<br>1 7<br>2 0<br>0 10</p><p>Output for Sample Input</p><p>Case 1: 1<br>Case 2: 0<br>Case 3: 0.3333333333<br>Case 4: 1</p><p>——————————————————————————–.<br>题目大意：<br>就是一座岛上有 <strong> 1 </strong> 个人 <strong> t </strong> 个老虎 <strong> d </strong> 只鹿，<br>现在每天都会有两只动物相遇，<br>老虎和人， 老虎会吃了人。<br>老虎和鹿，老虎会吃了鹿。<br>老虎和老虎，两只老虎都会死。<br>鹿和人，人可以吃鹿也可以不吃鹿。<br>鹿和鹿，什么也不会发生。</p><p>现在问你，最后人能活下来的概率。</p><p>解题思路：<br>首先还是分析一下，我们可以得到<br>1.鹿的存在对人能不能活下来是没有影响的。——所以考虑d的值没有任何意义<br>2.只有老虎全部死亡，人才能活下来。——又因为老虎只能两两自相残杀，所以只有t为偶数的时候人才有活下来的概率。</p><p>这时候问题其实可以转化为求在人与老虎相遇之前、偶数只老虎自相残杀全部死亡的概率，除此之外的其他相遇组合对结果无影响。</p><p>所以只要求每天人活下来的概率，累乘直到老虎全死了为止。</p><p>对于每一天人活下来的概率 = (两只老虎相遇的情况数)/(人和老虎总共可能相遇的情况数);即<br>t  ∗  (  t  −  1  )  2  t  ∗  (  t  +  1  )  2<br>约分一下<br>(  t  −  1  )  (  t  +  1  )<br>因为我们结果事t为2为止 所以总式子就是<br>(  t  −  1  )  (  t  +  1  )  ∗  (  (  t  −  2  )  −  1  )  (  (  t  −  2  )<br>+  1  )  ∗  .  .  .  ∗  (  2  −  1  )  (  2  +  1  )<br>通过约分最后剩下的式子就变成了<br>1  t  +  1</p><p>这题就做完了</p><p>==================分割线==================<br>之后看了下题解，居然给的概率dp！<br>作为DP废还是学习下，<br>首先确定的是dp[t][d]就是t只老虎d只鹿的概率.<br>首先dp[0][0]=1;<br>算了 直接上菊苣的方法吧</p><pre><code>设dp[t][d]表示还有t只老虎，d只鹿的时候，存活的概率。那么就有dp[0][0]=1根据概率dp的方程当前状态=Σ(转移到某个状态的概率*那个概率存活的概率)那么我们只要按题意去转移就好了。对于人与鹿吃还是不吃的情况，我们直接算出两种转移方式的存活概率，然后取最大值就可以了。对于两头鹿的情况，可以发现这种情况最后会从自己本身转移，我们通过移项，把右边的项移到左边去，那么就可以使得左边的系数减小。对于这种情况我们只需要维护一下左边的系数，最后再把答案除以左边的系数就可以了。那么dp[t][d]就是最后的答案菊苣的概率DP的代码http://paste.ubuntu.net/23738804/</code></pre><p>附本题代码<br>——————————-.</p><pre><code>#include &lt;bits/stdc++.h&gt;using namespace std;#define abs(x) ((x&gt;=0)?(x):-(x))typedef long long int LL;const int MOD = 1e9;const int N = 1000+7;/*******************************************/double dp[N][N];int main(){    int _,kcase = 0,t,d;    scanf(&quot;%d&quot;,&amp;_);    while(_--){        scanf(&quot;%d %d&quot;,&amp;t,&amp;d);        printf(&quot;Case %d: &quot;,++kcase);        if(0==t) puts(&quot;1&quot;);        else if(t%2==1) printf(&quot;0\n&quot;);        else {            double ans = (double)(1+t);            printf(&quot;%.9lf\n&quot;,1.0/ans);        }    }    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
            <tag> lightoj </tag>
            
            <tag> 杂类 </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  codeforces 607B</title>
      <link href="/2017/01/12/54377643/"/>
      <url>/2017/01/12/54377643/</url>
      
        <content type="html"><![CDATA[<h1 id="codeforces-607B-336B-Zuma-区间DP-【动态规划】"><a href="#codeforces-607B-336B-Zuma-区间DP-【动态规划】" class="headerlink" title="codeforces 607B #336B Zuma [区间DP]【动态规划】"></a>codeforces 607B #336B Zuma [区间DP]【动态规划】</h1><p>2017年01月12日 14:25:19  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：473<br>标签：  <a href="https://so.csdn.net/so/search/s.do?q=动态规划&amp;t=blog" target="_blank" rel="noopener"> 动态规划 </a> <a href="https://so.csdn.net/so/search/s.do?q=codeforces&amp;t=blog" target="_blank" rel="noopener"> codeforces</a> <a href="https://so.csdn.net/so/search/s.do?q=dp&amp;t=blog" target="_blank" rel="noopener"> dp</a></p><p>个人分类：  <a href="https://blog.csdn.net/qq_33184171/article/category/6235560" target="_blank" rel="noopener"> codeforces</a> <a href="https://blog.csdn.net/qq_33184171/article/category/6362438" target="_blank" rel="noopener"> ==== 动态规划 ====</a></p><hr><p> 博客爬取于<code>2019-04-18 17:18:27</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/54377643" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/54377643</a></p><p>题目连接: <a href="http://codeforces.com/contest/607/problem/B" target="_blank" rel="noopener"> http://codeforces.com/contest/607/problem/B</a><br>————————————————————————-.<br>B. Zuma<br>time limit per test2 seconds<br>memory limit per test512 megabytes<br>inputstandard input<br>outputstandard output<br>Genos recently installed the game Zuma on his phone. In Zuma there exists a<br>line of n gemstones, the i-th of which has color ci. The goal of the game is<br>to destroy all the gemstones in the line as quickly as possible.</p><p>In one second, Genos is able to choose exactly one continuous substring of<br>colored gemstones that is a palindrome and remove it from the line. After the<br>substring is removed, the remaining gemstones shift to form a solid line<br>again. What is the minimum number of seconds needed to destroy the entire<br>line?</p><p>Let us remind, that the string (or substring) is called palindrome, if it<br>reads same backwards or forward. In our case this means the color of the first<br>gemstone is equal to the color of the last one, the color of the second<br>gemstone is equal to the color of the next to last and so on.</p><p>Input<br>The first line of input contains a single integer n (1 ≤ n ≤ 500) — the number<br>of gemstones.</p><p>The second line contains n space-separated integers, the i-th of which is ci<br>(1 ≤ ci ≤ n) — the color of the i-th gemstone in a line.</p><p>Output<br>Print a single integer — the minimum number of seconds needed to destroy the<br>entire line.</p><p>Examples<br>input<br>3<br>1 2 1<br>output<br>1<br>input<br>3<br>1 2 3<br>output<br>3<br>input<br>7<br>1 4 4 2 3 2 1<br>output<br>2<br>Note<br>In the first sample, Genos can destroy the entire line in one second.</p><p>In the second sample, Genos can only destroy one gemstone at a time, so<br>destroying three gemstones takes three seconds.</p><p>In the third sample, to achieve the optimal time of two seconds, destroy<br>palindrome 4 4 first and then destroy palindrome 1 2 3 2 1.<br>———————————————————————–.<br>题目大意：<br>就是在长度为n的序列中，每次能够消去任意一段回文字串，问最少多少次才能使这个序列全部消去</p><p>解题思路：<br>区间DP<br>dp[i][j] 表示消去区间  [  i  ,  j  ]  的最小次数</p><p>那么首先对于回文的时候也就是<br>a  i  =  =  a  j  的时候 <strong> dp[i][j]=dp[i+1][j-1]; </strong></p><p>对于其他情况我们可以枚举断点，计算区间dp[i][j]的最优解.即:<br><strong> dp[i][j]=min(dp[i][j],dp[i][k]+dp[k+1][j]); </strong></p><p>写的时候用得记忆化搜索的形式,相比for循环会少思考dp的先后关系,能减少一些错误.</p><p>附本题代码<br>——————————————–.</p><pre><code>#include &lt;bits/stdc++.h&gt;using namespace std;#define abs(x) ((x&gt;=0)?(x):-(x))typedef long long int LL;const int MOD = 1e9;const int N = 1e6+7;/*******************************************/int solve(int l,int r){    if(l&gt;=r) return 1;    if(dp[l][r]!=-1) return dp[l][r];    dp[l][r]=1000000;    if(a[l]==a[r]) dp[l][r]=solve(l+1,r-1);    for(int i=l;i&lt;r;i++) dp[l][r]=min(dp[l][r],solve(l,i)+solve(i+1,r));    return dp[l][r];}int main(){    int n;    scanf(&quot;%d&quot;,&amp;n);    for(int i=1;i&lt;=n;i++)scanf(&quot;%d&quot;,&amp;a[i]);    for(int i=0;i&lt;=n+1;++i)for(int j=0;j&lt;=n+1;++j) dp[i][j]=-1;    printf(&quot;%d\n&quot;,solve(1,n));    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
            <tag> dp </tag>
            
            <tag> codeforces </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  51nod 1189 阶乘分数 [因子个数+逆元]【数论】</title>
      <link href="/2017/01/11/54354875/"/>
      <url>/2017/01/11/54354875/</url>
      
        <content type="html"><![CDATA[<h1 id="51nod-1189-阶乘分数-因子个数-逆元-【数论】"><a href="#51nod-1189-阶乘分数-因子个数-逆元-【数论】" class="headerlink" title="51nod 1189 阶乘分数 [因子个数+逆元]【数论】"></a>51nod 1189 阶乘分数 [因子个数+逆元]【数论】</h1><p>2017年01月11日 23:28:45  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：254</p><hr><p> 博客爬取于<code>2019-04-18 17:18:28</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/54354875" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/54354875</a></p><p>题目连接: <a href="https://www.51nod.com/onlineJudge/questionCode.html#!problemId=1189" target="_blank" rel="noopener"> https://www.51nod.com/onlineJudge/questionCode.html#!problemId=1189</a><br>———————————————————————————-.<br>1189 阶乘分数<br>题目来源： Spoj<br>基准时间限制：1 秒 空间限制：131072 KB 分值: 80 难度：5级算法题 收藏 关注<br>1/N! = 1/X + 1/Y（0&lt; x&lt;=y），给出N，求满足条件的整数解的数量。例如：N = 2，1/2 = 1/3 + 1/6，1/2 = 1/4</p><ul><li>1/4。由于数量可能很大，输出Mod 10^9 + 7。<br>Input<br>输入一个数N（1 &lt;= N &lt;= 1000000)。<br>Output<br>输出解的数量Mod 10^9 + 7。<br>Input示例<br>2<br>Output示例<br>2<br>————————————————————————————-.</li></ul><p>解题思路:<br>对于这种题目就是转换下式子<br>由于<br>1  N  !  =  1  X  +  1  Y<br>1  X  =  1  N  !  −  1  Y<br>1  X  =  N  !  −  Y  Y  ∗  N  !<br>Y  ∗  N  !  =  (  N  !  −  X  )  ∗  Y<br>同理可得<br>X  ∗  N  !  =  (  N  !  −  Y  )  ∗  X</p><p>可得<br>X  ∗  N  !  ∗  Y  ∗  N  !  =  (  N  !  −  X  )  ∗  Y  ∗  (  N  !  −  Y  )  ∗<br>X<br>化简为<br>N  !  ∗  N  !  =  (  N  !  −  X  )  ∗  (  N  !  −  Y  )</p><p>这个时候由于N事确定的，那么将  (  N  !  −  X  )  看成一个整体,那么其为  (  N  !  )  2  的因子,  (  N  !<br>−  X  )  有多少个X就有多少个,<br>Y同理.</p><p>这样的话就是求  (  N  !  )  2  的因子个数  ∏  p  r  i  m  e  −  n  u  m  i  =  0  (  1  +<br>a  i  )  了.</p><p>但是由于题目要求,  X  &lt; =  Y  ,所以结果是  [  ∏  p  r  i  m  e  −  n  u  m  i  =  0  (  1<br>+  a  i  )  2  ]  向  上  取  整</p><p>除2很简单,求一下逆元即可</p><h2 id="附本题代码"><a href="#附本题代码" class="headerlink" title="附本题代码"></a>附本题代码</h2><pre><code>#include &lt;bits/stdc++.h&gt;using namespace std;#define abs(x) ((x&gt;=0)?(x):-(x))typedef long long int LL;const int MOD = 1e9+7;const int N = 1e6+7;/*******************************************/int prime[N],kp;int Is_or[N][2];void Prime(){    kp = 0;    memset(Is_or,true,sizeof(Is_or));    Is_or[0][0]=Is_or[1][0]=0;    for(int i=2;i&lt;=1000000;i++){        if(Is_or[i][0]) Is_or[i][1]=kp,prime[kp++]=i;        for(int j=0;j&lt;kp&amp;&amp;prime[j]*i&lt;=1000000;j++){            Is_or[prime[j]*i][0]=0;            if(0==i%prime[j]) break;        }    }    return ;}LL a[80000];LL qmod(LL a,LL b){    LL res= 1ll;    while(b){        if(b&amp;1)res=res*a%MOD;        b&gt;&gt;=1;        a=a*a%MOD;    }    return res;}int main(){    //printf(&quot;%I64d\n&quot;,qmod(2,MOD-2));    Prime();    //printf(&quot;%d\n&quot;,kp);    //for(int i=0;i&lt;kp;i++)printf(&quot;%d\n&quot;,prime[i]);    int n;    scanf(&quot;%d&quot;,&amp;n);    int tem ;    for(int i=1;i&lt;=n;i++){        tem = i;        for(int j=0;j&lt;kp&amp;&amp;tem&gt;=prime[j];j++){            if(Is_or[tem][0]) {a[Is_or[tem][1]]++;break;}            while(0==tem%prime[j]) a[j]++,tem/=prime[j];        }    }    LL ans = 1ll;    for(int i=0;i&lt;kp;i++){        ans*=((a[i]&lt;&lt;1)+1);        ans%=MOD;    }    printf(&quot;%I64d\n&quot;,(ans+1)*500000004%MOD);    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  codeforces 484D Kindergarten 【动态规划】</title>
      <link href="/2017/01/11/54350683/"/>
      <url>/2017/01/11/54350683/</url>
      
        <content type="html"><![CDATA[<h1 id="codeforces-484D-Kindergarten-【动态规划】"><a href="#codeforces-484D-Kindergarten-【动态规划】" class="headerlink" title="codeforces 484D Kindergarten 【动态规划】"></a>codeforces 484D Kindergarten 【动态规划】</h1><p>2017年01月11日 22:32:31  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：239</p><hr><p> 博客爬取于<code>2019-04-18 17:18:29</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/54350683" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/54350683</a></p><p>题目连接： <a href="http://codeforces.com/contest/484/problem/D" target="_blank" rel="noopener"> http://codeforces.com/contest/484/problem/D</a></p><p>—————————————————————————-.<br>D. Kindergarten<br>time limit per test2 seconds<br>memory limit per test256 megabytes<br>inputstandard input<br>outputstandard output<br>In a kindergarten, the children are being divided into groups. The teacher put<br>the children in a line and associated each child with his or her integer<br>charisma value. Each child should go to exactly one group. Each group should<br>be a nonempty segment of consecutive children of a line. A group’s sociability<br>is the maximum difference of charisma of two children in the group (in<br>particular, if the group consists of one child, its sociability equals a<br>zero).</p><p>The teacher wants to divide the children into some number of groups in such<br>way that the total sociability of the groups is maximum. Help him find this<br>value.</p><p>Input<br>The first line contains integer n — the number of children in the line  (  1<br>≤  n  ≤  10  6  )  .</p><p>The second line contains n integers ai — the charisma of the i-th child  (  −<br>10  9  ≤  a  i  ≤  10  9  )  .</p><p>Output<br>Print the maximum possible total sociability of all groups.</p><p>Examples<br>input<br>5<br>1 2 3 1 2<br>output<br>3<br>input<br>3<br>3 3 3<br>output<br>0<br>Note<br>In the first test sample one of the possible variants of an division is<br>following: the first three children form a group with sociability 2, and the<br>two remaining children form a group with sociability 1.</p><p>In the second test sample any division leads to the same result, the<br>sociability will be equal to 0 in each group.</p><p>——————————————————————————–.<br>题目大意:<br>就是给你长度为n的序列,然后让你将其分成任意段,每段的贡献是这段区间的最大值减最小值的差.求最终结果最大为多少.</p><p>解题思路:<br>通过对序列的分析我们能够知道，对于每一个单调的部分段 如果我们将其拆开了的话<br>其对结果的贡献就会变小，比如{1，2，3，4，5}对结果的贡献事4（5-1），如果拆开两段那么结果最多也就只能为3了，所以每一段区间我们都选取单调的。</p><p>然后对于整个数组，其结果事波动的，那么对于每两段区间会有一个相交的值,也就是拐点，我们只要在计算的时候要考虑其在左右区间哪一个对结果的贡献大我们就要怎么分就<br>好了。</p><p>计算的时候采用dp的想法<br>dp[i] 表示以i结尾的结果最大值.<br>我们可以通过遍历找到最接近i的拐点位置,那么计算的时候判断这个拐点是在哪一个区间对结果的贡献大就好了..</p><p>dp[i]=max(dp[pre-1]+abs(a[i]-a[pre]),dp[pre]+abs(a[i]-a[pre+1]));</p><p>我这种dp废 ,不看题解基本都没想过dp,,,还在考虑单调队列,,,,,,,</p><h2 id="附本题代码"><a href="#附本题代码" class="headerlink" title="附本题代码"></a>附本题代码</h2><pre><code>#include &lt;bits/stdc++.h&gt;using namespace std;#define abs(x) ((x&gt;=0)?(x):-(x))typedef long long int LL;const int N = 1e6+7;/*******************************************/LL a[N],dp[N];int main(){    int n;    scanf(&quot;%d&quot;,&amp;n);    dp[0]=0ll;    for(int i=1;i&lt;=n;i++){        scanf(&quot;%I64d&quot;,&amp;a[i]);        dp[i]=0ll;    }    int pre = 1;    for(int i=2;i&lt;=n;i++){        dp[i]=max(dp[pre-1]+abs(a[i]-a[pre]),dp[pre]+abs(a[i]-a[pre+1]));        if(a[i-1]&lt;=a[i] &amp;&amp; a[i]&gt;=a[i+1]) pre=i;        if(a[i-1]&gt;=a[i] &amp;&amp; a[i]&lt;=a[i+1]) pre=i;    }    printf(&quot;%I64d\n&quot;,dp[n]);    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  codeforces 509E Pretty Song [递推]【杂类】</title>
      <link href="/2017/01/11/54336383/"/>
      <url>/2017/01/11/54336383/</url>
      
        <content type="html"><![CDATA[<h1 id="codeforces-509E-Pretty-Song-递推-【杂类】"><a href="#codeforces-509E-Pretty-Song-递推-【杂类】" class="headerlink" title="codeforces 509E Pretty Song [递推]【杂类】"></a>codeforces 509E Pretty Song [递推]【杂类】</h1><p>2017年01月11日 01:41:15  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：250</p><hr><p> 博客爬取于<code>2019-04-18 17:18:30</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/54336383" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/54336383</a></p><p>题目链接: <a href="http://codeforces.com/contest/509/problem/E" target="_blank" rel="noopener"> http://codeforces.com/contest/509/problem/E</a><br>—————————————————————————————–.<br>E. Pretty Song<br>time limit per test1 second<br>memory limit per test256 megabytes<br>inputstandard input<br>outputstandard output<br>When Sasha was studying in the seventh grade, he started listening to music a<br>lot. In order to evaluate which songs he likes more, he introduced the notion<br>of the song’s prettiness. The title of the song is a word consisting of<br>uppercase Latin letters. The prettiness of the song is the prettiness of its<br>title.</p><p>Let’s define the simple prettiness of a word as the ratio of the number of<br>vowels in the word to the number of all letters in the word.</p><p>Let’s define the prettiness of a word as the sum of simple prettiness of all<br>the substrings of the word.</p><p>More formally, let’s define the function vowel(c) which is equal to 1, if c is<br>a vowel, and to 0 otherwise. Let si be the i-th character of string s, and<br>si..j be the substring of word s, staring at the i-th character and ending at<br>the j-th character (sisi + 1… sj, i ≤ j).</p><p>Then the simple prettiness of s is defined by the formula:</p><p><img src="http://codeforces.com/predownloaded/27/14/27145b36c09cc72c5deb69d6a300f48b844b6576.png" alt><br>The prettiness of s equals<br><img src="http://codeforces.com/predownloaded/5c/1a/5c1a465eff7d8862a5715fbc7b5ef2f981542680.png" alt></p><p>Find the prettiness of the given song title.</p><p>We assume that the vowels are I, E, A, O, U, Y.</p><p>Input<br>The input contains a single string s (1 ≤ |s| ≤ 5·105) — the title of the<br>song.</p><p>Output<br>Print the prettiness of the song with the absolute or relative error of at<br>most 10 - 6.</p><p>Examples<br>input<br>IEAIAIO<br>output<br>28.0000000<br>input<br>BYOB<br>output<br>5.8333333<br>input<br>YISVOWEL<br>output<br>17.0500000<br>Note<br>In the first sample all letters are vowels. The simple prettiness of each<br>substring is 1. The word of length 7 has 28 substrings. So, the prettiness of<br>the song equals to 28.</p><p>—————————————————————————————–.<br>题目大意：<br>就是求所有子串中元音字母占比的和</p><p>解题思路：<br>这种题很明显就是贡献求解 。<br>然后对于每一个位置我们考虑如下</p><p>s  0  s  1  s  2  s  3  .  .  .  s  n  −  1<br>我们只要知道每一个元音字符中所有在的子串都有哪些就好了</p><p>对于每一个元音字符我们能够确定在这些区间范围内它贡献1.<br>e  .  g  .  :  _  s  i<br>[  0  ,  i  ]  ,  [  0  ,  i  +  1  ]  .  .  .  [  0  ,  n  −  1  ]  ,<br>[  1  ,  i  ]  ,  [  1  ,  i  +  1  ]  .  .  .  [  1  ,  n  −  1  ]<br>…<br>[  i  ,  i  ]  ,  [  i  ,  i  +  1  ]  .  .  .  [  i  ,  n  −  1  ]</p><p>那么结果就是</p><p>1  i  +  1  i  +  1  +  .  .  .  +  1  n  −  1<br>1  i  −  1  +  1  i  +  1  −  1  +  .  .  .  +  1  n  −  1  −  1<br>…<br>1  1  +  1  2  +  .  .  .  +  1  i</p><p>上面的可能看着不太清晰<br>换成这个看一下就清晰了<br>1  1  +  1  2  +  .  .  .  +  1  l  e  n  −  i  +  1<br>——  1  2  +  1  3  +  .  .  .  +  1  l  e  n  −  i  +  1  +  1<br>—— ——  1  3  +  1  4  +  .  .  .  +  1  l  e  n  −  i  +  1  +  2<br>——————————————<br>—— —— ——  1  i  +  1  i  +  1  +  .  .  .  +  1  l  e  n  .<br>（总感觉上面那里写错了呢，，，，，）</p><p>我们发现这样是很有规律的<br>我们可以把这个想象成<br>∑  n  j  =  1  ∑  j  i  =  1  1  i</p><p>通过预处理<br>我们就能在O(1)的时候计算每个位置的贡献了.<br>就是把上面的平行四边形部分和变成3个左下为直角的三角形部分和的差的形式.</p><p>=========================华丽的分割线==========================<br>AC之后在standing里面看到另一种做法，<br>这种做法其实也是求贡献，只不过是以长度做的贡献，<br>把长度为1 为2 为n 的计算出来再累加起来就是了，<br>（感觉这样的不是怎么好想。。。所以不要脸的贴过来）<br><a href="http://blog.csdn.net/u014679804/article/details/44543833" target="_blank" rel="noopener"> 以下盗用这个博客 </a></p><p>用数组s来存储前缀和。即s[i]表示前i个字符中元音字母个数，这样可以方便统计区间[l,r]元音字母个数。设串总长为L<br>则有：<br>长度为1的子串中元音字母出现的个数之和为：ans[1]=s[L]<br>长度为2：ans[2]=ans[1]+s[L-1]-s[1]<br>长度为3：ans[3]=ans[2]+s[L-2]-s[2]<br>……<br>最后结果即为 ans[1]/1+ans[2]/2+ans[3]/3+……+ans[L]/L</p><p>附本题代码<br>——————————————–.</p><pre><code>//方法一#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 500000+5;typedef long long int LL;/***************************************/double a[N];bool check(char ch){    return (ch==&#39;I&#39;||ch==&#39;E&#39;||ch==&#39;A&#39;||ch==&#39;O&#39;||ch==&#39;U&#39;||ch==&#39;Y&#39;);}int main(){    string str;    cin&gt;&gt;str;    int len = str.length();    double ans =  0.0,sum = 0.0;    a[0]=0.0;    for(int i=1;i&lt;=len;i++){        sum+=1.0/i;        a[i]=a[i-1]+sum;    }    for(int i=0;i&lt;len;i++){        if(check(str[i])){            ans+=a[len]-a[len-i-1]-a[i];        }    }    printf(&quot;%.9lf\n&quot;,ans);    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  SPOJ IITWPC4F - Gopu and the Grid Problem [线段树]【数据结构】</title>
      <link href="/2017/01/11/54319679/"/>
      <url>/2017/01/11/54319679/</url>
      
        <content type="html"><![CDATA[<h1 id="SPOJ-IITWPC4F-Gopu-and-the-Grid-Problem-线段树-【数据结构】"><a href="#SPOJ-IITWPC4F-Gopu-and-the-Grid-Problem-线段树-【数据结构】" class="headerlink" title="SPOJ IITWPC4F - Gopu and the Grid Problem [线段树]【数据结构】"></a>SPOJ IITWPC4F - Gopu and the Grid Problem [线段树]【数据结构】</h1><p>2017年01月11日 00:06:46  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：226</p><hr><p> 博客爬取于<code>2019-04-18 17:18:32</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/54319679" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/54319679</a></p><p>题目链接： <a href="http://www.spoj.com/problems/IITWPC4F/" target="_blank" rel="noopener"> http://www.spoj.com/problems/IITWPC4F/</a><br>————————————————————————————-.<br>IITWPC4F - Gopu and the Grid Problem<br>no tags</p><p>Gopu is interested in the integer co-ordinates of the X-Y plane<br>(0&lt;=x,y&lt;=100000). Each integer coordinate contain a lamp, initially all the<br>lamps are in off mode. Flipping a lamp means switching it on if it is in off<br>mode and vice versa. Maggu will ask gopu 3 type of queries.</p><p>Type 1: x l r, meaning: flip all the lamps whose x-coordinate are between l<br>and r (both inclusive) irrespective of the y coordinate.</p><p>Type 2: y l r, meaning: flip all the lamps whose y-coordinate are between l<br>and r (both inclusive) irrespective of the x coordinate.</p><p>Type 3: q x y X Y, meaning: count the number of lamps which are in ‘on<br>mode’(say this number be A) and ‘off mode’ (say this number be B) in the<br>region where x-coordinate is between x and X(both inclusive) and y-coordinate<br>is between y and Y(both inclusive).<br>Input</p><p>First line contains Q-number of queries that maggu will ask to gopu. (Q &lt;=<br>10^5)</p><p>Then there will be Q lines each containing a query of one of the three type<br>described above.<br>Output</p><p>For each query of 3rd type you need to output a line containing one integer A.</p><p>Example</p><p>Input:<br>3<br>x 0 1<br>y 1 2<br>q 0 0 2 2</p><p>Output:<br>4<br>————————————————————————————-.<br>题目大意：<br>就是有一个横纵坐标范围均为  [  0  ,  100000  ]  的二位平面 ,每个位置的值只有0/1,初始的时候均为0.<br>定义三种操作,<br>x a b 将x轴坐标范围  [  a  ,  b  ]  的区域翻转,即0/1互换<br>y a b 将y轴坐标范围  [  a  ,  b  ]  的区域翻转,即0/1互换<br>q a b A B 查询  (  a  ,  b  )  (  A  ,  B  )  范围内的区间中1的个数有多少.</p><p>解题思路:<br>因为题目提示的是整行的操作,所以很容易想到用两个数组分别标记对应行/列的翻转次数,奇数次为1,偶数次为0.</p><p>然后因为动态求区间和,想到树状数组,</p><p>然后发现一点,树状数组虽然能够很好的维护某一个值增减的变化,但是对于区间内翻转的变化既有增也有减,所以不可行,于是换成麻烦写的线段树维护就好了,</p><p>用区间更新就能很好的维护翻转标记了.</p><p>然后查询的操作与二维树状数组求和的操作一模一样,不再赘述.</p><p>附本题代码<br>——————————————————————————-.</p><pre><code>#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 100000+5;typedef long long int LL;/***************************************/struct node {    int l,r;    LL  val;    int lazy;    int md(){return (l+r)&gt;&gt;1; }    int ln(){return (r-l+1); }}tree[N&lt;&lt;2][2];#define ll  (rt&lt;&lt;1)#define rr  (rt&lt;&lt;1|1)#define mid (tree[rt][xy].md())void pushup(int rt,int xy){    tree[rt][xy].val = tree[ll][xy].val+ tree[rr][xy].val;}void build(int rt,int l,int r,int xy){    tree[rt][xy].l=l,tree[rt][xy].r=r;    tree[rt][xy].val=0ll,tree[rt][xy].lazy=0;    if(l==r) return ;    build(ll,l,mid,xy);    build(rr,mid+1,r,xy);}void pushdown(int rt,int xy){    if(tree[rt][xy].lazy){        tree[rr][xy].lazy = 1 - tree[rr][xy].lazy;        tree[ll][xy].lazy = 1 - tree[ll][xy].lazy;        tree[ll][xy].val  = tree[ll][xy].ln()-tree[ll][xy].val;        tree[rr][xy].val  = tree[rr][xy].ln()-tree[rr][xy].val;        tree[rt][xy].lazy = 0;    }}void update(int rt,int L,int R,int xy){    if(L&lt;=tree[rt][xy].l&amp;&amp;tree[rt][xy].r&lt;=R){        tree[rt][xy].lazy = 1-tree[rt][xy].lazy;        tree[rt][xy].val  = tree[rt][xy].ln()-tree[rt][xy].val;        return ;    }    pushdown(rt,xy);    if(L&lt;=mid) update(ll,L,R,xy);    if(R&gt; mid) update(rr,L,R,xy);    pushup(rt,xy);}LL query(int rt,int L,int R,int xy){    if(L&lt;=tree[rt][xy].l&amp;&amp;tree[rt][xy].r&lt;=R){        return tree[rt][xy].val ;    }    pushdown(rt,xy);    LL ans = 0;    if(L&lt;=mid) ans+=query(ll,L,R,xy);    if(R&gt; mid) ans+=query(rr,L,R,xy);    pushup(rt,xy);    return ans;}LL getSum(int x,int y){    //if(0&gt;=x||0&gt;=y) return 0ll;    LL X=query(1,0,x,1),Y=query(1,0,y,0);    return 1ll*X*(y-Y)+1ll*Y*(x-X);}int main(){    int n,x,y,x1,x2,y1,y2;    char ch ;    build(1,0,100001,0);    build(1,0,100001,1);    scanf(&quot;%d&quot;,&amp;n);getchar();    for(int i=0;i&lt;n;i++){        scanf(&quot;%c &quot;,&amp;ch);        if(&#39;x&#39;==ch){            scanf(&quot;%d %d&quot;,&amp;x,&amp;y);            x++,y++;            update(1,x,y,1);        }        else if(&#39;y&#39;==ch){            scanf(&quot;%d %d&quot;,&amp;x,&amp;y);            x++,y++;            update(1,x,y,0);        }        else {            scanf(&quot;%d %d %d %d&quot;,&amp;x1,&amp;y1,&amp;x2,&amp;y2);            x1++,x2++,y1++,y2++;            printf(&quot;%lld\n&quot;,getSum(x2,y2)-getSum(x1-1,y2)-getSum(x2,y1-1)+getSum(x1-1,y1-1));        }        getchar();    }    return 0;}/**树状数组维护x，y的区间tree[rt][1] XXXXXXXXtree[rt][0] YYYYYYYY*/</code></pre>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  codeforces 349C Mafia [贪心]/[二分答案]</title>
      <link href="/2017/01/10/54300967/"/>
      <url>/2017/01/10/54300967/</url>
      
        <content type="html"><![CDATA[<h1 id="codeforces-349C-Mafia-贪心-二分答案"><a href="#codeforces-349C-Mafia-贪心-二分答案" class="headerlink" title="codeforces 349C Mafia [贪心]/[二分答案]"></a>codeforces 349C Mafia [贪心]/[二分答案]</h1><p>2017年01月10日 02:05:58  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：294</p><hr><p> 博客爬取于<code>2019-04-18 17:18:33</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/54300967" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/54300967</a></p><p>题目链接： <a href="http://codeforces.com/contest/349/problem/C" target="_blank" rel="noopener"> http://codeforces.com/contest/349/problem/C</a><br>———————————————————————————————————————–.<br>C. Mafia<br>time limit per test2 seconds<br>memory limit per test256 megabytes<br>inputstandard input<br>outputstandard output<br>One day n friends gathered together to play “Mafia”. During each round of the<br>game some player must be the supervisor and other n - 1 people take part in<br>the game. For each person we know in how many rounds he wants to be a player,<br>not the supervisor: the i-th person wants to play ai rounds. What is the<br>minimum number of rounds of the “Mafia” game they need to play to let each<br>person play at least as many rounds as they want?</p><p>Input<br>The first line contains integer n (3 ≤ n ≤ 105). The second line contains n<br>space-separated integers a1, a2, …, an (1 ≤ ai ≤ 109) — the i-th number in the<br>list is the number of rounds the i-th person wants to play.</p><p>Output<br>In a single line print a single integer — the minimum number of game rounds<br>the friends need to let the i-th person play at least ai rounds.</p><p>Please, do not use the %lld specifier to read or write 64-bit integers in С++.<br>It is preferred to use the cin, cout streams or the %I64d specifier.</p><p>Examples<br>input<br>3<br>3 2 2<br>output<br>4<br>input<br>4<br>2 2 2 2<br>output<br>3<br>Note<br>You don’t need to know the rules of “Mafia” to solve this problem. If you’re<br>curious, it’s a game Russia got from the Soviet times: <a href="http://en.wikipedia.org/wiki/Mafia_\(party_game\" target="_blank" rel="noopener"><br>http://en.wikipedia.org/wiki/Mafia_(party_game)</a>) .</p><p>———————————————————————————————————————–.</p><p>题目大意：就是有n个人做游戏，每次需要有一个人作为”Mafia”，剩下的人作为“player”，现在有n个人每个人想做“player”的次数，问你满足所有人<br>想做“player”的次数意愿的同时最小游戏次数是多少。</p><p>题目大意：<br>我是用二分答案做的，然后看了下别人的 发现直接贪心就可以了。。<br>对结果进行二分,然后check的时候,只要判断所有人能做”Mafia”的次数能不能满足mid就行了。</p><p>但是神TM二分范围啊 ，本来想找找自信，结果r的范围TM的WA三发、、、<br>首先l一定是  m  a  x  {  a  i  }<br>然后r的范围我设  1  l  l  &lt; &lt; 62  居然不行。  1  l  l  &lt; &lt; 60  居然还TM不行。？</p><p>最后1e12才过、、</p><p>附本题代码<br>—————————————————–。</p><p>​    </p><pre class=" language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;bits/stdc++.h></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token macro property">#<span class="token directive keyword">define</span> INF        (~(1&lt;&lt;31))</span><span class="token macro property">#<span class="token directive keyword">define</span> INFLL      (~(1ll&lt;&lt;63))</span><span class="token macro property">#<span class="token directive keyword">define</span> pb         push_back</span><span class="token macro property">#<span class="token directive keyword">define</span> mp         make_pair</span><span class="token macro property">#<span class="token directive keyword">define</span> abs(a)     ((a)>0?(a):-(a))</span><span class="token macro property">#<span class="token directive keyword">define</span> lalal      puts("*******");</span><span class="token macro property">#<span class="token directive keyword">define</span> s1(x)      scanf("%d",&amp;x)</span><span class="token macro property">#<span class="token directive keyword">define</span> Rep(a,b,c) for(int a=(b);a&lt;=(c);a++)</span><span class="token macro property">#<span class="token directive keyword">define</span> Per(a,b,c) for(int a=(b);a>=(c);a--)</span><span class="token keyword">typedef</span> <span class="token keyword">long</span> <span class="token keyword">long</span> <span class="token keyword">int</span> LL <span class="token punctuation">;</span><span class="token keyword">typedef</span> <span class="token keyword">unsigned</span> <span class="token keyword">long</span> <span class="token keyword">long</span> <span class="token keyword">int</span> uLL <span class="token punctuation">;</span><span class="token keyword">const</span> <span class="token keyword">int</span> MOD <span class="token operator">=</span> <span class="token number">1e9</span><span class="token operator">+</span><span class="token number">7</span><span class="token punctuation">;</span><span class="token keyword">const</span> <span class="token keyword">int</span> N <span class="token operator">=</span> <span class="token number">100000</span><span class="token operator">+</span><span class="token number">8</span><span class="token punctuation">;</span><span class="token keyword">const</span> <span class="token keyword">double</span> eps <span class="token operator">=</span> <span class="token number">1e-6</span><span class="token punctuation">;</span><span class="token keyword">const</span> <span class="token keyword">double</span> PI <span class="token operator">=</span> <span class="token function">acos</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">fre</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">freopen</span><span class="token punctuation">(</span><span class="token string">"in.txt"</span><span class="token punctuation">,</span><span class="token string">"r"</span><span class="token punctuation">,</span><span class="token constant">stdin</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">freopen</span><span class="token punctuation">(</span><span class="token string">"out.txt"</span><span class="token punctuation">,</span><span class="token string">"w"</span><span class="token punctuation">,</span><span class="token constant">stdout</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/*************************************************/</span>LL a<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">int</span> n<span class="token punctuation">;</span><span class="token keyword">bool</span> <span class="token function">check</span><span class="token punctuation">(</span>LL x<span class="token punctuation">)</span><span class="token punctuation">{</span>    LL res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token function">Rep</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span>n<span class="token punctuation">)</span> res<span class="token operator">+</span><span class="token operator">=</span>x<span class="token operator">-</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>res<span class="token operator">>=</span>x<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">~</span><span class="token function">s1</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        LL l <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span>r<span class="token operator">=</span><span class="token number">1e12</span><span class="token punctuation">,</span>mid<span class="token punctuation">,</span>ans<span class="token operator">=</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token function">Rep</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span>n<span class="token punctuation">)</span> <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%I64d"</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span>l<span class="token operator">=</span><span class="token function">max</span><span class="token punctuation">(</span>l<span class="token punctuation">,</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>l<span class="token operator">&lt;=</span>r<span class="token punctuation">)</span><span class="token punctuation">{</span>            mid<span class="token operator">=</span><span class="token punctuation">(</span>l<span class="token operator">+</span>r<span class="token punctuation">)</span><span class="token operator">>></span><span class="token number">1</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">check</span><span class="token punctuation">(</span>mid<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                ans <span class="token operator">=</span> mid<span class="token punctuation">;</span>                r<span class="token operator">=</span>mid<span class="token number">-1</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">else</span> l<span class="token operator">=</span>mid<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%I64d\n"</span><span class="token punctuation">,</span>ans<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  SPOJ TBATTLE - Thor vs Frost Giants [数论+二分]</title>
      <link href="/2017/01/10/54297591/"/>
      <url>/2017/01/10/54297591/</url>
      
        <content type="html"><![CDATA[<h1 id="SPOJ-TBATTLE-Thor-vs-Frost-Giants-数论-二分"><a href="#SPOJ-TBATTLE-Thor-vs-Frost-Giants-数论-二分" class="headerlink" title="SPOJ TBATTLE - Thor vs Frost Giants [数论+二分]"></a>SPOJ TBATTLE - Thor vs Frost Giants [数论+二分]</h1><p>2017年01月10日 00:13:01  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：397</p><hr><p> 博客爬取于<code>2019-04-18 17:18:33</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/54297591" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/54297591</a></p><p>题目链接： <a href="http://www.spoj.com/problems/TBATTLE" target="_blank" rel="noopener"> http://www.spoj.com/problems/TBATTLE</a><br>——————————————————————————————.<br>TBATTLE - Thor vs Frost Giants</p><h1 id="number-theory-sliding-window-1"><a href="#number-theory-sliding-window-1" class="headerlink" title="number-theory #sliding-window-1"></a>number-theory #sliding-window-1</h1><p>Thor is caught up in a fierce battle with Loki’s army. This army consists of<br>frost giants that have magical powers with them. Their strength levels gets<br>multiplied when they are together. Giants are not highly skilled in the arts<br>of combat, but their sheer size and strength make them formidable opponents<br>even for the Asgardian gods. Thor is no exception. They recover very fast from<br>physical injury but their recovery slows down when they are exposed to extreme<br>heat.<br>Thor’s hammer can generate heat only in multiples of heat quantum N. Frost<br>giants get killed only when their combined strength level is exactly equal to<br>the heat level of the hammer. Thor is interested in killing a continuous<br>stretch of frost enemies with a throw of his hammer with a preference to kill<br>closer enemies first.<br>Continuous stretch is defined as a set of consecutive elements.<br>Help Thor to determine the minimum stretch of frost giants that could be<br>killed in a throw. In case of multiple minimal stretches, output the indices<br>of that stretch that has lowest starting index. If there is no such continuous<br>stretch possible then print -1.</p><p>Input</p><p>The first line will contain N, the number of Frost Giants in Loki’s army and<br>the Heat quantum.<br>The second line will contain N integers (a_0, a_2….., a_n-1) - the strength of<br>each frost giant.<br>Minimum stretch of the army should be 1.</p><p>1 ≤ N ≤ 100000<br>1 ≤ a_i ≤ 100000<br>Output</p><p>Output the range of the minimum stretch of frost giants that could be killed<br>in a throw. In case of multiple minimal stretches, output the indices of that<br>stretch that has lowest starting index.<br>If there is no such continuous stretch possible then print -1.</p><p>Example</p><p>Input:<br>3<br>1 2 9<br>Output:<br>2 2</p><p>Input:<br>5<br>2 3 4 8 9<br>Output:<br>-1 </p><p>Input:<br>10<br>2 4 3 5 17 4 7 5 2 15<br>Output:<br>7 8</p><p>Explanation</p><p>Input #1:<br>Thor can only kill the stretch [2,2] as this is the minimum length range with<br>strength, multiple of 3.</p><p>Input #2:<br>There is no stretch of frost giants that have combined strength as a multiple<br>of 5.</p><p>Input #3:<br>There are many stretches of frost giants that have strength as multiple of 10.<br>But the minimal stretch with the least indices is from [7,8]. Minimum size<br>stretches are [7, 8] and [8, 9]. Out of them we select [7,8].<br>——————————————————————————————.<br>题目大意：就是给你长度为n的序列  a  0  ,  a  1  ,  .  .  .  a  n  −  1  .找一个最短的区见  [  a  ,  b<br>]  使得  (  ∏  b  i  =  a  a  i  )  %  n  =  =  0  求最小区间，如果多个就输出最左边的，没有输出  −  1<br>.</p><p>解题思路:<br>首先看到这个题我有两个思路,<br>思路一: 我可以把每个数根据算数基本定理展开,向右扫,就是单调的了,我们可以确定区间的一个值来二分另一个值,这样复杂度为  O  (  n  l  o  g<br>2  n  )<br>思路二: 我利用线段树维护区间的乘积取模,然后用尺取法的方法来确定区间 ,这样复杂度同样为  O  (  n  l  o  g  2  n  )<br>,但是我写了一发wa了……</p><p>附本题代码<br>—————————————————————-.</p><pre><code>// 尺取法的WA了........#include &lt;bits/stdc++.h&gt;using namespace std;#define INF        (~(1&lt;&lt;31))#define INFLL      (~(1ll&lt;&lt;63))#define pb         push_back#define mp         make_pair#define abs(a)     ((a)&gt;0?(a):-(a))#define lalal      puts(&quot;*******&quot;);#define s1(x)      scanf(&quot;%d&quot;,&amp;x)#define Rep(a,b,c) for(int a=(b);a&lt;=(c);a++)#define Per(a,b,c) for(int a=(b);a&gt;=(c);a--)typedef long long int LL ;typedef unsigned long long int uLL ;const int MOD = 1e9+7;const int N = 100000+8;const double eps = 1e-6;const double PI = acos(-1.0);void fre(){    freopen(&quot;in.txt&quot;,&quot;r&quot;,stdin);    freopen(&quot;out.txt&quot;,&quot;w&quot;,stdout);}/*************************************************/LL a[N];int n;struct node{    int l,r;    LL val;    int md(){return (l+r)&gt;&gt;1;}}tree[N&lt;&lt;2];#define ll  (rt&lt;&lt;1)#define rr  (rt&lt;&lt;1|1)#define mid (tree[rt].md())void pushup(int rt){    tree[rt].val = tree[ll].val * tree[rr].val % n;}void build (int rt,int l,int r){    tree[rt].l=l,tree[rt].r=r;    if(l==r){        tree[rt].val = a[l];        return ;    }    build(ll,l,mid);    build(rr,mid+1,r);    pushup(rt);}LL query(int rt,int L,int R){    if(L&lt;=tree[rt].l&amp;&amp;tree[rt].r&lt;=R)        return tree[rt].val;    LL ans = 1ll;    if(L&lt;=mid) ans=ans*query(ll,L,R)%n;    if(R&gt; mid) ans=ans*query(rr,L,R)%n;    return ans%n;}int main(){    while(~s1(n)){        int flag = -1;        Rep(i,0,n-1) {            scanf(&quot;%lld&quot;,&amp;a[i]),a[i]%=n;            if(0ll==a[i]&amp;&amp;flag == -1) flag = i;        }        if(flag!=-1) {            printf(&quot;%d %d\n&quot;,flag,flag);            continue;        }        build(1,0,n-1);        int mi=1010101,weizhi = -1,weizhi2 = -1;        LL tem = a[0];        int l,r;        l=-1,r=0,a[n]=1;        while(l&lt;r&amp;&amp;r&lt;n){            while(r&lt;n&amp;&amp;tem%n) tem=tem*a[++r]%n;            if(r-l+1&lt;mi&amp;&amp;0 == tem%n) mi=r-l+1,weizhi = l-1,weizhi2 = r;           // printf(&quot;%d %d&lt;&lt;---\n&quot;,l,r);            while(l&lt;r&amp;&amp;0 == tem%n) l=l+1,tem=query(1,l,r)%n,weizhi++;        }        if(mi != 1010101) {            printf(&quot;%d %d\n&quot;,weizhi,weizhi2);            continue;        }        puts(&quot;-1&quot;);    }    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  SPOJ STC02 - Antisymmetry [Manacher]【思维】</title>
      <link href="/2017/01/09/54263566/"/>
      <url>/2017/01/09/54263566/</url>
      
        <content type="html"><![CDATA[<h1 id="SPOJ-STC02-Antisymmetry-Manacher-【思维】"><a href="#SPOJ-STC02-Antisymmetry-Manacher-【思维】" class="headerlink" title="SPOJ STC02 - Antisymmetry [Manacher]【思维】"></a>SPOJ STC02 - Antisymmetry [Manacher]【思维】</h1><p>2017年01月09日 00:44:19  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：476</p><hr><p> 博客爬取于<code>2019-04-18 17:18:34</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/54263566" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/54263566</a></p><p>题目链接： <a href="http://www.spoj.com/problems/STC02/" target="_blank" rel="noopener"> http://www.spoj.com/problems/STC02/</a><br>—————————————————————————————–.<br>STC02 - Antisymmetry<br>no tags<br>Byteasar studies certain strings of zeroes and ones. Let S be such a string.<br>By Sr we will denote the reversed (i.e., “read backwards”) string S, and by SI<br>we will denote the string obtained from S by changing all the zeroes to ones<br>and ones to zeroes.</p><p>Byteasar is interested in antisymmetry, while all things symmetric bore him.<br>Antisymmetry however is not a mere lack of symmetry. We will say that a<br>(nonempty) string S is antisymmetric if, for every position i in S, the i-th<br>last character is different than the i-th (first) character. In particular, a<br>string S consisting of zeroes and ones is antisymmetric if and only if S=SIr.<br>For example, the strings 00001111 and 010101 are antisymmetric, while 1001 is<br>not.</p><p>In a given string consisting of zeroes and ones we would like to determine the<br>number of contiguous nonempty antisymmetric fragments. Different fragments<br>corresponding to the same substrings should be counted multiple times.</p><p>Input<br>The first line of the standard input contains an integer N (1 &lt;= N &lt;= 500000)<br>that denotes the length of the string. The second line gives a string of 0<br>and/or 1 of length N. There are no spaces in the string.</p><p>Output<br>The first and only line of the standard output should contain a single<br>integer, namely the number of contiguous (non empty) fragments of the given<br>string that are antisymmetric.</p><p>Example<br>For the input data:</p><p>8<br>11001011<br>the correct result is:</p><p>7<br>Antisymmetric fragments are: 01 (occurs twice), 10 (also twice), 0101, 1100,<br>and 001011.<br>——————————————————————————————.</p><p>题目大意：<br>就是给你一个字符串，然你统计满足0/1互换之后在翻转等于原串的子串有多少个</p><p>解题思路:<br>这个可以利用求最长回文子串的Manacher算法解决，只要把check换成下述就可以</p><p>​<br>    bool check(int x,int y){<br>        if(x&lt;1||x&gt;len) return false;<br>        if(y&lt;1||y&gt;len) return false;<br>        return ((a[x]==’0’&amp;&amp;a[y]==’1’)||(a[x]==’1’&amp;&amp;a[y]==’0’)||(a[x]==’#’&amp;&amp;a[y]==’#’));<br>    }</p><p>这样题目就变得非常简单了<br>计算子串的方法一样,与标准的Manacher一模一样.都是用p[i]来维护以i为中心的最长子串的半径,但由于题意的限制,这个中心只能是’#’.最后累加下就好<br>了.</p><p>但是为什么我的代码还是不能过掉 test61！！！！ 调了好久还是不知道问题出在哪里 ，最后无奈只好贴了OMRailgun的代码。。。。</p><p>然后改了改，已经和OMRailgun的代码一模一样了，但是最后一组样例还是过不去 ，ZTMDCD。。</p><p>===================Update=========================<br>问题已发现 ,因为!!!因为!!!<br>p[i]=(p[(id&lt;&lt;1)-i]&lt;(mx-i))?p[(id&lt;&lt;1)- <strong> 1 </strong> ]:(mx-i);<br>应该是<br>p[i]=(p[(id&lt;&lt;1)-i]&lt;(mx-i))?p[(id&lt;&lt;1)- <strong> i </strong> ]:(mx-i);<br>我就是个**…..</p><p>附本题代码<br>—————————————–.</p><p>​<br>    //能AC的OMRailgun的代码<br>    //OMRailgun博客的链接<a href="http://blog.csdn.net/omrailgun/article/details/53931521" target="_blank" rel="noopener">http://blog.csdn.net/omrailgun/article/details/53931521</a></p><pre><code>#include&lt;iostream&gt;  #include&lt;stdio.h&gt;  #include&lt;string.h&gt;  #include&lt;stdlib.h&gt;  using namespace std;  #define ll long long  const int N=500008;  int n,len,f[N*2];  char a[N*2],str[N];  int minx(int x,int y){if(x&lt;y)y=x;return y;}  int pan(int x,int y){return ((a[x]==&#39;0&#39;&amp;&amp;a[y]==&#39;1&#39;)||(a[x]==&#39;1&#39;&amp;&amp;a[y]==&#39;0&#39;)||(a[x]==&#39;#&#39;&amp;&amp;a[y]==&#39;#&#39;));}  int main(void)  {      int i,m,id;ll ans=0;      scanf(&quot;%d%s&quot;,&amp;n,str+1);      a[len=0]=0;a[++len]=&#39;#&#39;;      for(i=1;i&lt;=n;i++){a[++len]=str[i];a[++len]=&#39;#&#39;;}      m=0;      for(i=1;i&lt;=len;i++)      {          if(m&gt;i)f[i]=minx(f[2*id-i],m-i);else f[i]=1;          while(i-f[i]&gt;=1&amp;&amp;i+f[i]&lt;=len&amp;&amp;pan(i+f[i],i-f[i]))f[i]++;          if(a[i]==&#39;#&#39;&amp;&amp;i&gt;1&amp;&amp;i&lt;len){            ans+=f[i]/2;            if(i+f[i]&gt;m){                m=i+f[i];id=i;            }         }      }      printf(&quot;%lld&quot;,ans);      return 0;  } //能AC的我的代码 已经改正了#include &lt;bits/stdc++.h&gt;using namespace std;#define INF        (~(1&lt;&lt;31))#define INFLL      (~(1ll&lt;&lt;63))#define pb         push_back#define mp         make_pair#define abs(a)     ((a)&gt;0?(a):-(a))#define lalal      puts(&quot;*******&quot;);#define s1(x)      scanf(&quot;%d&quot;,&amp;x)#define Rep(a,b,c) for(int a=(b);a&lt;=(c);a++)#define Per(a,b,c) for(int a=(b);a&gt;=(c);a--)typedef long long int LL ;typedef unsigned long long int uLL ;const int MOD = 1e9+7;const int N = 500000+105;const double eps = 1e-6;const double PI = acos(-1.0);void fre(){    freopen(&quot;in.txt&quot;,&quot;r&quot;,stdin);    freopen(&quot;out.txt&quot;,&quot;w&quot;,stdout);}/*************************************************/int minx(int x,int y){if(x&lt;y)y=x;return y;}char a[N&lt;&lt;1],str[N];int p[N&lt;&lt;1],slen,len;bool check(int x,int y){    if(x&lt;0||x&gt;len) return false;    if(y&lt;0||y&gt;len) return false;    if( (a[x]==&#39;0&#39;&amp;&amp;a[y]==&#39;1&#39;)||        (a[x]==&#39;1&#39;&amp;&amp;a[y]==&#39;0&#39;)||        (a[x]==&#39;#&#39;&amp;&amp;a[y]==&#39;#&#39;) )            return true;    return false;}void solve(){    LL ans = 0;    a[len]   = &#39;$&#39;, a[++len] = &#39;#&#39;,len  = 0;    Rep(i,0,slen-1) a[++len] = str[i],a[++len] = &#39;#&#39;;    memset(p,0,sizeof(p));    int id = -1,mx = -1;    Rep(i,0,len){        if(mx &gt; i) p[i] = minx(p[(id&lt;&lt;1)-i],(mx-i));        else p[i]=1;        while(check(i-p[i],i+p[i])) p[i]++;        if(a[i]==&#39;#&#39;) {ans+=p[i]&gt;&gt;1;        if(p[i]+i&gt;mx) mx=p[i]+i,id=i;}    }    printf(&quot;%lld\n&quot;,ans);    return ;}int main(){    while(~scanf(&quot;%d%s&quot;,&amp;slen,str)) solve();    return 0;}</code></pre><p>​    </p>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  HDU 3068 最长回文 [Manacher]【字符串】</title>
      <link href="/2017/01/08/54237933/"/>
      <url>/2017/01/08/54237933/</url>
      
        <content type="html"><![CDATA[<h1 id="HDU-3068-最长回文-Manacher-【字符串】"><a href="#HDU-3068-最长回文-Manacher-【字符串】" class="headerlink" title="HDU 3068 最长回文 [Manacher]【字符串】"></a>HDU 3068 最长回文 [Manacher]【字符串】</h1><p>2017年01月08日 23:01:19  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：212</p><hr><p> 博客爬取于<code>2019-04-18 17:18:35</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/54237933" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/54237933</a></p><p>题目链接: <a href="http://acm.hdu.edu.cn/showproblem.php?pid=3068" target="_blank" rel="noopener"> http://acm.hdu.edu.cn/showproblem.php?pid=3068</a></p><p>———————————————————.<br>最长回文</p><p>Time Limit: 4000/2000 MS (Java/Others) Memory Limit: 32768/32768 K<br>(Java/Others)<br>Total Submission(s): 18924 Accepted Submission(s): 6934</p><p>Problem Description<br>给出一个只由小写英文字符a,b,c…y,z组成的字符串S,求S中最长回文串的长度.<br>回文就是正反读都是一样的字符串,如aba, abba等</p><p>Input<br>输入有多组case,不超过120组,每组输入为一行小写英文字符a,b,c…y,z组成的字符串S<br>两组case之间由空行隔开(该空行不用处理)<br>字符串长度len &lt;= 110000</p><p>Output<br>每一行一个整数x,对应一组case,表示该组case的字符串中所包含的最长回文长度.</p><p>Sample Input<br>aaaa</p><p>abab</p><p>Sample Output<br>4<br>3</p><p>——————————————————-.</p><p>解题思路:<br>就是Manacher入门题目<br>Manacher 是一个能在  O  (  n  )  的复杂度内解决字符串中最长回文子串的问题</p><p><a href="http://www.cnblogs.com/biyeymyhjob/archive/2012/10/04/2711527.html" target="_blank" rel="noopener"> 这篇帖子给的挺详细的</a></p><h2 id="附本题代码"><a href="#附本题代码" class="headerlink" title="附本题代码"></a>附本题代码</h2><pre><code>#include &lt;bits/stdc++.h&gt;using namespace std;#define INF        (~(1&lt;&lt;31))#define INFLL      (~(1ll&lt;&lt;63))#define pb         push_back#define mp         make_pair#define abs(a)     ((a)&gt;0?(a):-(a))#define lalal      puts(&quot;*******&quot;);#define s1(x)      scanf(&quot;%d&quot;,&amp;x)#define Rep(a,b,c) for(int a=(b);a&lt;=(c);a++)#define Per(a,b,c) for(int a=(b);a&gt;=(c);a--)typedef long long int LL ;typedef unsigned long long int uLL ;const int MOD = 1e9+7;const int N = 500000+5;const double eps = 1e-6;const double PI = acos(-1.0);void fre(){    freopen(&quot;in.txt&quot;,&quot;r&quot;,stdin);    freopen(&quot;out.txt&quot;,&quot;w&quot;,stdout);}/*************************************************//***str  原字符串a    进行Manacher算法的为减轻编码难度改进的字符串p[i] 以a[i]为中心的回文串的半径(含a[i])id   最长回文子串的中心位置mx   id+p[id] 最长回文子串的左外边界。算法核心的部分if(mx &gt; i) p[i] = (p[(id&lt;&lt;1)-i]&lt;(mx-i))?p[(id&lt;&lt;1)-1]:(mx-i);else p[i]=1;首先我们知道对于一个字符串进行操作的时候，是从左到右依次进行的那么由于回文串的对称性，那么可以确定的是对于a[i]为中心的回文串的长度至少是在以这个最大的回文串中对称的那个位置为中心的回文串的长度,但只能确定的是在最大的回文串的那一部分中的长度,至于之外的就要一个个的匹配了*//***id  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7a： $ # 1 # 2 # 2 # 1 # 2 # 3 # 2 # 1 #p_i 1 1 2 1 2 5 2 */char a[N],str[N];int p[N];void train(){    int len  = 0;    a[len] = &#39;$&#39;, a[++len] = &#39;#&#39;;    int slen = strlen(str)-1;    Rep(i,0,slen) a[++len] = str[i],a[++len] = &#39;#&#39;;    memset(p,0,sizeof(p));    int id = -1,mx = -1,mxp = -1;    Rep(i,0,len){        if(mx &gt; i) p[i] = (p[(id&lt;&lt;1)-i]&lt;(mx-i))?p[(id&lt;&lt;1)-i]:(mx-i);        else p[i]=1;        while(a[i-p[i]]==a[i+p[i]]) p[i]++;        if(p[i]+i&gt;mx) mx=p[i]+i,id=i;        if(p[i]&gt;mxp) mxp = p[i];    }    printf(&quot;%d\n&quot;,mxp-1);    return ;}int main(){    while(~scanf(&quot;%s&quot;,str)) train();    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  SPOJ MINSUN Largest Submatrix [二分+单调栈]</title>
      <link href="/2017/01/08/54234049/"/>
      <url>/2017/01/08/54234049/</url>
      
        <content type="html"><![CDATA[<h1 id="SPOJ-MINSUN-Largest-Submatrix-二分-单调栈"><a href="#SPOJ-MINSUN-Largest-Submatrix-二分-单调栈" class="headerlink" title="SPOJ MINSUN Largest Submatrix [二分+单调栈]"></a>SPOJ MINSUN Largest Submatrix [二分+单调栈]</h1><p>2017年01月08日 15:18:59  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：250</p><hr><p> 博客爬取于<code>2019-04-18 17:18:37</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/54234049" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/54234049</a></p><p>题目链接： <a href="http://www.spoj.com/problems/MINSUB/" target="_blank" rel="noopener"> http://www.spoj.com/problems/MINSUB/</a><br>—————————————————————————————.<br>MINSUB - Largest Submatrix<br>no tags<br>You are given an matrix M (consisting of nonnegative integers) and an integer<br>K. For any submatrix of M’ of M define min(M’) to be the minimum value of all<br>the entries of M’. Now your task is simple: find the maximum value of min(M’)<br>where M’ is a submatrix of M of area at least K (where the area of a submatrix<br>is equal to the number of rows times the number of columns it has).</p><p>Input</p><p>The first line contains a single integer T (T ≤ 10) denoting the number of<br>test cases, T test cases follow. Each test case starts with a line containing<br>three integers, R (R ≤ 1000), C (C ≤ 1000) and K (K ≤ R * C) which represent<br>the number of rows, columns of the matrix and the parameter K. Then follow R<br>lines each containing C nonnegative integers, representing the elements of the<br>matrix M. Each element of M is ≤ 10^9</p><p>Output</p><p>For each test case output two integers: the maximum value of min(M’), where M’<br>is a submatrix of M of area at least K, and the maximum area of a submatrix<br>which attains the maximum value of min(M’). Output a single space between the<br>two integers.</p><p>Example</p><p>Input:<br>2<br>2 2 2<br>1 1<br>1 1<br>3 3 2<br>1 2 3<br>4 5 6<br>7 8 9</p><p>Output:<br>1 4<br>8 2<br>——————————————————————————————.</p><p>题目大意：问你找到一个面积大于K的子矩阵中的最小值，在保证最小值最大的情况下计算面积的最大值</p><p>解题思路：<br>首先最小值最大这种就想到了二分，甚至都想到了每次将  &gt; =  m  i  d<br>的值用一表示,其他用0表示,然后枚举子矩阵的左上角和右下角二维树状数组计算值,这样的话总复杂度就到了  O  (  n  4  ∗  l  o  g  3<br>2  n  )<br>然后就不会了<br>看了wannaflyunion的题解才知道用一个叫做单调栈的东西能在  O  (  n  m  )  的复杂度中解决求子矩阵的最大值<br>想法也同样是每次将  &gt; =  m  i  d  的值用一表示,其他用0表示. <strong> 增加 </strong><br>的是在这个过程中处理了每个点向左的1的个数,然后通过维护每一列的时候向上有几个不小于这个值的向下有几个不小于这个值的. 这个过程通过单调栈能做到  O  (<br>n  )  ,然后判断的是  m  列的 所以总复杂度最后只到了  O  (  n  m  l  o  g  2  (  1  e  9  +  1  )<br>)</p><p>因为二分的不同写法 注意下1e9这个值就好了,,,,</p><p>附本题代码<br>—————————————————–.</p><pre><code>再次抄袭wannaflyunion的代码..#include &lt;bits/stdc++.h&gt;using namespace std;#define INF        (~(1&lt;&lt;31))#define INFLL      (~(1ll&lt;&lt;63))#define pb         push_back#define mp         make_pair#define abs(a)     ((a)&gt;0?(a):-(a))#define lalal      puts(&quot;*******&quot;);#define s1(x)      scanf(&quot;%d&quot;,&amp;x)#define Rep(a,b,c) for(int a=(b);a&lt;=(c);a++)#define Per(a,b,c) for(int a=(b);a&gt;=(c);a--)typedef long long int LL ;typedef unsigned long long int uLL ;const int MOD = 1e9+7;const int N = 100000+5;const double eps = 1e-6;const double PI = acos(-1.0);void fre(){    freopen(&quot;in.txt&quot;,&quot;r&quot;,stdin);    freopen(&quot;out.txt&quot;,&quot;w&quot;,stdout);}/*************************************************/int n,m,k;int a[1005][1005],f[1005][1005],U[1005],D[1005];int check(int x){    memset(f,0,sizeof(f));    memset(U,0,sizeof(U));    memset(D,0,sizeof(D));    Rep(i,1,n)Rep(j,1,m)    if(a[i][j]&gt;=x)f[i][j]=f[i][j-1]+1;    else f[i][j]=0;    int now ,area = 0;    Rep(i,1,m){        Rep(j,1,n){            now = j-1;            while(now&amp;&amp;f[j][i]&lt;=f[now][i]) now = U[now];            U[j] = now ;        }        Per(j,n,1){            now = j+1;            while(now!=n+1&amp;&amp;f[j][i]&lt;=f[now][i]) now = D[now];            D[j] = now;        }        Rep(j,1,n) area = max(area,(D[j]-U[j]-1)*f[j][i]);    }    return area;}int main(){    int _;    while(~s1(_)){        while(_--){            s1(n),s1(m),s1(k);            Rep(i,1,n)Rep(j,1,m) s1(a[i][j]);            int l,r = -1,mid,ans;            l = 0,r = 1e9+1,ans =0;            while(l&lt;=r){                mid = (l+r)&gt;&gt;1;                if(check(mid)&gt;=k)    ans = mid, l=mid+1;                else    r=mid-1;            }            printf(&quot;%d %d\n&quot;,ans,check(ans));        }    }    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  POJ 2796 Feel Good 【单调栈】</title>
      <link href="/2017/01/07/54150706/"/>
      <url>/2017/01/07/54150706/</url>
      
        <content type="html"><![CDATA[<h1 id="POJ-2796-Feel-Good-【单调栈】"><a href="#POJ-2796-Feel-Good-【单调栈】" class="headerlink" title="POJ 2796 Feel Good 【单调栈】"></a>POJ 2796 Feel Good 【单调栈】</h1><p>2017年01月07日 01:11:20  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：324</p><hr><p> 博客爬取于<code>2019-04-18 17:18:38</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/54150706" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/54150706</a></p><p>题目链接： <a href="http://poj.org/problem?id=2796" target="_blank" rel="noopener"> http://poj.org/problem?id=2796 </a></p><p>—————————————————————————————————-.<br>Feel Good<br>Time Limit: 3000MS Memory Limit: 65536K<br>Total Submissions: 13624 Accepted: 3807<br>Case Time Limit: 1000MS Special Judge<br>Description</p><p>Bill is developing a new mathematical theory for human emotions. His recent<br>investigations are dedicated to studying how good or bad days influent<br>people’s memories about some period of life.</p><p>A new idea Bill has recently developed assigns a non-negative integer value to<br>each day of human life.</p><p>Bill calls this value the emotional value of the day. The greater the<br>emotional value is, the better the daywas. Bill suggests that the value of<br>some period of human life is proportional to the sum of the emotional values<br>of the days in the given period, multiplied by the smallest emotional value of<br>the day in it. This schema reflects that good on average period can be greatly<br>spoiled by one very bad day.</p><p>Now Bill is planning to investigate his own life and find the period of his<br>life that had the greatest value. Help him to do so.<br>Input</p><p>The first line of the input contains n - the number of days of Bill’s life he<br>is planning to investigate(1 &lt;= n &lt;= 100 000). The rest of the file contains n<br>integer numbers a1, a2, … an ranging from 0 to 106 - the emotional values of<br>the days. Numbers are separated by spaces and/or line breaks.<br>Output</p><p>Print the greatest value of some period of Bill’s life in the first line. And<br>on the second line print two numbers l and r such that the period from l-th to<br>r-th day of Bill’s life(inclusive) has the greatest possible value. If there<br>are multiple periods with the greatest possible value,then print any one of<br>them.<br>Sample Input</p><p>6<br>3 1 6 4 5 2<br>Sample Output</p><p>60<br>3 5<br>Source</p><p>Northeastern Europe 2005<br>—————————————————————————————————-.</p><p>题目大意：<br>给定一个序列，让你求[  ∑  j  i  a  i  ∗  m  i  n  a  [  i  ,  j  ]  ]的最大值。</p><p>解题思路：<br>如果暴力求解的话很明显需要  O  (  n  2  )  来解决,但是更明显的就是会 <strong> 超时 </strong> .<br>于是换一种想法,由于我是找的单调栈类型题,所以,就没有想算法…….</p><p>至于单调栈怎么维护,其实很简单了,<br>于其类似的有单调队列,<br>单调,单调,所以栈中所有元素都是递增的,<br>那么我们在维护一个单调栈的时候要将所有的于即将进栈的元素不单调的元素出栈,这样下去就能维护一个单调栈了.<br>维护单调栈的好处也很明显,能够快速的维护一个区间内的最小值.<br>这样下来在进行统计的时候就能减少很多不必要的计算.</p><p>首先区间和用一个前缀和来表示,将求取区间和的部分降到  O  (  1  )  ,在每一次维护一个元素的时候,采用一个结构体,</p><pre><code>struct node{    int val; //元素的值    int weizhi; //元素在序列中的位置    int l,r;  //这个元素能控制的区间} des[N];</code></pre><p>在每一次出栈操作的时候维护一下所需要计算的结果就行.</p><p><a href="http://www.cnblogs.com/ziyi--caolu/archive/2013/06/23/3151556.html" target="_blank" rel="noopener"> 这个题解介绍的非常详细了,自己写的是在太罗嗦还是删了吧… </a></p><p>并不是很难想,但是注意元素全部为0的时候,初始化ans需要&lt;0</p><p>附本题代码</p><pre><code>//#include &lt;bits/stdc++.h&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;math.h&gt;using namespace std;#define INF        (~(1&lt;&lt;31))#define INFLL      (~(1ll&lt;&lt;63))#define pb         push_back#define mp         make_pair#define abs(a)     ((a)&gt;0?(a):-(a))#define lalal      puts(&quot;*******&quot;);#define s1(x)      scanf(&quot;%d&quot;,&amp;x)#define Rep(a,b,c) for(int a=(b);a&lt;=(c);a++)#define Per(a,b,c) for(int a=(b);a&gt;=(c);a--)#define no         puts(&quot;NO&quot;)typedef long long int LL ;typedef unsigned long long int uLL ;const int MOD = 1e9+7;const int N = 100000+5;const double eps = 1e-6;const double PI = acos(-1.0);void fre(){    freopen(&quot;in.txt&quot;,&quot;r&quot;,stdin);    freopen(&quot;out.txt&quot;,&quot;w&quot;,stdout);}/*************************************************/int a[N];LL sum[N];struct node{    int val;    int weizhi;    int l,r;} des[N];int ind;int main(){    int n;    while(~s1(n))    {        sum[0]=0;        Rep(i,1,n) s1(a[i]),sum[i]=sum[i-1]+a[i];        ind = 1;        int l,r;        LL ans = -1,tem = -1;        des[1].val = a[1];        des[1].weizhi = 1;        des[1].l = 1;        des[1].r = 1;        Rep(i,2,n)        {            while(ind &amp;&amp; a[i]&lt;=des[ind].val)            {                des[ind].r = i-1;                tem = (sum[des[ind].r]-sum[des[ind].l-1])*des[ind].val;                if(tem &gt; ans)                {                    ans = tem ;                    l = des[ind].l;                    r = des[ind].r;                }                ind--;                if(!ind) break;            }            des[++ind].val = a[i];            des[ind].weizhi = i;            des[ind].l = des[ind-1].weizhi+1;            des[ind].r = i;        }        while(ind)        {            des[ind].r = n;            tem = (sum[des[ind].r]-sum[des[ind].l-1])*des[ind].val;            if(tem &gt; ans)            {                ans = tem ;                l = des[ind].l;                r = des[ind].r;            }            ind--;        }        printf(&quot;%lld\n%d %d\n&quot;,ans,l,r);    }    return 0;}/**Posted by flywarrior at 2012-11-01 20:09:53 on Problem 2796input1031 2 141 2 2 191 1 1 1 1 1 1 2 210102 58 149 52 66 52 105 28 161 111697 111 154 93 72 109161 2 1 1 1 1 1 1 1 1 1 1 1 1 1 160 0 0 0 0 0答案：01 142 282 3111 9303681 7457921 6171 1601 1*/</code></pre>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  SPOJ KAOS [Trie]【字符串】</title>
      <link href="/2017/01/05/54098779/"/>
      <url>/2017/01/05/54098779/</url>
      
        <content type="html"><![CDATA[<h1 id="SPOJ-KAOS-Trie-【字符串】"><a href="#SPOJ-KAOS-Trie-【字符串】" class="headerlink" title="SPOJ KAOS [Trie]【字符串】"></a>SPOJ KAOS [Trie]【字符串】</h1><p>2017年01月05日 22:17:18  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：374</p><p>个人分类：  <a href="https://blog.csdn.net/qq_33184171/article/category/6253262" target="_blank" rel="noopener"> 思维 </a> <a href="https://blog.csdn.net/qq_33184171/article/category/6362436" target="_blank" rel="noopener"><br>==== 字符串 ==== </a> <a href="https://blog.csdn.net/qq_33184171/article/category/6667053" target="_blank" rel="noopener"><br>SPOJ </a></p><hr><p> 博客爬取于<code>2019-04-18 17:18:39</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/54098779" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/54098779</a></p><p>题目连接: <a href="http://www.spoj.com/problems/KAOS/" target="_blank" rel="noopener"> http://www.spoj.com/problems/KAOS/</a><br>基本都是借（chao）鉴(xi)WannaflyUnion</p><p>——————————————————.<br>KAOS - Kaos</p><p>kaos</p><p>Little Lovro likes to play games with words. During the last few weeks he<br>realized that some words don’t like each other.</p><p>The words A and B don’t like each other if the word A is lexicographically<br>before the word B, but the word B’ is lexicographically before the word A’,<br>where X’ stands for the word X reversed (if X = “kamen”, then X’ = “nemak”).<br>For example, the words “lova” and “novac” like each other, but the words<br>“aron” and “sunce” don’t like each other.</p><p>Given some set of the words, we define the degree of chaos of the set as the<br>number of pairs of different words that don’t like each other.</p><p>Write a program that, given a set of words, finds the chaos degree for the<br>set.</p><p>input data</p><p>The first line of input contains an integer N, 2 ≤ N ≤ 100 000.</p><p>Each of the following N lines contains one word – a sequence of at most 10<br>lowercase letters of the English alphabet (‘a’ – ‘z’). There will be no two<br>identical words in the set.</p><p>output data</p><p>The first and only line of output should contain a single integer – the chaos<br>degree of the given set of words.<br>Note: use 64-bit signed integer type (int64 in Pascal, long long in C/C++)</p><p>examples</p><p>input</p><p>input</p><p>input</p><p>2</p><p>4</p><p>14</p><p>lopta</p><p>lova</p><p>branimir</p><p>kugla</p><p>novac</p><p>vladimir</p><p>aron</p><p>tom</p><p>output</p><p>sunce</p><p>kruz</p><p>0</p><p>bred</p><p>output</p><p>pit</p><p>3</p><p>zemlja</p><p>nije</p><p>ravna</p><p>ploca</p><p>ko</p><p>je</p><p>zapalio</p><p>zito</p><p>output</p><p>48</p><p>——————————————————.</p><p>题目大意：<br>就是给你一堆字符串，问你有多少对满足，正序时字典序a&gt;b且逆序时字典序b&gt;a的对数</p><p>解题思路:<br>很容易想到先对字符串按照字典序排序一遍,然后问题就能简化为仅仅判断逆序时字典序  s  t  r  i  &lt; s  t  r  j  ,  i  &lt; j<br>的对数就好了.<br>但是对于如何统计这个没有什么好的思路,最后看了WannaFlyUnion的题解才想到用Trie就好了..(不会字符串的渣渣根本没有向这方面想)</p><p>然后才惊人的发现,Trie树居然也可以用静态数组来实现,..</p><p>然后学习了… 这样就成了简单的Trie入门题了..</p><p>以下借（chao）鉴(xi)WannaflyUnion的题解代码</p><p>———————————————————————————-.</p><pre><code>#include &lt;bits/stdc++.h&gt;using namespace std;#define INF        (~(1&lt;&lt;31))#define INFLL      (~(1ll&lt;&lt;63))#define pb         push_back#define mp         make_pair#define abs(a)     ((a)&gt;0?(a):-(a))#define lalal      puts(&quot;*******&quot;);#define s1(x)      scanf(&quot;%d&quot;,&amp;x)#define Rep(a,b,c) for(int a=(b);a&lt;=(c);a++)#define Per(a,b,c) for(int a=(b);a&gt;=(c);a--)#define no         puts(&quot;NO&quot;)typedef long long int LL ;typedef unsigned long long int uLL ;const int MOD = 1e9+7;const int N = 1000000*2+5;const double eps = 1e-6;const double PI = acos(-1.0);void fre(){    freopen(&quot;in.txt&quot;,&quot;r&quot;,stdin);    freopen(&quot;out.txt&quot;,&quot;w&quot;,stdout);}/*************************************************/int a[N][27],f[N],cnt;string str[N];/**DAT（DFA）就是索引而已了cnt 来记录接下来的索引，仔细想一想就和模拟数组差不多的想法然后记录数据用的是另一个数组，a[k^n ? ][位数]  f[数据的范围]*/inline void insert(string str){    int len = str.length(),now = 0;    for(int i = len - 1; i &gt;= 0; --i){        if(!a[now][str[i]-&#39;a&#39;])            a[now][str[i]-&#39;a&#39;] = ++cnt;        now = a[now][str[i]-&#39;a&#39;];        ++f[now];    }}/**统计就是以abc来看分别统计的就是b**c***...ac**ad**..abd**abe**..abca**abcb***/int calc(string str){    int len = str.length(),now = 0,ans = 0;    for(int i = len - 1 ;i &gt;= 0;--i){        for(int j = str[i]-&#39;a&#39;+1;j&lt;26;++j)            ans += f[a[now][j]];        now = a[now][str[i]-&#39;a&#39;];    }    for(int i = 0;i&lt;26;++i) ans += f[a[now][i]];    return ans ;}int main(){    int n,ind;    LL ans;    while(~s1(n)){        Rep(i,1,n) cin &gt;&gt; str[i];        sort(str+1,str+1+n);        Rep(i,1,n)    cout&lt;&lt;str[i]&lt;&lt;endl;        memset(a,0,sizeof(a));        memset(f,0,sizeof(f));        ans = 0ll,cnt = 0;        Rep(i,1,n)   insert(str[i]),ans+=calc(str[i]);        printf(&quot;%lld\n&quot;,ans);    }    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 思维 </tag>
            
            <tag> 字符串 </tag>
            
            <tag> SPOJ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  算是年末总结吧。</title>
      <link href="/2016/12/31/53949605/"/>
      <url>/2016/12/31/53949605/</url>
      
        <content type="html"><![CDATA[<h1 id="算是年末总结吧。"><a href="#算是年末总结吧。" class="headerlink" title="算是年末总结吧。"></a>算是年末总结吧。</h1><p>2016年12月31日 03:54:03  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：577<br>标签：  <a href="https://so.csdn.net/so/search/s.do?q=acm&amp;t=blog" target="_blank" rel="noopener"> acm </a></p><p>个人分类：  <a href="https://blog.csdn.net/qq_33184171/article/category/6475846" target="_blank" rel="noopener"> 操蛋的ACM之路</a></p><hr><p> 博客爬取于<code>2019-04-18 17:18:40</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/53949605" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/53949605</a></p><p>今天2016/12/31日，大二上倒数第3天，距离下一赛季网选还有大概8个月。<br>先总结一下过去的一年半所做所为。<br>大一上：<br>听说了学院有一个叫做ACM的组织，然后来了3天，初步接触了C语言。第一次选拔赛很荣幸的没有被选拔上，然后经历了20多天的堕落（期间除了上网玩，没碰过一次键盘<br>），后来参加了第三次院内选拔赛，发挥比第一次强了一丢丢但是还是不太好。最后和学长一顿好说，终于算是同意我加入ACM了。然后的每天平时除了上课和在寝室睡觉，其<br>他时间都在实验室，当初所认知的有限，完全不知道算法都有什么，于是就整天刷校OJ。在听了最近的几次培训内容，在学长们的帮助下也算是了解了一些算法，但是对于当时<br>简单的算法还是不能很好掌握。日子一天天过去，迎来了第一次相对正式的ACM比赛，是院内举行的个人赛，很荣幸当时发挥不错得到了rank5。后来又与C和Z组队参加<br>了校团队赛，虽然名次不是很理想，但是毕竟才刚大一，时间还很多，还可以努力。于是一个学期就这么过去了。第一学期对文化课比较重视，题目又简单，再加上英语老师又那<br>么美丽，没有挂科。<br>大一寒假：<br>以前中学班任经常说的一句话，假期是一个很好的超过别人的机会，可是当时我并没有珍惜。记得是42天的假期，除了ACM学长们组织的训练之外，自己做的题目少的可怜，<br>刷题时间加起来不足20小时。一个假期就这么荒废了过去。<br>大一下：<br>新学期开学，提前就知道这学期比较忙，有蓝桥杯、校个人、省选和省赛，期间几乎每周都有训练/比赛。首先蓝桥杯还是做了一些准备了，幸运的是取了省1=，获得了北京的<br>参赛资格。去北京呆了四天，逛了逛故宫、圆明园，然后没啥准备就去了PKU比赛了，然后一道水题没有做对，一道计算几何没有模板。心态还是比较炸的。获得了3=的ra<br>nk10+，说不定多得一分就能拿2=的O(T_T)O。其次是校个人赛，虽然英文题面有一道前几天做过的题没有出比较遗憾，但是最终校内rank16还是比较开心的<br>。最后是省选+省赛，省选一共两场，从组队开始队伍配合就有着严重的问题，再加上那时候胃不好总打嗝影响了队友，导致队友输出削弱。还好最终还是通过省选拿到省赛参赛<br>资格。省赛就非常惨淡了，热身赛就开始懵逼，看着对面HIT金大爷队两个一血气球，顿时感到自己菜的一逼。决赛也只做出了两道简单的签到题，一道建边四层for能过的<br>题目我硬是要降到线性，然后GG。第二学期虽然不重视文化课了，但是靠前突击加上linlinsong学神的帮助下索性没有挂科（在此鸣谢linlinsong）。<br>大一暑假：<br>估计这段时间是我目前为止人生中最宝贵的一段时光了吧？<br>因为假期ACM暑期集训的缘故，假期时间并没有回家（因为家在同城还是回家取被子待了几个小时的）。因为之前的留校申请没有写所以最终无奈和队友们在学校附近租的房子<br>住了一个月。<br>七月份跟着NULL等巨巨挂的训练题目。穿插着多校训练（根本作不动，完全就是被虐的说）。回去没事打一打BC/CF，然后补补番+上网溜达溜达。七月份就过去了。<br>八月份，因为上层联系到HIT，所以ACM一堆人都去参加了HIT的暑期训练营，虽然去了那里基本跟不上那里的进度，但还是见到了好多HIT的dalao（可惜生的晚<br>了一年没有亲眼见到xiaodao)学到了不少东西，至少知道了之前所没听说过、没学过的算法，尤其是通过HIT才学会了数位DP（一直以来的痛，这个在网选上贡献很<br>大，如果最后一场网选鄙队没有AC拿到数位DP的话可能连被发配到杭州的资格也没有了）。最后由于鄙校与HIT开学时间不一样，无奈没有坚持到最后一天。<br>中间因为有着CCPC的网选，所以回西区打了网选，题目思路还好，就是因为一个变量没有用64位长整型，坑了一波队友。虽然在校内rank4，但是远远达不到取得现场<br>赛名额的水平，归根结底还是菜的一逼。<br>这个暑假是目前为止最为充实的一段时间了，基本每一天都在进步，每一天都能了解到新的东西。<br>大二上：<br>大二开学就是2016赛季的开始了，同时也是鄙院ACM吸收新鲜血液的时候，那时候真的是很忙得，但还是很开心的，有好多16级同学过来学习编程。由于受到学长抬举，<br>在ACM给了一个能说上几句话的职位，平时就是没事安排人给新生出/挂点题就好了，最后算是选拔了一些人来加入到ACM的学习中（但很讽刺的是根本没几个人来学习竞赛<br>的内容）。9月中上旬，有着多场网选，不幸的是鄙队没有一次发挥差不多的，校内排名最坏达到了11，好在长老向东北赛的举办方要来的几个名额加上学长打下来的正好是1<br>1个，艰难的获得了东北地区赛的名额。在最后一场网选中，在多队没有AC的情况下AC了一道数位DP排名上升了两名，所幸获得了被发配到杭州参赛的资格（至于杭州的悲<br>惨遭遇在渣渣的CSDN博客上有，可以百度【Tabris】第三个应该就是我的博客， 然后去博客左侧所搜【杭州】就出来了）。东北赛和省赛类似都是最后的几个小时我<br>在写题，不一样的是省赛时的思路可能就是错的（因为题目没有OJ公布所以一直没法补题）东北赛的题目思路确实是正解了，但由于本渣渣弱鸡一般的代码能力，一直没有调试<br>好代码，造成鄙队最终只出了3个签到题。然后基本除了带带新生就没有什么大事了。直到2016年的院赛，因为之前与老师沟通，这次院赛的题目命题工作被我和我的一名队<br>友（mengxiang000）接下来了，为了出这套题也是费了一些功夫，为了保密，只能偷偷的在实验室包了4次宿，为了有防止AK的情况，mengxiang000<br>还在高年租中加入了一道邀请Tommy巨巨出的一道防AK题目。但由于个人实力水平有限，在个人负责的两个题目中由于考虑不够周全，数据不强，导致有人水过，一定程度<br>的影响了一些参赛选手的成绩。然后就是校赛了，热身是16年上半年的个人赛题目，和队友无聊的水了三个一血。歇了一会二，就开始正式赛了，发挥还不错（主要是很多人都<br>为了拿奖金没有3人组队参赛），最后凭着手速拿了rank2，但也发现了和rank1的差距，差了两道题目（怪不得人家regional能拿金，我们在CCPC只能拿<br>铁233）。这一学期，由于自己对文化课的不重视，还不知道最后会挂几科。训练也不积极，真的是最咸鱼的一学期了。</p><p>=====================分割线================================<br>明明说好了是说自己大学来的所作所为，写着写着就变成了类似退役贴的东西？？！。但是除了竞赛我也确实没有什么好说的了，大学除了吃喝玩就是在睡觉，剩下点的时间就泡<br>在实验室里咸鱼。以致于造成现在这样一事无成的状况，文化课什么都不是，投入一些精力的竞赛还是啥也不是。细数数自己倒了大学妹子也没有，学习还不好，竞赛也只是个菜<br>鸡，玩的也不开心。一天天我到底在干什么？！学习？不，上课要么睡觉、要么玩手机。训练？不，好好训练也不至于现在这么菜。撩妹？no，现在还没有这个精力。<br>仔细想想这一天真的纯是混日子啊，无所事事。学习不好，安慰自己把精力投入到竞赛上了；竞赛不好，安慰自己还需要上课而没有充分的时间来训练。但是反思一下，在教室是<br>看竞赛方面的东西多还是玩游戏、睡觉多？显然是后者。典型的主观不努力，客观找原因的行为。还整天在抱怨ACM集训队实验室没有训练氛围（但也确实是，除了偶尔几个大<br>一的能刷几个题,真的没谁实在搞竞赛了，剩下的整日不是做项目，就是学文化课，再不就是 _ ** _<br>）。但还是自己作为ACM集训队的fhz，没有将实验室训练氛围带动起来的原因。<br>今天和队友算了一下日子，距离2017赛季大概也就是仅仅的8个月了，然而现在鄙队的竞赛水平还是菜的一逼，运气好了能在区域赛垫底拿一个牌子回来，运气不好就还是打<br>铁，回顾一下这一学期，真的是没什么收获，水平依然还是停留在哪个菜鸡的水平上，作为一个三流大学四流院系N流队伍中第三队员的我真的不知到应该用什么样的语言来训斥<br>我了。自己不努力，还妄想着要怎样怎样，简直痴人说梦。<br>在此立下几个flag（行了队友知道就行了，说出去大家会笑话的）。希望今年能完成这些中的大部分。在一个是距离下一个赛季仅有8个月左右的时间了，确实应该闭关修炼<br>一波了。想想8个月之后，我也应该退役了吧？时间过得真快，如果真的退役了，也不知道以后到底能去做什么。顺气自然吧，先把这8个月过好，对得起自己最后的一点点青春<br>。</p><p>=========语文不好，如果真有人赏脸给面子看了这点牢骚，原谅我这搓逼的语文==========</p><p>最后附上两张巨巨的语录提醒自己应该干什么，少水群啊，多做题！！！。</p>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> acm </tag>
            
            <tag> 操蛋的ACM之路 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  POJ 3667 Hotel [线段树+区间更新]【数据结构】</title>
      <link href="/2016/12/28/53912212/"/>
      <url>/2016/12/28/53912212/</url>
      
        <content type="html"><![CDATA[<h1 id="POJ-3667-Hotel-线段树-区间更新-【数据结构】"><a href="#POJ-3667-Hotel-线段树-区间更新-【数据结构】" class="headerlink" title="POJ 3667 Hotel [线段树+区间更新]【数据结构】"></a>POJ 3667 Hotel [线段树+区间更新]【数据结构】</h1><p>2016年12月28日 19:13:06  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：237</p><hr><p> 博客爬取于<code>2019-04-18 17:18:41</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/53912212" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/53912212</a></p><p>题目链接: <a href="http://poj.org/problem?id=3667" target="_blank" rel="noopener"> http://poj.org/problem?id=3667 </a></p><p>———————————————————————————.<br>Hotel<br>Time Limit: 3000MS Memory Limit: 65536K<br>Total Submissions: 16674 Accepted: 7234<br>Description</p><p>The cows are journeying north to Thunder Bay in Canada to gain cultural<br>enrichment and enjoy a vacation on the sunny shores of Lake Superior. Bessie,<br>ever the competent travel agent, has named the Bullmoose Hotel on famed<br>Cumberland Street as their vacation residence. This immense hotel has N (1 ≤ N<br>≤ 50,000) rooms all located on the same side of an extremely long hallway (all<br>the better to see the lake, of course).</p><p>The cows and other visitors arrive in groups of size Di (1 ≤ Di ≤ N) and<br>approach the front desk to check in. Each group i requests a set of Di<br>contiguous rooms from Canmuu, the moose staffing the counter. He assigns them<br>some set of consecutive room numbers r..r+Di-1 if they are available or, if no<br>contiguous set of rooms is available, politely suggests alternate lodging.<br>Canmuu always chooses the value of r to be the smallest possible.</p><p>Visitors also depart the hotel from groups of contiguous rooms. Checkout i has<br>the parameters Xi and Di which specify the vacating of rooms Xi ..Xi +Di-1 (1<br>≤ Xi ≤ N-Di+1). Some (or all) of those rooms might be empty before the<br>checkout.</p><p>Your job is to assist Canmuu by processing M (1 ≤ M &lt; 50,000) checkin/checkout<br>requests. The hotel is initially unoccupied.</p><p>Input</p><ul><li>Line 1: Two space-separated integers: N and M </li><li>Lines 2..M+1: Line i+1 contains request expressed as one of two possible formats: (a) Two space separated integers representing a check-in request: 1 and Di (b) Three space-separated integers representing a check-out: 2, Xi, and Di </li></ul><p>Output</p><ul><li>Lines 1…..: For each check-in request, output a single line with a single integer r, the first room in the contiguous sequence of rooms to be occupied. If the request cannot be satisfied, output 0. </li></ul><p>Sample Input</p><p>10 6<br>1 3<br>1 3<br>1 3<br>1 3<br>2 5 5<br>1 6<br>Sample Output</p><p>1<br>4<br>7<br>0<br>5<br>Source</p><p>USACO 2008 February Gold<br>——————————————————————————–.</p><p>题目大意:<br>就是在  [  1  ,  n  ]  这个区间.<br>有两种操作<br>1) x 问你有没有连续x个的空房,有的话就在最左面的住进去,输出最左边的房间号,没有的话就输出0;<br>2) a b 就是从a开始接下来的b个房间的人退房 也就是  [  a  ,  a  +  b  −  1  ]  这个区间的房间都退房了.</p><p>解题思路:<br>还是基本的想到了线段树的区间更新.<br>不一样的就是这次要查找的是连续的x个长度,<br>这点想了好久,最后还是想到在节点上增加两个值,来代表区间中最左边有多少个连续的,最右边代表有多少个连续的,原本的值来代表区间内最大的连续的长度是多少.然后维<br>护一下就行了.</p><p>思路构建的很容易 ,但是最后代码实现的时候发现好麻烦啊,因为一个rr写成了ll 硬是调试了2个小时有没有啊……..</p><p>跟普通的区间更新差别也就是在pushup和pushdown两个操作上面.<br><strong> pushup </strong></p><pre><code>/*维护左右的最大值,在维护区间内的最大值就好了*/void pushup(int rt){    if(tree[ll].ls == tree[ll].len())        tree[rt].ls = tree[ll].len() + tree[rr].ls;    else tree[rt].ls = tree[ll].ls;    if(tree[rr].rs == tree[rr].len())        tree[rt].rs = tree[rr].len() + tree[ll].rs;    else tree[rt].rs = tree[rr].rs;    tree[rt].val = max(tree[ll].rs + tree[rr].ls,max(tree[rr].val,tree[ll].val));}</code></pre><p><strong> pushdown </strong></p><pre><code>/*这时候0代表入房1代表退房维护的时候直接tree[ll].len()*tree[rt].lazy;就好了 方便  代码还短一点.*/void pushdown(int rt){    if(tree[rt].lazy != -1){        tree[ll].lazy = tree[rr].lazy = tree[rt].lazy;        tree[ll].val  = tree[ll].ls   = tree[ll].rs = tree[ll].len()*tree[rt].lazy;        tree[rr].val  = tree[rr].ls   = tree[rr].rs = tree[rr].len()*tree[rt].lazy;        tree[rt].val  = tree[rt].ls   = tree[rt].rs = tree[rt].len()*tree[rt].lazy;        tree[rt].lazy = -1;    }}</code></pre><p>附本题代码</p><pre><code>//#include &lt;bits/stdc++.h&gt;#include &lt;stdio.h&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;string.h&gt;#include &lt;math.h&gt;#include &lt;vector&gt;#include &lt;map&gt;#include &lt;queue&gt;using namespace std;#define INF        (~(1&lt;&lt;31))#define INFLL      (~(1ll&lt;&lt;63))#define pb         push_back#define mp         make_pair#define abs(a)     ((a)&gt;0?(a):-(a))#define lalal      puts(&quot;*******&quot;);#define s1(x)      scanf(&quot;%d&quot;,&amp;x)#define Rep(a,b,c) for(int a=(b);a&lt;=(c);a++)#define Per(a,b,c) for(int a=(b);a&gt;=(c);a--)#define no         puts(&quot;NO&quot;)typedef long long int LL ;typedef unsigned long long int uLL ;const int    MOD = 1e9+7;const int    N   = 50000+5;const double eps = 1e-6;const double PI  = acos(-1.0);/***********************************************************************/struct node {    int l,r;    int val;    int ls,rs;    int lazy;    int md(){return (l+r)&gt;&gt;1;}    int len(){return (r-l+1);}}tree[N&lt;&lt;2];#define ll  (rt&lt;&lt;1)#define rr  (rt&lt;&lt;1|1)#define mid (tree[rt].md())void pushup(int rt){    if(tree[ll].ls == tree[ll].len())        tree[rt].ls = tree[ll].len() + tree[rr].ls;    else tree[rt].ls = tree[ll].ls;    if(tree[rr].rs == tree[rr].len())        tree[rt].rs = tree[rr].len() + tree[ll].rs;    else tree[rt].rs = tree[rr].rs;    tree[rt].val = max(tree[ll].rs + tree[rr].ls,max(tree[rr].val,tree[ll].val));}void build(int rt,int l,int r){    tree[rt].l  =l,tree[rt].r=r,tree[rt].lazy=-1;    tree[rt].val=tree[rt].ls=tree[rt].rs=tree[rt].len();    if(l==r) return ;    build(ll,l,mid);    build(rr,mid+1,r);}void pushdown(int rt){    if(tree[rt].lazy != -1){        tree[ll].lazy = tree[rr].lazy = tree[rt].lazy;        tree[ll].val  = tree[ll].ls   = tree[ll].rs = tree[ll].len()*tree[rt].lazy;        tree[rr].val  = tree[rr].ls   = tree[rr].rs = tree[rr].len()*tree[rt].lazy;        tree[rt].val  = tree[rt].ls   = tree[rt].rs = tree[rt].len()*tree[rt].lazy;        tree[rt].lazy = -1;    }}void update(int rt,int L,int R,int op){  //update 就是将 所有的 [a,a+b-1] 清一下    if(L&lt;=tree[rt].l&amp;&amp;tree[rt].r&lt;=R){        if(1 == op){ //入住            tree[rt].val = tree[rt].ls   = tree[rt].rs = 0;            tree[rt].lazy = 0;        }        else {  //退房            tree[rt].val  = tree[rt].ls   = tree[rt].rs = tree[rt].len();            tree[rt].lazy = 1;        }        return ;    }    pushdown(rt);    if(L&lt;=mid) update(ll,L,R,op);    if(R&gt; mid) update(rr,L,R,op);    pushup(rt);}int query(int rt,int val){    if(tree[rt].l==tree[rt].r){        if(val == tree[rt].val) return tree[rt].l;        return 0;    }    pushdown(rt);    if(tree[ll].val&gt;=val)        return query(ll,val);    else if(tree[rr].ls+tree[ll].rs &gt;= val)        return tree[ll].r-tree[ll].rs+1;    else if(tree[rr].val &gt;= val)        return query(rr,val);    return 0;}int main(){    int n,m;    int op,a,b;    while(~s1(n)){        s1(m);        build(1,1,n);        Rep(i,1,m){            s1(op);            if(1==op){                s1(a);                int tem = query(1,a);                if(tem)   update(1,tem,a+tem-1,op);                printf(&quot;%d\n&quot;,tem);            }            else {                s1(a),s1(b);                update(1,a,a+b-1,op);            }        }    }    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  POJ 1436 Horizontally Visible Segments [线段树-区间更新]【数据结构】</title>
      <link href="/2016/12/09/53541831/"/>
      <url>/2016/12/09/53541831/</url>
      
        <content type="html"><![CDATA[<h1 id="POJ-1436-Horizontally-Visible-Segments-线段树-区间更新-【数据结构】"><a href="#POJ-1436-Horizontally-Visible-Segments-线段树-区间更新-【数据结构】" class="headerlink" title="POJ 1436 Horizontally Visible Segments [线段树-区间更新]【数据结构】"></a>POJ 1436 Horizontally Visible Segments [线段树-区间更新]【数据结构】</h1><p>2016年12月09日 17:08:59  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：181</p><hr><p> 博客爬取于<code>2019-04-18 17:18:42</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/53541831" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/53541831</a></p><p>题目链接： <a href="http://poj.org/problem?id=1436" target="_blank" rel="noopener"> http://poj.org/problem?id=1436 </a><br>————————————————————————-.<br>Horizontally Visible Segments<br>Time Limit: 5000MS Memory Limit: 65536K<br>Total Submissions: 5262 Accepted: 1932<br>Description</p><p>There is a number of disjoint vertical line segments in the plane. We say that<br>two segments are horizontally visible if they can be connected by a horizontal<br>line segment that does not have any common points with other vertical<br>segments. Three different vertical segments are said to form a triangle of<br>segments if each two of them are horizontally visible. How many triangles can<br>be found in a given set of vertical segments?</p><p>Task</p><p>Write a program which for each data set:</p><p>reads the description of a set of vertical segments,</p><p>computes the number of triangles in this set,</p><p>writes the result.<br>Input</p><p>The first line of the input contains exactly one positive integer d equal to<br>the number of data sets, 1 &lt;= d &lt;= 20. The data sets follow.</p><p>The first line of each data set contains exactly one integer n, 1 &lt;= n &lt;= 8<br>000, equal to the number of vertical line segments.</p><p>Each of the following n lines consists of exactly 3 nonnegative integers<br>separated by single spaces:</p><p>yi’, yi”, xi - y-coordinate of the beginning of a segment, y-coordinate of its<br>end and its x-coordinate, respectively. The coordinates satisfy 0 &lt;= yi’ &lt; yi”<br>&lt;= 8 000, 0 &lt;= xi &lt;= 8 000. The segments are disjoint.<br>Output</p><p>The output should consist of exactly d lines, one line for each data set. Line<br>i should contain exactly one integer equal to the number of triangles in the<br>i-th data set.<br>Sample Input</p><p>1<br>5<br>0 4 4<br>0 3 1<br>3 4 2<br>0 2 2<br>0 2 3<br>Sample Output</p><p>1<br>Source</p><p>Central Europe 2001<br>—————————————————————————.<br>题目大意：<br>就是在二维平面上有 <strong> n </strong> 个平行于 <strong> Y </strong> 轴的线段，问你两两能用水平线（平行于 <strong> X </strong> 轴）直接连接在一起的三元组有多少个。<br>大概就这意思吧</p><p>解题思路：<br>遇到知道题目的做法一定是考虑怎么判断两个线段是不是能够直接连接在一起的，其实只要维护一个线段树从左向右或者从右向左扫一遍就行了，对于每个线段每个都染色，维护<br>最左或最右边的颜色就行了，只要先 <strong> 查询 </strong> ，后 <strong> 更新 </strong> 就能判断出当前的线段和之前出现过的几个线段能够直接相连接的了。<br>但是要注意的是，在维护线段树的时候不能直接用（y1,y2）来更新。因为会在（1,4,1）（1,2,2）（3,4,2）（1,4,3）这样的情况下出现第四条线段<br>查询的时候查询不到第一条，所以维护的室友要用（y1<em>2,y2</em>2）来维护，这样的话。就能空出来一个5，这样就能够查询到了。<br>期间两个边的链接关系用一个bool型的二维数组就可以了,这样不会MLE了<br>最后统计结果的时候因为时间给的很宽只要三层for中间剪下枝就能怼过去了。</p><p>※数据不保证一定是从左到右的 一定要 <strong> 排序啊 </strong> .<br>附本题代码<br>——————————————————————————————–.</p><pre><code>//#include &lt;bits/stdc++.h&gt;#include &lt;stdio.h&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;string.h&gt;#include &lt;math.h&gt;#include &lt;vector&gt;#include &lt;map&gt;#include &lt;queue&gt;using namespace std;#define INF         (~(1&lt;&lt;31))#define INFLL       (~(1ll&lt;&lt;63))#define pb          push_back#define mp          make_pair#define abs(a)      ((a)&gt;0?(a):-(a))#define lalal       puts(&quot;*******&quot;);#define s1(x)       scanf(&quot;%d&quot;,&amp;x)#define Rep(a,b,c)  for(int a=(b);a&lt;=(c);a++)typedef long long int LL ;typedef unsigned long long int uLL ;const int MOD = 1e9+7;const int N = 8000+5;const double eps = 1e-6;const double PI = acos(-1.0);/***********************************************************************/bool path[N][N];struct node {    int l,r;    int val;    int md() {return (l+r)&gt;&gt;1;}    int len(){return (r-l+1);}}tree[N&lt;&lt;3];#define ll  (rt&lt;&lt;1)#define rr  (rt&lt;&lt;1|1)#define mid (tree[rt].md())void build(int rt,int l,int r){    tree[rt].l=l,tree[rt].r=r,tree[rt].val=0;    if(l==r)    return ;    build(ll,l,mid);    build(rr,mid+1,r);}void pushdown(int rt){    if(tree[rt].val)    {        tree[ll].val = tree[rr].val = tree[rt].val;        tree[rt].val =0;    }}void update(int rt,int &amp;L,int &amp;R,int &amp;val){    if(L&lt;=tree[rt].l&amp;&amp;tree[rt].r&lt;=R){tree[rt].val=val;return ;}    pushdown(rt);    if(L&lt;=mid) update(ll,L,R,val);    if(R&gt; mid) update(rr,L,R,val);    return ;}void query(int rt,int &amp;L,int &amp;R,int &amp;id){    if(tree[rt].val){path[id][tree[rt].val]=true; return ;}    if(tree[rt].l==tree[rt].r) return ;    if(L&lt;=mid) query(ll,L,R,id);    if(R&gt; mid) query(rr,L,R,id);    return ;}struct segment{    int y1,y2,x1;}e[N];bool cmp (segment A,segment B){    return A.x1&lt;B.x1;}int main(){    int _;    while(~s1(_))    {        while(_--)        {            int n;            s1(n);            memset(path,0,sizeof(path));            build(1,0,8000*2);            int y1,y2,x1;            Rep(i,1,n)            {                s1(y1),s1(y2),s1(x1);                e[i].y1=(y1&lt;&lt;1);                e[i].y2=(y2&lt;&lt;1);                e[i].x1=x1;            }            sort(e+1,e+n+1,cmp);            Rep(i,1,n)            {                query (1,e[i].y1,e[i].y2,i);                update(1,e[i].y1,e[i].y2,i);            }            LL sum = 0;            Rep(i,1,n)Rep(j,1,n)                if(path[i][j])                    Rep(k,1,n)if(path[i][k]&amp;&amp;path[k][j]) sum++;            printf(&quot;%d\n&quot;,sum);  //因为只存了单向边  所以就不用去重了        }    }    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  广工2016新生决赛 H《为什么会变成这样呢》 [位运算]【思维】【好题】</title>
      <link href="/2016/12/07/53510746/"/>
      <url>/2016/12/07/53510746/</url>
      
        <content type="html"><![CDATA[<h1 id="广工2016新生决赛-H《为什么会变成这样呢》-位运算-【思维】【好题】"><a href="#广工2016新生决赛-H《为什么会变成这样呢》-位运算-【思维】【好题】" class="headerlink" title="广工2016新生决赛 H《为什么会变成这样呢》 [位运算]【思维】【好题】"></a>广工2016新生决赛 H《为什么会变成这样呢》 [位运算]【思维】【好题】</h1><p>2016年12月07日 21:39:16  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：580</p><hr><p> 博客爬取于<code>2019-04-18 17:18:43</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/53510746" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/53510746</a></p><p>题目连接： <a href="http://gdutcode.sinaapp.com/problem.php?cid=1051&amp;pid=7" target="_blank" rel="noopener"> http://gdutcode.sinaapp.com/problem.php?cid=1051&amp;pid=7</a></p><p>—————————————–.<br>《为什么会变成这样呢》<br>Problem Description：<br>“第一次有了喜欢的人，还得到了一生的挚友，两份喜悦互相重叠，这双重的喜悦又带来了更多更多的喜悦，本应已经得到了梦幻一般的幸福时光，然而，为什么，会变成这样呢<br>？”双重的喜悦感却无法带来更多的幸福，现在，雪菜在很多喜悦感之中只想要得到两份不重叠的喜悦感（其他的喜悦感都是重叠的），你能帮她找出这两份不同的喜悦感是多少<br>吗？</p><p>Input：<br>第一行一个整数T，代表数据的组数（1&lt;=T&lt;=10）,接下来T组数据，每组数据的第一行是一个整数n（1&lt;=n&lt;=1000000），第二行是n个整数ai（0<br>&lt;= ai &lt;= 1000000000）代表喜悦感，每两个整数之间有一个空格，题目保证有且仅有两个不同的整数出现一次，其他的整数都是出现两次。</p><p>Output：<br>对于每组数据，输出两个整数，分别代表两份不同的喜悦感，中间有一个空格，并且喜悦感较小的先输出。</p><p>Sample input：<br>2<br>6<br>2 2 1 1 3 4<br>4<br>1 1 3 4</p><p>Sample output：<br>3 4<br>3 4</p><p>——————————————————-.</p><p>题意：中文题 不解释，</p><p>解题思路：<br>遇到这个题目 大家应该都能想出来  O  (  n  l  o  g  n  )  的做法,只要先排个序 ,然后找在扫一遍就行了. 但是这题的 <strong><br>时限只有1000ms </strong> ,所以就 <strong> TLE </strong> 了</p><p>正解是采用位运算 用  O  (  n  )  的做法</p><p>首先考虑,除了要求的两个数之外,其他的数都有2个 那么 对于所有的数异或的话,结果就是目标两个数的异或和,<br>因为这两个数不同,所以异或的结果一定&gt;0<br>这时候考虑,异或的结果在某二进制上的某一个1 一定是目标数的其中一个贡献的,那么只要讲  a  1  ,  a  2  ,  .  .  .  ,  a<br>n  之间的在同二进制位下为1/0的分成两部分分别求异或和,结果一定是目标数.</p><p>输出的时候判断下大小就好了</p><p>附本题代码<br>—————————————-.</p><pre><code>#include &lt;bits/stdc++.h&gt;#define abs(a)  (((a)&gt;0)?(a):-(a))typedef long long int LL;using namespace std;const int N = 1e6+7;/******************************************/int a[N];int main(){    int _;    while(~scanf(&quot;%d&quot;,&amp;_))    {        while(_--)        {            int n,x;            scanf(&quot;%d&quot;,&amp;n);            for(int i=1; i&lt;=n; i++)                scanf(&quot;%d&quot;,&amp;a[i]),x^=a[i];            int num1 = 0, num2 = 0;            int tmp = 1;            while(!(tmp &amp; x)) tmp &lt;&lt;= 1;            for(int i = 1; i &lt;= n; i++)            {                if(tmp &amp; a[i]) num1 ^= a[i];                else num2 ^= a[i];            }            printf(&quot;%d %d\n&quot;, min(num1, num2), max(num1, num2));        }    }    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  2016ZSTU新生赛个人题解 【未完待续。。】</title>
      <link href="/2016/11/30/53413365/"/>
      <url>/2016/11/30/53413365/</url>
      
        <content type="html"><![CDATA[<h1 id="2016ZSTU新生赛个人题解-【未完待续。。】"><a href="#2016ZSTU新生赛个人题解-【未完待续。。】" class="headerlink" title="2016ZSTU新生赛个人题解 【未完待续。。】"></a>2016ZSTU新生赛个人题解 【未完待续。。】</h1><p>2016年11月30日 20:30:18  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：470</p><hr><p> 博客爬取于<code>2019-04-18 17:18:44</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/53413365" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/53413365</a></p><p>大二选手做新生题目，最后累死累活做了8道(3H) ，剩下的待补。。。<br>还是太菜 ,继续努力</p><p>———————————————————————————————————————-.<br><a href="http://oj.acm.zstu.edu.cn/JudgeOnline/problem.php?id=4238" target="_blank" rel="noopener"> Save the Princess</a><br>题目大意 ：就是有两个人要去九公主 ，一共有Ｎ个人　公主在第Ｋ个位置，两人轮流杀强盗，杀完最后一个强盗的人赢</p><p>解题思路：<br>没什么好说的，把题读明白就行了。<br>就是判断ｎ的奇偶性。</p><pre><code>//#include &lt;bits/stdc++.h&gt;#include &lt;stdio.h&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;string.h&gt;#include &lt;math.h&gt;#include &lt;vector&gt;#include &lt;queue&gt;using namespace std;#define INF         2100000000ll#define pb          push_back#define mp          make_pair#define abs(a)      ((a)&gt;0?(a):-(a))#define lalal       puts(&quot;*******&quot;);#define s1(x)       scanf(&quot;%d&quot;,&amp;x)#define Rep(a,b,c)  for(int a=(b);a&lt;=(c);a++)typedef long long int LL ;typedef unsigned long long int LLu ;/*******************************/const int MOD = 1e9+7;const int N = 1000005;const double eps = 1e-9;int main(){    int _;    while(~s1(_))    {        while(_--)        {            int n,k;            s1(n),s1(k);            if(n&amp;1) puts(&quot;BH&quot;);            else    puts(&quot;LYF&quot;);        }    }    return 0;}</code></pre><p>———————————————————————————————————————-.<br><a href="http://oj.acm.zstu.edu.cn/JudgeOnline/problem.php?id=4239" target="_blank" rel="noopener"> 巴比伦花园 </a><br>这题我不会　，待补。。<br>———————————————————————————————————————-.<br><a href="http://oj.acm.zstu.edu.cn/JudgeOnline/problem.php?id=4240" target="_blank" rel="noopener"> 极差 </a><br>题目:中文题</p><p>解题思路:<br>水题,只要扫一遍,维护个最大最小值,然后想减即可.</p><pre><code>//#include &lt;bits/stdc++.h&gt;#include &lt;stdio.h&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;string.h&gt;#include &lt;math.h&gt;#include &lt;vector&gt;#include &lt;queue&gt;using namespace std;#define INF         2100000000ll#define pb          push_back#define mp          make_pair#define abs(a)      ((a)&gt;0?(a):-(a))#define lalal       puts(&quot;*******&quot;);#define s1(x)       scanf(&quot;%d&quot;,&amp;x)#define Rep(a,b,c)  for(int a=(b);a&lt;=(c);a++)typedef long long int LL ;typedef unsigned long long int LLu ;/*******************************/const int MOD = 1e9+7;const int N = 100000+5;const double eps = 1e-9;LL a[N];int main(){    int _;    while(~s1(_))    {        while(_--)        {            int n,k,q;            s1(n);//,s1(k),s1(q);            int mx= -1,mi=INF,x;            Rep(i,1,n) {                s1(x);                if(x&gt;mx) mx=x;                if(x&lt;mi) mi=x;            }            printf(&quot;%d\n&quot;,mx-mi);        }    }    return 0;}</code></pre><p>———————————————————————————————————————-.<br><a href="http://oj.acm.zstu.edu.cn/JudgeOnline/problem.php?id=4241" target="_blank" rel="noopener"> 圣杯战争 </a><br>还没有做这道题 ,做了也出不了…<br>———————————————————————————————————————-.<br><a href="http://oj.acm.zstu.edu.cn/JudgeOnline/problem.php?id=4242" target="_blank" rel="noopener"> 校庆 </a><br>题意 : 中文题</p><p>解题思路:直接暴力模拟,<br>(和2016hrbust校个人赛相似 ,就xjb搞就行</p><pre><code>//#include &lt;bits/stdc++.h&gt;#include &lt;stdio.h&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;string.h&gt;#include &lt;math.h&gt;#include &lt;vector&gt;#include &lt;queue&gt;using namespace std;#define INF         2100000000ll#define pb          push_back#define mp          make_pair#define abs(a)      ((a)&gt;0?(a):-(a))#define lalal       puts(&quot;*******&quot;);#define s1(x)       scanf(&quot;%d&quot;,&amp;x)#define Rep(a,b,c)  for(int a=(b);a&lt;=(c);a++)typedef long long int LL ;typedef unsigned long long int LLu ;/*******************************/const int MOD = 1e9+7;const int N = 100000+5;const double eps = 1e-9;int mon[]={0,31,28,31,30,31,30,31,31,30,31,30,31};int dsum[]={};int check(int y,int m,int d){    if((y%4==0&amp;&amp;y%100!=0)||y%400==0) return 1;    return 0;}bool judge(int y,int m,int d){    if(y==2017&amp;&amp;m==10&amp;&amp;d==28) return true;    return false;}int main(){    int _;    while(~s1(_))    {        while(_--)        {            int y,m,d;            s1(y),s1(m),s1(d);            int days= 0;            while(true)            {                if(judge(y,m,d)) break;                days++;                if(m==1){                    if(d==mon[m]) m++,d=1;                    else d++;                }                else if(m==2){                    if(d==(mon[m]+check(y,m,d)))m++,d=1;                    else d++;                }                else if(m==3){                    if(d==mon[m]) m++,d=1;                    else d++;                }                else if(m==4){                    if(d==mon[m]) m++,d=1;                    else d++;                }                else if(m==5){                    if(d==mon[m]) m++,d=1;                    else d++;                }                else if(m==6){                    if(d==mon[m]) m++,d=1;                    else d++;                }                else if(m==7){                    if(d==mon[m]) m++,d=1;                    else d++;                }                else if(m==8){                    if(d==mon[m]) m++,d=1;                    else d++;                }                else if(m==9){                    if(d==mon[m]) m++,d=1;                    else d++;                }                else if(m==10){                    if(d==mon[m]) m++,d=1;                    else d++;                }                else if(m==11){                    if(d==mon[m]) m++,d=1;                    else d++;                }                else if(m==12){                    if(d==mon[m]) y++,m=1,d=1;                    else d++;                }            }            printf(&quot;%d\n&quot;,days);        }    }    return 0;}</code></pre><p>———————————————————————————————————————-.<br><a href="http://oj.acm.zstu.edu.cn/JudgeOnline/problem.php?id=4243" target="_blank" rel="noopener"> 牛吃草 </a><br>题意 : 中文题</p><p>解题思路：<br>直接对牛能吃草的面积二分答案即可<br>check部分用相交圆面积计算即可；<br><a href="http://blog.csdn.net/qq_33184171/article/details/51114511" target="_blank" rel="noopener"> 不知道相交圆面积如何求的戳这里 </a><br>二分范围即  [  0  ,  d  i  s  (  牛  ,  圆  心  )  +  半  径  ]<br>(如果不考虑牛在园内  [  d  i  s  (  牛  ,  圆  心  )  ,  d  i  s  (  牛  ,  圆  心  )  +  半<br>径  ]  ,这样的话绝对会WA</p><pre><code>//#include &lt;bits/stdc++.h&gt;#include &lt;stdio.h&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;string.h&gt;#include &lt;math.h&gt;#include &lt;vector&gt;#include &lt;queue&gt;using namespace std;#define INF         2100000000ll#define pb          push_back#define mp          make_pair#define abs(a)      ((a)&gt;0?(a):-(a))#define lalal       puts(&quot;*******&quot;);#define s1(x)       scanf(&quot;%d&quot;,&amp;x)#define Rep(a,b,c)  for(int a=(b);a&lt;=(c);a++)typedef long long int LL ;typedef unsigned long long int LLu ;/*******************************/const int MOD = 1e9+7;const int N = 100000+5;const double eps = 1e-6;const double PI = acos(-1.0);struct Round {    double x, y;    double r;}c1,c2;double dis(Round p1,Round p2){    return(sqrt((p1.x-p2.x)*(p1.x-p2.x)+(p1.y-p2.y)*(p1.y-p2.y)));}double solve(Round a, Round b){    double d = dis(a, b);    if (d &gt;= a.r + b.r)        return 0;    if (d &lt;= fabs(a.r - b.r))    {        double r = a.r &lt; b.r ? a.r : b.r;        return PI * r * r;    }    double ang1 = acos((a.r * a.r + d * d - b.r * b.r) / 2. / a.r / d);    double ang2 = acos((b.r * b.r + d * d - a.r * a.r) / 2. / b.r / d);    double ret = ang1 * a.r * a.r + ang2 * b.r * b.r - d * a.r * sin(ang1);    return ret;}int main(){    int _;    while(~s1(_))    {        while(_--)        {            scanf(&quot;%lf&quot;,&amp;c2.x);            scanf(&quot;%lf&quot;,&amp;c2.y);            scanf(&quot;%lf&quot;,&amp;c1.x);            scanf(&quot;%lf&quot;,&amp;c1.y);            scanf(&quot;%lf&quot;,&amp;c2.r);            double area = PI*c2.r*c2.r/2.0;            double l=0,r=dis(c1,c2)+c2.r,mid;            //printf(&quot;%lf\n&quot;,c2.r);            while(abs(r-l)&gt;eps)            {                mid = (l+r)/2.0;                c1.r= mid;                if(solve(c1,c2)+eps&gt;area)   r=mid;                else    l=mid;            }            printf(&quot;%.4lf\n&quot;,c1.r);        }    }    return 0;}</code></pre><p>———————————————————————————————————————-.<br><a href="http://oj.acm.zstu.edu.cn/JudgeOnline/problem.php?id=4244" target="_blank" rel="noopener"> 众数 </a><br>题意 : 中文题</p><p>解题思路:<br>水题,还是扫一遍就行了;</p><pre><code>//#include &lt;bits/stdc++.h&gt;#include &lt;stdio.h&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;string.h&gt;#include &lt;math.h&gt;#include &lt;vector&gt;#include &lt;queue&gt;using namespace std;#define INF         2100000000ll#define pb          push_back#define mp          make_pair#define abs(a)      ((a)&gt;0?(a):-(a))#define lalal       puts(&quot;*******&quot;);#define s1(x)       scanf(&quot;%d&quot;,&amp;x)#define Rep(a,b,c)  for(int a=(b);a&lt;=(c);a++)typedef long long int LL ;typedef unsigned long long int LLu ;/*******************************/const int MOD = 1e9+7;const int N = 100000+5;const double eps = 1e-9;int a[N];int ha[10001];int main(){    int _;    while(~s1(_))    {        while(_--)        {            int n;            s1(n);            int mx=-1,pre=0;            int x;            Rep(i,1,1000) ha[i]=0;            Rep(i,1,n) s1(x),ha[x]++;            Rep(i,1,1000)            {                if(ha[i]&gt;mx)                {                    mx=ha[i];                    pre=i;                }            }            int flag= 0;            Rep(i,1,1000)            {                if(ha[i]==mx)                {                    if(flag) printf(&quot; &quot;);                    printf(&quot;%d&quot;,i);                    flag=1;                }            }            puts(&quot;&quot;);        }    }    return 0;}</code></pre><p>———————————————————————————————————————-.<br><a href="http://oj.acm.zstu.edu.cn/JudgeOnline/problem.php?id=4245" target="_blank" rel="noopener"> KI的斐波那契 </a><br>题意 : 中文题</p><p>解题思路:<br>首先考虑 ,字符串的变化规律和斐波那契是相同的规律的<br>那么我们可以将一个大的数依次减去斐波那契数列变成一个很小的值,这样的话我们就直接能求出来了.</p><p>(其实这样看的话 我的代码还是能优化很多的,直接让fibo数变成0or1 的话 根本不用写这么长..</p><pre><code>//#include &lt;bits/stdc++.h&gt;#include &lt;stdio.h&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;string.h&gt;#include &lt;math.h&gt;#include &lt;vector&gt;#include &lt;queue&gt;using namespace std;#define INF         2100000000ll#define pb          push_back#define mp          make_pair#define abs(a)      ((a)&gt;0?(a):-(a))#define lalal       puts(&quot;*******&quot;);#define s1(x)       scanf(&quot;%d&quot;,&amp;x)#define Rep(a,b,c)  for(int a=(b);a&lt;=(c);a++)typedef long long int LL ;typedef unsigned long long int LLu ;/*******************************/const int MOD = 1e9+7;const int N = 100000+5;const double eps = 1e-9;char ch[100][100]={    &quot;0b\n&quot;,    &quot;0a\n&quot;,    &quot;0ab\n&quot;,    &quot;0aba\n&quot;,    &quot;0abaab\n&quot;,    &quot;0abaababa\n&quot;,    &quot;0abaababaabaab\n&quot;,    &quot;0abaababaabaababaababa\n&quot;,    &quot;0abaababaabaababaababaabaababaabaab\n&quot;,    &quot;0abaababaabaababaababaabaababaabaababaababaabaababaababa\n&quot;};LL f[100];int main(){    f[0]=1ll,f[1]=1ll;    Rep(i,2,90)    {        f[i]=f[i-1]+f[i-2];        //printf(&quot;%lld\n&quot;,f[i]);    }    //Rep(i,0,9)   puts(ch[i]);    int _;    while(~s1(_))    {        while(_--)        {            int n;            s1(n);            LL m;            scanf(&quot;%lld&quot;,&amp;m);            if(n==0&amp;&amp;m==1ll)            {                puts(&quot;b&quot;);                continue;            }            while(m&gt;55)            {                Rep(i,1,90)                {                    if(f[i+1]&gt;=m)                    {                        n--;                        m-=f[i];                        break;                    }                }            }            printf(&quot;%c\n&quot;,ch[9][m]);        }    }    return 0;}</code></pre><p>———————————————————————————————————————-.<br><a href="http://oj.acm.zstu.edu.cn/JudgeOnline/problem.php?id=4246" target="_blank" rel="noopener"> 萌新吃果果 </a><br>题意 : 中文题</p><p>阶梯思路:<br>就是一个模拟题 ,按要求直接来就行了.(不懂看代码</p><pre><code>//#include &lt;bits/stdc++.h&gt;#include &lt;stdio.h&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;string.h&gt;#include &lt;math.h&gt;#include &lt;vector&gt;#include &lt;queue&gt;using namespace std;#define INF         2100000000ll#define pb          push_back#define mp          make_pair#define abs(a)      ((a)&gt;0?(a):-(a))#define lalal       puts(&quot;*******&quot;);#define s1(x)       scanf(&quot;%d&quot;,&amp;x)#define Rep(a,b,c)  for(int a=(b);a&lt;=(c);a++)typedef long long int LL ;typedef unsigned long long int LLu ;/*******************************/const int MOD = 1e9+7;const int N = 100000+5;const double eps = 1e-9;char str[N];int main(){    int _;    while(~s1(_))    {        while(_--)        {            int n,k;            s1(n),s1(k);            scanf(&quot;%s&quot;,str+1);            int ctn=1,sum=1;            Rep(i,2,n)            {                if(str[i]==&#39;a&#39;){                    ctn++,sum++;                }                else if(str[i]==&#39;b&#39;){                    if(str[i-1]==&#39;a&#39;){                        ctn=0;                        sum++;                    }                    ctn++;                    sum++;                }                else {                    if(ctn&gt;=k){                        ctn=0;                        sum++;                    }                    ctn++;                    sum++;                }            }            printf(&quot;%d\n&quot;,sum);        }    }    return 0;}</code></pre><p>———————————————————————————————————————-.<br><a href="http://oj.acm.zstu.edu.cn/JudgeOnline/problem.php?id=4247" target="_blank" rel="noopener"> 萌新的旅行 </a><br>这题 没想明白 .待补…<br>———————————————————————————————————————-.<br><a href="http://oj.acm.zstu.edu.cn/JudgeOnline/problem.php?id=4248" target="_blank" rel="noopener"> KI的目标 </a><br>题意 :中文题</p><p>解题思路:<br>这题就是在一个树上去掉一些子树,问最后剩下多少节点 ,</p><p>那么根据题意:<br>我们只要在遍历树的时候不遍历删掉的子树就行了,然后统计一下遍历了多少节点即可.</p><p>因为点很多 ,所以采用邻接表存储图.</p><pre><code>//#include &lt;bits/stdc++.h&gt;#include &lt;stdio.h&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;string.h&gt;#include &lt;math.h&gt;#include &lt;vector&gt;#include &lt;map&gt;#include &lt;queue&gt;using namespace std;#define INF         2100000000ll#define pb          push_back#define mp          make_pair#define abs(a)      ((a)&gt;0?(a):-(a))#define lalal       puts(&quot;*******&quot;);#define s1(x)       scanf(&quot;%d&quot;,&amp;x)#define Rep(a,b,c)  for(int a=(b);a&lt;=(c);a++)typedef long long int LL ;typedef unsigned long long int uLL ;const int MOD = 1e9+7;const int N = 100000+5;const double eps = 1e-6;const double PI = acos(-1.0);/***********************************************************************/vector&lt;pair&lt;LL,LL&gt; &gt;E[N];int a[N],h[N];int ans ;LL fir,sec;void dfs(int u,int v){    h[u]=1,ans++;    Rep(i,0,E[u].size()-1)    {        fir=E[u][i].first,sec=E[u][i].second;        if(fir!=v&amp;&amp;!h[fir]&amp;&amp;sec&gt;=a[u]-a[fir])            dfs(fir,u);    }}int main(){    int _;    while(~s1(_))    {        while(_--)        {            int n;            s1(n);            Rep(i,1,n) E[i].clear();            int u,v,l;            Rep(i,2,n)            {                h[i]=0;                s1(u),s1(v),s1(l);                E[u].pb(mp(v,l));                E[v].pb(mp(u,l));            }            Rep(i,1,n) s1(a[i]);            ans=0,dfs(1,-1);            printf(&quot;%d\n&quot;,ans);        }    }    return 0;}</code></pre><p>———————————————————————————————————————-.</p>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  2016级新生程序设计全国邀请赛个人题解 [未完待续..]</title>
      <link href="/2016/11/29/53400832/"/>
      <url>/2016/11/29/53400832/</url>
      
        <content type="html"><![CDATA[<h1 id="2016级新生程序设计全国邀请赛个人题解-未完待续"><a href="#2016级新生程序设计全国邀请赛个人题解-未完待续" class="headerlink" title="2016级新生程序设计全国邀请赛个人题解 [未完待续..]"></a>2016级新生程序设计全国邀请赛个人题解 [未完待续..]</h1><p>2016年11月29日 21:58:33  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：347</p><hr><p> 博客爬取于<code>2019-04-18 17:18:46</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/53400832" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/53400832</a></p><p>首先作为大二选手,做新生的题目就很尴尬了，然后3个小时单挑(6)加补题(2)，最后也只能8个题也是菜的可以。<br>外加膜拜一发rank1的新生队伍，Orz。。</p><h3 id="棋盘村-http-acm-hrbust-edu-cn-index-php-m-ProblemSet-amp-a-showProblem-amp-pro"><a href="#棋盘村-http-acm-hrbust-edu-cn-index-php-m-ProblemSet-amp-a-showProblem-amp-pro" class="headerlink" title="[ 棋盘村 ](http://acm.hrbust.edu.cn/index.php?m=ProblemSet&amp;a=showProblem&amp;pro"></a>[ 棋盘村 ](<a href="http://acm.hrbust.edu.cn/index.php?m=ProblemSet&amp;a=showProblem&amp;pro" target="_blank" rel="noopener">http://acm.hrbust.edu.cn/index.php?m=ProblemSet&amp;a=showProblem&amp;pro</a></h3><p>blem_id=2293)</p><p>从(0,0)走到(n,m)很好办 直接dp一下就能计算出来<br>因为不能路过强盗的位置和强盗一步就能走到的位置.所以这几个位置要特殊判断一下即可.</p><p>转移方程<br>d  p  [  i  ]  [  j  ]  =  d  p  [  i  −  1  ]  [  j  ]  +  d  p  [  i  ]  [<br>j  −  1  ]  ;</p><pre><code>//#include &lt;bits/stdc++.h&gt;#include &lt;stdio.h&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;string.h&gt;#include &lt;math.h&gt;#include &lt;vector&gt;#include &lt;map&gt;#include &lt;queue&gt;using namespace std;#define INF         2100000000ll#define pb          push_back#define mp          make_pair#define abs(a)      ((a)&gt;0?(a):-(a))#define lalal       puts(&quot;*******&quot;);#define s1(x)       scanf(&quot;%d&quot;,&amp;x)#define Rep(a,b,c)  for(int a=(b);a&lt;=(c);a++)typedef long long int LL ;typedef unsigned long long int uLL ;/*******************************/const int mod = 1e9+7;const int MOD = 1e9+7;const int N = 100000+5;const double eps = 1e-6;const double PI = acos(-1.0);LL dp[30][30];bool vis[30][30];int fx[]={0,1,1,-1,-1,2,2,-2,-2};int fy[]={0,2,-2,2,-2,1,-1,1,-1};int main (){    int n,m,x,y;    int _;    while(~s1(_))    {        while(_--)        {            s1(n),s1(m),s1(x),s1(y);            int xx,yy;            memset(dp,0,sizeof(dp));            memset(vis,0,sizeof(vis));            vis[0][0]=1;            Rep(i,0,8)            {                xx=x+fx[i];                yy=y+fy[i];                if(xx&gt;=0&amp;&amp;yy&gt;=0&amp;&amp;xx&lt;=n&amp;&amp;yy&lt;=m)                    vis[xx][yy]=1;            }            dp[0][0]=1;            Rep(i,0,n)Rep(j,0,m)            {                if(vis[i][j]) continue;                if(i-1&gt;=0) dp[i][j]+=dp[i-1][j];                if(j-1&gt;=0) dp[i][j]+=dp[i][j-1];            }            printf(&quot;%lld\n&quot;,dp[n][m]);        }    }    return 0;}</code></pre><p>———————————————————————————.</p><h3 id="修建传送门-http-acm-hrbust-edu-cn-index-php-m-ProblemSet-amp-a-showProblem-amp-p"><a href="#修建传送门-http-acm-hrbust-edu-cn-index-php-m-ProblemSet-amp-a-showProblem-amp-p" class="headerlink" title="[ 修建传送门 ](http://acm.hrbust.edu.cn/index.php?m=ProblemSet&amp;a=showProblem&amp;p"></a>[ 修建传送门 ](<a href="http://acm.hrbust.edu.cn/index.php?m=ProblemSet&amp;a=showProblem&amp;p" target="_blank" rel="noopener">http://acm.hrbust.edu.cn/index.php?m=ProblemSet&amp;a=showProblem&amp;p</a></h3><p>roblem_id=2294)</p><p>这道题首先看到了最小的最大值,我就想二分答案做,但是check部分想了好久也写不出来,于是放弃这个思路.</p><p>想了一下最暴力的思路<br>要枚举三个位置——两个传送阵+1个折中点的位置<br>在枚举过程中维护的就是几个距离的最大值即可<br>1)min_dis(1,n)<br>2)min_dis(1,折中点)<br>3)min_dis(1,折中点左边的位置) （通过传送阵之后的）</p><p>维护过程我们可以先处理个前缀和 这样的话就能  O  (  1  )  维护了.</p><p>然而发现  O  (  n  3  )  的复杂度根本不可行</p><p>然后我们发现我们需要的距离一定是从  1  到其他点的 ，那么我们可以确定，其中一个传送阵一定要放在  1<br>位置上,否则的话最小的最大长度就是就会多了dis(1,左边的传送阵).<br>这样的话复杂度就降到了  O  (  n  2  )<br>但是发现还是不够用</p><p>首先我们能够确定的是 一定要枚举一个值,<br>那么我们考虑是枚举第二个传送阵还是枚举折中的点..<br>发现如果开始就枚举折中的点的话,那么不好找传送阵.<br>于是决定枚举传送阵.</p><p>发现,如果枚举传送阵,那么我能能够利用双指针法的方式确定折中点.<br>这样的话复杂度就降到了  O  (  n  )</p><p>问题就解决了….</p><pre><code>//#include &lt;bits/stdc++.h&gt;#include &lt;stdio.h&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;string.h&gt;#include &lt;math.h&gt;#include &lt;vector&gt;#include &lt;map&gt;#include &lt;queue&gt;using namespace std;#define INF         2100000000ll#define pb          push_back#define mp          make_pair#define abs(a)      ((a)&gt;0?(a):-(a))#define lalal       puts(&quot;*******&quot;);#define s1(x)       scanf(&quot;%d&quot;,&amp;x)#define Rep(a,b,c)  for(int a=(b);a&lt;=(c);a++)typedef long long int LL ;typedef unsigned long long int uLL ;const int MOD = 1e9+7;const int N = 100000+5;const double eps = 1e-6;const double PI = acos(-1.0);/***********************************************************************/LL a[N],sum[N];int n;int main(){    int _;    while(~s1(_))    {        while(_--)        {            s1(n);            sum[0]=0;            LL mi = 0;            Rep(i,1,n-1)s1(a[i]),mi+=a[i],sum[i]=sum[i-1]+a[i];            int l,r;            l=1,r=2;            //尺取法的思想  r枚举传送阵 l枚举折点            //3个距离就是 1-&gt;l  r-&gt;l+1  r-&gt;n-1            LL tem = mi ;            while(r&lt;=n)            {                while(l&lt;r &amp;&amp; sum[r-1]-sum[l] &gt; sum[l] )l++;                tem = max(sum[l-1],sum[r-1]-sum[l]);                tem = max(tem,sum[n-1]-sum[r-1]);                if(tem&lt;mi) mi=tem;                //printf(&quot;%d %d  &lt;-%d\n&quot;,l,r,tem);                r++;            }            printf(&quot;%lld\n&quot;,mi);        }    }    return 0;}</code></pre><p>———————————————————————————.</p><h3 id="方方正正-http-acm-hrbust-edu-cn-index-php-m-ProblemSet-amp-a-showProblem-amp-pr"><a href="#方方正正-http-acm-hrbust-edu-cn-index-php-m-ProblemSet-amp-a-showProblem-amp-pr" class="headerlink" title="[ 方方正正 ](http://acm.hrbust.edu.cn/index.php?m=ProblemSet&amp;a=showProblem&amp;pr"></a>[ 方方正正 ](<a href="http://acm.hrbust.edu.cn/index.php?m=ProblemSet&amp;a=showProblem&amp;pr" target="_blank" rel="noopener">http://acm.hrbust.edu.cn/index.php?m=ProblemSet&amp;a=showProblem&amp;pr</a></h3><p>oblem_id=2295)</p><p>这道题个人对最终的结果的证明是不太够的,但是也怼过去了…<br>其实就是来判断3个情况,<br>1.行和列的和是不是相等,不是的话那么一定不可能.<br>2.然后判断的是行的最大值和列上的非0值能不能对上,如果对不上的话那么也是不可能的.<br>3.同上，就是把行列交换一下,</p><pre><code>//#include &lt;bits/stdc++.h&gt;#include &lt;stdio.h&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;string.h&gt;#include &lt;math.h&gt;#include &lt;vector&gt;#include &lt;map&gt;#include &lt;queue&gt;using namespace std;#define INF         2100000000ll#define pb          push_back#define mp          make_pair#define abs(a)      ((a)&gt;0?(a):-(a))#define lalal       puts(&quot;*******&quot;);#define s1(x)       scanf(&quot;%d&quot;,&amp;x)#define Rep(a,b,c)  for(int a=(b);a&lt;=(c);a++)typedef long long int LL ;typedef unsigned long long int uLL ;/*******************************/const int mod = 1e9+7;const int MOD = 1e9+7;const int N = 100000+5;const double eps = 1e-6;const double PI = acos(-1.0);int main(){    int r,c;    while(~s1(r))    {        s1(c);        LL t,sr,sc,nr,nc,mr,mc;        sr=sc=nr=nc=mr=mc=0;        Rep(i,1,r)        {            scanf(&quot;%lld&quot;,&amp;t);            if(t&gt;0) nr++;            sr+=t;            if(t&gt;mr) mr = t;        }        Rep(i,1,c)        {            scanf(&quot;%lld&quot;,&amp;t);            if(t&gt;0) nc++;            sc+=t;            if(t&gt;mc) mc = t;        }       // printf(&quot;%lld %lld %lld %lld\n&quot;,nr,mr,nc,mc);        if(sr!=sc||nr&lt;mc||nc&lt;mr)            puts(&quot;NO&quot;);        else            puts(&quot;YES&quot;);    }    return 0;}</code></pre><p>———————————————————————————.</p><h3 id="陈月亮的数学题-http-acm-hrbust-edu-cn-index-php-m-ProblemSet-amp-a-showProblem"><a href="#陈月亮的数学题-http-acm-hrbust-edu-cn-index-php-m-ProblemSet-amp-a-showProblem" class="headerlink" title="[ 陈月亮的数学题 ](http://acm.hrbust.edu.cn/index.php?m=ProblemSet&amp;a=showProblem"></a>[ 陈月亮的数学题 ](<a href="http://acm.hrbust.edu.cn/index.php?m=ProblemSet&amp;a=showProblem" target="_blank" rel="noopener">http://acm.hrbust.edu.cn/index.php?m=ProblemSet&amp;a=showProblem</a></h3><p>&amp;problem_id=2296)</p><p>这道题目粗看很难 但是想一想其实还是能做的<br>首先对于  n  1  +  n  2  +  n  3  +  …  +  n  k  还是非常好求的<br>我们想到将N按照算数基本定理展开变成<br>N  =  p  a  1  1  ∗  p  a  2  2  ∗  p  a  3  3  ∗  …  ∗  p  a  n  n<br>这时候我们有N的因子个数为  (  a  1  +  1  )  (  a  2  +  1  )  (  a  3  +  1  )  …  (<br>a  k  +  1  )  =  ∏  k  i  =  1  (  a  i  +  1  )</p><p>这时候我考虑某一个N的因子也就是将  a  1  变成  x  ∈  [  0  ,  a  1  ]<br>那么最终N的所有因子的因子个数和就是<br>∏  k  i  =  1  (  1  +  2  +  3  +  …  +  a  i  +  1  )  =  ∏  k  i  =  1<br>(  1  +  a  i  +  1  )  (  a  i  +  1  )  2</p><p>但是说了半天我们计算的只是  S  =  n  1  +  n  2  +  n  3  +  …  +  n  k  的值<br>那么我对于  S  =  n  3  1  +  n  3  2  +  n  3  3  +  …  +  n  3  k  该如何求解呢</p><p>首先我们知道这样三个数列的前n项和<br>1  +  2  +  3  +  …  +  n  =  (  1  +  n  )  n  2<br>1  2  +  2  2  +  3  2  +  …  +  n  2  =  (  2  +  n  )  (  1  +  n  )<br>n  6<br>1  3  +  2  3  +  3  3  +  …  +  n  3  =  (  (  1  +  n  )  n  2  )  2<br>…</p><p>证明过程从略.(方法好像叫列项相消…</p><p>然后我们发现其中两项很相像,<br>通过观察法发现,与题目要求的有很强的对应关系,那么结论也会有很强的对应关系,<br>所以得出结论 , 我们只要求出  ∏  k  i  =  1  (  (  1  +  a  i  )  a  i  2  )  2<br>即可,事实发现可行,于是AC…</p><p>但是我们需要怎么才能证明得出呢?<br>考虑到N只有一个素因子的时候,那么他的因子的因子个数和就是<br>1  +  2  +  3  +  …  +  a  i  =  ∑  a  i  i  =  1  i  =  (  1  +  a  i  )<br>a  i  2<br>=&gt; S  (  N  )  =  1  3  +  2  3  +  3  3  +  …  +  a  3  i  =  ∑  a  i  i<br>=  1  i  3  =  (  (  1  +  a  i  )  a  i  2  )  2<br>那么对于N有2个素因子的时候他的因子的因子个数和就是<br>(  1  +  2  +  3  +  …  +  a  1  )  (  1  +  2  +  3  +  …  +  a  2  )<br>=  ∑  a  i  i  =  1  (  i  ∑  a  j  j  =  1  j  )  =  (  (  1  +  a  1  )  a<br>1  2  )  (  (  1  +  a  2  )  a  2  2  )<br>=&gt; S  (  N  )  =  (  1  3  +  2  3  +  3  3  +  …  +  a  3  1  )  (  1  3<br>+  2  3  +  3  3  +  …  +  a  3  2  )  =  ∑  a  i  i  =  1  (  i  3  ∑  a<br>j  j  =  1  j  3  )  =  (  (  1  +  a  1  )  a  1  2  )  2  (  (  1  +  a  2<br>)  a  2  2  )  2<br>然后采用数学归纳法，即可得出对于N有多个素因子的时候<br>=&gt; ∏  k  i  =  1  (  (  1  +  a  i  )  a  i  2  )  2</p><p>最后一句 ,以后再也不想证明数学题了,尼玛墨迹死了，还这么绕….</p><pre><code>//#include &lt;bits/stdc++.h&gt;#include &lt;stdio.h&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;string.h&gt;#include &lt;math.h&gt;#include &lt;vector&gt;#include &lt;map&gt;#include &lt;queue&gt;using namespace std;#define INF         2100000000ll#define pb          push_back#define mp          make_pair#define abs(a)      ((a)&gt;0?(a):-(a))#define lalal       puts(&quot;*******&quot;);#define s1(x)       scanf(&quot;%d&quot;,&amp;x)#define Rep(a,b,c)  for(int a=(b);a&lt;=(c);a++)typedef long long int LL ;typedef unsigned long long int uLL ;/*******************************/const int mod = 1e9+7;const int MOD = 1e9+7;const int N = 100000+5;const double eps = 1e-6;const double PI = acos(-1.0);int prime[N],kp;bool Is_or[N];void Prime(){    int n = 65540;    kp=0;    memset(Is_or,true,sizeof(Is_or));    Is_or[0]=Is_or[1]=false;    for(int i=2;i&lt;n;i++)    {        if(Is_or[i]) prime[kp++]=i;        for(int j=0;j&lt;kp&amp;&amp;prime[j]*i&lt;n;j++)        {            Is_or[prime[j]*i]=false;            if(i%prime[j]==0) break;        }    }    return ;}vector&lt;int&gt;a;int main(){    Prime();    int _,n;    while(~s1(_))    {        while(_--)        {            a.clear();            s1(n);            int cnt;            for(int i=0;i&lt;kp&amp;&amp;n&gt;=prime[i]*prime[i];i++)            {                cnt=0;                while(n%prime[i]==0) cnt++,n/=prime[i];                a.pb(cnt);            }            if(n&gt;1)   a.pb(1);            LL ans = 1,tmp;            for(int i=0;i&lt;a.size();i++)            {                tmp = (a[i]+1)*(a[i]+2)/2;                ans*=tmp*tmp;            }            printf(&quot;%lld\n&quot;,ans);        }    }    return 0;}</code></pre><p>———————————————————————————.</p><h3 id="Nine-Digits-http-acm-hrbust-edu-cn-index-php-m-ProblemSet-amp-a-showPro"><a href="#Nine-Digits-http-acm-hrbust-edu-cn-index-php-m-ProblemSet-amp-a-showPro" class="headerlink" title="[ Nine Digits ](http://acm.hrbust.edu.cn/index.php?m=ProblemSet&amp;a=showPro"></a>[ Nine Digits ](<a href="http://acm.hrbust.edu.cn/index.php?m=ProblemSet&amp;a=showPro" target="_blank" rel="noopener">http://acm.hrbust.edu.cn/index.php?m=ProblemSet&amp;a=showPro</a></h3><p>blem&amp;problem_id=2297)</p><p>这道题目其实和HDU1430是一样的<br>这里有我HDU1430的题解. <a href="http://blog.csdn.net/qq_33184171/article/details/53046282" target="_blank" rel="noopener"> 传送阵</a></p><p>本题问的是从1~9这个原序列到达其他序列的最少旋转次数，那么翻过来也就是从给定的某一个序列到达1~9这个原序列的最少旋转次数。因为  9  ！  =  =<br>362880  我们只要预处理出所有的情况就行了。</p><p>这道题目要求得最少次数，很容易想到BFS<br>然后根据题目的1~9的全排列，显然就是 <a href="http://blog.csdn.net/qq_33184171/article/details/52681216" target="_blank" rel="noopener"> 康拓展开</a> 。<br>利用康拓展开值来确定一个序列。</p><p>每一次BFS的过程中，向其旋转一个2*2后的序列一遍一遍的搜索就行了。（！！！注意的是 从当前序列到原序列是顺时针旋转的，那么从原序列过来就是逆时针的<br>，否则 虽然还是能过掉挺多数据，那也是WA啊。。别问我怎么知道能过掉很多数据的 /哭笑）</p><pre><code>//#include &lt;bits/stdc++.h&gt;#include &lt;stdio.h&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;string.h&gt;#include &lt;math.h&gt;#include &lt;vector&gt;#include &lt;map&gt;#include &lt;queue&gt;using namespace std;#define INF         2100000000ll#define pb          push_back#define mp          make_pair#define abs(a)      ((a)&gt;0?(a):-(a))#define lalal       puts(&quot;*******&quot;);#define s1(x)       scanf(&quot;%d&quot;,&amp;x)#define Rep(a,b,c)  for(int a=(b);a&lt;=(c);a++)typedef long long int LL ;typedef unsigned long long int uLL ;const int MOD = 1e9+7;const int N = 100000+5;const double eps = 1e-6;const double PI = acos(-1.0);/***********************************************************************/int step[363333];int jiecheng[10] = {1,1,2,6,24,120,720,5040,40320,362880};int a[10],b[10];int Cantor_expansion(int a[]){    //Rep(i,0,8)printf(&quot;%c%d&quot;,(i%3==0)?&#39;\n&#39;:&#39; &#39;,a[i]);puts(&quot;&quot;);    int x=0,len = 9 ;    for(int i=0; i&lt;len; i++)    {        for(int j=i+1; j&lt;len; j++)            if(a[j]&lt;a[i])                x+=jiecheng[len-1-i];    }    return x ;}bool h[10];void Cantor_inexpansion(int x){    memset(h,0,sizeof(h));    int ind ,tem ,len = 9;    for(int i=0; i&lt;len; i++)    {        ind = 0;        tem = x/jiecheng[len-1-i];        x  %=   jiecheng[len-1-i];        for(int j=1; j&lt;=len; j++)        {            if(h[j]) continue;            if(ind==tem)            {                a[i]=j;                break;            }            ind++;        }        h[a[i]]=1;    }    //Rep(i,0,8)printf(&quot;%d%c&quot;,a[i],(i==8)?&#39;\n&#39;:&#39; &#39;);    return ;}int opera(int ind){    Rep(i,0,8) b[i]=a[i];    int temp;    if(ind==1)        temp=b[0],b[0]=b[1],b[1]=b[4],b[4]=b[3],b[3]=temp;    else if(ind==2)        temp=b[1],b[1]=b[2],b[2]=b[5],b[5]=b[4],b[4]=temp;    else if(ind==3)        temp=b[3],b[3]=b[4],b[4]=b[7],b[7]=b[6],b[6]=temp;    else if(ind==4)        temp=b[4],b[4]=b[5],b[5]=b[8],b[8]=b[7],b[7]=temp;    return Cantor_expansion(b);}void BFS(){    memset(step,-1,sizeof(step));    queue&lt;int&gt;q;    int xx[10]= {1,2,3,4,5,6,7,8,9};    int x = Cantor_expansion(xx);    step[x]=0;    q.push(x);    int tem,tmp;    while(!q.empty())    {        tem = q.front(),q.pop();        Cantor_inexpansion(tem);        for(int i=1;i&lt;=4;i++)        {            tmp = opera(i);            if(step[tmp]!=-1) continue;            step[tmp] = step[tem] + 1 ;            q.push(tmp) ;        }    }    return ;}int main(){    BFS();    while(~s1(a[0]))    {        Rep(i,1,8) s1(a[i]);        int x = Cantor_expansion(a);        printf(&quot;%d\n&quot;,step[x]);    }    return 0;}</code></pre><p>———————————————————————————.</p><h3 id="Diamond-http-acm-hrbust-edu-cn-index-php-m-ProblemSet-amp-a-showProblem"><a href="#Diamond-http-acm-hrbust-edu-cn-index-php-m-ProblemSet-amp-a-showProblem" class="headerlink" title="[ Diamond ](http://acm.hrbust.edu.cn/index.php?m=ProblemSet&amp;a=showProblem"></a>[ Diamond ](<a href="http://acm.hrbust.edu.cn/index.php?m=ProblemSet&amp;a=showProblem" target="_blank" rel="noopener">http://acm.hrbust.edu.cn/index.php?m=ProblemSet&amp;a=showProblem</a></h3><p>&amp;problem_id=2298)</p><p>不会…<br>———————————————————————————.</p><h3 id="FBI-Tree-http-acm-hrbust-edu-cn-index-php-m-ProblemSet-amp-a-showProble"><a href="#FBI-Tree-http-acm-hrbust-edu-cn-index-php-m-ProblemSet-amp-a-showProble" class="headerlink" title="[ FBI Tree ](http://acm.hrbust.edu.cn/index.php?m=ProblemSet&amp;a=showProble"></a>[ FBI Tree ](<a href="http://acm.hrbust.edu.cn/index.php?m=ProblemSet&amp;a=showProble" target="_blank" rel="noopener">http://acm.hrbust.edu.cn/index.php?m=ProblemSet&amp;a=showProble</a></h3><p>m&amp;problem_id=2299)</p><p>这道题 据说不知道什么是后序遍历的16级同学暴力就过了<br>但是我这里真不知道怎么暴力 ,于是就模拟了一下题意,建了一颗二叉树,然后后序遍历了一下.(话树写的好糙啊但最后也怼过去了</p><pre><code>//#include &lt;bits/stdc++.h&gt;#include &lt;stdio.h&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;string.h&gt;#include &lt;math.h&gt;#include &lt;vector&gt;#include &lt;map&gt;#include &lt;queue&gt;using namespace std;#define INF         2100000000ll#define pb          push_back#define mp          make_pair#define abs(a)      ((a)&gt;0?(a):-(a))#define lalal       puts(&quot;*******&quot;);#define s1(x)       scanf(&quot;%d&quot;,&amp;x)#define Rep(a,b,c)  for(int a=(b);a&lt;=(c);a++)typedef long long int LL ;typedef unsigned long long int uLL ;/*******************************/const int mod = 1e9+7;const int MOD = 1e9+7;const int N = 100000+5;const double eps = 1e-6;const double PI = acos(-1.0);int tree[1&lt;&lt;16],n;char a[1&lt;&lt;16];#define ll (rt&lt;&lt;1)#define rr (rt&lt;&lt;1|1)#define mid ((l+r)&gt;&gt;1)void pushup(int rt){    if(tree[ll]==3||tree[rr]==3)tree[rt]=3;    else if(tree[ll]==1&amp;&amp;tree[rr]==1)tree[rt]=1;    else if(tree[ll]==1&amp;&amp;tree[rr]==2)tree[rt]=3;    else if(tree[ll]==2&amp;&amp;tree[rr]==1)tree[rt]=3;    else if(tree[ll]==2&amp;&amp;tree[rr]==2)tree[rt]=2;}void build(int rt,int l,int r){    if(l==r)    {        tree[rt]=a[l]-&#39;0&#39;+1;        return ;    }    build(ll,l,mid);    build(rr,mid+1,r);    pushup(rt);}int ans;void visit(int rt){   // printf(&quot;%d&quot;,rt);    ans++;    if(ans&gt;=(1&lt;&lt;(n+1))) return;    if(tree[rt]==1)        printf(&quot;B&quot;);    else if(tree[rt]==2)   printf(&quot;I&quot;);    else if(tree[rt]==3)   printf(&quot;F&quot;);    else printf(&quot;*&quot;);}void dfs(int rt,int l,int r){    if(l==r);    else    {        dfs(ll,l,mid);        dfs(rr,mid+1,r);    }    visit(rt);    return ;}int main(){    int _;    while(~s1(_))    {        while(_--)        {            ans = 0;            s1(n);            scanf(&quot;%s&quot;,a+1);            build(1,1,(1&lt;&lt;(n+1))-1);            dfs  (1,1,(1&lt;&lt;(n+1))-1);            //printf(&quot;%d\n&quot;,(1&lt;&lt;(n+1))-1);            puts(&quot;&quot;);            //printf(&quot;%d\n&quot;,ans);        }    }    return 0;}</code></pre><p>———————————————————————————.</p><h3 id="下雪啦-http-acm-hrbust-edu-cn-index-php-m-ProblemSet-amp-a-showProblem-amp-pro"><a href="#下雪啦-http-acm-hrbust-edu-cn-index-php-m-ProblemSet-amp-a-showProblem-amp-pro" class="headerlink" title="[ 下雪啦 ](http://acm.hrbust.edu.cn/index.php?m=ProblemSet&amp;a=showProblem&amp;pro"></a>[ 下雪啦 ](<a href="http://acm.hrbust.edu.cn/index.php?m=ProblemSet&amp;a=showProblem&amp;pro" target="_blank" rel="noopener">http://acm.hrbust.edu.cn/index.php?m=ProblemSet&amp;a=showProblem&amp;pro</a></h3><p>blem_id=2300)</p><p>没有想好怎么hash 待补题…<br>———————————————————————————.</p><h3 id="行编辑器-http-acm-hrbust-edu-cn-index-php-m-ProblemSet-amp-a-showProblem-amp-pr"><a href="#行编辑器-http-acm-hrbust-edu-cn-index-php-m-ProblemSet-amp-a-showProblem-amp-pr" class="headerlink" title="[ 行编辑器 ](http://acm.hrbust.edu.cn/index.php?m=ProblemSet&amp;a=showProblem&amp;pr"></a>[ 行编辑器 ](<a href="http://acm.hrbust.edu.cn/index.php?m=ProblemSet&amp;a=showProblem&amp;pr" target="_blank" rel="noopener">http://acm.hrbust.edu.cn/index.php?m=ProblemSet&amp;a=showProblem&amp;pr</a></h3><p>oblem_id=2301)</p><p>水题一个,没有什么好说的,随便做就行了<br>可以双端队列,<br>但是时效性最好的还是用数组做,用一个”指针”维护一下就好了</p><pre><code>//#include &lt;bits/stdc++.h&gt;#include &lt;stdio.h&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;string.h&gt;#include &lt;math.h&gt;#include &lt;vector&gt;#include &lt;map&gt;#include &lt;queue&gt;using namespace std;#define INF         2100000000ll#define pb          push_back#define mp          make_pair#define abs(a)      ((a)&gt;0?(a):-(a))#define lalal       puts(&quot;*******&quot;);#define s1(x)       scanf(&quot;%d&quot;,&amp;x)#define Rep(a,b,c)  for(int a=(b);a&lt;=(c);a++)typedef long long int LL ;typedef unsigned long long int uLL ;/*******************************/const int mod = 1e9+7;const int MOD = 1e9+7;const int N = 100000+5;const double eps = 1e-6;const double PI = acos(-1.0);char ch[1010101];char  a[1010101];int main(){    int _;    while(~s1(_))    {        while(_--)        {            scanf(&quot;%s&quot;,ch);            int len = strlen (ch);            int pos=0;            Rep(i,0,len-1)            {                if(ch[i]==&#39;#&#39;)                {                    pos--;                    if(pos&lt;0) pos=1;                }                else if(ch[i]==&#39;@&#39;)                {                    pos=0;                }                else                {                    a[pos++]=ch[i];                }            }            Rep(i,0,pos-1)            printf(&quot;%c&quot;,a[i]);            puts(&quot;&quot;);        }    }    return 0;}</code></pre><p>———————————————————————————.</p><h3 id="Another-Tree-http-acm-hrbust-edu-cn-index-php-m-ProblemSet-amp-a-showPr"><a href="#Another-Tree-http-acm-hrbust-edu-cn-index-php-m-ProblemSet-amp-a-showPr" class="headerlink" title="[ Another Tree ](http://acm.hrbust.edu.cn/index.php?m=ProblemSet&amp;a=showPr"></a>[ Another Tree ](<a href="http://acm.hrbust.edu.cn/index.php?m=ProblemSet&amp;a=showPr" target="_blank" rel="noopener">http://acm.hrbust.edu.cn/index.php?m=ProblemSet&amp;a=showPr</a></h3><p>oblem&amp;problem_id=2302)</p><p>这题不会。<br>———————————————————————————.</p><h3 id="小明和字符串-http-acm-hrbust-edu-cn-index-php-m-ProblemSet-amp-a-showProblem-amp"><a href="#小明和字符串-http-acm-hrbust-edu-cn-index-php-m-ProblemSet-amp-a-showProblem-amp" class="headerlink" title="[ 小明和字符串 ](http://acm.hrbust.edu.cn/index.php?m=ProblemSet&amp;a=showProblem&amp;"></a>[ 小明和字符串 ](<a href="http://acm.hrbust.edu.cn/index.php?m=ProblemSet&amp;a=showProblem&amp;" target="_blank" rel="noopener">http://acm.hrbust.edu.cn/index.php?m=ProblemSet&amp;a=showProblem&amp;</a></h3><p>problem_id=2303)</p><p>简单模拟，没有什么好说的</p><pre><code>//#include &lt;bits/stdc++.h&gt;#include &lt;stdio.h&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;string.h&gt;#include &lt;math.h&gt;#include &lt;vector&gt;#include &lt;map&gt;#include &lt;queue&gt;using namespace std;#define INF         2100000000ll#define pb          push_back#define mp          make_pair#define abs(a)      ((a)&gt;0?(a):-(a))#define lalal       puts(&quot;*******&quot;);#define s1(x)       scanf(&quot;%d&quot;,&amp;x)#define Rep(a,b,c)  for(int a=(b);a&lt;=(c);a++)typedef long long int LL ;typedef unsigned long long int uLL ;/*******************************/const int mod = 1e9+7;const int MOD = 1e9+7;const int N = 100000+5;const double eps = 1e-6;const double PI = acos(-1.0);char a[10101];int main(){    int _;    while(~s1(_))    {        while(_--)        {            scanf(&quot;%s&quot;,&amp;a);            int len = strlen (a);            char ch,num=0;            Rep(i,0,len-1)            {                if(a[i]&gt;=&#39;0&#39;&amp;&amp;a[i]&lt;=&#39;9&#39;)                {                    num+=a[i]-&#39;0&#39;;                }                else                {                    while(num--)printf(&quot;%c&quot;,ch);                    num=0;                    printf(&quot;%c&quot;,a[i]);                    ch=a[i];                }            }            while(num--)printf(&quot;%c&quot;,ch);            puts(&quot;&quot;);        }    }    return 0;}</code></pre><p>———————————————————————————.</p>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  POJ 2528 Mayor&#39;s posters [线段树-区间更新+离散化]【数据结构】</title>
      <link href="/2016/11/16/53190165/"/>
      <url>/2016/11/16/53190165/</url>
      
        <content type="html"><![CDATA[<h1 id="POJ-2528-Mayor’s-posters-线段树-区间更新-离散化-【数据结构】"><a href="#POJ-2528-Mayor’s-posters-线段树-区间更新-离散化-【数据结构】" class="headerlink" title="POJ 2528 Mayor’s posters [线段树-区间更新+离散化]【数据结构】"></a>POJ 2528 Mayor’s posters [线段树-区间更新+离散化]【数据结构】</h1><p>2016年11月16日 19:09:12  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：238</p><hr><p> 博客爬取于<code>2019-04-18 17:18:47</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/53190165" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/53190165</a></p><p>题目链接: <a href="http://poj.org/problem?id=2528" target="_blank" rel="noopener"> http://poj.org/problem?id=2528 </a><br>——————————————-.<br>Mayor’s posters<br>Time Limit: 1000MS Memory Limit: 65536K<br>Total Submissions: 60379 Accepted: 17492<br>Description</p><p>The citizens of Bytetown, AB, could not stand that the candidates in the<br>mayoral election campaign have been placing their electoral posters at all<br>places at their whim. The city council has finally decided to build an<br>electoral wall for placing the posters and introduce the following rules:<br>Every candidate can place exactly one poster on the wall.<br>All posters are of the same height equal to the height of the wall; the width<br>of a poster can be any integer number of bytes (byte is the unit of length in<br>Bytetown).<br>The wall is divided into segments and the width of each segment is one byte.<br>Each poster must completely cover a contiguous number of wall segments.</p><p>They have built a wall 10000000 bytes long (such that there is enough place<br>for all candidates). When the electoral campaign was restarted, the candidates<br>were placing their posters on the wall and their posters differed widely in<br>width. Moreover, the candidates started placing their posters on wall segments<br>already occupied by other posters. Everyone in Bytetown was curious whose<br>posters will be visible (entirely or in part) on the last day before<br>elections.<br>Your task is to find the number of visible posters when all the posters are<br>placed given the information about posters’ size, their place and order of<br>placement on the electoral wall.<br>Input</p><p>The first line of input contains a number c giving the number of cases that<br>follow. The first line of data for a single case contains number 1 &lt;= n &lt;=</p><ol start="10000"><li>The subsequent n lines describe the posters in the order in which they<br>were placed. The i-th line among the n lines contains two integer numbers li<br>and ri which are the number of the wall segment occupied by the left end and<br>the right end of the i-th poster, respectively. We know that for each 1 &lt;= i<br>&lt;= n, 1 &lt;= li &lt;= ri &lt;= 10000000. After the i-th poster is placed, it entirely<br>covers all wall segments numbered li, li+1 ,… , ri.<br>Output</li></ol><p>For each input data set print the number of visible posters after all the<br>posters are placed.</p><p>The picture below illustrates the case of the sample input.<br><img src="http://poj.org/images/2528_1.jpg" alt><br>Sample Input</p><p>1<br>5<br>1 4<br>2 6<br>8 10<br>3 4<br>7 10<br>Sample Output</p><p>4<br>Source</p><p>Alberta Collegiate Programming Contest 2003.10.18<br>——————————————.</p><p>题目大意:<br>就是给一个连续的区间,在上面的n个子区间(可覆盖)刷上n种颜色,问你最后漏出来的有几种颜色.</p><p>解题思路:<br>就是用线段树来维护每一个区间覆盖上颜色,最后计算叶子上的节点有几种颜色即可.</p><p>但是注意到  l  ,  r  范围有  1  e  8  这么大 但是n只有  1  e  6<br>所以能够离散化一下计算.</p><p>注意的是离散化后的区间应该是  2  e  6  不然RE</p><p>附本题代码<br>——————————–.</p><pre><code>/*memory 2104kbtime 954ms  *///#include &lt;bits/stdc++.h&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;math.h&gt;#include &lt;map&gt;#define abs(x)          (((x)&gt;0)?(x):-(x))#define lalal           puts(&quot;*********&quot;)#define Rep(a,b,c)      for(int a=(b);a&lt;=(c);a++)#define Req(a,b,c)      for(int a=(b);a&gt;=(c);a--)#define Rop(a,b,c)      for(int a=(b);a&lt;(c);a++)#define s1(a)           scanf(&quot;%d&quot;,&amp;a)typedef long long int LL;using namespace std;const int inf = 0x3f3f3f3f;const int MOD = 9901;/**************************************/const int N = 20000+5;#define ll  (rt&lt;&lt;1)#define rr  (rt&lt;&lt;1|1)#define mid (tree[rt].m())struct node{    int l,r;    int lazy;    int m()    {        return (l+r)&gt;&gt;1;    }    int len()    {        return  (r-l+1);    }} tree[N&lt;&lt;2];void build(int rt,int l,int r){    tree[rt].l=l,tree[rt].r=r,tree[rt].lazy=0;    if(l==r)       return ;    build(ll,l,mid);    build(rr,mid+1,r);}void pushdown(int rt){    if(tree[rt].lazy)    {        tree[ll].lazy=tree[rr].lazy=tree[rt].lazy;        tree[rt].lazy=0;    }}void update(int rt,int L,int R,int val){   if(L&lt;=tree[rt].l&amp;&amp;tree[rt].r&lt;=R)   {       tree[rt].lazy=val;       return ;   }   pushdown(rt);   if(L&lt;=mid) update(ll,L,R,val);   if(R &gt;mid) update(rr,L,R,val);}int query(int rt,int L,int R){    if(tree[rt].l==tree[rt].r) return tree[rt].lazy;    pushdown(rt);    if(L&lt;=mid) return query(ll,L,R);    if(R&gt; mid) return query(rr,L,R);}map&lt;int ,int &gt;mp,mmp;struct nod{    int l,r;    int ind;}b[N];int c[N];int main(){    int _;    while(~s1(_))    {        while(_--)        {            mp.clear(),mmp.clear();            int n,kn=0,cnt=0,color=0;            s1(n);            int l,r;            Rep(i,1,n) s1(b[i].l),s1(b[i].r),c[i]=b[i].l,c[i+n]=b[i].r;            sort(c+1,c+n*2+1);            Rep(i,1,n&lt;&lt;1)if(0==mp[c[i]])mp[c[i]]=++kn;            build(1,1,kn);            Rep(i,1,n) update(1,mp[b[i].l],mp[b[i].r],i);            Rep(i,1,kn)            {                color=query(1,i,i);                if(mmp[color]==0)                mmp[color]=1,cnt++;            }            printf(&quot;%d\n&quot;,cnt);        }    }    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  POJ 2886 Who Gets the Most Candies? [线段树-单点更新]【数据结构】</title>
      <link href="/2016/11/15/53176786/"/>
      <url>/2016/11/15/53176786/</url>
      
        <content type="html"><![CDATA[<h1 id="POJ-2886-Who-Gets-the-Most-Candies-线段树-单点更新-【数据结构】"><a href="#POJ-2886-Who-Gets-the-Most-Candies-线段树-单点更新-【数据结构】" class="headerlink" title="POJ 2886 Who Gets the Most Candies? [线段树-单点更新]【数据结构】"></a>POJ 2886 Who Gets the Most Candies? [线段树-单点更新]【数据结构】</h1><p>2016年11月15日 20:30:35  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：180</p><hr><p> 博客爬取于<code>2019-04-18 17:18:48</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/53176786" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/53176786</a></p><p>题目链接： <a href="http://poj.org/problem?id=2886" target="_blank" rel="noopener"> http://poj.org/problem?id=2886 </a></p><p>————————————.<br>Who Gets the Most Candies?<br>Time Limit: 5000MS Memory Limit: 131072K<br>Total Submissions: 13899 Accepted: 4397<br>Case Time Limit: 2000MS<br>Description</p><p>N children are sitting in a circle to play a game.</p><p>The children are numbered from 1 to N in clockwise order. Each of them has a<br>card with a non-zero integer on it in his/her hand. The game starts from the<br>K-th child, who tells all the others the integer on his card and jumps out of<br>the circle. The integer on his card tells the next child to jump out. Let A<br>denote the integer. If A is positive, the next child will be the A-th child to<br>the left. If A is negative, the next child will be the (−A)-th child to the<br>right.</p><p>The game lasts until all children have jumped out of the circle. During the<br>game, the p-th child jumping out will get F(p) candies where F(p) is the<br>number of positive integers that perfectly divide p. Who gets the most<br>candies?</p><p>Input</p><p>There are several test cases in the input. Each test case starts with two<br>integers N (0 &lt; N ≤ 500,000) and K (1 ≤ K ≤ N) on the first line. The next N<br>lines contains the names of the children (consisting of at most 10 letters)<br>and the integers (non-zero with magnitudes within 108) on their cards in<br>increasing order of the children’s numbers, a name and an integer separated by<br>a single space in a line with no leading or trailing spaces.<br>Output</p><p>Output one line for each test case containing the name of the luckiest child<br>and the number of candies he/she gets. If ties occur, always choose the child<br>who jumps out of the circle first.</p><p>Sample Input</p><p>4 2<br>Tom 2<br>Jack 4<br>Mary -1<br>Sam 1<br>Sample Output</p><p>Sam 3<br>Source</p><p>POJ Monthly–2006.07.30, Sempr<br>———————————–.</p><p>题目大意：<br>就是有n个人围城一圈，第一次第k个人离开，接下来离开的人是上一次离开的人的位置相对手上的数字相对位置上的人。<br>如果正的就是顺时针，负的就是逆时针</p><p>然后输出的是获得糖果最多的人。这个人获得的糖果数是  f  （  p  ）  第p个离开。  f  （  p  ）  是p的因子个数。</p><p>解题思路：<br>首先对于n个人来说，获得的最多的糖果个数和其是第几个离开的已经是确定的了,就是一个反素数，这个只要打个表就行了。</p><p>那么我们的任务就只剩下了 怎么找第K个离开的人。</p><p>每一次我们能够知道的离开的编号是哪一个，所以我们只要一个个的找就行了，但是直接暴力的找的话复杂度是  O  (  n  2  )  ,n又很大 一定会超时。</p><p>所以我们采取的就是用线段树维护的方法，每次离开的人放到树上，然后找下一个人，这样的话复杂度就降到了  O  (  n  l  o  g  n  )  .</p><p>维护的方法就是在树上的节点存储这个区间中剩下的没有离开的人的个数,然后更新的时候减掉1就行了.</p><p>这个与POJ2828一样 详情戳 <a href="http://blog.csdn.net/qq_33184171/article/details/53163302" target="_blank" rel="noopener"> 这里</a></p><p>附本题代码<br>—————————-.</p><pre><code>#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;math.h&gt;#define abs(x)          (((x)&gt;0)?(x):-(x))#define lalal           puts(&quot;*********&quot;)#define Rep(a,b,c)      for(int a=(b);a&lt;=(c);a++)#define Req(a,b,c)      for(int a=(b);a&gt;=(c);a--)#define Rop(a,b,c)      for(int a=(b);a&lt;(c);a++)#define s1(a)           scanf(&quot;%d&quot;,&amp;a)typedef long long int LL;using namespace std;const int inf = 0x3f3f3f3f;const int MOD = 9901;/**************************************/int RPrime[]= //反素数{    1,2,4,6,12,24,36,48,60,120,180,240,360,720,840,1260,1680,2520,5040,7560,10080,15120,    20160,25200,27720,45360,50400,55440,83160,110880,166320,221760,277200,332640,498960,    554400};int fact[]= //反素数约数个数{    1,2,3,4,6,8,9,10,12,16,18,20,24,30,32,36,40,48,60,64,72,80,84,90,96,100,108,120,128,    144,160,168,180,192,200,216};const int N = 500000+10;#define ll  (rt&lt;&lt;1)#define rr  (rt&lt;&lt;1|1)#define mid (tree[rt].m())struct node{    int l,r;    int val;    int flag;    int m()    {        return (r+l)&gt;&gt;1;    }} tree[N&lt;&lt;2];char a[N][12];int b[N];void build(int rt,int l,int r){    tree[rt].l=l,tree[rt].r=r;    tree[rt].flag=r-l+1;    if(l==r) return ;    build(ll,l,mid);    build(rr,mid+1,r);}int luck;void update(int rt,int pos){    tree[rt].flag--;    if(tree[rt].l==tree[rt].r){luck=tree[rt].l;return;}    if(pos&lt;=tree[ll].flag)update(ll,pos);    else    update(rr,pos-tree[ll].flag);    return ;}int main(){    //freopen(&quot;out.txt&quot;,&quot;w&quot;,stdout);    int n,k;    while(~s1(n))    {        s1(k);        build(1,1,n);        Rep(i,1,n)        {            scanf(&quot;%s&quot;,a[i]);            s1(b[i]);        }        int P=0;        for(int i=0; RPrime[i]&lt;=n; i++)P=i;        int mod;        luck=0;        b[luck]=0;        Rep(i,1,RPrime[P])        {            mod=tree[1].flag;            if(b[luck]&gt;0) k=((k+b[luck]-2)%mod+mod)%mod+1;            else          k=((k+b[luck]-1)%mod+mod)%mod+1;            update(1,k);        }        printf(&quot;%s %d\n&quot;,a[luck],fact[P]);    }    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  POJ 2828 Buy Tickets [线段树-单点更新]【数据结构】【好题】</title>
      <link href="/2016/11/14/53163302/"/>
      <url>/2016/11/14/53163302/</url>
      
        <content type="html"><![CDATA[<h1 id="POJ-2828-Buy-Tickets-线段树-单点更新-【数据结构】【好题】"><a href="#POJ-2828-Buy-Tickets-线段树-单点更新-【数据结构】【好题】" class="headerlink" title="POJ 2828 Buy Tickets [线段树-单点更新]【数据结构】【好题】"></a>POJ 2828 Buy Tickets [线段树-单点更新]【数据结构】【好题】</h1><p>2016年11月14日 19:49:32  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：228</p><hr><p> 博客爬取于<code>2019-04-18 17:18:49</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/53163302" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/53163302</a></p><p>题目链接： <a href="http://poj.org/problem?id=2828" target="_blank" rel="noopener"> http://poj.org/problem?id=2828 </a></p><p>——————————————————-.<br>Buy Tickets<br>Time Limit: 4000MS Memory Limit: 65536K<br>Total Submissions: 18998 Accepted: 9435<br>Description</p><p>Railway tickets were difficult to buy around the Lunar New Year in China, so<br>we must get up early and join a long queue…</p><p>The Lunar New Year was approaching, but unluckily the Little Cat still had<br>schedules going here and there. Now, he had to travel by train to Mianyang,<br>Sichuan Province for the winter camp selection of the national team of<br>Olympiad in Informatics.</p><p>It was one o’clock a.m. and dark outside. Chill wind from the northwest did<br>not scare off the people in the queue. The cold night gave the Little Cat a<br>shiver. Why not find a problem to think about? That was none the less better<br>than freezing to death!</p><p>People kept jumping the queue. Since it was too dark around, such moves would<br>not be discovered even by the people adjacent to the queue-jumpers. “If every<br>person in the queue is assigned an integral value and all the information<br>about those who have jumped the queue and where they stand after queue-jumping<br>is given, can I find out the final order of people in the queue?” Thought the<br>Little Cat.</p><p>Input</p><p>There will be several test cases in the input. Each test case consists of N +<br>1 lines where N (1 ≤ N ≤ 200,000) is given in the first line of the test case.<br>The next N lines contain the pairs of values Posi and Vali in the increasing<br>order of i (1 ≤ i ≤ N). For each i, the ranges and meanings of Posi and Vali<br>are as follows:</p><p>Posi ∈ [0, i − 1] — The i-th person came to the queue and stood right behind<br>the Posi-th person in the queue. The booking office was considered the 0th<br>person and the person at the front of the queue was considered the first<br>person in the queue.<br>Vali ∈ [0, 32767] — The i-th person was assigned the value Vali.<br>There no blank lines between test cases. Proceed to the end of input.</p><p>Output</p><p>For each test cases, output a single line of space-separated integers which<br>are the values of people in the order they stand in the queue.</p><p>Sample Input</p><p>4<br>0 77<br>1 51<br>1 33<br>2 69<br>4<br>0 20523<br>1 19243<br>1 3890<br>0 31492<br>Sample Output</p><p>77 33 69 51<br>31492 20523 3890 19243<br>Hint</p><p>The figure below shows how the Little Cat found out the final order of people<br>in the queue described in the first test case of the sample input.<br><img src="http://poj.org/images/2828.gif" alt></p><p>Source</p><p>POJ Monthly–2006.05.28, Zhu, Zeyuan<br>——————————————————.<br>题目大意:<br>就是一堆人排队去买票 ,然后每一次有一个人插在某一个位置上,现在问你,最后买票的顺序</p><p>解题思路:<br>首先要明确的是一定要逆序进行维护,逆序的话在插队的时候才能够确定他的最终位置</p><p>以第一组样例来说的话,<br>逆序看 那么一定能够确定<br>69在第2个位置上<br>33在第1个位置上<br>77在第0个位置上</p><p>这个是一定的 .</p><p>那么这时候在想51应该排在哪里,<br>写出这个的话可能更好理解一些<br>77<br>77 51<br>77 33 51<br>77 33 69 51</p><p>把这个想像成一个树的话 那么逆序插入的话 就能直接判断元素所在的位置了, 如果正序插入的话 还会涉及遍历后续所有元素,太耗时了.</p><p>那么这时候怎么判断之前在这个位置的元素应该放到什么位置呢?<br>想到这点的人真的是太机智了(现在越来越感觉自己的智商不够用了</p><p>用线段树的节点来存储这个节点所包含的区间 还有几个位置,<br>这样的话只要在每一次找到树中还剩下的第x个位置插入进去就行了<br>明白了这个就不难实现了</p><p>如果不太理解的话可以看下代码的注释</p><p>附本题代码<br>—————————————.</p><pre><code>//#include &lt;bits/stdc++.h&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;math.h&gt;#define abs(x)          (((x)&gt;0)?(x):-(x))#define lalal           puts(&quot;*********&quot;)#define Rep(a,b,c)      for(int a=(b);a&lt;=(c);a++)#define Req(a,b,c)      for(int a=(b);a&gt;=(c);a--)#define Rop(a,b,c)      for(int a=(b);a&lt;(c);a++)#define s1(a)           scanf(&quot;%d&quot;,&amp;a)typedef long long int LL;using namespace std;const int inf = 0x3f3f3f3f;const int MOD = 9901;/**************************************/const int N = 200000+10;struct node{    int l,r;//区间    int val;//叶子节点的元素    int flag;//这个区间有的空位置的位置数    int mid()    {        return (l+r)&gt;&gt;1;    }}tree[N&lt;&lt;2];#define ll (rt&lt;&lt;1)#define rr (rt&lt;&lt;1|1)int a[N],b[N],cnt,ans;void build(int rt,int l,int r){    tree[rt].l=l,tree[rt].r=r;    tree[rt].flag=r-l+1;    if(l==r) return;    int m = tree[rt].mid();    build(ll,l,m);    build(rr,m+1,r);}void update(int rt,int pos,int val){    tree[rt].flag--;//因为要插入一个值 所以就会少一个位置    if(tree[rt].l==tree[rt].r)    {        tree[rt].val = val;        return ;    }    if(tree[ll].flag&gt;=pos)    update(ll,pos,val);    else        update(rr,pos-tree[ll].flag,val);//因为这次遍历的是右儿子,所以在右儿子中找的是第pos-tree[ll].flag个位置}bool fl= 0;void dfs(int rt) //就是遍历叶子节点 输出结果{    if(tree[rt].l==tree[rt].r)    {        if(fl) printf(&quot; &quot;);        printf(&quot;%d&quot;,tree[rt].val),fl=true;        return ;    }    dfs(ll);    dfs(rr);}int main(){    int n;    while(~s1(n))    {        fl=false,build(1,1,n);        Rep(i,1,n) s1(a[i]),s1(b[i]);        Req(i,n,1) update(1,a[i]+1,b[i]);//因为建树是1~n所以讲元素位置右移一个        dfs(1),puts(&quot;&quot;);    }    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  HDU 1394 Minimum Inversion Number [线段树-&gt;单点更新]【数据结构】</title>
      <link href="/2016/11/13/53149713/"/>
      <url>/2016/11/13/53149713/</url>
      
        <content type="html"><![CDATA[<h1 id="HDU-1394-Minimum-Inversion-Number-线段树-gt-单点更新-【数据结构】"><a href="#HDU-1394-Minimum-Inversion-Number-线段树-gt-单点更新-【数据结构】" class="headerlink" title="HDU 1394 Minimum Inversion Number [线段树-&gt;单点更新]【数据结构】"></a>HDU 1394 Minimum Inversion Number [线段树-&gt;单点更新]【数据结构】</h1><p>2016年11月13日 16:27:43  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：214</p><hr><p> 博客爬取于<code>2019-04-18 17:18:51</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/53149713" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/53149713</a></p><p>题目链接： <a href="http://acm.hdu.edu.cn/showproblem.php?pid=1394" target="_blank" rel="noopener"> http://acm.hdu.edu.cn/showproblem.php?pid=1394</a></p><p>————————————————–.</p><p>Minimum Inversion Number<br>Time Limit: 2000/1000 MS (Java/Others) Memory Limit: 65536/32768 K<br>(Java/Others)<br>Total Submission(s): 18798 Accepted Submission(s): 11367</p><p>Problem Description<br>The inversion number of a given number sequence a1, a2, …, an is the number of<br>pairs (ai, aj) that satisfy i &lt; j and ai &gt; aj.</p><p>For a given sequence of numbers a1, a2, …, an, if we move the first m &gt;= 0<br>numbers to the end of the seqence, we will obtain another sequence. There are<br>totally n such sequences as the following:</p><p>a1, a2, …, an-1, an (where m = 0 - the initial seqence)<br>a2, a3, …, an, a1 (where m = 1)<br>a3, a4, …, an, a1, a2 (where m = 2)<br>…<br>an, a1, a2, …, an-1 (where m = n-1)</p><p>You are asked to write a program to find the minimum inversion number out of<br>the above sequences.</p><p>Input<br>The input consists of a number of test cases. Each case consists of two lines:<br>the first line contains a positive integer n (n &lt;= 5000); the next line<br>contains a permutation of the n integers from 0 to n-1.</p><p>Output<br>For each case, output the minimum inversion number on a single line.</p><p>Sample Input<br>10<br>1 3 6 9 0 8 5 7 4 2</p><p>Sample Output<br>16</p><p>Author<br>CHEN, Gaoli</p><p>Source<br>ZOJ Monthly, January 2003</p><p>—————————————————.</p><p>题目大意：<br>就是有一个序列 ，这个序列可以循环，变成下列这么些个序列。<br>a1, a2, …, an-1, an (m = 0 - the initial seqence)<br>a2, a3, …, an, a1 (m = 1)<br>a3, a4, …, an, a1, a2 (m = 2)<br>…<br>an, a1, a2, …, an-1 (m = n-1)<br>然后对于每种序列 计算逆序对数<br>然后输出逆序对数最小的值</p><p>解题思路:<br>首先对于最初的序列求解逆序对数 ，只需要线段树or树状数组就行了<br>这里采取的是线段树维护</p><p>在每次把数据挂到树上之前 可以区间查询的方式计算这个值的逆序数 然后O(  n  )遍历一遍就能知道整个序列的逆序数了<br>总复杂度是O(  n  l  o  g  n  )</p><p>然后他要求的序列一共有n个那样的话不能O(  n  2  l  o  g  n  ) 这样复杂度实在太高了</p><p>然后想最后发现了有一个规律；<br>因为序列中的数就是0~n-1且新的序列是从旧的序列移过来的。<br>那么逆序数就会相应减少  a  i  个 同时就增加了  n  −  a  i  −  1  个<br>这样的话就能够O(  1  )处理了</p><p>附本题代码<br>————————————.</p><pre><code>#include &lt;bits/stdc++.h&gt;#define abs(x)          (((x)&gt;0)?(x):-(x))#define lalal           puts(&quot;*********&quot;)#define Rep(a,b,c)      for(int a=(b);a&lt;=(c);a++)#define Req(a,b,c)      for(int a=(b);a&gt;=(c);a--)#define Rop(a,b,c)      for(int a=(b);a&lt;(c);a++)#define s1(a)           scanf(&quot;%d&quot;,&amp;a)typedef long long int LL;using namespace std;const int inf = 0x3f3f3f3f;const int MOD = 9901;/**************************************/const int N = 10000+5;struct node{    int l,r;    int val;    int md()    {        return (l+r)&gt;&gt;1;    }}tree[N&lt;&lt;2];int a[N],ans;#define ll  (rt&lt;&lt;1)#define rr  (rt&lt;&lt;1|1)#define mid (tree[rt].md())void pushup(int rt){    tree[rt].val=tree[ll].val+tree[rr].val;}void build(int rt,int l,int r){    tree[rt].l=l,tree[rt].r=r;    if(l==r)    {        tree[rt].val=0;        return ;    }    build(ll,l,mid);    build(rr,mid+1,r);    pushup(rt);    return;}void update(int rt,int pos,int val){    if(tree[rt].l==tree[rt].r)    {        tree[rt].val+=val;        return;    }    if(pos&lt;=mid)update(ll,pos,val);    else      update(rr,pos,val);    pushup(rt);    return;}void query(int rt,int L,int R){    if(L&lt;=tree[rt].l&amp;&amp;tree[rt].r&lt;=R)    {        ans += tree[rt].val;        return;    }    if(R&lt;=mid)        query(ll,L,R);    else if(L&gt;mid)        query(rr,L,R);    else    {        query(ll,L,R);        query(rr,L,R);    }    return;}int main(){    int n;    while(~s1(n))    {        build(1,0,n);        int sum = 0;        Rep(i,1,n)        {            s1(a[i]);            ans = 0;            query(1,a[i]+1,n);            sum+=ans;            update(1,a[i],1);        }        int mi = sum;        Rep(i,1,n)        {            sum+=n-a[i]-a[i]-1;            if(sum&lt;mi)                mi=sum;        }        printf(&quot;%d\n&quot;,mi);    }    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  HDU 1566 Color the ball [树状数组区间更新]【数据结构】</title>
      <link href="/2016/11/10/53120130/"/>
      <url>/2016/11/10/53120130/</url>
      
        <content type="html"><![CDATA[<h1 id="HDU-1566-Color-the-ball-树状数组区间更新-【数据结构】"><a href="#HDU-1566-Color-the-ball-树状数组区间更新-【数据结构】" class="headerlink" title="HDU 1566 Color the ball [树状数组区间更新]【数据结构】"></a>HDU 1566 Color the ball [树状数组区间更新]【数据结构】</h1><p>2016年11月10日 19:53:10  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：203</p><hr><p> 博客爬取于<code>2019-04-18 17:18:52</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/53120130" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/53120130</a></p><p>题目链接： <a href="http://acm.hdu.edu.cn/showproblem.php?pid=1556" target="_blank" rel="noopener"> http://acm.hdu.edu.cn/showproblem.php?pid=1556</a><br>————————————————-.<br>Color the ball</p><p>Time Limit: 9000/3000 MS (Java/Others) Memory Limit: 32768/32768 K<br>(Java/Others)<br>Total Submission(s): 17629 Accepted Submission(s): 8823</p><p>Problem Description<br>N个气球排成一排，从左到右依次编号为1,2,3….N.每次给定2个整数a b(a &lt;= b),lele便为骑上他的“小飞鸽”牌电动车从气球a开始到气球b依次<br>给每个气球涂一次颜色。但是N次以后lele已经忘记了第I个气球已经涂过几次颜色了，你能帮他算出每个气球被涂过几次颜色吗？</p><p>Input<br>每个测试实例第一行为一个整数N,(N &lt;= 100000).接下来的N行，每行包括2个整数a b(1 &lt;= a &lt;= b &lt;= N)。<br>当N = 0，输入结束。</p><p>Output<br>每个测试实例输出一行，包括N个整数，第I个数代表第I个气球总共被涂色的次数。</p><p>Sample Input<br>3<br>1 1<br>2 2<br>3 3<br>3<br>1 1<br>1 2<br>1 3<br>0</p><p>Sample Output<br>1 1 1<br>3 2 1</p><p>Author<br>8600</p><p>Source<br>HDU 2006-12 Programming Contest</p><p>—————————————————-.</p><p>题目大意： 。。。</p><p>解题思路：</p><p>题目给的很清楚了是区间更新，所以思考。<br>每次区间的每一个值都+1，那么考虑数据结构中的线段树和树状数组，<br>这里采用树状数组的做法。<br>这里只要直接根据树状数组的意义直接做就行了 ，<br>因为树状数组无非也就是一个动态的前缀和而且 。<br>这样的话没更新一个值，那么后面的所有值也相当于更新了；<br>所以更新区间就可以只单点更新两次就行了<br>对于区间（a，b）<br>只要给a更新+1，给b更新-1就行了；</p><p>附本题代码<br>——————————————-.</p><pre><code>#include &lt;bits/stdc++.h&gt;#define abs(x)          (((x)&gt;0)?(x):-(x))#define lalal           puts(&quot;*********&quot;)#define Rep(a,b,c)      for(int a=(b);a&lt;=(c);a++)#define Req(a,b,c)      for(int a=(b);a&gt;=(c);a--)#define Rop(a,b,c)      for(int a=(b);a&lt;(c);a++)#define s1(a)           scanf(&quot;%d&quot;,&amp;a)typedef long long int LL;using namespace std;const int inf = 0x3f3f3f3f;const int MOD = 9901;/**************************************/#define lowbit(x) (x&amp;-x)const int N = 100000+5;int sum[N];void update(int index,int val){    for(int i=index;i&lt;=N;i+=lowbit(i))        sum[i]+=val;}int getSum(int index){    int ans=0;    for(int i=index;i&gt;0;i-=lowbit(i))        ans+=sum[i];    return ans ;}int main(){    int n;    while(~s1(n)&amp;&amp;n){        Rep(i,1,n) sum[i]=0;        int a,b;        Rep(i,1,n){            s1(a),s1(b);            update(a,1);            update(b+1,-1);        }        Rop(i,1,n)  printf(&quot;%d &quot;,getSum(i));        printf(&quot;%d\n&quot;,getSum(n));    }    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  HDU 2836 Traversal [树状数组+二分+dp]【数据结构】</title>
      <link href="/2016/11/10/53116979/"/>
      <url>/2016/11/10/53116979/</url>
      
        <content type="html"><![CDATA[<h1 id="HDU-2836-Traversal-树状数组-二分-dp-【数据结构】"><a href="#HDU-2836-Traversal-树状数组-二分-dp-【数据结构】" class="headerlink" title="HDU 2836 Traversal [树状数组+二分+dp]【数据结构】"></a>HDU 2836 Traversal [树状数组+二分+dp]【数据结构】</h1><p>2016年11月10日 16:24:18  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：225<br>标签：  <a href="https://so.csdn.net/so/search/s.do?q=dp&amp;t=blog" target="_blank" rel="noopener"> dp </a></p><p>个人分类：  <a href="https://blog.csdn.net/qq_33184171/article/category/6362428" target="_blank" rel="noopener"> ==== 数据结构 ====</a> <a href="https://blog.csdn.net/qq_33184171/article/category/6362438" target="_blank" rel="noopener"> ==== 动态规划 ====</a> <a href="https://blog.csdn.net/qq_33184171/article/category/6117382" target="_blank" rel="noopener"> hdu</a></p><hr><p> 博客爬取于<code>2019-04-18 17:18:53</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/53116979" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/53116979</a></p><p>题目链接： <a href="http://acm.hdu.edu.cn/showproblem.php?pid=2836" target="_blank" rel="noopener"> http://acm.hdu.edu.cn/showproblem.php?pid=2836</a><br>———————————————————————————-.<br>Traversal</p><p>Time Limit: 2000/2000 MS (Java/Others) Memory Limit: 32768/32768 K<br>(Java/Others)<br>Total Submission(s): 891 Accepted Submission(s): 348</p><p>Problem Description<br>I arrive at a big lake and I have to cross it. Luckily, I’m a very good<br>jumper, but the lake is too big to be crossed in one jump. On the shore, I<br>find N boxes of different heights, set in a certain order. If I throw a box<br>into the lake, it will float and it will have the same height as on the shore.<br>This is good, because I intend to throw some boxes into the lake and get from<br>one shore to the other by jumping from box to box. The only things to consider<br>are:<br>The lake is big, so I must throw at least 2 boxes, which means that in order<br>to cross the lake I have to make at least 3 jumps.<br>Not all the boxes have to be thrown; some of them may be ignored.<br>The boxes can be thrown into the lake only in the order they are found on the<br>shore and I have to jump on them in this order.<br>The height difference between two consecutive boxes I use must be at most H<br>meters, because I can jump a lot in length, but I have some problems with<br>jumping in height.The height of a box doesn’t change when I jump on it.<br>I’m always able to jump from the shore to a box and from a box to the shore,<br>no matter what the height of the box is.</p><p>Facing so many possibilities that respect the above conditions, I begin<br>counting the number of possibilities that I have, instead of actually crossing<br>the lake. I quickly find the answer and I wonder whether you can also find it<br>as fast as I did.</p><p>Task</p><p>Write a program that determines the number of possibilities to cross the lake<br>in the above conditions. Since the number can be quite big, you only have to<br>output the remainder of this number, when divided by 9901.</p><p>Input<br>There are multiple test cases. Each test case contains two integers N and H,<br>separated by a space, representing the number of boxes and the maximum height<br>difference between two consecutive boxes thrown into the lake. The following N<br>lines contain the heights of the boxes, in the order the boxes are set on the<br>shore. The (i+1)th line contains the height of the ith box.</p><p>Output<br>For each test case you should output a single line, containing the number of<br>possibilities modulo 9901.</p><p>Constraints</p><p>1 &lt; N &lt; 100 001<br>0 &lt; H &lt; 100 000 001<br>The height of any box is a strictly positive integer and does not exceed 100<br>000 000</p><p>Sample Input<br>4 2<br>1<br>3<br>7<br>5</p><p>Sample Output<br>4</p><p>Hint</p><p>Explanation</p><p>There are 4 possibilities:<br>1 3<br>1 3 5<br>3 5<br>7 5</p><p>Source<br>2009 Multi-University Training Contest 3 - Host by WHU</p><p>————————————————————————————.<br>题目大意：<br>就是给你一个序列,至少选出两个元素的序列中使得相邻元素之间的差≤h 的方案数。</p><p>解题思路：<br>首先不看数据范围的话，很好想了 ，就是一个dp，<br>dp[i]为以i为结尾的方案数<br>转移就是<br>dp[i]=sigma{dp[j] | abs(a[i]-a[j])&lt;=H}+1</p><p>复杂度为O(n^2) ,所以不可行,<br>然后观察了一下,由于转移的过程中正好是一个连续的和,所以想到前缀和优化,又因为是动态的 ,所以采用了树状数组优化.</p><p>在选取连续区间的时候我们用另一个数组来存储 ,然后排个序,去个重,用来二分查询位置.</p><p>二分的就是3个<br>1) 是a[i]的位置 最后在这个位置+dp[i];<br>2) 是a[i]+H 转移过程的右极限<br>3) 是a[i] -H 转移过程的左极限</p><p>最后注意下代码细节 就可以了。<br>其实想到了如何DP这道题目就并不难了，奈何我个DP废。。。</p><p>附本题代码<br>—————————————————————————————–.</p><pre><code>#include &lt;bits/stdc++.h&gt;#define abs(x)          (((x)&gt;0)?(x):-(x))#define lalal           puts(&quot;*********&quot;)#define Rep(a,b,c)      for(int a=(b);a&lt;=(c);a++)#define Req(a,b,c)      for(int a=(b);a&gt;=(c);a--)#define Rop(a,b,c)      for(int a=(b);a&lt;(c);a++)#define s1(a)           scanf(&quot;%d&quot;,&amp;a)typedef long long int LL;using namespace std;const int inf = 0x3f3f3f3f;const int MOD = 9901;/**************************************/#define lowbit(x)  (x&amp;-x)const int N = 100000+5;int sum[N],n,m;int a[N],b[N],tot;void update(int index,int val){    for(int i=index;i&lt;=tot;i+=lowbit(i))        sum[i]+=val,sum[i]%=MOD;;}int getSum(int index){    int ans = 0;    for(int i=index;i&gt;0;i-=lowbit(i))        ans += sum[i],ans%=MOD;    return ans ;}int BS(int val){    int l=1,r=tot,mid;    while(l&lt;=r){        mid=(l+r)&gt;&gt;1;        if(b[mid]==val) return mid;        else if(b[mid]&lt;val) l=mid+1;        else r=mid-1;    }}int lBS(int val){    int l=1,r=tot,mid;    int ans = 1;    while(l&lt;=r){        mid=(l+r)&gt;&gt;1;        if(b[mid] &lt; val)            l=mid+1;        else ans=mid,r=mid-1;    }    return ans;}int rBS(int val){    int l=1,r=tot,mid;    int ans=tot;    while(l&lt;=r){        mid=(l+r)&gt;&gt;1;        if(b[mid] &lt;= val) ans=mid,l=mid+1;        else r=mid-1;    }    return ans;}int main(){    while(~s1(n)){        s1(m);        Rep(i,1,n) s1(a[i]),b[i]=a[i];        sort(b+1,b+n+1);        tot=0;        for(int i=1;i&lt;=n;i++){            if(i==1||b[i]!=b[i-1]){                b[++tot]=b[i];                sum[tot]=0;            }        }        int id,l,r,val,ans=0;        Rep(i,1,n){            id=BS(a[i]);            l=lBS(a[i]-m);            r=rBS(a[i]+m);            val=(getSum(r)-getSum(l-1)+MOD)%MOD;            ans=(ans+val)%MOD;            update(id,val+1);        }        printf(&quot;%d\n&quot;,ans);    }    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hdu </tag>
            
            <tag> 动态规划 </tag>
            
            <tag> dp </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  HDU 2642 Stars [二维树状数组]【数据结构】</title>
      <link href="/2016/11/09/53106292/"/>
      <url>/2016/11/09/53106292/</url>
      
        <content type="html"><![CDATA[<h1 id="HDU-2642-Stars-二维树状数组-【数据结构】"><a href="#HDU-2642-Stars-二维树状数组-【数据结构】" class="headerlink" title="HDU 2642 Stars [二维树状数组]【数据结构】"></a>HDU 2642 Stars [二维树状数组]【数据结构】</h1><p>2016年11月09日 21:26:29  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：284</p><hr><p> 博客爬取于<code>2019-04-18 17:18:54</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/53106292" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/53106292</a></p><p>题目链接: <a href="http://acm.hdu.edu.cn/showproblem.php?pid=2642" target="_blank" rel="noopener"> http://acm.hdu.edu.cn/showproblem.php?pid=2642</a></p><p>—————————————————————————————–.<br>Stars</p><p>Time Limit: 5000/2000 MS (Java/Others) Memory Limit: 32768/65536 K<br>(Java/Others)<br>Total Submission(s): 1675 Accepted Submission(s): 706</p><p>Problem Description<br>Yifenfei is a romantic guy and he likes to count the stars in the sky.<br>To make the problem easier,we considerate the sky is a two-dimension<br>plane.Sometimes the star will be bright and sometimes the star will be dim.At<br>first,there is no bright star in the sky,then some information will be given<br>as “B x y” where ‘B’ represent bright and x represent the X coordinate and y<br>represent the Y coordinate means the star at (x,y) is bright,And the ‘D’ in “D<br>x y” mean the star at(x,y) is dim.When get a query as “Q X1 X2 Y1 Y2”,you<br>should tell Yifenfei how many bright stars there are in the region correspond<br>X1,X2,Y1,Y2.</p><p>There is only one case.</p><p>Input<br>The first line contain a M(M &lt;= 100000), then M line followed.<br>each line start with a operational character.<br>if the character is B or D,then two integer X,Y (0 &lt;=X,Y&lt;= 1000)followed.<br>if the character is Q then four integer X1,X2,Y1,Y2(0 &lt;=X1,X2,Y1,Y2&lt;= 1000)<br>followed.</p><p>Output<br>For each query,output the number of bright stars in one line.</p><p>Sample Input<br>5<br>B 581 145<br>B 581 145<br>Q 0 600 0 200<br>D 581 145<br>Q 0 600 0 200</p><p>Sample Output<br>1<br>0</p><p>Author<br>teddy</p><p>Source<br>百万秦关终属楚</p><p>—————————————————————————————–.</p><p>题目大意：<br>就是一共有M个操作<br>操作一共有3种<br>1）B x y （x，y）位置上出现星星<br>2）D x y （x，y）位置的星星消失了<br>3）Q x1 x2 y1 y1 查询矩形范围内的星星有多少个</p><p>解题思路：</p><p>思路上没有什么可说的，因为是动态的 所以必须是二维树状数组，维护即可</p><p>注意的是 ，同一坐标下最多只能有一个星星，删除的话这个坐标就没有星星了</p><p><strong> 注意 </strong> 做题的时候注意下坐标的范围 ，因为是从0开始那么计算的时候所有坐标都要加1 否则的话会无限TLE </p><p>附本题代码<br>———————————————————————————————.</p><pre><code>#include &lt;bits/stdc++.h&gt;#define abs(x)          (((x)&gt;0)?(x):-(x))#define lalal           puts(&quot;*********&quot;)#define Rep(a,b,c)      for(int a=(b);a&lt;=(c);a++)#define Req(a,b,c)      for(int a=(b);a&gt;=(c);a--)#define Rop(a,b,c)      for(int a=(b);a&lt;(c);a++)#define s1(a)           scanf(&quot;%d&quot;,&amp;a)typedef long long int LL;using namespace std;/**************************************/const int N = 1000+5;#define lowbit(x) (x&amp;-x)LL sum[N][N];bool h[N][N];void update(int xi,int yi,int val){    for(int i=xi;i&lt;=N;i+=lowbit(i))        for(int j=yi;j&lt;=N;j+=lowbit(j))            sum[i][j]+=val;    return;}int getSum(int xi,int yi){    int ans = 0;    for(int i=xi;i&gt;0;i-=lowbit(i))        for(int j=yi;j&gt;0;j-=lowbit(j))            ans+=sum[i][j];    return ans ;}int main(){    int n;    while(~s1(n)){        memset(sum,0,sizeof(sum));        memset(h,0,sizeof(h));        char ch;        int x1,y1,x2,y2;        int tem;        while(n--){            getchar();            scanf(&quot;%c&quot;,&amp;ch);            if(&#39;B&#39;==ch){                s1(x1),s1(y1);                x1++,y1++;                if(h[x1][y1]) continue;                update(x1,y1,1);                h[x1][y1]=1;            }            else if(&#39;D&#39;==ch){                s1(x1),s1(y1);                x1++,y1++;                if(h[x1][y1]) update(x1,y1,-1);                h[x1][y1]=0;            }            else {                s1(x1),s1(x2),s1(y1),s1(y2);                x1++,y1++,x2++,y2++;                if(x1&gt;x2) swap(x1,x2);                if(y1&gt;y2) swap(y1,y2);                tem=getSum(x2,y2)-getSum(x2,y1-1)-getSum(x1-1,y2)+getSum(x1-1,y1-1);                printf(&quot;%d\n&quot;,tem);            }        }    }    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  HDU 2852 KiKi&#39;s K-Number [树状数组+二分答案]【数据结构】</title>
      <link href="/2016/11/09/53105883/"/>
      <url>/2016/11/09/53105883/</url>
      
        <content type="html"><![CDATA[<h1 id="HDU-2852-KiKi’s-K-Number-树状数组-二分答案-【数据结构】"><a href="#HDU-2852-KiKi’s-K-Number-树状数组-二分答案-【数据结构】" class="headerlink" title="HDU 2852 KiKi’s K-Number [树状数组+二分答案]【数据结构】"></a>HDU 2852 KiKi’s K-Number [树状数组+二分答案]【数据结构】</h1><p>2016年11月09日 20:47:06  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：216</p><hr><p> 博客爬取于<code>2019-04-18 17:18:55</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/53105883" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/53105883</a></p><p>题目链接： <a href="http://acm.hdu.edu.cn/showproblem.php?pid=2852" target="_blank" rel="noopener"> http://acm.hdu.edu.cn/showproblem.php?pid=2852</a></p><p>———————————————————–.<br>KiKi’s K-Number</p><p>Time Limit: 4000/2000 MS (Java/Others) Memory Limit: 32768/32768 K<br>(Java/Others)<br>Total Submission(s): 3865 Accepted Submission(s): 1716</p><p>Problem Description<br>For the k-th number, we all should be very familiar with it. Of course,to kiki<br>it is also simple. Now Kiki meets a very similar problem, kiki wants to design<br>a container, the container is to support the three operations.</p><p>Push: Push a given element e to container</p><p>Pop: Pop element of a given e from container</p><p>Query: Given two elements a and k, query the kth larger number which greater<br>than a in container;</p><p>Although Kiki is very intelligent, she can not think of how to do it, can you<br>help her to solve this problem?</p><p>Input<br>Input some groups of test data ,each test data the first number is an integer<br>m (1 &lt;= m &lt;100000), means that the number of operation to do. The next m<br>lines, each line will be an integer p at the beginning, p which has three<br>values:<br>If p is 0, then there will be an integer e (0 &lt; e &lt;100000), means press<br>element e into Container.</p><p>If p is 1, then there will be an integer e (0 &lt; e &lt;100000), indicated that<br>delete the element e from the container</p><p>If p is 2, then there will be two integers a and k (0 &lt; a &lt;100000, 0 &lt; k</p><p>&lt;10000),means the inquiries, the element is greater than a, and the k-th<br>larger number.</p><p>Output<br>For each deletion, if you want to delete the element which does not exist, the<br>output “No Elment!”. For each query, output the suitable answers in line .if<br>the number does not exist, the output “Not Find!”.</p><p>Sample Input<br>5<br>0 5<br>1 2<br>0 6<br>2 3 2<br>2 8 1<br>7<br>0 2<br>0 2<br>0 4<br>2 1 1<br>2 1 2<br>2 1 3<br>2 1 4</p><p>Sample Output<br>No Elment!<br>6<br>Not Find!<br>2<br>2<br>4<br>Not Find!</p><p>Source<br>2009 Multi-University Training Contest 4 - Host by HDU</p><p>———————————————————–.</p><p>题目大意：<br>就是有N个操作 ，操作一共有3种<br>1） 0 的时候 就是在集合中加上一个e<br>2） 1 的时候 就是在集合中删除一个e<br>3） 2 的时候 就是找到在集合中比a大的第K个数</p><p>解题思路：<br>因为数一直是在1e6以内的 所以我们只要将其放在一个树状数组中就行了</p><p>这样的话对于 1，2操作就非常好处理了 ，利用桶的思想，记录一下就行了</p><p>但是对于3操作的话 就不行了，因为直接暴力的话会TLE啊 ，<br>所以我们只要二分一下答案 就可以了；</p><p>还是很简单啊 。</p><p>附本题代码</p><p>———————————————————————.</p><pre><code>#include &lt;bits/stdc++.h&gt;#define abs(x)          (((x)&gt;0)?(x):-(x))#define lalal           puts(&quot;*********&quot;)#define Rep(a,b,c)      for(int a=(b);a&lt;=(c);a++)#define Req(a,b,c)      for(int a=(b);a&gt;=(c);a--)#define Rop(a,b,c)      for(int a=(b);a&lt;(c);a++)#define s1(a)           scanf(&quot;%d&quot;,&amp;a)typedef long long int LL;using namespace std;/**************************************/const int N = 100000+5;#define lowbit(x) (x&amp;-x)LL sum[N];int h[N];void update(int index,int val){    for(int i=index;i&lt;=N;i+=lowbit(i))        sum[i]+=val;    return ;}LL getSum(int index){    LL ans=0;    for(int i=index;i&gt;0;i-=lowbit(i))        ans+=sum[i];    return ans;}LL cal(int l,int r){    return getSum(r)-getSum(l);//因为是比a大 所以不用-1;}int main(){    int n;    while(~s1(n)){        memset(sum,0,sizeof(sum));        memset(h,0,sizeof(h));        int op,e,a,k;        while(n--){            s1(op);            if(0==op){                s1(e);                update(e,1);                h[e]++;            }            else if(1==op){                s1(e);                if(h[e]&gt;0) update(e,-1),h[e]--;                else    puts(&quot;No Elment!&quot;);            }            else {                s1(a),s1(k);                int l=a,r=100000,mid,ret=-1;                while(l&lt;=r){                    mid=(l+r)&gt;&gt;1;                    if(cal(a,mid)&gt;=k){                        ret = mid;                        r = mid-1;                    }                    else l = mid+1;                }                if(-1==ret) puts(&quot;Not Find!&quot;);                else        printf(&quot;%d\n&quot;,ret);            }        }    }    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  HDU 1559 最大子矩阵 [二维树状数组]【数据结构】</title>
      <link href="/2016/11/09/53100103/"/>
      <url>/2016/11/09/53100103/</url>
      
        <content type="html"><![CDATA[<h1 id="HDU-1559-最大子矩阵-二维树状数组-【数据结构】"><a href="#HDU-1559-最大子矩阵-二维树状数组-【数据结构】" class="headerlink" title="HDU 1559 最大子矩阵 [二维树状数组]【数据结构】"></a>HDU 1559 最大子矩阵 [二维树状数组]【数据结构】</h1><p>2016年11月09日 15:09:25  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：236</p><hr><p> 博客爬取于<code>2019-04-18 17:18:56</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/53100103" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/53100103</a></p><p>题目链接： <a href="http://acm.hdu.edu.cn/showproblem.php?pid=1559" target="_blank" rel="noopener"> http://acm.hdu.edu.cn/showproblem.php?pid=1559</a><br>———————————————————————————————.<br>最大子矩阵</p><p>Time Limit: 30000/10000 MS (Java/Others) Memory Limit: 32768/32768 K<br>(Java/Others)<br>Total Submission(s): 4361 Accepted Submission(s): 2273</p><p>Problem Description<br>给你一个m×n的整数矩阵，在上面找一个x×y的子矩阵，使子矩阵中所有元素的和最大。</p><p>Input<br>输入数据的第一行为一个正整数T，表示有T组测试数据。每一组测试数据的第一行为四个正整数m,n,x,y（0&lt; m,n&lt;1000 AND 0&lt; x&lt;=m AND<br>0&lt; y&lt;=n），表示给定的矩形有m行n列。接下来这个矩阵，有m行，每行有n个不大于1000的正整数。</p><p>Output<br>对于每组数据，输出一个整数，表示子矩阵的最大和。</p><p>Sample Input<br>1<br>4 5 2 2<br>3 361 649 676 588<br>992 762 156 993 169<br>662 34 638 89 543<br>525 165 254 809 280</p><p>Sample Output<br>2474</p><p>Author<br>lwg</p><p>Source<br>HDU 2006-12 Programming Contest</p><p>———————————————————————————————.</p><p>题目大意：中文题</p><p>解题思路 ：<br>根据这个时限 目测暴力都能过去 ，但是为了练习树状数组 还是用二维的树状数组过得</p><p>最最最最裸的二维树状数组 没什么可说的</p><p>附本题代码<br>—————————————————————————————-.</p><pre><code>#include &lt;bits/stdc++.h&gt;#define abs(x)          (((x)&gt;0)?(x):-(x))#define lalal           puts(&quot;*********&quot;)#define Rep(a,b,c)      for(int a=(b);a&lt;=(c);a++)#define Req(a,b,c)      for(int a=(b);a&gt;=(c);a--)#define Rop(a,b,c)      for(int a=(b);a&lt;(c);a++)#define s1(a)           scanf(&quot;%d&quot;,&amp;a)typedef long long int LL;using namespace std;/**************************************/const int N = 1000+5;#define lowbit(x)       (x&amp;-x)int cnt,sum[N][N],n,m;void update(int xi,int yi,int val){    for(int i=xi;i&lt;=n;i+=lowbit(i))        for(int j=yi;j&lt;=m;j+=lowbit(j))            sum[i][j]+=val;    return;}int getSum(int xi,int yi){    int ans = 0;    for(int i=xi;i&gt;0;i-=lowbit(i))        for(int j=yi;j&gt;0;j-=lowbit(j))            ans+=sum[i][j];    return ans;}int main(){    int _;    while(~s1(_)){        while(_--){            memset(sum,0,sizeof(sum));            int x,y,temp;            s1(n),s1(m),s1(x),s1(y);            Rep(i,1,n)Rep(j,1,m) s1(temp),update(i,j,temp);            int mx=-1;            Rep(i,x,n)Rep(j,y,m){                temp=getSum(i,j)-getSum(i,j-y)-getSum(i-x,j)+getSum(i-x,j-y);                mx=max(mx,temp);            }            printf(&quot;%d\n&quot;,mx);        }    }    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  HDU 2838 Cow Sorting [树状数组]【数据结构】</title>
      <link href="/2016/11/08/53088871/"/>
      <url>/2016/11/08/53088871/</url>
      
        <content type="html"><![CDATA[<h1 id="HDU-2838-Cow-Sorting-树状数组-【数据结构】"><a href="#HDU-2838-Cow-Sorting-树状数组-【数据结构】" class="headerlink" title="HDU 2838 Cow Sorting [树状数组]【数据结构】"></a>HDU 2838 Cow Sorting [树状数组]【数据结构】</h1><p>2016年11月08日 21:46:00  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：213</p><hr><p> 博客爬取于<code>2019-04-18 17:18:57</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/53088871" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/53088871</a></p><p>题目链接: <a href="http://acm.hdu.edu.cn/showproblem.php?pid=2838" target="_blank" rel="noopener"> http://acm.hdu.edu.cn/showproblem.php?pid=2838</a><br>—————————————————-.<br>Cow Sorting</p><p>Time Limit: 2000/1000 MS (Java/Others) Memory Limit: 32768/32768 K<br>(Java/Others)<br>Total Submission(s): 3275 Accepted Submission(s): 1102</p><p>Problem Description<br>Sherlock’s N (1 ≤ N ≤ 100,000) cows are lined up to be milked in the evening.<br>Each cow has a unique “grumpiness” level in the range 1…100,000. Since grumpy<br>cows are more likely to damage Sherlock’s milking equipment, Sherlock would<br>like to reorder the cows in line so they are lined up in increasing order of<br>grumpiness. During this process, the places of any two cows (necessarily<br>adjacent) can be interchanged. Since grumpy cows are harder to move, it takes<br>Sherlock a total of X + Y units of time to exchange two cows whose grumpiness<br>levels are X and Y.</p><p>Please help Sherlock calculate the minimal time required to reorder the cows.</p><p>Input<br>Line 1: A single integer: N<br>Lines 2..N + 1: Each line contains a single integer: line i + 1 describes the<br>grumpiness of cow i.</p><p>Output<br>Line 1: A single line with the minimal time required to reorder the cows in<br>increasing order of grumpiness.</p><p>Sample Input<br>3<br>2<br>3<br>1</p><p>Sample Output<br>7</p><p>Hint</p><p>Input Details</p><p>Three cows are standing in line with respective grumpiness levels 2, 3, and 1.<br>Output Details</p><p>2 3 1 : Initial order.<br>2 1 3 : After interchanging cows with grumpiness 3 and 1 (time=1+3=4).<br>1 2 3 : After interchanging cows with grumpiness 1 and 2 (time=2+1=3).</p><p>Source<br>2009 Multi-University Training Contest 3 - Host by WHU</p><p>—————————————————-.</p><p>题目大意:<br>主要看hint就能知道了<br>其实还是一个冒泡排序 只不过求得是总花费 每次花费为交换的两个值得和</p><p>解题思路:<br>首先用树状数组对每个数求一下他出现之前逆序对数<br>对于每个数来说 它对结果的贡献就是<br>他之前的逆序对数*a_i+与他逆序的数的总和</p><p>这里直接采取了维护两个树状数组的暴力思路:<br>一个维护逆序对个数<br>一个维护逆序数的和</p><p>注意要用I64 否则溢出了…</p><p>附本题代码<br>————————————————————————.</p><pre><code>#include &lt;bits/stdc++.h&gt;#define abs(x)          (((x)&gt;0)?(x):-(x))#define lalal           puts(&quot;*********&quot;)#define Rep(a,b,c)      for(int a=(b);a&lt;=(c);a++)#define Req(a,b,c)      for(int a=(b);a&gt;=(c);a--)#define Rop(a,b,c)      for(int a=(b);a&lt;(c);a++)#define s1(a)           scanf(&quot;%d&quot;,&amp;a)typedef long long int LL;using namespace std;/**************************************/const int N = 100000+5;#define lowbit(x)    (x&amp;-x)LL sum1[N],sum2[N];int cnt;void update1(int index,int val){    for(int i=index;i&lt;=cnt;i+=lowbit(i))        sum1[i]+=val;    return ;}LL getSum1(int index){    LL ans=0;    for(int i=index;i&gt;0;i-=lowbit(i))        ans+=sum1[i];    return ans;}void update2(int index,int val){    for(int i=index;i&lt;=cnt;i+=lowbit(i))        sum2[i]+=val;    return ;}LL getSum2(int index){    LL ans=0;    for(int i=index;i&gt;0;i-=lowbit(i))        ans+=sum2[i];    return ans;}int main(){    while(~s1(cnt)){        int x;        LL ans=0;        memset(sum1,0,sizeof(sum1));        memset(sum2,0,sizeof(sum2));        Rep(i,1,cnt){            s1(x);            ans+=x*(getSum2(cnt)-getSum2(x))+(getSum1(cnt)-getSum1(x));            update1(x,x);            update2(x,1);        }        printf(&quot;%I64d\n&quot;,ans);    }    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  HDU 5775 Bubble Sort [树状数组]【数据结构】</title>
      <link href="/2016/11/08/53088409/"/>
      <url>/2016/11/08/53088409/</url>
      
        <content type="html"><![CDATA[<h1 id="HDU-5775-Bubble-Sort-树状数组-【数据结构】"><a href="#HDU-5775-Bubble-Sort-树状数组-【数据结构】" class="headerlink" title="HDU 5775 Bubble Sort [树状数组]【数据结构】"></a>HDU 5775 Bubble Sort [树状数组]【数据结构】</h1><p>2016年11月08日 21:03:47  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：202</p><hr><p> 博客爬取于<code>2019-04-18 17:18:58</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/53088409" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/53088409</a></p><p>题目链接： <a href="http://acm.hdu.edu.cn/showproblem.php?pid=5775" target="_blank" rel="noopener"> http://acm.hdu.edu.cn/showproblem.php?pid=5775</a></p><p>———————————————————-.<br>Bubble Sort</p><p>Time Limit: 2000/1000 MS (Java/Others) Memory Limit: 65536/65536 K<br>(Java/Others)<br>Total Submission(s): 1241 Accepted Submission(s): 683</p><p>Problem Description<br>P is a permutation of the integers from 1 to N(index starting from 1).<br>Here is the code of Bubble Sort in C++.</p><p>for(int i=1;i&lt;=N;++i)<br>for(int j=N,t;j&gt;i;—j)<br>if(P[j-1] &gt; P[j])<br>t=P[j],P[j]=P[j-1],P[j-1]=t;</p><p>After the sort, the array is in increasing order. ?? wants to know the<br>absolute values of difference of rightmost place and leftmost place for every<br>number it reached.</p><p>Input<br>The first line of the input gives the number of test cases T; T test cases<br>follow.<br>Each consists of one line with one integer N, followed by another line with a<br>permutation of the integers from 1 to N, inclusive.</p><p>limits<br>T &lt;= 20<br>1 &lt;= N &lt;= 100000<br>N is larger than 10000 in only one case.</p><p>Output<br>For each test case output “Case #x: y1 y2 … yN” (without quotes), where x is<br>the test case number (starting from 1), and yi is the difference of rightmost<br>place and leftmost place of number i.</p><p>Sample Input<br>2<br>3<br>3 1 2<br>3<br>1 2 3</p><p>Sample Output<br>Case #1: 1 1 2<br>Case #2: 0 0 0</p><p>Hint<br>In first case, (3, 1, 2) -&gt; (3, 1, 2) -&gt; (1, 3, 2) -&gt; (1, 2, 3)<br>the leftmost place and rightmost place of 1 is 1 and 2, 2 is 2 and 3, 3 is 1<br>and 3<br>In second case, the array has already in increasing order. So the answer of<br>every number is 0.</p><p>Author<br>FZU</p><p>Source<br>2016 Multi-University Training Contest 4</p><p>———————————————————–.</p><p>题目大意：<br>就是求每个数字在冒泡排序的过程中位置的区间大小</p><p>解题思路：<br>用手写了写 发现结果就是<br>max（前面有几个比a_i大，后面有几个比a_i小）；<br>其实也很好想 根据冒泡排序的交换规则<br>很容易的计算每一个数字左移数和右移数<br>至于结果为什么是二者的最大值 也很好想,<br>因为两者的差就是a_i-i,画图演示的话就是<br><img src="https://img-blog.csdn.net/20161108210304551" alt="这里写图片描述"><br>其他情况得跟这个差不多 不再赘述/</p><p>然后用树状数组维护两遍就行了</p><p>附本题代码<br>—————————————.</p><pre><code>#include &lt;bits/stdc++.h&gt;#define abs(x)          (((x)&gt;0)?(x):-(x))#define lalal           puts(&quot;*********&quot;)#define Rep(a,b,c)      for(int a=(b);a&lt;=(c);a++)#define Req(a,b,c)      for(int a=(b);a&gt;=(c);a--)#define Rop(a,b,c)      for(int a=(b);a&lt;(c);a++)#define s1(a)           scanf(&quot;%d&quot;,&amp;a)using namespace std;/**************************************/const int N = 100000+5;#define lowbit(x)  (x&amp;-x)int sum[N],cnt,ans[N],a[N];void update(int index,int val){    for(int i=index;i&lt;=cnt;i+=lowbit(i))        sum[i]+=val;    return;}int getSum(int index){    int ans = 0;    for(int i=index;i&gt;0;i-=lowbit(i))        ans+=sum[i];    return ans;}int main(){    int _,kc,x;    while(~s1(_)){        kc=0;        while(_--){            s1(cnt);            memset(sum,0,sizeof(sum));            memset(ans,0,sizeof(ans));            Rep(i,1,cnt){                s1(a[i]);                ans[a[i]] =getSum(cnt)-getSum(a[i]);                update(a[i],1);            }            memset(sum,0,sizeof(sum));            Req(i,cnt,1){                ans[a[i]] =max(ans[a[i]],getSum(a[i]));                update(a[i],1);            }            printf(&quot;Case #%d:&quot;,++kc);            Rep(i,1,cnt) printf(&quot; %d&quot;,ans[i]);            puts(&quot;&quot;);        }    }    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  HDU 2689 Sort it [树状数组]【数据结构】</title>
      <link href="/2016/11/08/53086898/"/>
      <url>/2016/11/08/53086898/</url>
      
        <content type="html"><![CDATA[<h1 id="HDU-2689-Sort-it-树状数组-【数据结构】"><a href="#HDU-2689-Sort-it-树状数组-【数据结构】" class="headerlink" title="HDU 2689 Sort it [树状数组]【数据结构】"></a>HDU 2689 Sort it [树状数组]【数据结构】</h1><p>2016年11月08日 20:10:00  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：230</p><hr><p> 博客爬取于<code>2019-04-18 17:18:59</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/53086898" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/53086898</a></p><p>题目链接: <a href="http://acm.hdu.edu.cn/showproblem.php?pid=2689" target="_blank" rel="noopener"> http://acm.hdu.edu.cn/showproblem.php?pid=2689</a><br>————————————————————————————-.<br>Sort it</p><p>Time Limit: 2000/1000 MS (Java/Others) Memory Limit: 32768/32768 K<br>(Java/Others)<br>Total Submission(s): 4140 Accepted Submission(s): 2945</p><p>Problem Description<br>You want to processe a sequence of n distinct integers by swapping two<br>adjacent sequence elements until the sequence is sorted in ascending order.<br>Then how many times it need.<br>For example, 1 2 3 5 4, we only need one operation : swap 5 and 4.</p><p>Input<br>The input consists of a number of test cases. Each case consists of two lines:<br>the first line contains a positive integer n (n &lt;= 1000); the next line<br>contains a permutation of the n integers from 1 to n.</p><p>Output<br>For each case, output the minimum times need to sort it in ascending order on<br>a single line.</p><p>Sample Input<br>3<br>1 2 3<br>4<br>4 3 2 1</p><p>Sample Output<br>0<br>6</p><p>Author<br>WhereIsHeroFrom</p><p>Source<br>ZJFC 2009-3 Programming Contest</p><p>————————————————————————————-.</p><p>题目大意：<br>就是问这个序列冒泡排序的话 需要交换多少次</p><p>解题思路：<br>明确题意之后就非常好理解了<br>对于每个数字来说交换了多少次 也就是在这个数出现之前有几个比他大的数字。累加即可。</p><p>这里维护一个树状数组，每次把a[i]的值更新为1，这样的话查询的时候1~a[i]的和就是这个数出现之前比他大的数字的个数。</p><p>处理不难 。</p><p>附本题代码<br>———————————-.</p><pre><code>#include &lt;bits/stdc++.h&gt;#define abs(x)  (((x)&gt;0)?(x):-(x))#define lalal   puts(&quot;*********&quot;)using namespace std;/**************************************/const int N = 1000+5;#define lowbit(x) (x&amp;-x)int cnt,sum[N],a[N];void update(int index,int val){    for(int i=index;i&lt;=cnt;i+=lowbit(i))        sum[i]+=val;    return ;}int getSum(int index){    int ans = 0;    for(int i=index;i&gt;0;i-=lowbit(i))        ans+=sum[i];    return ans;}int main(){    while(~scanf(&quot;%d&quot;,&amp;cnt)){        memset(sum,0,sizeof(sum));        for(int i=1;i&lt;=cnt;i++)            scanf(&quot;%d&quot;,&amp;a[i]);        int ans=0;        for(int i=cnt;i;i--){            ans+=getSum(a[i]);            update(a[i],1);        }        printf(&quot;%d\n&quot;,ans);    }    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  HDU 4046 Panda [树状数组]【数据结构】</title>
      <link href="/2016/11/08/53086391/"/>
      <url>/2016/11/08/53086391/</url>
      
        <content type="html"><![CDATA[<h1 id="HDU-4046-Panda-树状数组-【数据结构】"><a href="#HDU-4046-Panda-树状数组-【数据结构】" class="headerlink" title="HDU 4046 Panda [树状数组]【数据结构】"></a>HDU 4046 Panda [树状数组]【数据结构】</h1><p>2016年11月08日 19:45:07  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：244</p><hr><p> 博客爬取于<code>2019-04-18 17:19:00</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/53086391" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/53086391</a></p><p>题目链接： <a href="http://acm.hdu.edu.cn/showproblem.php?pid=4046" target="_blank" rel="noopener"> http://acm.hdu.edu.cn/showproblem.php?pid=4046</a></p><p>—————————————————————.</p><p>Panda</p><p>Time Limit: 10000/4000 MS (Java/Others) Memory Limit: 32768/32768 K<br>(Java/Others)<br>Total Submission(s): 3439 Accepted Submission(s): 1113</p><p>Problem Description<br>When I wrote down this letter, you may have been on the airplane to U.S.<br>We have known for 15 years, which has exceeded one-fifth of my whole life. I<br>still remember the first time we went to the movies, the first time we went<br>for a walk together. I still remember the smiling face you wore when you were<br>dressing in front of the mirror. I love your smile and your shining eyes. When<br>you are with me, every second is wonderful.<br>The more expectation I had, the more disappointment I got. You said you would<br>like to go to U.S.I know what you really meant. I respect your decision.<br>Gravitation is not responsible for people falling in love. I will always be<br>your best friend. I know the way is difficult. Every minute thinking of giving<br>up, thinking of the reason why you have held on for so long, just keep going<br>on. Whenever you’re having a bad day, remember this: I LOVE YOU.<br>I will keep waiting, until you come back. Look into my eyes and you will see<br>what you mean to me.<br>There are two most fortunate stories in my life: one is finally the time I<br>love you exhausted. the other is that long time ago on a particular day I met<br>you.<br>Saerdna.</p><p>It comes back to several years ago. I still remember your immature face.<br>The yellowed picture under the table might evoke the countless memory. The boy<br>will keep the last appointment with the girl, miss the heavy rain in those<br>years, miss the love in those years. Having tried to conquer the world, only<br>to find that in the end, you are the world. I want to tell you I didn’t<br>forget. Starry night, I will hold you tightly.</p><p>Saerdna loves Panda so much, and also you know that Panda has two colors,<br>black and white.<br>Saerdna wants to share his love with Panda, so he writes a love letter by just<br>black and white.<br>The love letter is too long and Panda has not that much time to see the whole<br>letter.<br>But it’s easy to read the letter, because Saerdna hides his love in the letter<br>by using the three continuous key words that are white, black and white.<br>But Panda doesn’t know how many Saerdna’s love there are in the letter.<br>Can you help Panda?</p><p>Input<br>An integer T means the number of test cases T&lt;=100<br>For each test case:<br>First line is two integers n, m<br>n means the length of the letter, m means the query of the Panda.<br>n&lt;=50000,m&lt;=10000<br>The next line has n characters ‘b’ or ‘w’, ‘b’ means black, ‘w’ means white.<br>The next m lines<br>Each line has two type<br>Type 0: answer how many love between L and R. (0&lt;=L&lt;=R&lt; n)<br>Type 1: change the kth character to ch(0&lt;=k&lt; n and ch is ‘b’ or ‘w’)</p><p>Output<br>For each test case, output the case number first.<br>The answer of the question.</p><p>Sample Input<br>2</p><p>5 2<br>bwbwb<br>0 0 4<br>0 1 3<br>5 5<br>wbwbw<br>0 0 4<br>0 0 2<br>0 2 4<br>1 2 b<br>0 0 4</p><p>Sample Output<br>Case 1:<br>1<br>1<br>Case 2:<br>2<br>1<br>1<br>0</p><p>Source<br>The 36th ACM/ICPC Asia Regional Beijing Site —— Online Contest</p><p>—————————————————————.</p><p>题目大意：<br>就是最开始有一个n这么长的串 有m次操作<br>操作０，L，R，询问L~R中内包含”wbw”的个数。<br>操作１，k，ch，将第k个字符更换为ch。</p><p>解题思路：<br>就是用树状数组维护一下 ，在“wbw”中以左边为界放到树状数组中就行了。</p><p>然后在更换字符的时候<br>枚举一下几种情况就行了</p><p>附本题代码<br>—————————————–.</p><pre><code>#include &lt;bits/stdc++.h&gt;#define abs(x)  (((x)&gt;0)?(x):-(x))#define lalal   puts(&quot;*********&quot;)using namespace std;/**************************************/const int N = 50000+5;#define lowbit(x) (x&amp;-x)int sum[N],cnt;void update(int index,int val){    for(int i=index; i&lt;=cnt; i+=lowbit(i)){        sum[i]+=val;    }    return ;}int getSum(int index){    int ans = 0;    for(int i=index; i&gt;0; i-=lowbit(i)){        ans+=sum[i];    }    return ans ;}char a[N];int main(){    int _,kc;    while(~scanf(&quot;%d&quot;,&amp;_)){        kc=0;        while(_--){            memset(sum,0,sizeof(sum));            int n,m;            scanf(&quot;%d %d&quot;,&amp;n,&amp;m);            cnt=n;            scanf(&quot;%s&quot;,a+1);            for(int i=3; i&lt;=n; i++){                if(a[i-2]==&#39;w&#39;&amp;&amp;a[i-1]==&#39;b&#39;&amp;&amp;a[i]==&#39;w&#39;)                    update(i,1);            }            int order,l,r,k;            char ch;            printf(&quot;Case %d:\n&quot;,++kc);            while(m--){                scanf(&quot;%d&quot;,&amp;order);                if(1==order){                    scanf(&quot;%d %c&quot;,&amp;k,&amp;ch);                    k++;                    if(a[k]==ch) continue;                    if(k&gt;=3&amp;&amp;a[k-2]==&#39;w&#39;&amp;&amp;a[k-1]==&#39;b&#39;&amp;&amp;a[k]==&#39;w&#39;)                        update(k,-1);                    if(k&gt;=3&amp;&amp;a[k-2]==&#39;w&#39;&amp;&amp;a[k-1]==&#39;b&#39;&amp;&amp;ch==&#39;w&#39;)                        update(k,1);                    if(k&gt;=2&amp;&amp;k+1&lt;=n&amp;&amp;a[k-1]==&#39;w&#39;&amp;&amp;a[k]==&#39;b&#39;&amp;&amp;a[k+1]==&#39;w&#39;)                        update(k+1,-1);                    if(k&gt;=2&amp;&amp;k+1&lt;=n&amp;&amp;a[k-1]==&#39;w&#39;&amp;&amp;ch==&#39;b&#39;&amp;&amp;a[k+1]==&#39;w&#39;)                        update(k+1,1);                    if(k+2&lt;=n&amp;&amp;a[k]==&#39;w&#39;&amp;&amp;a[k+1]==&#39;b&#39;&amp;&amp;a[k+2]==&#39;w&#39;)                        update(k+2,-1);                    if(k+2&lt;=n&amp;&amp;ch==&#39;w&#39;&amp;&amp;a[k+1]==&#39;b&#39;&amp;&amp;a[k+2]==&#39;w&#39;)                        update(k+2,1);                    a[k]=ch;                }                if(0==order){                    scanf(&quot;%d %d&quot;,&amp;l,&amp;r);                    if(r-l&lt;2) puts(&quot;0&quot;);                    else  printf(&quot;%d\n&quot;,getSum(r+1)-getSum(l+1+1));                }            }        }    }    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  HDU 1542 Stars [树状数组]【数据结构】</title>
      <link href="/2016/11/07/53072003/"/>
      <url>/2016/11/07/53072003/</url>
      
        <content type="html"><![CDATA[<h1 id="HDU-1542-Stars-树状数组-【数据结构】"><a href="#HDU-1542-Stars-树状数组-【数据结构】" class="headerlink" title="HDU 1542 Stars [树状数组]【数据结构】"></a>HDU 1542 Stars [树状数组]【数据结构】</h1><p>2016年11月07日 21:24:45  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：232</p><hr><p> 博客爬取于<code>2019-04-18 17:19:01</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/53072003" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/53072003</a></p><p>题目链接： <a href="http://acm.hdu.edu.cn/showproblem.php?pid=1541" target="_blank" rel="noopener"> http://acm.hdu.edu.cn/showproblem.php?pid=1541</a><br>———————–.<br>Stars</p><p>Time Limit: 2000/1000 MS (Java/Others) Memory Limit: 65536/32768 K<br>(Java/Others)<br>Total Submission(s): 8916 Accepted Submission(s): 3547</p><p>Problem Description<br>Astronomers often examine star maps where stars are represented by points on a<br>plane and each star has Cartesian coordinates. Let the level of a star be an<br>amount of the stars that are not higher and not to the right of the given<br>star. Astronomers want to know the distribution of the levels of the stars.</p><p>For example, look at the map shown on the figure above. Level of the star<br>number 5 is equal to 3 (it’s formed by three stars with a numbers 1, 2 and 4).<br>And the levels of the stars numbered by 2 and 4 are 1. At this map there are<br>only one star of the level 0, two stars of the level 1, one star of the level<br>2, and one star of the level 3.</p><p>You are to write a program that will count the amounts of the stars of each<br>level on a given map.</p><p>Input<br>The first line of the input file contains a number of stars N (1&lt;=N&lt;=15000).<br>The following N lines describe coordinates of stars (two integers X and Y per<br>line separated by a space, 0&lt;=X,Y&lt;=32000). There can be only one star at one<br>point of the plane. Stars are listed in ascending order of Y coordinate. Stars<br>with equal Y coordinates are listed in ascending order of X coordinate.</p><p>Output<br>The output should contain N lines, one number per line. The first line<br>contains amount of stars of the level 0, the second does amount of stars of<br>the level 1 and so on, the last line contains amount of stars of the level<br>N-1.</p><p>Sample Input<br>5<br>1 1<br>5 1<br>7 1<br>3 3<br>5 5</p><p>Sample Output<br>1<br>2<br>1<br>1<br>0</p><p>Source<br>Ural Collegiate Programming Contest 1999</p><p>————————————————————.</p><p>题目大意 ：<br>就是求左下角有多少个星星的星星的个数</p><p>解题思路 ：<br>就是一个基本的数据结构<br>树状数组和线段树都可做<br>我用的树状数组AC的 闲来无事复习一下也是有收获的 维护的时候i&lt;=maxn 而不是树状数组的长度 。。 很强势<br>也怪当初没有好好学习树状数组就去搞线段树了。。然后做了几天就放弃数据结构了 看来这的要好好学习数据结构了。。。</p><p>仔细读题 发现y是递增的 这样的话 y值就没什么用了 我们只要维护x就可以了 维护前用桶记录一下就可以了;;</p><p>附本题代码<br>—————————.</p><pre><code>#include &lt;bits/stdc++.h&gt;using namespace std;/**************************************/const int N = 50000 + 5;#define lowbit(x)  (x&amp;(-x))int sum[N],cnt,nnn[N];void update(int index,int val){    for(int i=index;i&lt;=N;i+=lowbit(i)){        sum[i]+=val;    }}int getSum(int index) {  int ans = 0;  for (int i = index; i&gt;0; i -= lowbit(i))    ans += sum[i];  return ans;}int main(){    while(~scanf(&quot;%d&quot;,&amp;cnt)){        int x,y;        memset(sum,0,sizeof(sum));        memset(nnn,0,sizeof(nnn));        for(int i=0;i&lt;cnt;i++){            scanf(&quot;%d%d&quot;,&amp;x,&amp;y);            nnn[getSum(x+1)]++;            update(x+1,1);        }        for(int i=0;i&lt;cnt;i++){            printf(&quot;%d\n&quot;,nnn[i]);        }    }    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  HDU 1430 魔板 [BFS+康拓展开]【数学】</title>
      <link href="/2016/11/05/53046282/"/>
      <url>/2016/11/05/53046282/</url>
      
        <content type="html"><![CDATA[<h1 id="HDU-1430-魔板-BFS-康拓展开-【数学】"><a href="#HDU-1430-魔板-BFS-康拓展开-【数学】" class="headerlink" title="HDU 1430 魔板 [BFS+康拓展开]【数学】"></a>HDU 1430 魔板 [BFS+康拓展开]【数学】</h1><p>2016年11月05日 16:48:35  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：514</p><hr><p> 博客爬取于<code>2019-04-18 17:19:02</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/53046282" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/53046282</a></p><p>题目链接： <a href="http://acm.hdu.edu.cn/showproblem.php?pid=1430" target="_blank" rel="noopener"> http://acm.hdu.edu.cn/showproblem.php?pid=1430</a><br>———————————————.<br>魔板</p><p>Time Limit: 10000/5000 MS (Java/Others) Memory Limit: 65536/32768 K<br>(Java/Others)<br>Total Submission(s): 2968 Accepted Submission(s): 672</p><p>Problem Description<br>在魔方风靡全球之后不久，Rubik先生发明了它的简化版——魔板。魔板由8个同样大小的方块组成，每个方块颜色均不相同，可用数字1-8分别表示。任一时刻魔板的状<br>态可用方块的颜色序列表示：从魔板的左上角开始，按顺时针方向依次写下各方块的颜色代号，所得到的数字序列即可表示此时魔板的状态。例如，序列(1,2,3,4,5,<br>6,7,8)表示魔板状态为：</p><p>1 2 3 4<br>8 7 6 5</p><p>对于魔板，可施加三种不同的操作，具体操作方法如下：</p><p>A: 上下两行互换,如上图可变换为状态87654321<br>B: 每行同时循环右移一格,如上图可变换为41236785<br>C: 中间4个方块顺时针旋转一格,如上图可变换为17245368</p><p>给你魔板的初始状态与目标状态，请给出由初态到目态变换数最少的变换步骤，若有多种变换方案则取字典序最小的那种。</p><p>Input<br>每组测试数据包括两行，分别代表魔板的初态与目态。</p><p>Output<br>对每组测试数据输出满足题意的变换步骤。</p><p>Sample Input<br>12345678<br>17245368<br>12345678<br>82754631</p><p>Sample Output<br>C<br>AC</p><p>Author<br>LL</p><p>———————————————.</p><p>题目大意 ：中文题 自己读。。。。</p><p>解题思路：</p><p>首先可以明确的是 这个字符串改变之前和改变之后的关系是一定有的 那么原串和终串无论是什么 只要讲原串和终串映射回“12345678”这样的话 就能够计算了</p><p>那样的话 所有的解都可以变成 “12345678” 这个串的变化 ；<br>由于 8！=40320 状态数目非常少 变化也只有三种 那么我们只要用BFS就可以了 利用广度优先的特性 求出的解也是最优的</p><p>那么首先BFS预处理结果一下就行了 串的变化模拟就可以了<br>后来计算的时候 把原串和终串处理一下 变成”12345678”与”balabala”的样子 然后输出结果就行了</p><p>但是在标记的时候 想到用康托展开的值来标记 而不是用map映射（但是想想map映射 也没什么毛病吧）。</p><p><strong> 这个代码确实是AC的 只是win7 CB13.2 运行会渣掉 找了1天BUG还是没有找到 最后提交上去想保存一下代码的时候 发现居然AC了!! AC了! </strong></p><p>附本题代码<br>—————————-.</p><pre><code>#include &lt;bits/stdc++.h&gt;using namespace std;#define INF      0x3f3f3f3f#define pb       push_back#define abs(a)   ((a)&gt;0?(a):-(a))#define min(a,b) ((a)&gt;(b)?(a):(b))#define lalal    puts(&quot;*******&quot;)typedef long long int LL ;typedef unsigned long long int LLu ;/*******************************/bool vis[40050];int  jiecheng[10]={1,1,2,6,24,120,720,5040,40320,362880};int Cantor_expansion(string &amp;a){    int x=0,tem=0;    for(int i=0;i&lt;8;i++){        tem = 0;        for(int j=i+1;j&lt;8;j++)            if(a[j]&lt;a[i]) tem++;        x+=tem*jiecheng[7-i];    }    return x;}void op_A(string &amp;a){    for(int i=0;i&lt;4;i++) swap(a[i],a[7-i]);}void op_B(string &amp;a){    char t=a[0];    for(int i=1;i&lt;4;i++) swap(t,a[i]);    a[0]=t;    t=a[7];    for(int i=7;i&gt;=4;i--) swap(t,a[i]);    a[7]=t;}void op_C(string &amp;a){    swap(a[1],a[2]);    swap(a[1],a[5]);    swap(a[1],a[6]);}struct node {    string str,step;    int x;};string mmp[44444];void BFS(){    memset(vis,false,sizeof(vis));    queue&lt;node &gt;q;    string a=&quot;12345678&quot;;    int x=Cantor_expansion(a);    vis[x]=1;    mmp[x]=&quot;&quot;;    node tem ,tmp;    tem.str=a;    tem.step=&quot;&quot;;    tem.x=x;    q.push(tem);    while(!q.empty()){        tmp=q.front();q.pop();        //AAAAAAAAAAAAA        tem=tmp;        op_A(tem.str);        tem.x=Cantor_expansion(tem.str);        if(!vis[tem.x]){            vis[tem.x]=true;            tem.step+=&quot;A&quot;;            mmp[tem.x]=tem.step;            q.push(tem);        }        //BBBBBBBBBBBBB        tem=tmp;        op_B(tem.str);        tem.x=Cantor_expansion(tem.str);        if(!vis[tem.x]){            vis[tem.x]=true;            tem.step+=&quot;B&quot;;            mmp[tem.x]=tem.step;            q.push(tem);        }        //CCCCCCCCCCCCC        tem=tmp;        op_C(tem.str);        tem.x=Cantor_expansion(tem.str);        if(!vis[tem.x]){            vis[tem.x]=true;            tem.step+=&quot;C&quot;;            mmp[tem.x]=tem.step;            q.push(tem);        }    }    return ;}void change(string &amp;a,string &amp;b){    map&lt;char,char&gt;mp;    for(int i=0;i&lt;a.size();i++)        mp[a[i]]=&#39;1&#39;+i;    for(int i=0;i&lt;b.size();i++)        b[i]=mp[b[i]];    return ;}int main(){    BFS();    string a1,b1;    while(cin&gt;&gt;a1&gt;&gt;b1){        change(a1,b1);        int x=Cantor_expansion(b1);        cout&lt;&lt;mmp[x]&lt;&lt;endl;    }    return 0;}</code></pre><p>—————————-.</p>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  HDU 1027 Ignatius and the Princess II [康托逆展开]【数学】</title>
      <link href="/2016/11/04/53036273/"/>
      <url>/2016/11/04/53036273/</url>
      
        <content type="html"><![CDATA[<h1 id="HDU-1027-Ignatius-and-the-Princess-II-康托逆展开-【数学】"><a href="#HDU-1027-Ignatius-and-the-Princess-II-康托逆展开-【数学】" class="headerlink" title="HDU 1027 Ignatius and the Princess II [康托逆展开]【数学】"></a>HDU 1027 Ignatius and the Princess II [康托逆展开]【数学】</h1><p>2016年11月04日 16:16:54  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：210</p><hr><p> 博客爬取于<code>2019-04-18 17:19:03</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/53036273" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/53036273</a></p><p>题目链接： <a href="http://acm.hdu.edu.cn/showproblem.php?pid=1027" target="_blank" rel="noopener"> http://acm.hdu.edu.cn/showproblem.php?pid=1027</a></p><p>——————————————–.</p><p>Ignatius and the Princess II</p><p>Time Limit: 2000/1000 MS (Java/Others) Memory Limit: 65536/32768 K<br>(Java/Others)<br>Total Submission(s): 7182 Accepted Submission(s): 4264</p><p>Problem Description<br>Now our hero finds the door to the BEelzebub feng5166. He opens the door and<br>finds feng5166 is about to kill our pretty Princess. But now the BEelzebub has<br>to beat our hero first. feng5166 says, “I have three question for you, if you<br>can work them out, I will release the Princess, or you will be my dinner,<br>too.” Ignatius says confidently, “OK, at last, I will save the Princess.”</p><p>“Now I will show you the first problem.” feng5166 says, “Given a sequence of<br>number 1 to N, we define that 1,2,3…N-1,N is the smallest sequence among all<br>the sequence which can be composed with number 1 to N(each number can be and<br>should be use only once in this problem). So it’s easy to see the second<br>smallest sequence is 1,2,3…N,N-1. Now I will give you two numbers, N and M.<br>You should tell me the Mth smallest sequence which is composed with number 1<br>to N. It’s easy, isn’t is? Hahahahaha……”<br>Can you help Ignatius to solve this problem?</p><p>Input<br>The input contains several test cases. Each test case consists of two numbers,<br>N and M(1&lt;=N&lt;=1000, 1&lt;=M&lt;=10000). You may assume that there is always a<br>sequence satisfied the BEelzebub’s demand. The input is terminated by the end<br>of file.</p><p>Output<br>For each test case, you only have to output the sequence satisfied the<br>BEelzebub’s demand. When output a sequence, you should print a space between<br>two numbers, but do not output any spaces after the last number.</p><p>Sample Input<br>6 4<br>11 8</p><p>Sample Output<br>1 2 3 5 6 4<br>1 2 3 4 5 6 7 9 8 11 10</p><p>Author<br>Ignatius.L</p><p>——————————————–.</p><p>题目大意：<br>就是求有n个数的第m个排列</p><p>解题思路：<br>由于m≤1e5 但是不知道数据量到底是多大 所以不应该采取暴力的做法 正解应该是康托逆展开</p><p>但是这时候考虑n比较大 到了1000,这时候如果直接康托逆展开的话 阶乘会爆掉 所以不可取<br>这时候看了一下m值只有1e5 那么就能知道变化的序列里面也只有后面几位而已<br>这时候暴力跑一下 发现 只有后8位的顺序有变化<br>这时候我们只要单独把8位逆展开就可以了</p><p>注意的是n小于8的时候 不要算多就可以了</p><p>展开过程比较水 随便写写就好了 如果不是特别了解康拓展开 <a href="http://blog.csdn.net/qq_33184171/article/details/52681216#t2" target="_blank" rel="noopener"> 可以戳这里&lt;-目录里面有</a></p><p>附本题AC代码<br>————————————————————————————–.</p><pre><code>#include &lt;stdio.h&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;string.h&gt;#include &lt;cmath&gt;using namespace std;#define INF      0x3f3f3f3f#define pb       push_back#define abs(a)   ((a)&gt;0?(a):-(a))#define min(a,b) ((a)&gt;(b)?(a):(b))#define lalal    puts(&quot;*******&quot;)typedef long long int LL ;typedef unsigned long long int LLu ;/*******************************/const int MOD = 10086;const int N = 1e7+5;int prime[700000],kp;bool Is_or[N];char s1[30];bool vis[30];LL a[30];LL jiecheng[30];void init(){    jiecheng[0]=1;    for(int i=1; i&lt;=12; i++)        jiecheng[i]=jiecheng[i-1]*i;    return ;}LL Cantor_expansion(char s1[]){    LL x=0;    int rk=0;    for(int i=0; i&lt;12; i++)    {        rk=0;        for(int j=11; j&gt;i; j--)            if(s1[i]&gt;s1[j])rk++;        a[i]=rk;    }    for(int i=0; i&lt;12; i++)        x+=a[i]*jiecheng[11-i];    return x+1;}void Cantor_inexpansion(int len,int x){    int li=(len&gt;=8?8:len);    int ind=0,tem;    for(int i=0;i&lt;li;i++) vis[i]=0;    for(int i=li-1;i&gt;=0;i--){        ind=0;        tem = x/jiecheng[i];        for(int j=0;j&lt;li;j++){            if(vis[j])   continue;            if(ind==tem) {a[i]=j;break; }            ind++;        };        vis[a[i]]=1;        x%=jiecheng[i];    }    for(int i=1;i&lt;=len-li;i++)        if(i==1)printf(&quot;1&quot;);else printf(&quot; %d&quot;,i);    for(int i=li-1;i&gt;=0;i--)        if(a[i]+len-li+1==1)printf(&quot;1&quot;);        else    printf(&quot; %d&quot;,a[i]+len-li+1);    puts(&quot;&quot;);    return ;}int main(){    init();    int n,m;    while(~scanf(&quot;%d%d&quot;,&amp;n,&amp;m)){        Cantor_inexpansion(n,m-1);    }    return 0;}</code></pre><p>—————————————————————————————-.</p>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  NYOJ 139 我排第几个 [康拓展开]【数学】</title>
      <link href="/2016/11/04/53033813/"/>
      <url>/2016/11/04/53033813/</url>
      
        <content type="html"><![CDATA[<h1 id="NYOJ-139-我排第几个-康拓展开-【数学】"><a href="#NYOJ-139-我排第几个-康拓展开-【数学】" class="headerlink" title="NYOJ 139 我排第几个 [康拓展开]【数学】"></a>NYOJ 139 我排第几个 [康拓展开]【数学】</h1><p>2016年11月04日 13:22:06  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：347</p><hr><p> 博客爬取于<code>2019-04-18 17:19:04</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/53033813" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/53033813</a></p><p>题目链接: <a href="http://acm.nyist.net/JudgeOnline/problem.php?pid=139" target="_blank" rel="noopener"> http://acm.nyist.net/JudgeOnline/problem.php?pid=139</a></p><p>———————————————.<br>我排第几个<br>时间限制：1000 ms | 内存限制：65535 KB<br>难度：3<br>描述<br>现在有”abcdefghijkl”12个字符，将其所有的排列中按字典序排列，给出任意一种排列，说出这个排列在所有的排列中是第几小的？</p><p>输入<br>第一行有一个整数n（0 &lt; n&lt;=10000）;<br>随后有n行，每行是一个排列；<br>输出<br>输出一个整数m，占一行，m表示排列是第几位；<br>样例输入<br>3<br>abcdefghijkl<br>hgebkflacdji<br>gfkedhjblcia<br>样例输出<br>1<br>302715242<br>260726926<br>———————————————-.</p><p>解题思路:<br>本题就是一道康拓展开的入门练习题目<br>找到这个字符串在字典序中排在第几就行了</p><p>求出展开值+1就是了</p><p>康拓展开现见 <a href="http://blog.csdn.net/qq_33184171/article/details/52681216#t2" target="_blank" rel="noopener"> 这里&lt;-翻目录</a></p><p>附本题代码<br>———————————–.</p><pre><code>#include &lt;stdio.h&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;string.h&gt;#include &lt;cmath&gt;using namespace std;#define INF      0x3f3f3f3f#define pb       push_back#define abs(a)   ((a)&gt;0?(a):-(a))#define min(a,b) ((a)&gt;(b)?(a):(b))#define lalal    puts(&quot;*******&quot;)typedef long long int LL ;typedef unsigned long long int LLu ;/*******************************/const int MOD = 10086;const int N = 1e7+5;int prime[700000],kp;bool Is_or[N];char s1[30];bool vis[30];LL a[30];LL jiecheng[30];void init(){    jiecheng[0]=1;    for(int i=1; i&lt;=12; i++)        jiecheng[i]=jiecheng[i-1]*i;    return ;}LL Cantor_expansion(char s1[]){    LL x=0;    int rk=0;    for(int i=0; i&lt;12; i++)    {        rk=0;        for(int j=11; j&gt;i; j--)            if(s1[i]&gt;s1[j])rk++;        a[i]=rk;    }    for(int i=0; i&lt;12; i++)        x+=a[i]*jiecheng[11-i];    return x+1;}int main(){    init();    int _;    while(~scanf(&quot;%d&quot;,&amp;_))    {        while(_--)        {            scanf(&quot;%s&quot;,s1);            printf(&quot;%I64d\n&quot;,Cantor_expansion(s1));        }    }    return 0;}</code></pre><p>————————————.</p>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  Codeforces Round</title>
      <link href="/2016/11/03/53020524/"/>
      <url>/2016/11/03/53020524/</url>
      
        <content type="html"><![CDATA[<h1 id="Codeforces-Round-297-Div-2-D-Arthur-and-Walls-思维-【思维】"><a href="#Codeforces-Round-297-Div-2-D-Arthur-and-Walls-思维-【思维】" class="headerlink" title="Codeforces Round #297 (Div. 2) D - Arthur and Walls [思维]【思维】"></a>Codeforces Round #297 (Div. 2) D - Arthur and Walls [思维]【思维】</h1><p>2016年11月03日 13:13:07  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：178<br>标签：  <a href="https://so.csdn.net/so/search/s.do?q=codeforces&amp;t=blog" target="_blank" rel="noopener"> codeforces </a></p><p>个人分类：  <a href="https://blog.csdn.net/qq_33184171/article/category/6235560" target="_blank" rel="noopener"> codeforces</a> <a href="https://blog.csdn.net/qq_33184171/article/category/6253262" target="_blank" rel="noopener"> 思维</a> <a href="https://blog.csdn.net/qq_33184171/article/category/6362373" target="_blank" rel="noopener"> ===== 杂类 =====</a></p><hr><p> 博客爬取于<code>2019-04-18 17:19:06</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/53020524" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/53020524</a></p><p>题目链接： <a href="http://codeforces.com/contest/525/problem/D" target="_blank" rel="noopener"> http://codeforces.com/contest/525/problem/D</a><br>————————————–.<br>D. Arthur and Walls<br>time limit per test2 seconds<br>memory limit per test512 megabytes<br>inputstandard input<br>outputstandard output<br>Finally it is a day when Arthur has enough money for buying an apartment. He<br>found a great option close to the center of the city with a nice price.</p><p>Plan of the apartment found by Arthur looks like a rectangle n × m consisting<br>of squares of size 1 × 1. Each of those squares contains either a wall (such<br>square is denoted by a symbol “*” on the plan) or a free space (such square is<br>denoted on the plan by a symbol “.”).</p><p>Room in an apartment is a maximal connected area consisting of free squares.<br>Squares are considered adjacent if they share a common side.</p><p>The old Arthur dream is to live in an apartment where all rooms are<br>rectangles. He asks you to calculate minimum number of walls you need to<br>remove in order to achieve this goal. After removing a wall from a square it<br>becomes a free square. While removing the walls it is possible that some rooms<br>unite into a single one.</p><p>Input<br>The first line of the input contains two integers n, m (1 ≤ n, m ≤ 2000)<br>denoting the size of the Arthur apartments.</p><p>Following n lines each contain m symbols — the plan of the apartment.</p><p>If the cell is denoted by a symbol “*” then it contains a wall.</p><p>If the cell is denoted by a symbol “.” then it this cell is free from walls<br>and also this cell is contained in some of the rooms.</p><p>Output<br>Output n rows each consisting of m symbols that show how the Arthur apartment<br>plan should look like after deleting the minimum number of walls in order to<br>make each room (maximum connected area free from walls) be a rectangle.</p><p>If there are several possible answers, output any of them.</p><p>Examples</p><pre><code>input5 5.*.*.*****.*.*.*****.*.*.output.*.*.*****.*.*.*****.*.*.input6 7***.*.*..*.*.**.*.*.**.*.*.*..*...********output***...*..*...*..*...*..*...*..*...********input4 5............***..*..output....................</code></pre><p>————————————–.</p><p>题目大意 ：<br>就是给你一个n<em>m的矩阵 里面‘</em>’代表着墙 ‘.’代表空地<br>现在让你尽可能少的移开墙 然后使每一片联通的空地都成为一个矩形</p><p>解题思路：<br>最开始看到这题的想法就是搜索 判断联通快然后让这一部分所在的最小矩形全部变成‘.’ 然后发现不行 有可能<br>操作之后的两个矩形又连到一起了，这样的话所有操作都需要再从新来一下，图还特别大 所以一定会超时</p><p>然后左想右想 还是不明白<br>最后看了 别人的代码 明白了<br>只需要看每一个2*2的部分就行了<br>对于连不连通 也非常好判断了</p><p>而判断用不用移走墙 就更好想了 对于每一个2<em>2内 只有一个‘</em>’号的时候一定要移走 其他情况就不用<br>想明白这句话 这道题就可以解决了</p><p>最后处理的时候用一个队列 维护一下坐标即可<br>每个点最多也只是遍历一遍,这样就不会超时了 而且操作也更简单<br>详情看代码就好</p><p>附本题代码<br>——————————–.</p><pre><code>#include&lt;bits/stdc++.h&gt;#define abs(x)  ((x)&gt;0?(x):-(x))using namespace std;typedef long long LL;const int maxn = 505;char  mp[2020][2020];bool vis[2020][2020];queue&lt;pair&lt;int ,int &gt; &gt;q;int  n,m;bool check(int x,int y){//检查2*2内是不是只有一个 &#39;*&#39;    return x&gt;=0&amp;&amp;y&gt;=0&amp;&amp;x&lt;n-1&amp;&amp;y&lt;m-1&amp;&amp;    ((mp[x][y]==&#39;*&#39;)+(mp[x+1][y]==&#39;*&#39;)+(mp[x][y+1]==&#39;*&#39;)+(mp[x+1][y+1]==&#39;*&#39;)==1);}int main(){    while(~scanf(&quot;%d%d&quot;,&amp;n,&amp;m)){        for(int i=0;i&lt;n;i++) scanf(&quot;%s&quot;,mp[i]);        for(int i=0;i&lt;n;i++) for(int j=0;j&lt;m;j++) vis[i][j]=0;        for(int i=0;i&lt;n-1;i++){            for(int j=0;j&lt;m-1;j++){//对于2*2 枚举的是左上的坐标  其实哪里都一样                if(check(i,j)) q.push(make_pair(i,j)),vis[i][j]=1;            }        }        int x,y;        while(!q.empty()){            x=q.front().first,y=q.front().second; q.pop();            for(int i=0;i&lt;2;i++) for(int j=0;j&lt;2;j++) mp[x+i][y+j]=&#39;.&#39;;//移走墙            for(int i=-1;i&lt;=1;i++)                for(int j=-1;j&lt;=1;j++){                    if(!vis[x+i][y+j]&amp;&amp;check(x+i,y+j)){//移走墙之后 要在判断一下周围的有没有需要移走墙的位置                        q.push(make_pair(x+i,y+j)),vis[x+i][y+j]=1;                    }                }        }        for(int i=0;i&lt;n;i++) puts(mp[i]);    }    return 0;}</code></pre><p>——————————–.</p>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 思维 </tag>
            
            <tag> 杂类 </tag>
            
            <tag> codeforces </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  HDU 3415 Max Sum of Max-K-sub-sequence [单调队列]【杂类】</title>
      <link href="/2016/11/02/53007513/"/>
      <url>/2016/11/02/53007513/</url>
      
        <content type="html"><![CDATA[<h1 id="HDU-3415-Max-Sum-of-Max-K-sub-sequence-单调队列-【杂类】"><a href="#HDU-3415-Max-Sum-of-Max-K-sub-sequence-单调队列-【杂类】" class="headerlink" title="HDU 3415 Max Sum of Max-K-sub-sequence [单调队列]【杂类】"></a>HDU 3415 Max Sum of Max-K-sub-sequence [单调队列]【杂类】</h1><p>2016年11月02日 14:14:50  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：208</p><p>个人分类：  <a href="https://blog.csdn.net/qq_33184171/article/category/6117382" target="_blank" rel="noopener"> hdu </a> <a href="https://blog.csdn.net/qq_33184171/article/category/6362373" target="_blank" rel="noopener"><br>===== 杂类 ===== </a></p><hr><p> 博客爬取于<code>2019-04-18 17:19:07</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/53007513" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/53007513</a></p><p>题目链接： <a href="http://acm.hdu.edu.cn/showproblem.php?pid=3415" target="_blank" rel="noopener"> http://acm.hdu.edu.cn/showproblem.php?pid=3415</a><br>————————————-.<br>Max Sum of Max-K-sub-sequence</p><p>Time Limit: 2000/1000 MS (Java/Others) Memory Limit: 32768/32768 K<br>(Java/Others)<br>Total Submission(s): 7522 Accepted Submission(s): 2776</p><p>Problem Description<br>Given a circle sequence A[1],A[2],A[3]……A[n]. Circle sequence means the left<br>neighbour of A[1] is A[n] , and the right neighbour of A[n] is A[1].<br>Now your job is to calculate the max sum of a Max-K-sub-sequence. Max-K-sub-<br>sequence means a continuous non-empty sub-sequence which length not exceed K.</p><p>Input<br>The first line of the input contains an integer T(1&lt;=T&lt;=100) which means the<br>number of test cases.<br>Then T lines follow, each line starts with two integers N , K(1&lt;=N&lt;=100000 ,<br>1&lt;=K&lt;=N), then N integers followed(all the integers are between -1000 and<br>1000).</p><p>Output<br>For each test case, you should output a line contains three integers, the Max<br>Sum in the sequence, the start position of the sub-sequence, the end position<br>of the sub-sequence. If there are more than one result, output the minimum<br>start position, if still more than one , output the minimum length of them.</p><p>Sample Input<br>4<br>6 3<br>6 -1 2 -6 5 -5<br>6 4<br>6 -1 2 -6 5 -5<br>6 3<br>-1 2 -6 5 -5 6<br>6 6<br>-1 -1 -1 -1 -1 -1 </p><p>Sample Output<br>7 1 3<br>7 1 3<br>7 6 2<br>-1 1 1 </p><p>Author<br>shǎ崽@HDU</p><p>Source<br>HDOJ Monthly Contest – 2010.06.05</p><p>————————————–.</p><p>题目大意：<br>给你一个成环的数列，让你寻找其中区间长度不大于k的区间最大和与 区间的起始位置和结束位置。</p><p>解题思路：</p><p>因为做的题目就是单调队列的专题 就没想算法</p><p>然后考虑成环的 所以要把区间变成2倍的 这样就有环了，，，</p><p>然后因为要取区间的和 而维护单调队列的时候也只是维护区间的左界 为了方便计算区间的值 所以把数组变成前缀和的形式</p><p>然后在维护的时候个人维护的是左界限的左一位的值 计算区间和比较容易</p><p>总的来说就是<br>枚举右界限 维护一下每次最优的左界线 然后把不符合结果的出队列就好了</p><p>附本题代码<br>————————————–.</p><pre><code>#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;typedef long long int LL ;using namespace std;#define Rep(i,a,b) for(int (i)=(a);(i)&lt;=(b);(i)++)const int N = 2e6+5;int a[N];int p[N]; //单调队列 维护左界线下标int main(){    int _;    scanf(&quot;%d&quot;,&amp;_);    while(_--){        int n,k;        scanf(&quot;%d%d&quot;,&amp;n,&amp;k);        a[0]=0;        Rep(i,1,n) scanf(&quot;%d&quot;,&amp;a[i]),a[i+n]=a[i];        n+=k-1;   //成环的话 因为最大的区间是K 座椅长度只需要n+k-1就行了        Rep(i,2,n) a[i]+=a[i-1];        int l=1,r=0,ml=-1,mr=-1,mx=-0x3f3f3f3f,tem=0;        p[0]=p[++r]=0;//其实P[0] 是没有用的。。        Rep(i,1,n){            while(l&lt;=r &amp;&amp; p[l] &lt; i-k) l++;  //不满足K的需要出队列            tem = a[i]-a[p[l]];//  一定要在更新之前计算  否则结果可能因为负值出现错误            if( tem &gt; mx )    ml=p[l]+1,mr=i,mx=tem;            while(l&lt;=r &amp;&amp; a[i] &lt; a[ p[r] ]) r--;//更新最优解            p[++r]=i;        }        n-=k-1;        mr=(mr&gt;n?mr-n:mr);//大于n的位置 处理一下        printf(&quot;%d %d %d\n&quot;,mx,ml,mr);    }    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hdu </tag>
            
            <tag> 杂类 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  POJ 2823 Sliding Window [单调队列]【杂类】</title>
      <link href="/2016/10/31/52984325/"/>
      <url>/2016/10/31/52984325/</url>
      
        <content type="html"><![CDATA[<h1 id="POJ-2823-Sliding-Window-单调队列-【杂类】"><a href="#POJ-2823-Sliding-Window-单调队列-【杂类】" class="headerlink" title="POJ 2823 Sliding Window [单调队列]【杂类】"></a>POJ 2823 Sliding Window [单调队列]【杂类】</h1><p>2016年10月31日 17:37:05  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：209<br>标签：  <a href="https://so.csdn.net/so/search/s.do?q=poj&amp;t=blog" target="_blank" rel="noopener"> poj </a></p><p>个人分类：  <a href="https://blog.csdn.net/qq_33184171/article/category/6362379" target="_blank" rel="noopener"> ===== 各OJ =====</a> <a href="https://blog.csdn.net/qq_33184171/article/category/6114215" target="_blank" rel="noopener"> POJ</a> <a href="https://blog.csdn.net/qq_33184171/article/category/6362373" target="_blank" rel="noopener"> ===== 杂类 =====</a></p><hr><p> 博客爬取于<code>2019-04-18 17:19:08</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/52984325" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/52984325</a></p><p>题目链接： <a href="http://poj.org/problem?id=2823" target="_blank" rel="noopener"> http://poj.org/problem?id=2823 </a><br>——————————–.<br>Sliding Window<br>Time Limit: 12000MS Memory Limit: 65536K<br>Total Submissions: 55854 Accepted: 16062<br>Case Time Limit: 5000MS<br>Description</p><p>An array of size n ≤ 106 is given to you. There is a sliding window of size k<br>which is moving from the very left of the array to the very right. You can<br>only see the k numbers in the window. Each time the sliding window moves<br>rightwards by one position. Following is an example:<br>The array is [1 3 -1 -3 5 3 6 7], and k is 3.<br>Window position Minimum value Maximum value</p><p>:  :  :</p><p>Window position</p><p>Minimum value</p><p>Maximum value</p><p>[1 3 -1] -3 5 3 6 7</p><p>-1<br>3</p><p>1 [3 -1 -3] 5 3 6 7</p><p>-3<br>3</p><p>1 3 [-1 -3 5] 3 6 7</p><p>-3<br>5</p><p>1 3 -1 [-3 5 3] 6 7</p><p>-3<br>5</p><p>1 3 -1 -3 [5 3 6] 7</p><p>3</p><p>6</p><p>1 3 -1 -3 5 [3 6 7]</p><p>3</p><p>7</p><p>Your task is to determine the maximum and minimum values in the sliding window<br>at each position.</p><p>Input</p><p>The input consists of two lines. The first line contains two integers n and k<br>which are the lengths of the array and the sliding window. There are n<br>integers in the second line.<br>Output</p><p>There are two lines in the output. The first line gives the minimum values in<br>the window at each position, from left to right, respectively. The second line<br>gives the maximum values.<br>Sample Input</p><p>8 3<br>1 3 -1 -3 5 3 6 7<br>Sample Output</p><p>-1 -3 -3 -3 3 3<br>3 3 5 5 6 7</p><p>———————————–.<br>题目大意：<br>就是求长度为n的数列中长度为k的邻近区间的最大值和最小值；</p><p>解题思路：<br>这道题就是单调队列的入门题目<br>但是据说线段树也可以过 但是不仅代码量大 而且复杂度也不是最优的。</p><p>以为这个求得区间与区间之间存在邻近的关系 所以想到用单调队列优化的思路这样的话可以把复杂度降到O(n)</p><p>维护的时候只要维护一下下标就行了</p><p>单调队列的数组实现其实和尺追法差不多,觉得不好写的话用手过几遍数据强化一下就行.</p><p>附本题代码<br>———————-.</p><pre><code>#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;typedef long long int LL ;using namespace std;const int N = 1e6+5;int a[N];int deq[N]; //单调队列 维护下标/*维护下标和直接维护值 好像并没有什么区别啊稍加改动就行了对于在线输出的只要维护一下下标就可以了离线的话目测还必须把队列给加上。。*/int main(){    int n,k;    while(~scanf(&quot;%d%d&quot;,&amp;n,&amp;k)){        for(int i=1;i&lt;=n;i++)            scanf(&quot;%d&quot;,&amp;a[i]);        int l,r,flag;        //最小值        l=deq[1]=1,r=flag=0;        for(int i=1;i&lt;=n;i++){            while(l&lt;=r&amp;&amp;deq[l]&lt;=i-k) l++;            while(l&lt;=r&amp;&amp;a[deq[r]]&gt;=a[i]) r--;            deq[++r]=i;            if(i&gt;=k){                if(flag) printf(&quot; &quot;);flag=1;                printf(&quot;%d&quot;,a[deq[l]]);            }        }        puts(&quot;&quot;);        //最大值        l=deq[1]=1,r=flag=0;        for(int i=1;i&lt;=n;i++){            while(l&lt;=r&amp;&amp;deq[l]&lt;=i-k) l++;            while(l&lt;=r&amp;&amp;a[deq[r]]&lt;=a[i]) r--;            deq[++r]=i;            if(i&gt;=k){                if(flag) printf(&quot; &quot;);flag=1;                printf(&quot;%d&quot;,a[deq[l]]);            }        }        puts(&quot;&quot;);    }    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> poj </tag>
            
            <tag> POJ </tag>
            
            <tag> 杂类 </tag>
            
            <tag> 各OJ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  HDU 5945 Fxx and game [单调队列+dp]【动态规划】</title>
      <link href="/2016/10/30/52974565/"/>
      <url>/2016/10/30/52974565/</url>
      
        <content type="html"><![CDATA[<h1 id="HDU-5945-Fxx-and-game-单调队列-dp-【动态规划】"><a href="#HDU-5945-Fxx-and-game-单调队列-dp-【动态规划】" class="headerlink" title="HDU 5945 Fxx and game [单调队列+dp]【动态规划】"></a>HDU 5945 Fxx and game [单调队列+dp]【动态规划】</h1><p>2016年10月30日 21:38:33  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：243<br>标签：  <a href="https://so.csdn.net/so/search/s.do?q=dp&amp;t=blog" target="_blank" rel="noopener"> dp </a></p><p>个人分类：  <a href="https://blog.csdn.net/qq_33184171/article/category/6362438" target="_blank" rel="noopener"> ==== 动态规划 ====</a> <a href="https://blog.csdn.net/qq_33184171/article/category/6132246" target="_blank" rel="noopener"> bestcoder</a> <a href="https://blog.csdn.net/qq_33184171/article/category/6117382" target="_blank" rel="noopener"> hdu</a></p><hr><p> 博客爬取于<code>2019-04-18 17:19:09</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/52974565" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/52974565</a></p><p>题目链接: <a href="http://acm.split.hdu.edu.cn/showproblem.php?pid=5945" target="_blank" rel="noopener"> http://acm.split.hdu.edu.cn/showproblem.php?pid=5945</a><br>————————————.</p><p>问题描述<br>青年理论计算机科学家Fxx给的学生设计了一款数字游戏。</p><p>一开始你将会得到一个数:XX，每次游戏将给定两个参数:k,tk,t, 任意时刻你可以对你的数执行下面两个步骤之一：</p><p>1.:X = X - i(1 &lt;= i &lt;= t)1.X=X−i(1&lt;=i&lt;=t)。</p><p>2.:2.若:X:X为:k:k的倍数，X = X / kX=X/k。</p><p>现在Fxx想要你告诉他最少的运行步骤，使:X:X变成:11。<br>输入描述<br>第一行一个整数:T(1\leq T\leq20):T(1≤T≤20)表示数据组数。</p><p>接下来:T:T行，每行三个数:X,k,t(0\leq t\leq10^6,1\leq X,k\leq10^6)X,k,t(0≤t≤10^​6​​<br>,1≤X,k≤10^​6​​ )</p><p>数据保证有解。<br>输出描述<br>输出共:T:T行。</p><p>每行一个整数表示答案。<br>输入样例<br>2<br>9 2 1<br>11 3 3<br>输出样例<br>4<br>3</p><p>—————————————.</p><p>题目大意:中文题 不解释.</p><p>解题思路:</p><p>很容易先到是一个sbDP<br>状态转移方程就是<br>if(0==i%k)dp[i]=min(dp[i],dp[i/k]+1);<br>dp[i]=min(dp[i],min{dp[i+1],dp[i+2], <del> ,dp[i+t]}+1);<br>上述转移方程很好设计 但是因为数据很大 所以min{dp[i+1],dp[i+2], </del><br>,dp[i+t]}这个操作如果暴力求解的话复杂度是O(xt) 很不现实 ，所以要优化 。</p><p>首先想到的是挂到线段树上 每次更新一个点+查询一个区间最小值 这样的话复杂度就降到O(x*logt) 然后发现还是会超时 ，于是乎就GG了</p><p>最后结束之后发现这是一个叫做单调队列优化的东西 于是借鉴巨巨们的博客 <a href="http://blog.csdn.net/guhaiteng/article/details/52972757" target="_blank" rel="noopener"><br>http://blog.csdn.net/guhaiteng/article/details/52972757</a></p><p>学习到了<br>单调队列 其实就是一个通过维护下标在O(1)内知道区间最小值的东西<br>其实有点模拟数组的思想</p><p>然后根据题意<br>确定一下值的范围 ，删去无用值 ，每次操作都是线性的。<br>这样下来 总的时间复杂度就是O(n)</p><p>好高端的东西 现在理解的还不是那么特别透 。。。。继续努力。</p><p>然后</p><p>附本题代码<br>——————————.</p><pre><code>#include &lt;bits/stdc++.h&gt;using namespace std;#define INF 0x3f3f3f3f#define pb push_back#define abs(a) (a)&gt;0?(a):-(a)#define lalal puts(&quot;*******&quot;)typedef long long int LL ;typedef unsigned long long int LLu ;/*******************************/const int MOD = 1e9+7;const int N = 1000005;const double eps = 1e-9;int dp[N],deq[N];//单调队列 维护下标int main(){    int _;    while(~scanf(&quot;%d&quot;,&amp;_)){        while(_--){            int x,t,k;            scanf(&quot;%d%d%d&quot;,&amp;x,&amp;k,&amp;t);            int l,r;            l=r=1;            deq[1]=1,dp[1]=0;            for(int i=2;i&lt;=x;i++){                dp[i]=10101010;                while(l&lt;=r&amp;&amp;deq[l]&lt;i-t)l++; //确定范围的左值 在t的范围内                if(l&lt;=r)dp[i]=dp[deq[l]]+1;                if(0==i%k)dp[i]=min(dp[i],dp[i/k]+1);                while(l&lt;=r&amp;&amp;dp[deq[r]] &gt;= dp[i]) r--;  //维护右值 使无用的数据删除掉                deq[++r] = i; //入队            }            printf(&quot;%d\n&quot;,dp[x]);        }    }    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hdu </tag>
            
            <tag> bestcoder </tag>
            
            <tag> 动态规划 </tag>
            
            <tag> dp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  HDU 1524 A Chess Game [SG函数]【博弈】</title>
      <link href="/2016/10/27/52950443/"/>
      <url>/2016/10/27/52950443/</url>
      
        <content type="html"><![CDATA[<h1 id="HDU-1524-A-Chess-Game-SG函数-【博弈】"><a href="#HDU-1524-A-Chess-Game-SG函数-【博弈】" class="headerlink" title="HDU 1524 A Chess Game [SG函数]【博弈】"></a>HDU 1524 A Chess Game [SG函数]【博弈】</h1><p>2016年10月27日 21:56:49  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：320</p><hr><p> 博客爬取于<code>2019-04-18 17:19:10</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/52950443" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/52950443</a></p><p>题目链接： <a href="http://acm.hdu.edu.cn/showproblem.php?pid=1524" target="_blank" rel="noopener"> http://acm.hdu.edu.cn/showproblem.php?pid=1524</a><br>——————————-.<br>A Chess Game</p><p>Time Limit: 2000/1000 MS (Java/Others) Memory Limit: 65536/32768 K<br>(Java/Others)<br>Total Submission(s): 2133 Accepted Submission(s): 954</p><p>Problem Description<br>Let’s design a new chess game. There are N positions to hold M chesses in this<br>game. Multiple chesses can be located in the same position. The positions are<br>constituted as a topological graph, i.e. there are directed edges connecting<br>some positions, and no cycle exists. Two players you and I move chesses<br>alternately. In each turn the player should move only one chess from the<br>current position to one of its out-positions along an edge. The game does not<br>end, until one of the players cannot move chess any more. If you cannot move<br>any chess in your turn, you lose. Otherwise, if the misfortune falls on me… I<br>will disturb the chesses and play it again.</p><p>Do you want to challenge me? Just write your program to show your<br>qualification!</p><p>Input<br>Input contains multiple test cases. Each test case starts with a number N (1<br>&lt;= N &lt;= 1000) in one line. Then the following N lines describe the out-<br>positions of each position. Each line starts with an integer Xi that is the<br>number of out-positions for the position i. Then Xi integers following specify<br>the out-positions. Positions are indexed from 0 to N-1. Then multiple queries<br>follow. Each query occupies only one line. The line starts with a number M (1<br>&lt;= M &lt;= 10), and then come M integers, which are the initial positions of<br>chesses. A line with number 0 ends the test case.</p><p>Output<br>There is one line for each query, which contains a string “WIN” or “LOSE”.<br>“WIN” means that the player taking the first turn can win the game according<br>to a clever strategy; otherwise “LOSE” should be printed.</p><p>Sample Input<br>4<br>2 1 2<br>0<br>1 3<br>0<br>1 0<br>2 0 2<br>0</p><p>4<br>1 1<br>1 2<br>0<br>0<br>2 0 1<br>2 1 1<br>3 0 1 3<br>0</p><p>Sample Output<br>WIN<br>WIN<br>WIN<br>LOSE<br>WIN</p><p>Source<br>PKU Monthly</p><p>————————————–.<br>题目大意：<br>这题就是给你一个有向图 最后不能移动的人就输了 问你先手输赢的情况</p><p>这题的输入比较乱 反正我是看了半天才明白；<br>就是先输入一个n代表有n个点<br>然后又n行 分别表示的是0~n-1这几个点指向的节点<br>第一个数x是指向几个节点，然后的x个数表示节点<br>然后有q次询问<br>接下来有q行<br>每行第一个数表示有x个起始位置 接下来的是x个其实位置的值<br>然后让你判断先手的输赢</p><p>解题思路：<br>这题就是最最最最裸的SG函数了<br>恰恰就是sg函数的定义：把问题抽象成一个有向无环图</p><p>并没有什么可说的 只要dfs一下就行了 当然for也可以</p><p><strong> 然而特别要注意的是，mex操作中的标记数组声明在外面就不能过 在函数里面声明就AC </strong><br>这都是玄学。。。</p><p>附本题代码<br>——————————-.</p><pre><code>//#include &lt;bits/stdc++.h&gt;#include &lt;stdio.h&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;string.h&gt;#include &lt;math.h&gt;#include &lt;vector&gt;using namespace std;#define INF 0x3f3f3f3f#define pb push_back#define abs(a) (a)&gt;0?(a):-(a)#define min(a,b) (a)&gt;(b)?(a):(b)#define lalal puts(&quot;*******&quot;)typedef long long int LL ;typedef unsigned long long int LLu ;/*******************************/const int MOD = 10086;const int N = 1e4+5;const double eps = 1e-9;int sg[1010];vector&lt;int&gt;E[1010];int getsg(int v){    if(sg[v]!=-1) return sg[v];    bool h[1010];    memset(h,0,sizeof(h));    for(int i=0;i&lt;E[v].size();i++)        h[getsg(E[v][i])]=1;    for(int i=0;;i++)        if(0==h[i]) {sg[v]=i;break;}    return sg[v];}int main(){    int n;    while(~scanf(&quot;%d&quot;,&amp;n)){        memset(sg,-1,sizeof(sg));        int x,y;        for(int i=0;i&lt;n;i++){            E[i].clear();            scanf(&quot;%d&quot;,&amp;x);            while(x--){                scanf(&quot;%d&quot;,&amp;y);                E[i].pb(y);            }        }        int ans;        while(true){            ans=0;            scanf(&quot;%d&quot;,&amp;x);            if(0==x) break;            while(x--){                scanf(&quot;%d&quot;,&amp;y);                ans^=getsg(y);            }        if(ans) puts(&quot;WIN&quot;);        else    puts(&quot;LOSE&quot;);        }    }    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  HDU 1517 A Multiplication Game [。。]【博弈】</title>
      <link href="/2016/10/27/52946902/"/>
      <url>/2016/10/27/52946902/</url>
      
        <content type="html"><![CDATA[<h1 id="HDU-1517-A-Multiplication-Game-。。-【博弈】"><a href="#HDU-1517-A-Multiplication-Game-。。-【博弈】" class="headerlink" title="HDU 1517 A Multiplication Game [。。]【博弈】"></a>HDU 1517 A Multiplication Game [。。]【博弈】</h1><p>2016年10月27日 16:17:26  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：221</p><p>个人分类：  <a href="https://blog.csdn.net/qq_33184171/article/category/6117381" target="_blank" rel="noopener"> ===== 博弈 =====</a></p><hr><p> 博客爬取于<code>2019-04-18 17:19:11</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/52946902" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/52946902</a></p><p>题目链接: <a href="http://acm.hdu.edu.cn/showproblem.php?pid=1517" target="_blank" rel="noopener"> http://acm.hdu.edu.cn/showproblem.php?pid=1517</a></p><p>——————————-.<br>A Multiplication Game</p><p>Time Limit: 5000/1000 MS (Java/Others) Memory Limit: 65536/32768 K<br>(Java/Others)<br>Total Submission(s): 5345 Accepted Submission(s): 3048</p><p>Problem Description<br>Stan and Ollie play the game of multiplication by multiplying an integer p by<br>one of the numbers 2 to 9. Stan always starts with p = 1, does his<br>multiplication, then Ollie multiplies the number, then Stan and so on. Before<br>a game starts, they draw an integer 1 &lt; n &lt; 4294967295 and the winner is who<br>first reaches p &gt;= n.</p><p>Input<br>Each line of input contains one integer number n.</p><p>Output<br>For each line of input output one line either</p><p>Stan wins.</p><p>or</p><p>Ollie wins.</p><p>assuming that both of them play perfectly.</p><p>Sample Input<br>162<br>17<br>34012226</p><p>Sample Output<br>Stan wins.<br>Ollie wins.<br>Stan wins.</p><p>Source<br>University of Waterloo Local Contest 2001.09.22</p><p>Recommend<br>LL</p><p>——————————-.</p><p>题目大意：就是给你数n 两个人轮流对x（初始为1）乘上一个[2,9]之间的一个数字 最先得到x≥n的人获胜</p><p>解题思路：<br>这种题 很显然是博弈 但是又不是几个常见的模型<br>所以找一下其中的必胜态和必败态</p><p>首先对于[n,+∞]一定是必胜态 ，没有问题 ；<br>那么能够一步到达这里的一定是必败态<br>那就是[ceil(n/9),n-1];<br>然后不管怎么样一步只能到达必败态的位置一定是必胜态；<br>那就是[ceil(n/2),n-1];</p><p>之后这样的话我们就可以暴力的枚举到最后 看一看1这个位置是必胜态还是必败态就好了</p><p>附本题代码<br>————————-.</p><pre><code>#include &lt;bits/stdc++.h&gt;int main(){    LL n;    while(~scanf(&quot;%I64d&quot;,&amp;n))    {        int i;        for(i=0;n&gt;1;i++)        {            if(i&amp;1) n = ceil(n*1.0/2);            else    n = ceil(n*1.0/9);        }        puts(i&amp;1?&quot;Stan wins.&quot;:&quot;Ollie wins.&quot;);    }    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博弈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  LIGHT OJ 1278 Sum of Consecutive Integers [因子个数]【数论】</title>
      <link href="/2016/10/25/52926338/"/>
      <url>/2016/10/25/52926338/</url>
      
        <content type="html"><![CDATA[<h1 id="LIGHT-OJ-1278-Sum-of-Consecutive-Integers-因子个数-【数论】"><a href="#LIGHT-OJ-1278-Sum-of-Consecutive-Integers-因子个数-【数论】" class="headerlink" title="LIGHT OJ 1278 Sum of Consecutive Integers [因子个数]【数论】"></a>LIGHT OJ 1278 Sum of Consecutive Integers [因子个数]【数论】</h1><p>2016年10月25日 19:37:29  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：627</p><hr><p> 博客爬取于<code>2019-04-18 17:19:12</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/52926338" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/52926338</a></p><p>题目链接： <a href="http://vjudge.net/contest/137260#problem/W" target="_blank" rel="noopener"> http://vjudge.net/contest/137260#problem/W</a><br>———————————–.<br>Sum of Consecutive Integers<br>Time Limit:2000MS Memory Limit:32768KB 64bit IO Format:%lld &amp; %llu</p><p>Description<br>Given an integer N, you have to find the number of ways you can express N as<br>sum of consecutive integers. You have to use at least two integers.</p><p>For example, N = 15 has three solutions, (1+2+3+4+5), (4+5+6), (7+8).</p><p>Input<br>Input starts with an integer T (≤ 200), denoting the number of test cases.</p><p>Each case starts with a line containing an integer N (1 ≤ N ≤ 1014).</p><p>Output<br>For each case, print the case number and the number of ways to express N as<br>sum of consecutive integers.</p><p>Sample Input<br>5<br>10<br>15<br>12<br>36<br>828495<br>Sample Output<br>Case 1: 1<br>Case 2: 3<br>Case 3: 1<br>Case 4: 2<br>Case 5: 47</p><p>————————————-.</p><p>题目大意 :<br>给你一个数N ，然后问你 一些连续的数和 等于N的种类数</p><p>解题思路：<br>首先<br>N=a+（a+1）+（a+2）+（a+3）+…+（a+k-1）<br>=（a+a+k-1）<em>k/2 =（2</em>a+k-1）*k/2</p><p>然后把式子转换一下<br>得到这样的结果<br>2<em>N/K-K=2</em>a-1</p><p>我们能够知道2<em>a-1是奇数 所以2</em>N/K与K之间一定是一个奇数一个偶数的<br>那么这时候只要求有多少种K的值能够满足 这个式子 就可以了<br>1）K为奇数 2<em>N/K为偶数<br>2）K为偶数 2</em>N/K为奇数<br>这时候2<em>N/K和/K都是2</em>N的奇因子 其中上述两种情况在计算中不会出现重叠的时候 所以计算两者加和就行了也就是N*2的奇因子，</p><p>综上所述 ：N的奇数因子的个数即为解。</p><p>然后只要求N得奇质因子的个数就行了<br>根据算数基本定理讲N展开<br>N=p1^a1<em>p2^a2</em>p2^a2<em>…</em>pn^an</p><p>然后根据因子个数的公式 ∏ i_n （ai+1）<br>由于我们求的是奇质因子的个数 所有质因子为偶数的时候就不用计算了 当然质因子中只有2一个是偶数</p><p>附本题代码<br>————————.</p><pre><code>//#include &lt;bits/stdc++.h&gt;#include &lt;stdio.h&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;string.h&gt;#include &lt;cmath&gt;using namespace std;#define INF 0x3f3f3f3f#define pb push_back#define abs(a) (a)&gt;0?(a):-(a)#define min(a,b) (a)&gt;(b)?(a):(b)#define lalal puts(&quot;*******&quot;)typedef long long int LL ;typedef unsigned long long int LLu ;/*******************************/const int MOD = 10086;const int N = 1e7+5;int prime[700000],kp;bool Is_or[N];void shacker(){    for(int i=0;i&lt;N;i++) Is_or[i]=1;    for(int i=2;i&lt;N;i++)    {        if(Is_or[i]) prime[kp++]=i;        for(int j=0;j&lt;kp&amp;&amp;i*prime[j]&lt;N;j++)        {            Is_or[i*prime[j]]=0;            if(0==i%prime[j]) break;        }    }    //printf(&quot;%d\n&quot;,kp);    return ;}LL solve(LL a){    LL num;    LL result=1;    while(a%2==0) a/=2;    for(int i=1;i&lt;kp&amp;&amp;a&gt;=prime[i];i++)    {        num=0;        while(a%prime[i]==0) a/=prime[i],num++;        //printf(&quot;%I64d-%I64d(%d)  &quot;,a,num,prime[i]);        result*=(num+1);    }    //puts(&quot;&quot;);    if(a&gt;1) result*=2;    return result-1;}int main(){    shacker();    int _;    while(~scanf(&quot;%d&quot;,&amp;_))    {        int kase = 0;        while(_--)        {            LL n;            scanf(&quot;%lld&quot;,&amp;n);            printf(&quot;Case %d: %lld\n&quot;,++kase,solve(n));        }    }    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>&lt;转&gt;#  ACM 所有算法</title>
      <link href="/2016/10/24/52916166/"/>
      <url>/2016/10/24/52916166/</url>
      
        <content type="html"><![CDATA[<h1 id="ACM-所有算法"><a href="#ACM-所有算法" class="headerlink" title="ACM 所有算法"></a>ACM 所有算法</h1><p>2016年10月24日 22:00:16  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：9593</p><hr><p> 博客爬取于<code>2019-04-18 17:19:13</code><br><strong><em>以下为正文</em></strong></p><p>转载自：<a href="http://blog.sina.com.cn/s/blog_adb6743801019h29.html" target="_blank" rel="noopener">http://blog.sina.com.cn/s/blog_adb6743801019h29.html</a>  </p><p>ACM 所有算法</p><p>数据结构</p><ul><li>栈，队列，链表 </li><li>哈希表，哈希数组 </li><li><p>堆，优先队列<br>双端队列<br>可并堆<br>左偏堆</p></li><li><p>二叉查找树<br>Treap<br>伸展树</p></li><li><p>并查集<br>集合计数问题<br>二分图的识别</p></li><li><p>平衡二叉树 </p></li><li>二叉排序树 </li><li><p>线段树<br>一维线段树<br>二维线段树</p></li><li><p>树状数组<br>一维树状数组<br>N维树状数组</p></li><li><p>字典树 </p></li><li>后缀数组，后缀树 </li><li>块状链表 </li><li>哈夫曼树 </li><li>桶，跳跃表 </li><li>Trie树(静态建树、动态建树) </li><li>AC自动机 </li><li>LCA和RMQ问题 </li><li>KMP算法 </li></ul><p>图论</p><ul><li><p>基本图算法图<br>广度优先遍历<br>深度优先遍历<br>拓扑排序<br>割边割点<br>强连通分量<br>Tarjan算法<br>双连通分量<br>强连通分支及其缩点<br>图的割边和割点<br>最小割模型、网络流规约<br>2-SAT问题<br>欧拉回路<br>哈密顿回路</p></li><li><p>最小生成树<br>Prim算法<br>Kruskal算法(稀疏图)<br>Sollin算法<br>次小生成树<br>第k小生成树<br>最优比例生成树<br>最小树形图<br>最小度限制生成树<br>平面点的欧几里德最小生成树<br>平面点的曼哈顿最小生成树<br>最小平衡生成树</p></li><li><p>最短路径<br>有向无环图的最短路径-&gt;拓扑排序<br>非负权值加权图的最短路径-&gt;Dijkstra算法(可使用二叉堆优化)<br>含负权值加权图的最短路径-&gt;Bellmanford算法<br>含负权值加权图的最短路径-&gt;Spfa算法<br>(稠密带负权图中SPFA的效率并不如Bellman-Ford高)<br>全源最短路弗洛伊德算法Floyd<br>全源最短路Johnson算法<br>次短路径<br>第k短路径<br>差分约束系统<br>平面点对的最短路径(优化)<br>双标准限制最短路径</p></li><li><p>最大流<br>增广路-&gt;Ford-Fulkerson算法<br>预推流<br>Dinic算法<br>有上下界限制的最大流<br>节点有限制的网络流<br>无向图最小割-&gt;Stoer-Wagner算法<br>有向图和无向图的边不交路径<br>Ford-Fulkerson迭加算法<br>含负费用的最小费用最大流</p></li><li><p>匹配<br>Hungary算法<br>最小点覆盖<br>最小路径覆盖<br>最大独立集问题<br>二分图最优完备匹配Kuhn-Munkras算法<br>不带权二分匹配：匈牙利算法<br>带权二分匹配：KM算法<br>一般图的最大基数匹配<br>一般图的赋权匹配问题</p></li><li><p>拓扑排序 </p></li><li>弦图 </li><li>稳定婚姻问题 </li></ul><p>搜索</p><ul><li><p>广搜的状态优化<br>利用M进制数存储状态<br>转化为串用hash表判重<br>按位压缩存储状态<br>双向广搜<br>A*算法</p></li><li><p>深搜的优化<br>位运算<br>剪枝<br>函数参数尽可能少<br>层数不易过大<br>双向搜索或者是轮换搜索<br>IDA*算法</p></li><li><p>记忆化搜索 </p></li></ul><p>动态规划</p><ul><li>四边形不等式理论 </li><li><p>不完全状态记录<br>青蛙过河问题<br>利用区间dp</p></li><li><p>背包类问题<br>0-1背包，经典问题<br>无限背包，经典问题<br>判定性背包问题<br>带附属关系的背包问题<br>+ -1背包问题<br>双背包求最优值<br>构造三角形问题<br>带上下界限制的背包问题(012背包)</p></li><li><p>线性的动态规划问题<br>积木游戏问题<br>决斗（判定性问题）<br>圆的最大多边形问题<br>统计单词个数问题<br>棋盘分割<br>日程安排问题<br>最小逼近问题(求出两数之比最接近某数/两数之和等于某数等等)<br>方块消除游戏(某区间可以连续消去求最大效益)<br>资源分配问题<br>数字三角形问题<br>漂亮的打印<br>邮局问题与构造答案<br>最高积木问题<br>两段连续和最大<br>2次幂和问题<br>N个数的最大M段子段和<br>交叉最大数问题</p></li><li><p>判定性问题的dp(如判定整除、判定可达性等)<br>模K问题的dp<br>特殊的模K问题，求最大(最小)模K的数<br>变换数问题</p></li><li><p>单调性优化的动态规划<br>1-SUM问题<br>2-SUM问题<br>序列划分问题(单调队列优化)</p></li><li><p>剖分问题(多边形剖分/石子合并/圆的剖分/乘积最大)<br>凸多边形的三角剖分问题<br>乘积最大问题<br>多边形游戏(多边形边上是操作符,顶点有权值)<br>石子合并(N^3/N^2/NLogN各种优化)</p></li><li><p>贪心的动态规划<br>最优装载问题<br>部分背包问题<br>乘船问题<br>贪心策略<br>双机调度问题Johnson算法</p></li><li><p>状态dp<br>牛仔射击问题(博弈类)<br>哈密顿路径的状态dp<br>两支点天平平衡问题<br>一个有向图的最接近二部图</p></li><li><p>树型dp<br>完美服务器问题(每个节点有3种状态)<br>小胖守皇宫问题<br>网络收费问题<br>树中漫游问题<br>树上的博弈<br>树的最大独立集问题<br>树的最大平衡值问题<br>构造树的最小环</p></li></ul><p>数学</p><p>数论</p><ul><li>中国剩余定理 </li><li>欧拉函数 </li><li>欧几里得定理 </li><li>欧几里德辗转相除法求GCD(最大公约数) </li><li>扩展欧几里得 </li><li>大数分解与素数判定 </li><li>佩尔方程 </li><li>同余定理(大数求余) </li><li><p>素数测试<br>一千万以内：筛选法<br>一千万以外：米勒测试法</p></li><li><p>连分数逼近 </p></li><li>因式分解 </li><li>循环群生成元 </li><li>素数与整除问题 </li><li>进制位. </li><li>同余模运算 </li></ul><p>组合数学</p><ul><li>排列组合 </li><li>容斥原理 </li><li>递推关系和生成函数 </li><li><p>Polya计数法<br>Polya计数公式<br>Burnside定理</p></li><li><p>N皇后构造解 </p></li><li>幻方的构造 </li><li>满足一定条件的hamilton圈的构造 </li><li>Catalan数 </li><li>Stirling数 </li><li>斐波拉契数 </li><li>调和数 </li><li>连分数 </li><li>MoBius反演 </li><li>偏序关系理论 </li><li>加法原理和乘法原理 </li></ul><p>计算几何</p><ul><li><p>基本公式<br>叉乘<br>点乘<br>常见形状的面积、周长、体积公式<br>坐标离散化</p></li><li><p>线段<br>判断两线段（一直线、一线段）是否相交<br>求两线段的交点</p></li><li><p>多边形<br>判定凸多边形,顶点按顺时针或逆时针给出,(不)允许相邻边共线<br>判点在凸多边形内或多边形边上,顶点按顺时针或逆时针给出<br>判点在凸多边形内,顶点按顺时针或逆时针给出,在多边形边上返回0<br>判点在任意多边形内,顶点按顺时针或逆时针给出<br>判线段在任意多边形内,顶点按顺时针或逆时针给出,与边界相交返回1<br>多边形重心<br>多边形切割(半平面交)<br>扫描线算法<br>多边形的内核</p></li><li><p>三角形<br>内心<br>外心<br>重心<br>垂心<br>费马点</p></li><li><p>圆<br>判直线和圆相交,包括相切<br>判线段和圆相交,包括端点和相切<br>判圆和圆相交,包括相切<br>计算圆上到点p最近点,如p与圆心重合,返回p本身<br>计算直线与圆的交点,保证直线与圆有交点<br>计算线段与圆的交点可用这个函数后判点是否在线段上<br>计算圆与圆的交点,保证圆与圆有交点,圆心不重合<br>计算两圆的内外公切线<br>计算线段到圆的切点<br>点集最小圆覆盖</p></li><li><p>可视图的建立 </p></li><li>对踵点 </li><li>经典问题<br>平面凸包<br>三维凸包<br>Delaunay剖分/Voronoi图</li></ul><p>计算方法</p><ul><li><p>二分法<br>二分法求解单调函数相关知识<br>用矩阵加速的计算</p></li><li><p>迭代法 </p></li><li>三分法 </li><li><p>解线性方程组<br>LUP分解<br>高斯消元</p></li><li><p>解模线性方程组 </p></li><li>定积分计算 </li><li>多项式求根 </li><li>周期性方程 </li><li>线性规划 </li><li>快速傅立叶变换 </li><li>随机算法 </li><li>0/1分数规划 </li><li>三分法求解单峰(单谷)的极值 </li><li>迭代逼近 </li><li>矩阵法 </li></ul><p>博弈论</p><ul><li>极大极小过程 </li><li>Nim问题 </li></ul><p>文章中的算法可能有些冗余以及不全之处还望指正，多多修改。</p>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  FZU 1692 [循环矩阵+矩阵快速幂]【数论】</title>
      <link href="/2016/10/22/52893406/"/>
      <url>/2016/10/22/52893406/</url>
      
        <content type="html"><![CDATA[<h1 id="FZU-1692-循环矩阵-矩阵快速幂-【数论】"><a href="#FZU-1692-循环矩阵-矩阵快速幂-【数论】" class="headerlink" title="FZU 1692 [循环矩阵+矩阵快速幂]【数论】"></a>FZU 1692 [循环矩阵+矩阵快速幂]【数论】</h1><p>2016年10月22日 16:58:05  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：274</p><hr><p> 博客爬取于<code>2019-04-18 17:19:14</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/52893406" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/52893406</a></p><p>题目链接： <a href="http://acm.fzu.edu.cn/problem.php?pid=1692" target="_blank" rel="noopener"> http://acm.fzu.edu.cn/problem.php?pid=1692</a><br>—————————————-.<br>Problem 1692 Key problem<br>Accept: 197 Submit: 865<br>Time Limit: 1000 mSec Memory Limit : 32768 KB</p><p>Problem Description</p><p>Whenever rxw meets Coral, he requires her to give him the laboratory key.<br>Coral does not want to give him the key, so Coral ask him one question. if rxw<br>can solve the problem, she will give him the key, otherwise do not give him.<br>rxw turns to you for help now,can you help him?<br>N children form a circle, numbered 0,1,2, … …, n-1,with Clockwise. Initially<br>the ith child has Ai apples. Each round game, the ith child will obtain (<br>L<em>A(i+n-1)%n+R</em>A(i+1)%n ) apples. After m rounds game, Coral would like to<br>know the number of apples each child has. Because the final figure may be very<br>large, so output the number model M.<br>Input</p><p>The first line of input is an integer T representing the number of test cases<br>to follow. Each case consists of two lines of input: the first line contains<br>five integers n,m,L,R and M . the second line contains n integers A0, A1, A2 …<br>An-1. (0 &lt;= Ai &lt;= 1000,3 &lt;= n &lt;= 100,0 &lt;= L, R &lt;= 1000,1 &lt;= M &lt;= 10 ^ 6,0 &lt;=m<br>&lt; = 10 ^ 9). After m rounds game, output the number model M of apples each<br>child has.<br>Output</p><p>Each case separated by a space. See sample.<br>Sample Input</p><p>1<br>3 2 3 4 10000<br>1 2 3<br>Sample Output</p><p>120 133 131<br>Source</p><p>FOJ月赛-2009年3月— Coral<br>—————————————-.</p><p>题目大意：就是每个人初始有a[i]个苹果,每一轮能得到左边L倍+右边R倍的苹果,问你M轮之后每个人有多少个苹果.</p><p>解题思路:<br>很明显的矩阵快速幂.构造矩阵非常简单<br>但是要注意下n≤100 所以n^3会超时,所以要优化一下,,<br>根据矩阵我们能够发现<br>[1 L 0 0 R]<br>[R 1 L 0 0]<br>[0 R 1 L 0]<br>[0 0 R 1 L]<br>[L 0 0 R 1]</p><p>这是一个很明显的循环矩阵<br>根据 <strong> 循环矩阵的n次幂还是循环矩阵的 </strong> 这个性质我们每次求解的时候只需要求解一行或一列就可以了，这样的话就能把n^3优化到n^2了<br>这样就不会超时了</p><p>附本题代码<br>———————————。</p><pre><code>//#include &lt;bits/stdc++.h&gt;#include &lt;stdio.h&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;string.h&gt;using namespace std;#define INF 0x3f3f3f3f#define pb push_back#define abs(a) (a)&gt;0?(a):-(a)#define min(a,b) (a)&gt;(b)?(a):(b)#define lalal puts(&quot;*******&quot;);typedef long long int LL ;/*******************************/const int N = 100+5;int MOD ;struct Matrix{    LL m[N][N];    int row,culumn;    void clearE()    {        for(int i=0; i&lt;row; i++)            for(int j=0; j&lt;culumn; j++)                m[i][j]=(i==j);    }    void clearO()    {        for(int i=0; i&lt;row; i++)            for(int j=0; j&lt;culumn; j++)                m[i][j]=0;    }    void display()    {        for(int i=0; i&lt;row; i++)        {            for(int j=0; j&lt;culumn; j++)                printf(&quot;%d &quot;,m[i][j]);            puts(&quot;&quot;);        }    }};//循环矩阵的写法。。对于循环矩阵来说 行和列是一样都循环的Matrix operator *(Matrix &amp;a,Matrix &amp;b){    Matrix c;    c.row=a.row,c.culumn=b.culumn,c.clearO();    for (int k = 0; k &lt; a.culumn; k++)        if (a.m[0][k])        {            for (int j = 0; j &lt; b.culumn; j++)                if (b.m[k][j])                    c.m[0][j] = (c.m[0][j] + a.m[0][k] * b.m[k][j]) % MOD;        }    for (int i = 1; i &lt; c.culumn; i++)  //每一次根据规律把矩阵打出来    {        c.m[i][0] = c.m[i - 1][c.culumn - 1];        for (int j = 1; j &lt; c.culumn; j++)            c.m[i][j] = c.m[i - 1][j - 1];    }    return c;}Matrix operator ^(Matrix &amp;a,int b){    Matrix c;    c.row=a.row,c.culumn=a.culumn,c.clearE();    while(b)    {        if(b&amp;1) c=c*a;        b&gt;&gt;=1;        a=a*a;    }    return c;}int main(){    int t;    scanf(&quot;%d&quot;,&amp;t);    while(t--)    {        LL n,m,L,R,M;        scanf(&quot;%I64d%I64d%I64d%I64d%I64d&quot;,&amp;n,&amp;m,&amp;L,&amp;R,&amp;M);        MOD=M;        Matrix a,b;        a.row=1,b.row=a.culumn=b.culumn=n,a.clearO(),b.clearO();        for(int i=0; i&lt;n; i++)        {            scanf(&quot;%I64d&quot;,&amp;a.m[0][i]);            a.m[0][i]%=MOD;            b.m[(i-1+n)%n][i]=R%MOD;            b.m[(i+1)%n][i]=L%MOD;            b.m[i][i]=1;        }        b=b^(m);        a=a*b;        for(int i=0; i&lt;n; i++)        {            if(i)printf(&quot; &quot;);            printf(&quot;%I64d&quot;,a.m[0][i]);        }        puts(&quot;&quot;);    }    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  2016CCPC杭州站打铁纪念</title>
      <link href="/2016/10/22/52888634/"/>
      <url>/2016/10/22/52888634/</url>
      
        <content type="html"><![CDATA[<h1 id="2016CCPC杭州站打铁纪念"><a href="#2016CCPC杭州站打铁纪念" class="headerlink" title="2016CCPC杭州站打铁纪念"></a>2016CCPC杭州站打铁纪念</h1><p>2016年10月22日 00:30:09  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：902</p><hr><p> 博客爬取于<code>2019-04-18 17:19:15</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/52888634" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/52888634</a></p><p>首先感谢学校把这次机会给了网赛打的那么差的我们队。</p><p>然后说一下杭州之旅，因为在东北，要是坐火车的话，要坐31个小时的火车，于是我们决定自己多出一点坐3个小时的飞机去杭州。于是提早半个多月买了4折的往返机票。等<br>到机场的时候，由于我们没有老师，学长带队，还都第一次坐飞机，于是天真的以为等飞机起飞前几分钟去飞机上就好了，于是愉快的第一次就误机了。。由于买的打折机票，于<br>是不能改签，不能退。于是查了一下航班，准备订更晚点的另一班飞机去，然后也不知道怎么了估计是队友着急了，手快的订了26号的航班。。。然而当天是16号。。。也是<br>醉了 ，然后退票，由于又是打折机票，所以每张票只退了50…于是半个小时，2000软妹币直接变成150、、、还好我们订的机票早了一天，连忙又订了第二天晚上22<br>：05的机票，这才能在比赛开始前及时报道，。。</p><p>热身赛，由于比赛环境是hdoj，还有熟悉的CB所以，并没有测试什么乱遭的东西。。。于是直接开始做题。。。A题开始刚看题目，，，感觉很简单 ，直接对半非就行了<br>。刚写完，队友说错了，有组样例过不去，然后出了几个数据都是分成最大，最小的在一个集合，剩下的在另一个集合，然后提交WA。最后队友说枚举断点，然后交了，又是W<br>A、、、（赛后听说这是正解。。）。然后队友做B。。。一道sb搜索题，，队友RE了一发，，然后改了一下bug。AC了 ，然后调A ，结果最后结束也没有Ａ。。。</p><p>正式赛、比赛开始先读题目，不到5分钟清华的队伍就FB了Ａ　于是我们就去翻译Ａ，然后以我渣比的英语和马虎的翻译加上队友成功把题意翻译错了，题目要求是只能对相邻<br>的两个进行操作，然而我们当成了任意的，，，于是乎无论怎么贪心，就是有问题，，于是队友看F题。。上来WA一发，然后找到一个没考虑到的情况AC了，，然后看身边的<br>队伍ABCF都过了。。。开始看BC，，，，C题思路秒想出，直接从后面的开始扫，然后可以了，因为一个队友再改A我又看了B，然后B题队友也在想，我想计算几何方向<br>，队友想图论方向，队友说这个只要缩下点，建一个有向图用个XX算法就行了（本人不会图论名字也说不明白），然后我觉得很可行，起码比计算几何靠谱多了，，于是这两题<br>的思路就没有改变，等队友ACA题。。但是队友还是没A，于是我另一个队友先去写了C，不幸WA了，，这个时候我重读了一下Ａ题然后发现了读题失误，，然后把Ｃ的代码<br>打印下来找BUG,我回去敲A然后果断的TLE了，，然后我蒙蔽了，明明是线性的算法数据量并不是非常大，怎么能TLE呢。。于是换队友敲了一发，又TLE了。。。<br>最后每个人都敲了一发还是TLE，，然后改C题。。C题的思路很明确<br>并不会有错，，然后我又去写了一发，还是错，，这时候队友上厕所了，我换个姿势写了一下A，，结果就这么AC了， ，，，于是回头看C，C还是没想到为什么会WA，，<br>这时候应该说一下之前队友写了一发B然而在刚把B的代码写完的时候电脑突然断电了，，，于是本就很炸的队友这回直接就临近崩溃了，，重新开机，发现代码果然已经没有了<br>。。。于是有重敲了一发B，，然后提交WA.。。然后队友重新考虑了一下，，，有个点没有考虑到，，，给了给。。还是没有AC….<br>这时候比赛还剩40分钟，我就改了一下C 。。提交还是WA，，，这时候早已经怀疑人生，，，剩下的时间一直在不停的交B和C题 但是最后还是没有过，，，<br>最后2题滚粗，，，，拿了人生首次铁牌，，也感受到了高中OI爷的可怕，比赛时坐我们后面的福州三中拿了rank3的牛逼成绩%%%%%。。其他rank2也是安师大<br>附中的淼焱轟队伍，其他OI爷队伍也都非常牛逼，，%%%%</p><p>赛后问了群里发现B,C题目的思路都没有错，C题是因为被卡了精度，然后有人用分数过的，有人用EPS过的，由于比赛期间根本没考虑精度这个问题，所以C题GG，B题<br>的思路一样估计还是队友因为电脑断电加上心态爆炸代码写炸了，，</p><p>虽然这次打铁了，杭州一路也比较坎坷，但是也是非常有意义的，首先比赛的经验就收获了很多，还见到了众多大佬，，很后悔没有向jls，cls，dls要签名，，，赛后<br>5分钟终于在杭州首次见到了学校的老师。老师也在安慰，，还好拿到了一些纪念品杭州也没算白来，，，由于误机+打铁后心情不是很好杭州的游玩时间就没有了，最后也没有<br>去西湖看一看就回去了，。。。虽然来之前就知道南方的奖不好拿，，但是也还是不甘心，首先Ａ题这个最水的签到题居然犯下一个又一个的失误，直接打乱了队内的节奏，，其<br>他两道题也并不是不会，但是没有AC否则4题的话还是能够稳铜的。。还是做题太少经验不足，作为队长，这是我的失责，，在这里向我的两个队友表示歉意。。<br>接下来还是要好好努力，争取明年一定要拿一个铜甚至银，，虽然是弱校，弱队，没有老师，但是要知道靠谁不如靠自己，，不管以后结果如何，都要对得起自己。。</p><p><strong> 不忘初心，方得始终。 </strong></p><p>人生成就：</p><p>第一次误机 get<strong>√</strong><br>第一次坐飞机 get<strong>√</strong><br>第一次去南方 get<strong>√</strong><br>第一次打全国性比赛 get<strong>√</strong><br>第一次打铁 get<strong>√</strong></p>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  HDU 5925 Coconuts [二维离散化]【杂类+思维】</title>
      <link href="/2016/10/10/52782106/"/>
      <url>/2016/10/10/52782106/</url>
      
        <content type="html"><![CDATA[<h1 id="HDU-5925-Coconuts-二维离散化-【杂类-思维】"><a href="#HDU-5925-Coconuts-二维离散化-【杂类-思维】" class="headerlink" title="HDU 5925 Coconuts [二维离散化]【杂类+思维】"></a>HDU 5925 Coconuts [二维离散化]【杂类+思维】</h1><p>2016年10月10日 21:41:07  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：1038</p><hr><p> 博客爬取于<code>2019-04-18 17:19:16</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/52782106" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/52782106</a></p><p>题目链接： <a href="http://acm.hdu.edu.cn/showproblem.php?pid=5925" target="_blank" rel="noopener"> http://acm.hdu.edu.cn/showproblem.php?pid=5925</a></p><p>———————————.<br>Coconuts</p><p>Time Limit: 9000/4500 MS (Java/Others) Memory Limit: 65536/65536 K<br>(Java/Others)<br>Total Submission(s): 343 Accepted Submission(s): 110</p><p>Problem Description<br>TanBig, a friend of Mr. Frog, likes eating very much, so he always has dreams<br>about eating. One day, TanBig dreams of a field of coconuts, and the field<br>looks like a large chessboard which has R rows and C columns. In every cell of<br>the field, there is one coconut. Unfortunately, some of the coconuts have gone<br>bad. For sake of his health, TanBig will eat the coconuts following the rule<br>that he can only eat good coconuts and can only eat a connected component of<br>good coconuts one time(you can consider the bad coconuts as barriers, and the<br>good coconuts are 4-connected, which means one coconut in cell (x, y) is<br>connected to (x - 1, y), (x + 1, y), (x, y + 1), (x, y - 1).</p><p>Now TanBig wants to know how many times he needs to eat all the good coconuts<br>in the field, and how many coconuts he would eat each time(the area of each<br>4-connected component).</p><p>Input<br>The first line contains apositiveinteger T(T≤10) which denotes the test cases.<br>T test cases begin from the second line. In every test case, the first line<br>contains two integers R and C, 0&lt; R,C ≤109 the second line contains an integer<br>n, the number of bad coconuts, 0≤n≤200 from the third line, there comes n<br>lines, each line contains two integers, xi and yi, which means in cell(xi,yi),<br>there is a bad coconut.</p><p>It is guaranteed that in the input data, the first row and the last row will<br>not have bad coconuts at the same time, the first column and the last column<br>will not have bad coconuts at the same time.</p><p>Output<br>For each test case, output “Case #x:” in the first line, where x denotes the<br>number of test case, one integer k in the second line, denoting the number of<br>times TanBig needs, in the third line, k integers denoting the number of<br>coconuts he would eat each time, you should output them in increasing order.</p><p>Sample Input<br>2</p><p>3 3<br>2<br>1 2<br>2 1</p><p>3 3<br>1<br>2 2</p><p>Sample Output<br>Case #1:<br>2<br>1 6<br>Case #2:<br>1<br>8</p><p>————————————————–.<br>题目大意：<br>就是有r<em>c的方阵，代表每个房间，每个房间上有一个糖 ，其中有n个坏的 。<br>然后一个人吃糖，只能上下左右的房间是连着的，然后不能去糖坏了的房间，<br>问你一共需要进入几次 ，每次能吃多少糖。<br>/ <strong> _ </strong> <strong>** </strong> _ ** /<br>上述表达不清晰<br>下面换一种说法<br>就是有r</em>c的方阵 上面都是白的 其中有n个黑色的点 ，问你黑色的点把白色的点分成了几个部分，每个部分的点有多少。</p><p>解题思路：</p><p>正常的思想就应该是搜索了，但是奈何图太大 ，会超时；<br>所以得换个思路想问题 ，<br>图虽然很大 ，但是黑色的点只有200个，<br>所以突破点应该就在这里。<br>最终想出用离散化的方法解决这个问题，；<br>图很大的时候每个点之间的距离很大，只要把这一部分离散化就好了，离散化后 图最坏也只是400*400，这样的话搜索就不会超时了。</p><p>离散化的时候很简单 对于x，y坐标分别离散化一下就行了，然后映射到图上就是二维的离散化了。<br>注意的是 挨着的坐标在离散化后也是挨着的，不挨着的坐标，在离散化后也是不挨着的。然后开个数组存储下离散化后，每个x，y应该是多少，然后直接dfs/bfs均可<br>，在搜索的时候就能统计值了。</p><p>知道怎样离散化，然后写写代码就好了。</p><p>注意：题目数据量大 要用LL</p><p>当时在赛场上，上个厕所的功夫终于想出了离散化的正解 ，然后我那渣比的代码能力 +队友搅屎，调了2h没有调好。。。</p><p>附本题代码<br>————————-.</p><pre><code>#include &lt;bits/stdc++.h&gt;using namespace std;#define INF 0x3f3f3f3f#define pb push_back#define abs(a) (a)&gt;0?(a):-(a)#define lalal puts(&quot;*******&quot;);typedef long long int LL ;/*******************************/int ma[444][444];int vis[444][444];int xx[222],yy[222];//横纵坐标struct node   //点{    int x,y,col;} bad[222];map&lt;int ,int &gt;mx,my;  //离散化的映射LL vx[444],vy[444];  //离散化后横纵坐标的价值LL val[444];int fx[]= {0,0,1,-1};int fy[]= {1,-1,0,0};int main(){    int _,p;    while(~scanf(&quot;%d&quot;,&amp;_))    {        p=0;        while(_--)        {            /******这是一堆预处理******/            mx.clear(),my.clear();            memset(val,0,sizeof(val));            int n,m,num,num1,num2;            scanf(&quot;%d%d&quot;,&amp;n,&amp;m);            scanf(&quot;%d&quot;,&amp;num),num1=num2=num;            for(int i=1; i&lt;=num; i++)            {                scanf(&quot;%d%d&quot;,&amp;bad[i].x,&amp;bad[i].y);                xx[i]=bad[i].x,yy[i]=bad[i].y;            }            xx[0]=1,yy[0]=1,xx[num+1]=n ,yy[num+1]=m ;//离散化图的边界            int hang=1,lie=1,pre=1;            /**************离散化行**************/            sort(xx,xx+num1+2);            num1=unique(xx,xx+num1+2)-xx;            //for(int i=0;i&lt;num1;i++)  printf(&quot;%d &quot;,xx[i]);  puts(&quot;&quot;);            for(int i=0; i&lt;num1; i++)            {                if(i&amp;&amp;xx[i]!=xx[i-1]+1) vx[hang]=xx[i]-pre-1,hang++;                vx[hang]=1,mx[xx[i]]=hang++;                pre=xx[i];            }            /**************离散化列**************/            pre=1;            sort(yy,yy+num2+2);            num2=unique(yy,yy+num2+2)-yy;            for(int i=0; i&lt;num2; i++)            {                if(i&amp;&amp;yy[i]!=yy[i-1]+1) vy[lie]=yy[i]-pre-1,lie++;                vy[lie]=1,my[yy[i]]=lie++;                pre=yy[i];            }            for(int i=0; i&lt;=hang; i++) for(int j=0; j&lt;=lie; j++) ma[i][j]=1;            for(int i=1; i&lt;hang; i++) for(int j=1; j&lt;lie; j++) vis[i][j]=ma[i][j]=0;            for(int i=1; i&lt;=num; i++) ma[mx[bad[i].x]][my[bad[i].y]]=1;            int color=1,xx,yy;            node tem,tmp;            queue&lt;node &gt;qq;            for(int i=1; i&lt;hang; i++) for(int j=1; j&lt;lie; j++)                {                    if(vis[i][j]||ma[i][j]==1) continue;                    vis[i][j]=1;                    tem.x=i,tem.y=j,tem.col=color++;                    qq.push(tem);                    while(!qq.empty())                    {                        tem=qq.front(),qq.pop();                        val[tem.col]+=vx[tem.x]*vy[tem.y];                        for(int k=0; k&lt;4; k++)                        {                            tmp.x=xx=tem.x+fx[k];                            tmp.y=yy=tem.y+fy[k];                            tmp.col=tem.col;                            if(xx&gt;0&amp;&amp;yy&gt;0&amp;&amp;xx&lt;hang&amp;&amp;yy&lt;lie&amp;&amp;!vis[xx][yy]&amp;&amp;ma[xx][yy]==0)                                vis[xx][yy]=1,qq.push(tmp);                        }                    }                }            printf(&quot;Case #%d:\n&quot;,++p);            printf(&quot;%d\n&quot;,color-1);            if(color-1)            {                sort(val+1,val+color);                for(int i=1; i&lt;color; i++)                {                    if(i!=1) printf(&quot; &quot;);                    printf(&quot;%I64d&quot;,val[i]);                }                puts(&quot;&quot;);            }        }    }    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  hdu 4790 Just Random 2013 Asia Chengdu Regional Contest [数学]【思维】</title>
      <link href="/2016/10/05/52740134/"/>
      <url>/2016/10/05/52740134/</url>
      
        <content type="html"><![CDATA[<h1 id="hdu-4790-Just-Random-2013-Asia-Chengdu-Regional-Contest-数学-【思维】"><a href="#hdu-4790-Just-Random-2013-Asia-Chengdu-Regional-Contest-数学-【思维】" class="headerlink" title="hdu 4790 Just Random 2013 Asia Chengdu Regional Contest [数学]【思维】"></a>hdu 4790 Just Random 2013 Asia Chengdu Regional Contest [数学]【思维】</h1><p>2016年10月05日 19:28:29  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：266</p><p>个人分类：  <a href="https://blog.csdn.net/qq_33184171/article/category/6162724" target="_blank" rel="noopener"> 数学 </a> <a href="https://blog.csdn.net/qq_33184171/article/category/6362373" target="_blank" rel="noopener"><br>===== 杂类 ===== </a> <a href="https://blog.csdn.net/qq_33184171/article/category/6117382" target="_blank" rel="noopener"><br>hdu </a></p><hr><p> 博客爬取于<code>2019-04-18 17:19:17</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/52740134" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/52740134</a></p><p>题目链接： <a href="http://acm.hdu.edu.cn/showproblem.php?pid=4790" target="_blank" rel="noopener"> http://acm.hdu.edu.cn/showproblem.php?pid=4790</a><br>——————————.<br>Just Random</p><p>Time Limit: 2000/1000 MS (Java/Others) Memory Limit: 32768/32768 K<br>(Java/Others)<br>Total Submission(s): 2782 Accepted Submission(s): 850</p><p>Problem Description<br>Coach Pang and Uncle Yang both love numbers. Every morning they play a game<br>with number together. In each game the following will be done:<br>1. Coach Pang randomly choose a integer x in [a, b] with equal probability.<br>2. Uncle Yang randomly choose a integer y in [c, d] with equal probability.<br>3. If (x + y) mod p = m, they will go out and have a nice day together.<br>4. Otherwise, they will do homework that day.<br>For given a, b, c, d, p and m, Coach Pang wants to know the probability that<br>they will go out.</p><p>Input<br>The first line of the input contains an integer T denoting the number of test<br>cases.<br>For each test case, there is one line containing six integers a, b, c, d, p<br>and m(0 &lt;= a &lt;= b &lt;= 109, 0 &lt;=c &lt;= d &lt;= 109, 0 &lt;= m &lt; p &lt;= 109).</p><p>Output<br>For each test case output a single line “Case #x: y”. x is the case number and<br>y is a fraction with numerator and denominator separated by a slash (‘/’) as<br>the probability that they will go out. The fraction should be presented in the<br>simplest form (with the smallest denominator), but always with a denominator<br>(even if it is the unit).</p><p>Sample Input<br>4<br>0 5 0 5 3 0<br>0 999999 0 999999 1000000 0<br>0 3 0 3 8 7<br>3 3 4 4 7 0</p><p>Sample Output<br>Case #1: 1/3<br>Case #2: 1/1000000<br>Case #3: 0/1<br>Case #4: 1/1</p><p>Source<br>2013 Asia Chengdu Regional Contest</p><p>—————————–.</p><p>题目大意：<br>给你两个区间[a,b][c,d]<br>求分别从两个区间中取出x，y. 使得(x+y)mod p==m的概率</p><p>解题思路 :</p><p>概率就是<br>可行的组数/所有的组数<br>所有的组数就是(b-a+1)*(d-c+1)</p><p>问题就是怎么求解可行的组数<br>如果暴力的话 最坏是O(10^18) 一定会超时<br>如果把区间对p取模 存在数组里然后在选取 时空复杂度均为O(10^9) 还是不可行</p><p>于是 就改变一下思路<br>他要求的是(x+y)mod p==m 那么x+y的区间就是<br>[a+c,b+d]</p><p>这样的话 会发现 [a+c,b+d]中每个数出现的次数虽然不相等但是有非常严谨的规律 如下图<br><img src="https://img-blog.csdn.net/20161005192040178" alt="这里写图片描述"></p><p>明确这些就很好算了</p><p>只有分别对这三个区间进行统计就行了</p><p>但是为了方便计算这里讲[c,d]区间变成了[c+p-m,d+p-m]<br>这样的话选出来的数就相当于(x+y)mod p== <strong> 0 </strong><br>统计的时候就方便多了</p><p>统计的时候<br>每一个区间只要找到最大和最小的满足mod p== <strong> 0 </strong> 的数的位置<br>然后用高斯公式就能直接计算了 ::(首项+末项)*项数/2</p><p><strong> 为了避免重复统计 鄙渣做了2点改动 </strong><br>1.判断的区间为[A1,A2] (A2,A3) [A3,A4]<br>2.特判了一下(a==b&amp;&amp;c==d)的情况 否则按照我的思路就会多统计一遍</p><pre><code>    if(a==b&amp;&amp;c==d)    {        if((a+c)%p==m)            printf(&quot;Case #%d: 1/1\n&quot;,++kase);        else            printf(&quot;Case #%d: 0/1\n&quot;,++kase);        continue;    }</code></pre><p>附本题代码<br>—————————.</p><pre><code>#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long int LL;/*************************/LL gcd(LL a,LL b){    if(!b) return a;    else return gcd(b,a%b);}int num1[100050];int num2[100050];int main(){    int _,kase;    while(~scanf(&quot;%d&quot;,&amp;_))    {        kase=0;        while(_--)        {            LL a,b,c,d,p,m;            scanf(&quot;%I64d%I64d%I64d%I64d%I64d%I64d&quot;,&amp;a,&amp;b,&amp;c,&amp;d,&amp;p,&amp;m);            //            if(a==b&amp;&amp;c==d)            {                if((a+c)%p==m)                    printf(&quot;Case #%d: 1/1\n&quot;,++kase);                else                    printf(&quot;Case #%d: 0/1\n&quot;,++kase);                continue;            }            //            if(m)c+=p-m,d+=p-m;            LL sum = 0;            LL a1=a+c,a2=a+d,a3=b+c,a4=b+d;            int flag = 0;            if(a2&gt;a3)            {                swap(a2,a3);                flag=1;            }            int da,xi;            //a1,a2            xi=a1/p,da=a2/p;            if(xi*p&lt;a1)    xi++;            if(da*p&gt;a2)    da--;            if(da&gt;=xi&amp;&amp;a1&lt;=xi*p&amp;&amp;xi*p&lt;=a2&amp;&amp;a1&lt;=da*p&amp;&amp;da*p&lt;=a2)            {                sum+=(da-xi+1)*(xi*p-a1+1+da*p-a1+1)/2 ;            }            //printf(&quot;%I64d %I64d\n&quot;,da*p,xi*p);            //printf(&quot;%I64d\n&quot;,sum);            //a2,a3            xi=a2/p,da=a3/p;            if(xi*p&lt;=a2)    xi++;            if(da*p&gt;=a3)    da--;            if(da&gt;=xi&amp;&amp;a2&lt;=xi*p&amp;&amp;xi*p&lt;=a3&amp;&amp;a2&lt;=da*p&amp;&amp;da*p&lt;=a3)            {                sum+=(da-xi+1)*(a2-a1+1) ;            }            //printf(&quot;%I64d\n&quot;,sum);            //a3,a4            xi=a3/p,da=a4/p;            if(xi*p&lt;a3)    xi++;            if(da*p&gt;a4)    da--;            if(da&gt;=xi&amp;&amp;a3&lt;=xi*p&amp;&amp;xi*p&lt;=a4&amp;&amp;a3&lt;=da*p&amp;&amp;da*p&lt;=a4)            {                sum+=(da-xi+1)*(a4-xi*p+1+a4-da*p+1)/2 ;            }            //printf(&quot;%I64d\n&quot;,sum);            /****************************/            LL fenzi = sum;            LL fenmu = (b-a+1)*(d-c+1);            LL tem = gcd(fenzi,fenmu);            //printf(&quot;%I64d %I64d  %I64d\n&quot;,fenzi ,fenmu,tem);            printf(&quot;Case #%d: %I64d/%I64d\n&quot;,++kase,fenzi/tem,fenmu/tem);        }    }    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hdu </tag>
            
            <tag> 数学 </tag>
            
            <tag> 杂类 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  codeforces 723C. Polycarp at the Radio [模拟]【杂类】</title>
      <link href="/2016/10/04/52734843/"/>
      <url>/2016/10/04/52734843/</url>
      
        <content type="html"><![CDATA[<h1 id="codeforces-723C-Polycarp-at-the-Radio-模拟-【杂类】"><a href="#codeforces-723C-Polycarp-at-the-Radio-模拟-【杂类】" class="headerlink" title="codeforces 723C. Polycarp at the Radio [模拟]【杂类】"></a>codeforces 723C. Polycarp at the Radio [模拟]【杂类】</h1><p>2016年10月04日 18:34:39  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：289</p><p>个人分类：  <a href="https://blog.csdn.net/qq_33184171/article/category/6235560" target="_blank" rel="noopener"> codeforces</a> <a href="https://blog.csdn.net/qq_33184171/article/category/6362373" target="_blank" rel="noopener"> ===== 杂类 =====</a></p><hr><p> 博客爬取于<code>2019-04-18 17:19:18</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/52734843" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/52734843</a></p><p>题目链接: <a href="http://codeforces.com/contest/723/problem/C" target="_blank" rel="noopener"> http://codeforces.com/contest/723/problem/C</a><br>————————————.<br>C. Polycarp at the Radio<br>time limit per test2 seconds<br>memory limit per test256 megabytes<br>inputstandard input<br>outputstandard output<br>Polycarp is a music editor at the radio station. He received a playlist for<br>tomorrow, that can be represented as a sequence a1, a2, …, an, where ai is a<br>band, which performs the i-th song. Polycarp likes bands with the numbers from<br>1 to m, but he doesn’t really like others.</p><p>We define as bj the number of songs the group j is going to perform tomorrow.<br>Polycarp wants to change the playlist in such a way that the minimum among the<br>numbers b1, b2, …, bm will be as large as possible.</p><p>Find this maximum possible value of the minimum among the bj (1 ≤ j ≤ m), and<br>the minimum number of changes in the playlist Polycarp needs to make to<br>achieve it. One change in the playlist is a replacement of the performer of<br>the i-th song with any other group.</p><p>Input<br>The first line of the input contains two integers n and m (1 ≤ m ≤ n ≤ 2000).</p><p>The second line contains n integers a1, a2, …, an (1 ≤ ai ≤ 109), where ai is<br>the performer of the i-th song.</p><p>Output<br>In the first line print two integers: the maximum possible value of the<br>minimum among the bj (1 ≤ j ≤ m), where bj is the number of songs in the<br>changed playlist performed by the j-th band, and the minimum number of changes<br>in the playlist Polycarp needs to make.</p><p>In the second line print the changed playlist.</p><p>If there are multiple answers, print any of them.</p><p>Examples<br>input<br>4 2<br>1 2 3 2<br>output<br>2 1<br>1 2 1 2</p><p>input<br>7 3<br>1 3 2 2 2 2 1<br>output<br>2 1<br>1 3 3 2 2 2 1</p><p>input<br>4 4<br>1000000000 100 7 1000000000<br>output<br>1 4<br>1 2 3 4</p><p>Note<br>In the first sample, after Polycarp’s changes the first band performs two<br>songs (b1 = 2), and the second band also performs two songs (b2 = 2). Thus,<br>the minimum of these values equals to 2. It is impossible to achieve a higher<br>minimum value by any changes in the playlist.</p><p>In the second sample, after Polycarp’s changes the first band performs two<br>songs (b1 = 2), the second band performs three songs (b2 = 3), and the third<br>band also performs two songs (b3 = 2). Thus, the best minimum value is 2.</p><p>——————————————.</p><p>题目大意 ：<br>给定 n 个数，让把某一些变成 1-m之间的数，要改变最少，使得1-m中每个数中出现次数最少的尽量大。</p><p>解题思路：<br>就是模拟这个过程就行了</p><p>首先明确的是要想1-m之间的数中出现次数最少的尽量大那就是n/m个 （说白了就是匀乎匀乎。。。）</p><p>先记录一下1~m中每个数出现的次数 最后跟n/m比一下<br>然后就知道了 需要把改动多少个数了<br>我这里用另一个数组存储下改动的数</p><p>改动的 时候首先先把大于m的数给改成1~m个数<br>如果最后还有数需要改动就 在遍历一下数组 先统计下每个数的出现次数 只有出现次数==n/m之后才能改动这个数 这样才能保证1~m中每个数最少出现n/m个<br>然后注意下细节就能AC了、、</p><p>附本题代码<br>—————————.</p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;#define lalal puts(&quot;*****&quot;);#define abs(a)  (a)&gt;0?(a):-(a)#define INF 0x1f1f1f1f#define pb push_backtypedef long long int LL;/***********************************/int a[2222];int b[2222];int vis[2222];int main(){    int n,m;    while(~scanf(&quot;%d %d&quot;,&amp;n,&amp;m))    {        for(int i=1;i&lt;=m;i++) b[i]=0;        for(int i=0;i&lt;n;i++)        {            scanf(&quot;%d&quot;,&amp;a[i]);            if(a[i]&lt;=m)   b[a[i]]++;        }        int sum=0,len=0,len1=0;        for(int i=1;i&lt;=m;i++)            if(b[i]&lt;n/m)              for(int j=b[i];j&lt;n/m;j++)  vis[len++]=i;        for(int i=0;i&lt;n&amp;&amp;len!=len1;i++)            if(a[i]&gt;m) a[i]=vis[len1++];        for(int i=1;i&lt;=m;i++) b[i]=0;        for(int i=0;i&lt;n&amp;&amp;len!=len1;i++)        {            if(b[a[i]]&lt;n/m) b[a[i]]++;            else      a[i]=vis[len1++];        }        printf(&quot;%d %d\n&quot;,n/m,len);        for(int i=0;i&lt;n;i++)        {            if(i) printf(&quot; &quot;);            printf(&quot;%d&quot;,a[i]);        }        puts(&quot;&quot;);    }    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杂类 </tag>
            
            <tag> codeforces </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  codeforces 723D. Lakes in Berland [DFS]【】</title>
      <link href="/2016/10/04/52734656/"/>
      <url>/2016/10/04/52734656/</url>
      
        <content type="html"><![CDATA[<h1 id="codeforces-723D-Lakes-in-Berland-DFS-【】"><a href="#codeforces-723D-Lakes-in-Berland-DFS-【】" class="headerlink" title="codeforces 723D. Lakes in Berland [DFS]【】"></a>codeforces 723D. Lakes in Berland [DFS]【】</h1><p>2016年10月04日 17:34:41  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：370</p><hr><p> 博客爬取于<code>2019-04-18 17:19:19</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/52734656" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/52734656</a></p><p>题目链接： <a href="http://codeforces.com/contest/723/problem/D" target="_blank" rel="noopener"> http://codeforces.com/contest/723/problem/D</a><br>—————————————-.<br>D. Lakes in Berland<br>time limit per test2 seconds<br>memory limit per test256 megabytes<br>inputstandard input<br>outputstandard output<br>The map of Berland is a rectangle of the size n × m, which consists of cells<br>of size 1 × 1. Each cell is either land or water. The map is surrounded by the<br>ocean.</p><p>Lakes are the maximal regions of water cells, connected by sides, which are<br>not connected with the ocean. Formally, lake is a set of water cells, such<br>that it’s possible to get from any cell of the set to any other without<br>leaving the set and moving only to cells adjacent by the side, none of them is<br>located on the border of the rectangle, and it’s impossible to add one more<br>water cell to the set such that it will be connected with any other cell.</p><p>You task is to fill up with the earth the minimum number of water cells so<br>that there will be exactly k lakes in Berland. Note that the initial number of<br>lakes on the map is not less than k.</p><p>Input<br>The first line of the input contains three integers n, m and k (1 ≤ n, m ≤ 50,<br>0 ≤ k ≤ 50) — the sizes of the map and the number of lakes which should be<br>left on the map.</p><p>The next n lines contain m characters each — the description of the map. Each<br>of the characters is either ‘.’ (it means that the corresponding cell is<br>water) or ‘*’ (it means that the corresponding cell is land).</p><p>It is guaranteed that the map contain at least k lakes.</p><p>Output<br>In the first line print the minimum number of cells which should be<br>transformed from water to land.</p><p>In the next n lines print m symbols — the map after the changes. The format<br>must strictly follow the format of the map in the input data (there is no need<br>to print the size of the map). If there are several answers, print any of<br>them.</p><p>It is guaranteed that the answer exists on the given data.</p><p>Examples</p><pre><code>input5 4 1*****..*******.*..**output1*****..*********..**input3 3 0****.****output1*********</code></pre><p>Note<br>In the first example there are only two lakes — the first consists of the<br>cells (2, 2) and (2, 3), the second consists of the cell (4, 3). It is<br>profitable to cover the second lake because it is smaller. Pay attention that<br>the area of water in the lower left corner is not a lake because this area<br>share a border with the ocean.<br>————————.<br>题目大意:<br>就是 “.”代表水 “*”代表土<br>被土圈上的水是湖 没被圈上的水是海<br>现在只需要K个湖 所以要填上一些湖 问最小花费（填一格花费1）</p><p>解题思路：<br>就是无脑DFS<br>先把海搜索一遍 然后开始搜索湖 并染色 (染色拿vis数组染色就行)<br>拿一个结构体记录每个颜色的湖的大小 按照湖的大小从小到大排下序 最小的开始填湖 就能得到最小花费了</p><p>/ <strong> _ </strong> <strong><strong><strong><em>**</em></strong></strong></strong> <strong> _ </strong> /<br>打CF的时候无脑WA7 过后重敲一发 居然1发就AC了。。。思路一模一样。。。。 GG。。</p><p>附本题代码<br>————————–.</p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;#define lalal puts(&quot;*****&quot;);#define abs(a)  (a)&gt;0?(a):-(a)#define INF 0x1f1f1f1f#define pb push_backtypedef long long int LL;/***********************************/struct node{    int s,c;} num[2555];int cmp(node A,node B){    return A.s&lt;B.s;}char  a[55][55];int vis[55][55];int fx[4]= {0,0,1,-1};int fy[4]= {1,-1,0,0};int n,m,k;void dfs(int x,int y,int &amp;color,int &amp;step){    step++,vis[x][y]=color;    int xx,yy;    for(int i=0;i&lt;4;i++)    {        xx=x+fx[i];        yy=y+fy[i];        if(xx&gt;0&amp;&amp;xx&lt;=n&amp;&amp;yy&gt;0&amp;&amp;yy&lt;=m&amp;&amp;!vis[xx][yy]&amp;&amp;a[xx][yy]==&#39;.&#39;)            dfs(xx,yy,color,step);    }}int main(){    while(~scanf(&quot;%d %d %d&quot;,&amp;n,&amp;m,&amp;k))    {        for(int i=1; i&lt;=n; i++) for(int j=1; j&lt;=m; j++) vis[i][j]=0;        for(int i=1; i&lt;=n; i++) scanf(&quot;%s&quot;,a[i]+1);        int color=-1,step=0;        for(int i=1; i&lt;=n; i++)        {            if(!vis[i][1]&amp;&amp;a[i][1]==&#39;.&#39;)                dfs(i,1,color,step);            if(!vis[i][m]&amp;&amp;a[i][m]==&#39;.&#39;)                dfs(i,m,color,step);        }        for(int j=1; j&lt;=m; j++)        {            if(!vis[1][j]&amp;&amp;a[1][j]==&#39;.&#39;)                dfs(1,j,color,step);            if(!vis[n][j]&amp;&amp;a[n][j]==&#39;.&#39;)                dfs(n,j,color,step);        }        int len = 0; color=0;        for(int i=1; i&lt;=n; i++)            for(int j=1; j&lt;=m; j++)            {                if(!vis[i][j]&amp;&amp;a[i][j]==&#39;.&#39;)                    step=0,dfs(i,j,++color,step),num[len].s=step,num[len++].c=color;            }        int sum=0;        sort(num,num+len,cmp);        for(int u=0; u&lt;len-k; u++)        {            sum+=num[u].s;            for(int i=1; i&lt;=n; i++)                for(int j=1; j&lt;=m; j++)                {                    if(vis[i][j]==num[u].c)                        a[i][j]=&#39;*&#39;;                }        }        printf(&quot;%d\n&quot;,sum);        for(int i=1;i&lt;=n;i++) puts(a[i]+1);    }    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  Codeforces 344E Read Time [二分答案]【思维】</title>
      <link href="/2016/09/30/52710814/"/>
      <url>/2016/09/30/52710814/</url>
      
        <content type="html"><![CDATA[<h1 id="Codeforces-344E-Read-Time-二分答案-【思维】"><a href="#Codeforces-344E-Read-Time-二分答案-【思维】" class="headerlink" title="Codeforces 344E Read Time [二分答案]【思维】"></a>Codeforces 344E Read Time [二分答案]【思维】</h1><p>2016年09月30日 13:43:05  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：291<br>标签：  <a href="https://so.csdn.net/so/search/s.do?q=codeforces&amp;t=blog" target="_blank" rel="noopener"> codeforces </a></p><p>个人分类：  <a href="https://blog.csdn.net/qq_33184171/article/category/6235560" target="_blank" rel="noopener"> codeforces</a> <a href="https://blog.csdn.net/qq_33184171/article/category/6253262" target="_blank" rel="noopener"> 思维</a></p><hr><p> 博客爬取于<code>2019-04-18 17:19:20</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/52710814" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/52710814</a></p><p>题目链接： <a href="http://codeforces.com/contest/344/problem/E" target="_blank" rel="noopener"> http://codeforces.com/contest/344/problem/E</a></p><p>——————————————–.<br>E. Read Time<br>time limit per test1 second<br>memory limit per test256 megabytes<br>inputstandard input<br>outputstandard output<br>Mad scientist Mike does not use slow hard disks. His modification of a hard<br>drive has not one, but n different heads that can read data in parallel.</p><p>When viewed from the side, Mike’s hard drive is an endless array of tracks.<br>The tracks of the array are numbered from left to right with integers,<br>starting with 1. In the initial state the i-th reading head is above the track<br>number hi. For each of the reading heads, the hard drive’s firmware can move<br>the head exactly one track to the right or to the left, or leave it on the<br>current track. During the operation each head’s movement does not affect the<br>movement of the other heads: the heads can change their relative order; there<br>can be multiple reading heads above any of the tracks. A track is considered<br>read if at least one head has visited this track. In particular, all of the<br>tracks numbered h1, h2, …, hn have been read at the beginning of the<br>operation.<br><img src="http://codeforces.com/predownloaded/7c/3f/7c3f33e48d9d21de31574dfccd00ab7d5196416a.png" alt></p><p>Mike needs to read the data on m distinct tracks with numbers p1, p2, …, pm.<br>Determine the minimum time the hard drive firmware needs to move the heads and<br>read all the given tracks. Note that an arbitrary number of other tracks can<br>also be read.</p><p>Input<br>The first line of the input contains two space-separated integers n, m (1 ≤ n,<br>m ≤ 105) — the number of disk heads and the number of tracks to read,<br>accordingly. The second line contains n distinct integers hi in ascending<br>order (1 ≤ hi ≤ 1010, hi &lt; hi + 1) — the initial positions of the heads. The<br>third line contains m distinct integers pi in ascending order (1 ≤ pi ≤ 1010,<br>pi &lt; pi + 1) - the numbers of tracks to read.</p><p>Please, do not use the %lld specifier to read or write 64-bit integers in С++.<br>It is recommended to use the cin, cout streams or the %I64d specifier.</p><p>Output<br>Print a single number — the minimum time required, in seconds, to read all the<br>needed tracks.</p><p>Examples<br>input<br>3 4<br>2 5 6<br>1 3 6 8<br>output<br>2<br>input<br>3 3<br>1 2 3<br>1 2 3<br>output<br>0<br>input<br>1 2<br>165<br>142 200<br>output<br>81<br>Note<br>The first test coincides with the figure. In this case the given tracks can be<br>read in 2 seconds in the following way:</p><p>during the first second move the 1-st head to the left and let it stay there;<br>move the second head to the left twice;<br>move the third head to the right twice (note that the 6-th track has already<br>been read at the beginning).<br>One cannot read the tracks in 1 second as the 3-rd head is at distance 2 from<br>the 8-th track.<br>——————————————–.</p><p>题目大意：<br>就是有N个磁头 和M个要读取的位置<br>磁头每移动一格耗时1秒<br>问你最短多长时间 能够将这M个位置读取</p><p>解题思路：<br>首先二分答案<br>然后判断这个答案能不能满足<br>然后慢慢缩小区间 最后答案就出来了</p><p>判断的时候要采取贪心的策略<br>因为在判断的时候我们默认二分出来的就是答案<br>然后贪心 看一看在二分出来的那个答案中能不能满足题意<br>只要判断每个磁头走移动这些步最多能都读取几个位置<br>然后判断这些位置能不能被走完<br>走完就是成立了</p><p>判断的时候就是让每个磁头尽可能的像右走 (前提是想把左边需要读取的点都读取完毕)<br>详细的请看代码注释…</p><p>附本题代码<br>———-.</p><pre><code>#include &lt;bits/stdc++.h&gt;using namespace std;#define INF 0x3f3f3f3f#define pb push_back#define abs(a) (a)&gt;0?(a):-(a)#define lalal puts(&quot;*******&quot;);typedef long long int LL ;/**********************************/const LL MOD = 1e9+7;int n,m;LL a[101010],b[101010];bool check(LL x){    int step=0;    LL s;    for(int i=0; i&lt;n&amp;&amp;step&lt;m; i++)    {        if(a[i]-b[step]&gt;x) return false;        s=a[i];        if(b[step]&lt;s)        {            s=max(s,x-(a[i]-b[step])+b[step]); //先向左走 把之前啊没有读取的位置给读取了             s=max(s,(x-(a[i]-b[step]))/2+a[i]); //先向右走尽可能远 然后走回去 把之前没有读取的位置给读取了        }        else    s=x+a[i];        //s 记录的是 这个磁头 向右最远能够走到哪个位置        while(step&lt;m&amp;&amp;b[step]&lt;=s) step++;    }    if(step&lt;m) return false;    return true;}int main(){    while(~scanf(&quot;%d%d&quot;,&amp;n,&amp;m))    {        for(int i=0; i&lt;n; i++)scanf(&quot;%I64d&quot;,&amp;a[i]);        for(int i=0; i&lt;m; i++)scanf(&quot;%I64d&quot;,&amp;b[i]);        LL l=0,r=100000000000ll,mid;        //二分是对最终的答案二分的 每次判断这个答案能不能满足 以此不断的缩小区间。。        //二分的界限一定是小于数据范围10倍的         //其实最大界限只要abs(a[1]-b[1])*2+abs(a[i]-b[m-1])进行了 但是没什么必要 写起来还很累。。。。        while(l&lt;r)        {            mid=(l+r)&gt;&gt;1;            if(check(mid)) r=mid;//如果满足的话就缩小上限            else l=mid+1;//不满足的话就缩小区间下限        }        printf(&quot;%I64d\n&quot;,r);    }    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 思维 </tag>
            
            <tag> codeforces </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  杂（模板）</title>
      <link href="/2016/09/27/52681216/"/>
      <url>/2016/09/27/52681216/</url>
      
        <content type="html"><![CDATA[<h1 id="杂（模板）"><a href="#杂（模板）" class="headerlink" title="杂（模板）"></a>杂（模板）</h1><p>置顶  2016年09月27日 15:33:17  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：739</p><p>个人分类：  <a href="https://blog.csdn.net/qq_33184171/article/category/6362373" target="_blank" rel="noopener"> ===== 杂类 =====</a> <a href="https://blog.csdn.net/qq_33184171/article/category/6354517" target="_blank" rel="noopener"> ===== 模板 =====</a></p><hr><p> 博客爬取于<code>2019-04-18 17:15:10</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/52681216" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/52681216</a></p><h3 id="二维map这么开"><a href="#二维map这么开" class="headerlink" title="二维map这么开"></a>二维map这么开</h3><h3 id="读入优化"><a href="#读入优化" class="headerlink" title="读入优化"></a>读入优化</h3><pre><code>inline int read(){    int x=0,f=1;char ch=getchar();    while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;){if(ch==&#39;-&#39;)f=-1;ch=getchar();}    while(ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;){x=x*10+ch-&#39;0&#39;;ch=getchar();}    return x*f;}</code></pre><h3 id="四国以"><a href="#四国以" class="headerlink" title="四国以"></a>四国以</h3><p><code>printf(&quot;%*d&quot;,length+1,a[i][j]); //其中*号是位数 对应length是对应位数的数据 +1是数值之前的空格占一位</code>  </p><p>利用斯特林公式, <code>LL a = 0.5 * log10(2.0 * Pi * n) + n * log10(n * 1.0 / E) + 1;</code><br><a href="https://en.wikipedia.org/wiki/Stirling%27s_approximation" target="_blank" rel="noopener"> Wiki链接 </a></p><h3 id="求逆序对数"><a href="#求逆序对数" class="headerlink" title="求逆序对数"></a>求逆序对数</h3><pre><code>int sum[N];#define lowbit(x) (x&amp;-x)void update(int index,int val){for(int i=index;i&lt;N;i+=lowbit(i))sum[i]+=val;}int  getSum(int index){int ans=0;for(int i=index;i;i-=lowbit(i))ans+=sum[i];return ans;}int a[N],b[N];int findi(int *a,int len,int n){    int l = 1,r = len,mid,ans=-1;    while(l&lt;=r){        mid = (l+r)&gt;&gt;1;        if(a[mid]&gt;=n){            ans = mid;            r=mid-1;        }        else l=mid+1;    }    return ans;}int main(){    int n;    while(~scanf(&quot;%d&quot;,&amp;n)){        LL ans = 0;        Rep(i,1,n) a[i]=read(),sum[i]=0,b[i]=a[i];        sort(b+1,b+n+1);        int len = unique(b+1,b+n+1)-b-1;        Per(i,n,1){            int id = findi(b,len,a[i]);            ans+=getSum(id);            update(id,1);        }        printf(&quot;%d\n&quot;,ans);    }    return 0;}</code></pre><h3 id="最长上升子序列相关"><a href="#最长上升子序列相关" class="headerlink" title="最长上升子序列相关"></a>最长上升子序列相关</h3><pre><code>#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;using namespace std;typedef long long int LL ;const LL MOD = 1e9+7;const LL INF = 0xffffffff;const int N  = 1e5+7;int a[N];int b[N]; //为以a[i]为结尾的最长上升子序列的长度int c[N];int findi(int *a,int len,int n)//若返回值为x,则a[x]&gt;=n&gt;a[x-1]{    int left=0,right=len,mid=(left+right)/2;    while(left&lt;=right){        if(n&gt;a[mid]) left=mid+1;        else if(n&lt;a[mid]) right=mid-1;        else return mid;        mid=(left+right)/2;    }    return left;}void filli(int *a,int n){    for(int i=0;i&lt;=n;i++)        a[i]=1e9+7;}int main(){    int t;    scanf(&quot;%d&quot;,&amp;t);    while(t--){        int n;        scanf(&quot;%d&quot;,&amp;n);        filli(c,n+1);        int i,j;        for(i=0;i&lt;n;i++)            scanf(&quot;%d&quot;,&amp;a[i]);        c[0]=-1;        c[1]=a[0];        b[0]=1;        for(i=1;i&lt;n;i++){            j=findi(c,n+1,a[i]);            c[j]=a[i];            b[i]=j;        }        printf(&quot;%d&quot;,b[0]);        for(i=1;i&lt;n;i++)            printf(&quot; %d&quot;,b[i]);        puts(&quot;&quot;);    }    return 0;}</code></pre><h3 id="单调队列-专题链接"><a href="#单调队列-专题链接" class="headerlink" title="单调队列  专题链接 "></a>单调队列 <a href="http://vjudge.net/contest/126368#overview" target="_blank" rel="noopener"> 专题链接 </a></h3><p>1.单调队列：在一个双端对列中维护最后解的方法；</p><p>一般适用于：<br>在一个动态的范围内 对于一个限定长度的子区间进行处理最优解的过程<br>[解决 <strong> 浮动窗口 </strong> 的最优解]</p><p>注意： 顾名思义 一定要保证队列中元素的单调性</p><pre><code>int deq[] ；//队列实体int p[] ；//维护下标int head =1，tail = 0； //用于维护双端对列的左右值、。p[0]=p[++r]=0;//其实P[0] 是没有用的。。while(l&lt;=r &amp;&amp; p[l] &lt; i-k) l++;  //不满足子区间长度的需要出队列tem =  当前最优解 ; //  一定要在更新之前计算  否则结果可能因为负值or other 出现错误if( tem &gt; mx )    mx=tem，以及需要进行的操作 ;while(l&lt;=r &amp;&amp; 最优解需要的条件) r--;//更新最优解p[++r]=i;</code></pre><h3 id="康拓展开-转自"><a href="#康拓展开-转自" class="headerlink" title="康拓展开  转自 "></a>康拓展开 <a href="http://archive.cnblogs.com/a/2026276/" target="_blank" rel="noopener"> 转自 </a></h3><h4 id="康托展开"><a href="#康托展开" class="headerlink" title="康托展开"></a>康托展开</h4><blockquote><p>练习题目： <a href="http://acm.nyist.net/JudgeOnline/problem.php?pid=139" target="_blank" rel="noopener"> NYOJ 139 </a><br>康托展开的公式是 X=an<em>(n-1)!+an-1</em>(n-2)!+…+ai<em>(i-1)!+…+a2</em>1!+a1<em>0!<br>其中，ai为当前未出现的元素中是排在第几个（从0开始）。<br>这个公式可能看着让人头大，最好举个例子来说明一下。例如，有一个数组 s = [“A”, “B”, “C”, “D”]，它的一个排列 s1 = [“D”,<br>“B”, “A”, “C”]，现在要把 s1 映射成 X。n 指的是数组的长度，也就是4，所以<br>X(s1) = a4</em>3! + a3<em>2! + a2</em>1! + a1<em>0!<br>关键问题是 a4、a3、a2 和 a1 等于啥？<br>a4 = “D” 这个元素在子数组 [“D”, “B”, “A”, “C”] 中是第几大的元素。”A”是第0大的元素，”B”是第1大的元素，”C”<br>是第2大的元素，”D”是第3大的元素，所以 a4 = 3。<br>a3 = “B” 这个元素在子数组 [“B”, “A”, “C”] 中是第几大的元素。”A”是第0大的元素，”B”是第1大的元素，”C”<br>是第2大的元素，所以 a3 = 1。<br>a2 = “A” 这个元素在子数组 [“A”, “C”] 中是第几大的元素。”A”是第0大的元素，”C”是第1大的元素，所以 a2 = 0。<br>a1 = “C” 这个元素在子数组 [“C”] 中是第几大的元素。”C” 是第0大的元素，所以 a1 = 0。（因为子数组只有1个元素，所以a1总是为0）<br>所以，X(s1) = 3</em>3! + 1<em>2! + 0</em>1! + 0*0! = 20</p></blockquote><blockquote></blockquote><blockquote><p>A B C | 0<br>A C B | 1<br>B A C | 2<br>B C A | 3<br>C A B | 4<br>C B A | 5</p></blockquote><h4 id="通过康托逆展开生成全排列"><a href="#通过康托逆展开生成全排列" class="headerlink" title="通过康托逆展开生成全排列"></a>通过康托逆展开生成全排列</h4><p>练习题目： <a href="http://acm.hdu.edu.cn/showproblem.php?pid=1027" target="_blank" rel="noopener"> HDU 1027 </a><br>如果已知 s = [“A”, “B”, “C”, “D”]，X(s1) = 20，能否推出 s1 = [“D”, “B”, “A”, “C”] 呢？<br>因为已知 X(s1) = a4<em>3! + a3</em>2! + a2<em>1! + a1</em>0! = 20，所以问题变成由 20 能否唯一地映射出一组<br>a4、a3、a2、a1？如果不考虑 ai 的取值范围，有<br>3<em>3! + 1</em>2! + 0<em>1! + 0</em>0! = 20<br>2<em>3! + 4</em>2! + 0<em>1! + 0</em>0! = 20<br>1<em>3! + 7</em>2! + 0<em>1! + 0</em>0! = 20<br>0<em>3! + 10</em>2! + 0<em>1! + 0</em>0! = 20<br>0<em>3! + 0</em>2! + 20<em>1! + 0</em>0! = 20<br>等等。但是满足 0 &lt;= ai &lt;= n-1 的只有第一组。可以使用辗转相除的方法得到 ai，如下图所示：<br><img src="http://pic002.cnblogs.com/images/2011/25284/2011042422221712.png" alt><br>知道了a4、a3、a2、a1的值，就可以知道s1[0] 是子数组[“A”, “B”, “C”, “D”]中第3大的元素 “D”，s1[1] 是子数组<br>[“A”, “B”, “C”] 中第1大的元素”B”，s1[2] 是子数组 [“A”, “C”] 中第0大的元素”A”，s[3] 是子数组 [“C”]<br>中第0大的元素”C”，所以s1 = [“D”, “B”, “A”, “C”]。<br>这样我们就能写出一个函数 Permutation3()，它可以返回 s 的第 m 个排列。</p><pre><code>#include&lt;iostream&gt;  #include&lt;algorithm&gt;  #include&lt;vector&gt;  #include&lt;cstdlib&gt;  using namespace std;  class cantor{  public:      int n;//字符串的长度      string s;      int pos;//字符串在全排列中的字典位置，从0开始      vector&lt;int&gt;num;//所有的字符      cantor(string s):s(s){n=s.size();}      cantor(int n,int pos):n(n),pos(pos){          int i;          for(i=0;i&lt;n;i++)              num.push_back(i);      }      int fac(int);      void encode();      void decode();  };  int cantor::fac(int num){      if(num==0) return 1;          else return num*fac(num-1);  }  void cantor::encode(){      int i,j,count;      vector&lt;int&gt;vec(n);      for(i=0;i&lt;n;i++){          count=0;          for(j=i;j&lt;n;j++)              if(s[i]&gt;s[j]) count++;             vec[n-i-1]=count;                  }      pos=0;      for(i=0;i&lt;s.size();i++)          pos+=vec[i]*fac(i);   }  void cantor::decode(){      int i;      div_t divresult;      for(i=n-1;i&gt;=0;i--){          divresult=div(pos,fac(i));求余数与除数          s.push_back(num[divresult.quot]+&#39;0&#39;);          num.erase(num.begin()+divresult.quot);          pos=divresult.rem;              }  }  int main(){      cantor test(4,2);      test.decode();      cout&lt;&lt;test.s&lt;&lt;endl;  }/****************************************////这是我自己撸的  比上面的容易看的多int jiecheng[10] = {1,1,2,6,24,120,720,5040,40320,362880};int a[10],b[10];int Cantor_expansion(int a[],int len){    int x=0;    for(int i=0; i&lt;len; i++)        for(int j=i+1; j&lt;len; j++)            if(a[j]&lt;a[i])                x+=jiecheng[len-1-i];    return x ;}bool h[len+5];//len就是序列长度void Cantor_inexpansion(int x,int len){    memset(h,0,sizeof(h));    int ind ,tem;    for(int i=0; i&lt;len; i++)    {        ind = 0;        tem = x/jiecheng[len-1-i];        x  %=   jiecheng[len-1-i];        for(int j=1; j&lt;=len; j++)        {            if(h[j]) continue;            if(ind==tem)            {                a[i]=j;                break;            }            ind++;        }        h[a[i]]=1;    }    return ;}</code></pre><h3 id="双调欧几里得旅行商问题"><a href="#双调欧几里得旅行商问题" class="headerlink" title="双调欧几里得旅行商问题"></a>双调欧几里得旅行商问题</h3><p>算法介绍<br><a href="http://blog.csdn.net/zchahaha/article/details/51058738" target="_blank" rel="noopener"> http://blog.csdn.net/zchahaha/article/details/51058738</a><br><a href="http://www.mamicode.com/info-detail-523965.html" target="_blank" rel="noopener"> http://www.mamicode.com/info-detail-523965.html </a></p><pre><code>int dp[N][N];  //dp[i][j]为i点到1点，再从1点到j点的最短距离,int d[N][N];   //d[i][j] 为 i-&gt;j的距离struct point{    int x, y;}a[N];int dis(int i, int j){    int p,q;    if(a[i].y&gt;a[j].y)   q=(360+a[j].y-a[i].y)%360;    else          q=(360+a[i].y-a[j].y)%360;    p=abs(a[i].y-a[j].y)&gt;q?q:abs(a[i].y-a[j].y);    return (abs(a[i].x-a[j].x)*400+p);}int main(){    int _,n;    scanf(&quot;%d&quot;,&amp;_);    while(_--){        scanf(&quot;%d&quot;, &amp;n);        a[1].x=0,a[1].y=0;        for(int i = 2; i &lt;= n+1; i++) scanf(&quot;%d %d&quot;, &amp;a[i].x, &amp;a[i].y);        for(int i = 1; i &lt;= n+1; i++)            for(int j = 1; j &lt;= n+1; j++)                d[i][j] = dis(i, j);        dp[1][2] = d[1][2];        for(int i = 3; i &lt;= n+1; i++){            for(int j = 1; j &lt; i-1; j++)                 dp[j][i] = dp[j][i-1] + d[i-1][i];            dp[i-1][i] = 999999999;            for(int j = 1; j &lt; i-1; j++){                int sum = dp[j][i-1] + d[j][i];                if(dp[i-1][i] &gt; sum)  dp[i-1][i] = sum;            }        }        dp[n+1][n+1] = dp[n][n+1] + d[n][n+1];        printf(&quot;%d\n&quot;, dp[n+1][n+1]+10*n);    }    return 0;}</code></pre><h3 id="线性基"><a href="#线性基" class="headerlink" title="线性基"></a>线性基</h3><p><a href="http://www.cnblogs.com/vb4896/p/6149022.html" target="_blank" rel="noopener"> 线性基讲义 </a></p><p>基：在线性代数中，基（也称为基底）是描述、刻画向量空间的基本工具。向量空间的基是它的一个特殊的子集，基的元素称为基向量。向量空间中任意一个元素，都可以唯一地<br>表示成基向量的线性组合。如果基中元素个数有限，就称向量空间为有限维向量空间，将元素的个数称作向量空间的维数。</p><p>同样的，线性基是一种特殊的基，它通常会在异或运算中出现，它的意义是：通过原集合S的某一个最小子集S1使得S1内元素相互异或得到的值域与原集合S相互异或得到的<br>值域相同。</p><p>性质<br>1. 线性基能相互异或得到原集合的所有相互异或得到的值。<br>2. 线性基是满足性质1的最小的集合<br>3. 线性基没有异或和为0的子集。</p><p>求线性基.</p><pre><code>void Guass(){    for (int i=1;i&lt;=sz;i++)        for (int j=63;j&gt;=0;j--)            if ((A[i]&gt;&gt;j)&amp;1){                if (!P[j]) {P[j]=A[i]; break;}                else A[i]^=P[j];            }    for (int j=0;j&lt;=63;j++) if (P[j]) r++;}r为极大无关组的大小</code></pre><h3 id="算术表达式-计算"><a href="#算术表达式-计算" class="headerlink" title="算术表达式 计算"></a>算术表达式 计算</h3><h4 id="中缀表达式"><a href="#中缀表达式" class="headerlink" title="中缀表达式"></a>中缀表达式</h4><blockquote><p>中心思想就是用两个栈来维护,一个用来存储符号,另一个用来存储数值.</p></blockquote><pre><code>/***author: tabris time  : 2017/2/17 17:03这是在int范围内的整数计算的模板。包括+-*/() 六个符号*/char a[111];stack&lt;int &gt;num;//数值栈stack&lt;char &gt;ch;//符号栈//这个函数只接收+-号，+-号等级最低，运算符栈中除了括号外 都可以取出运算void js1(){    int num1,num2;  //从运算符栈中取一个运算符 对数值栈顶和次顶元素进行运算    while(ch.top()!=&#39;(&#39;){        num1 = num.top(); num.pop();        num2 = num.top(); num.pop();        if(ch.top()==&#39;+&#39;) num2+=num1;        if(ch.top()==&#39;-&#39;) num2-=num1;        if(ch.top()==&#39;*&#39;) num2*=num1;        if(ch.top()==&#39;/&#39;) num2/=num1;        num.push(num2);//将计算结果入数值栈        ch.pop();//删除已经用过的符号    }}//只接收*/运算符void js2() {    int num1,num2;  //栈中只有*/优先级大于*/    while (ch.top()==&#39;*&#39; || ch.top()==&#39;/&#39;) {        num1 = num.top(); num.pop();        num2 = num.top(); num.pop();        if(ch.top()==&#39;*&#39;) num2*=num1;        if(ch.top()==&#39;/&#39;) num2/=num1;        num.push(num2);ch.pop();    }}int solve(char *str){    while(!ch.empty())   ch.pop();    while(!num.empty()) num.pop();    int len = strlen(str);    int tem=0;    bool flag = false;    ch.push(&#39;(&#39;);    strcat(str,&quot;.&quot;);    for(int i=0;i&lt;=len;i++){        if(str[i]&gt;=&#39;0&#39;&amp;&amp;str[i]&lt;=&#39;9&#39;){            flag = true;            tem=(tem&lt;&lt;3)+(tem&lt;&lt;1)+str[i]-&#39;0&#39;;            continue;        }        if(flag){            num.push(tem);            tem = 0;            flag = false;        }        if(str[i]==&#39;+&#39;||str[i]==&#39;-&#39;){            js1();            ch.push(str[i]);        }        else if(str[i]==&#39;*&#39;||str[i]==&#39;/&#39;){            js2();            ch.push(str[i]);        }        else if(str[i]==&#39;(&#39;){            ch.push(str[i]);        }        else if(str[i]==&#39;)&#39;){            js1();            ch.pop();        }        else if(str[i]==&#39;.&#39;){            js1();            ch.pop();        }    }    return num.top();}int main(){    while(~scanf(&quot;%s&quot;,a))printf(&quot;%d\n&quot;,solve(a));    return 0;}</code></pre><h4 id="后缀表达式"><a href="#后缀表达式" class="headerlink" title="后缀表达式"></a>后缀表达式</h4><p>后缀表达式也叫逆波兰表达式</p><p><a href="http://blog.csdn.net/sjf0115/article/details/8661328" target="_blank" rel="noopener"> 参阅这里 </a></p><pre><code>#include&lt;iostream&gt;#include&lt;stack&gt;#include&lt;stdio.h&gt;#include&lt;string.h&gt;using namespace std;int main(){    string PostArray;    int len,i,a,b;    while(cin&gt;&gt;PostArray){        stack&lt;int&gt; Stack;        len = PostArray.length();        for(i = 0;i &lt; len;i++){            //跳过空格            if(PostArray[i] == &#39; &#39;){                continue;            }            //如果是数字则入栈            if(PostArray[i] &gt;= &#39;0&#39; &amp;&amp; PostArray[i] &lt;= &#39;9&#39;){                Stack.push(PostArray[i] - &#39;0&#39;);            }            //如果是字符则从栈读出两个数进行运算            else{                //算数a出栈                a = Stack.top();                Stack.pop();                //算法b出栈                b = Stack.top();                Stack.pop();                //进行运算（+ - * /）                if(PostArray[i] == &#39;+&#39;){                    Stack.push(a + b);                }                else if(PostArray[i] == &#39;-&#39;){                    Stack.push(a - b);                }                else if(PostArray[i] == &#39;*&#39;){                    Stack.push(a * b);                }                else if(PostArray[i] == &#39;/&#39;){                    Stack.push(a / b);                }            }        }//for        printf(&quot;%d\n&quot;,Stack.top());    }//while    return 0;}</code></pre><h3 id="多项式取模"><a href="#多项式取模" class="headerlink" title="多项式取模"></a>多项式取模</h3><p>对于两个多项式,求多项式的gcd，要求首项次数为1，多项式中的运算都%n</p><pre><code>#include &lt;bits/stdc++.h&gt;using namespace std;#define INF        (~(1&lt;&lt;31))#define INFLL      (~(1ll&lt;&lt;63))#define pb         push_back#define mp         make_pair#define abs(a)     ((a)&gt;0?(a):-(a))#define lalal      puts(&quot;*******&quot;);#define s1(x)      scanf(&quot;%d&quot;,&amp;x)#define Rep(a,b,c) for(int a=(b);a&lt;=(c);a++)#define Per(a,b,c) for(int a=(b);a&gt;=(c);a--)typedef long long int LL ;typedef unsigned long long int uLL ;const int    N   = 50000+7;const int    MOD = 1e9+7;const double eps = 1e-7;const double Pi  = acos(-1.0);const double E   = exp(1.0);inline int read(){    int x=0,f=1;char ch=getchar();    while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;){if(ch==&#39;-&#39;)f=-1;ch=getchar();}    while(ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;){x=x*10+ch-&#39;0&#39;;ch=getchar();}    return x*f;}void fre(){    freopen(&quot;in.txt&quot;,&quot;r&quot;,stdin);    freopen(&quot;out.txt&quot;,&quot;w&quot;,stdout);}template&lt;typename T&gt;inline T _gcd(T a,T b){return (b==0)?a:_gcd(b,a%b);}template&lt;typename T&gt;inline T _lcm(T a,T b){return        a/_gcd(a,b)*b;}LL qmod(LL a,LL b,LL c){LL ret=1ll;while(b){if(b&amp;1)ret=ret*a%c;b&gt;&gt;=1,a=a*a%c;}return ret;}/***********************************************************************/#define vi vector&lt;int&gt;int n;int inv(int x){    return qmod(x,n-2,n);}vi vimod(vi f,vi g){    int fz = f.size(),gz = g.size();    for(int i=0;i&lt;fz;i++){        if(fz-i-gz &lt; 0) break;        int a=f[i]*inv(g[0])%n;        for(int j=0;j&lt;gz;j++){            int now=i+j;            f[now]=((f[now]-a*g[j]%n)%n+n)%n;        }    }    vi ans;    int p=-1;    for(int i=0;i&lt;fz;i++)if(f[i]!=0){p=i;break;}    if(p&gt;=0) for(int i=p;i&lt;fz;i++)ans.pb(f[i]);    return ans;}vi gcd(vi f,vi g){    if(g.size()==0) return f;    return  gcd(g,vimod(f,g));}vi f,g;int main(){    int kcase = 0;    while(~scanf(&quot;%d&quot;,&amp;n)&amp;&amp;n){        f.clear(),g.clear();        int d,x;        scanf(&quot;%d&quot;,&amp;d);        for(int i=0;i&lt;=d;i++){            scanf(&quot;%d&quot;,&amp;x);            f.pb(x);        }        scanf(&quot;%d&quot;,&amp;d);        for(int i=0;i&lt;=d;i++){            scanf(&quot;%d&quot;,&amp;x);            g.pb(x);        }        vi ans = gcd(f,g);        int tmp = inv(ans[0]);        printf(&quot;Case %d: %d&quot;,++kcase,ans.size()-1);        for(int i=0;i&lt;ans.size();i++){}            printf(&quot; %d&quot;,ans[i]*tmp%n);        }        puts(&quot;&quot;);    }    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 模板 </tag>
            
            <tag> 杂类 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  HDU 3292 No more tricks, Mr Nanguo [佩尔方程+矩阵]【数论】</title>
      <link href="/2016/09/26/52673118/"/>
      <url>/2016/09/26/52673118/</url>
      
        <content type="html"><![CDATA[<h1 id="HDU-3292-No-more-tricks-Mr-Nanguo-佩尔方程-矩阵-【数论】"><a href="#HDU-3292-No-more-tricks-Mr-Nanguo-佩尔方程-矩阵-【数论】" class="headerlink" title="HDU 3292 No more tricks, Mr Nanguo [佩尔方程+矩阵]【数论】"></a>HDU 3292 No more tricks, Mr Nanguo [佩尔方程+矩阵]【数论】</h1><p>2016年09月26日 19:21:33  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：345</p><p>个人分类：  <a href="https://blog.csdn.net/qq_33184171/article/category/6117382" target="_blank" rel="noopener"> hdu </a> <a href="https://blog.csdn.net/qq_33184171/article/category/6362379" target="_blank" rel="noopener"><br>===== 各OJ ===== </a><br><a href="https://blog.csdn.net/qq_33184171/article/category/6362367" target="_blank" rel="noopener"> ===== 数论 ===== </a></p><hr><p> 博客爬取于<code>2019-04-18 17:19:22</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/52673118" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/52673118</a></p><p>题目链接： <a href="http://acm.split.hdu.edu.cn/showproblem.php?pid=3292" target="_blank" rel="noopener"> http://acm.split.hdu.edu.cn/showproblem.php?pid=3292</a></p><p>———————————————————–.<br>No more tricks, Mr Nanguo</p><p>Time Limit: 3000/1000 MS (Java/Others) Memory Limit: 65535/32768 K<br>(Java/Others)<br>Total Submission(s): 378 Accepted Submission(s): 250</p><p>Problem Description<br>Now Sailormoon girls want to tell you a ancient idiom story named “be there<br>just to make up the number”. The story can be described by the following<br>words.<br>In the period of the Warring States (475-221 BC), there was a state called Qi.<br>The king of Qi was so fond of the yu, a wind instrument, that he had a band of<br>many musicians play for him every afternoon. The number of musicians is just a<br>square number.Beacuse a square formation is very good-looking.Each row and<br>each column have X musicians.<br>The king was most satisfied with the band and the harmonies they performed.<br>Little did the king know that a member of the band, Nan Guo, was not even a<br>musician. In fact, Nan Guo knew nothing about the yu. But he somehow managed<br>to pass himself off as a yu player by sitting right at the back, pretending to<br>play the instrument. The king was none the wiser. But Nan Guo’s charade came<br>to an end when the king’s son succeeded him. The new king, unlike his father,<br>he decided to divide the musicians of band into some equal small parts. He<br>also wants the number of each part is square number. Of course, Nan Guo soon<br>realized his foolish would expose, and he found himself without a band to hide<br>in anymore.So he run away soon.<br>After he leave,the number of band is Satisfactory. Because the number of band<br>now would be divided into some equal parts,and the number of each part is also<br>a square number.Each row and each column all have Y musicians.</p><p>Input<br>There are multiple test cases. Each case contains a positive integer N ( 2 &lt;=<br>N &lt; 29). It means the band was divided into N equal parts. The folloing number<br>is also a positive integer K ( K &lt; 10^9).</p><p>Output<br>There may have many positive integers X,Y can meet such conditions.But you<br>should calculate the Kth smaller answer of X. The Kth smaller answer means<br>there are K – 1 answers are smaller than them. Beacuse the answer may be very<br>large.So print the value of X % 8191.If there is no answers can meet such<br>conditions,print “No answers can meet such conditions”.</p><p>Sample Input<br>2 999888<br>3 1000001<br>4 8373</p><p>Sample Output<br>7181<br>600<br>No answers can meet such conditions</p><p>Author<br>B.A.C</p><p>Source<br>2010 “HDU-Sailormoon” Programming Contest</p><p>—————————————-.<br><strong> 题目大意 </strong> ：<br>南郭先生的故事想必大家都知道<br>就是最开始有 <strong> X*X </strong> 人<br>后来南郭走了<br>变成了 <strong> N </strong> 个 <strong> Y*Y </strong><br>之后题目给你一个N 和K<br>让你求满足题意的第K大的X值是多少。。。</p><p><strong> 解题思路 </strong> ：<br>题目显然能够得到下面的方程<br>X<em>X=1+N</em>Y<em>Y<br>转化一下就是<br>X</em>X-N<em>Y</em>Y=1</p><p>这就是标准的佩尔方程了 不知道佩尔方程的话可以先去百度下.<br>首先N很小 所以可以先暴力的跑出特解 然后用迭代的方式求得第K大的解<br>X(n)=X(n-1)X(1)+N*Y(n-1)Y(1)<br>Y(n)=X(n-1)Y(1)+Y(n-1)X(1)</p><p>因为K很大 所以要用矩阵优化一下</p><p>矩阵略</p><p>附本题代码<br>———————————.</p><pre><code>#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;cstring&gt;using namespace std;#define INF 0x3f3f3f3f#define pb push_back#define abs(a) (a)&gt;0?(a):-(a)#define lalal puts(&quot;*******&quot;);typedef long long int LL ;/**********************************/const int MOD = 8191;const int M = 2;struct Matrix{    LL m[M][M];    void clearO()    {        for(int i=0; i&lt;M; i++) //初始化零矩阵            for(int j=0; j&lt;M; j++)                m[i][j]= 0;    }    void clearE()    {        for(int i=0; i&lt;M; i++) //初始化单位矩阵            for(int j=0; j&lt;M; j++)                m[i][j]= (i==j);    }    void display()    {        for(int i=0; i&lt;M; i++)        {            for(int j=0; j&lt;M; j++)                printf(&quot;%d &quot;,m[i][j]);            puts(&quot;&quot;);        }    }};Matrix operator * (Matrix a,Matrix b){    Matrix c;    c.clearO();    for(int k=0; k&lt;M; k++)        for(int i=0; i&lt;M; i++) //实现矩阵乘法        {            if(a.m[i][k] == 0)  continue;            for(int j=0; j&lt;M; j++)            {                if(b.m[k][j] ==  0)    continue;                c.m[i][j]=(c.m[i][j]+a.m[i][k]*b.m[k][j]+MOD)%MOD;            }        }    return c;}Matrix operator ^ (Matrix a,LL b){    Matrix c;    c.clearE();    while(b)    {        if(b&amp;1) c= c * a ;        b &gt;&gt;= 1;        a = a * a ;    }    return c;}int main(){    int n,k;    while(~scanf(&quot;%d%d&quot;,&amp;n,&amp;k))    {        if(4==n||9==n||16==n||25==n)        {            puts(&quot;No answers can meet such conditions&quot;);            continue;        }        LL x,y;        int tmp,tem;        for(int i=1;; i++)        {            tmp=n*i*i+1;            tem=sqrt(tmp);            if(tmp==tem*tem)            {                x=tem,y=i;                break;            }        }        Matrix a,b;        a.clearO(),b.clearO();        a.m[0][0] = x%MOD,a.m[0][1] = y%MOD;        b.m[0][0] = x%MOD,b.m[0][1] = y%MOD;        b.m[1][0] = n*y%MOD,b.m[1][1] = x%MOD;        b=b^(k-1);        a=a*b;        printf(&quot;%I64d\n&quot;,a.m[0][0]);        //printf(&quot;%I64d %I64d\n&quot;,x,y);    }    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hdu </tag>
            
            <tag> 数论 </tag>
            
            <tag> 各OJ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  POJ 1305 Fermat vs. Pythagoras [本源毕达哥拉斯不等式]【数论】</title>
      <link href="/2016/09/21/52613712/"/>
      <url>/2016/09/21/52613712/</url>
      
        <content type="html"><![CDATA[<h1 id="POJ-1305-Fermat-vs-Pythagoras-本源毕达哥拉斯不等式-【数论】"><a href="#POJ-1305-Fermat-vs-Pythagoras-本源毕达哥拉斯不等式-【数论】" class="headerlink" title="POJ 1305 Fermat vs. Pythagoras [本源毕达哥拉斯不等式]【数论】"></a>POJ 1305 Fermat vs. Pythagoras [本源毕达哥拉斯不等式]【数论】</h1><p>2016年09月21日 21:39:52  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：259</p><hr><p> 博客爬取于<code>2019-04-18 17:19:23</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/52613712" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/52613712</a></p><p>题目链接： <a href="http://poj.org/problem?id=1305" target="_blank" rel="noopener"> http://poj.org/problem?id=1305 </a><br>——————————-.<br>Fermat vs. Pythagoras<br>Time Limit: 2000MS Memory Limit: 10000K<br>Total Submissions: 1561 Accepted: 913<br>Description</p><p>Computer generated and assisted proofs and verification occupy a small niche<br>in the realm of Computer Science. The first proof of the four-color problem<br>was completed with the assistance of a computer program and current efforts in<br>verification have succeeded in verifying the translation of high-level code<br>down to the chip level.<br>This problem deals with computing quantities relating to part of Fermat’s Last<br>Theorem: that there are no integer solutions of a^n + b^n = c^n for n &gt; 2.<br>Given a positive integer N, you are to write a program that computes two<br>quantities regarding the solution of x^2 + y^2 = z^2, where x, y, and z are<br>constrained to be positive integers less than or equal to N. You are to<br>compute the number of triples (x,y,z) such that x &lt; y &lt; z, and they are<br>relatively prime, i.e., have no common divisor larger than 1. You are also to<br>compute the number of values 0 &lt; p &lt;= N such that p is not part of any triple<br>(not just relatively prime triples).<br>Input</p><p>The input consists of a sequence of positive integers, one per line. Each<br>integer in the input file will be less than or equal to 1,000,000. Input is<br>terminated by end-of-file<br>Output</p><p>For each integer N in the input file print two integers separated by a space.<br>The first integer is the number of relatively prime triples (such that each<br>component of the triple is &lt;=N). The second number is the number of positive<br>integers &lt;=N that are not part of any triple whose components are all &lt;=N.<br>There should be one output line for each input line.<br>Sample Input</p><p>10<br>25<br>100<br>Sample Output</p><p>1 4<br>4 9<br>16 27<br>—————————-.</p><p>题目大意 ：<br>就是问你在小于N中选取三个元素能构成多少个本源毕达哥拉斯不等式与其中不能形成毕达哥拉斯不等式的元素有多少个</p><p>解题思路：</p><p>毕达哥拉斯不等式<br>x^2 + y^2 = z^2 （其实就是勾股定理）</p><p>本源毕达哥拉斯不等式就是满足gcd（x，y，z）==1时的毕格拉斯不等式；</p><p>毕达哥拉斯不等式有下列特点<br>x=m^2-n^2;<br>y=2<em>m</em>n;<br>z=m^2+n^2;</p><p>其中m+n为奇数<br>在本源毕达哥拉斯不等式中满足gcd(m,n)==1;</p><p>本题数据量很小 所以只需要枚举一下m，n就行了</p><p>附本题代码<br>—————————-.</p><pre><code>#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;stdlib.h&gt;#include&lt;time.h&gt;#include&lt;iostream&gt;#include&lt;string.h&gt;#include&lt;math.h&gt;#include&lt;algorithm&gt;using namespace std;typedef long long int LL ;/**********************************/int sum ,num;int gcd(int a,int b){    if(!b)return a;    return gcd(b,a%b);}bool flag [1010101];void solve(int t){    sum=0,num=0;    for(int i=1;i&lt;=t;i++)flag[i]=true;    int temp=sqrt(t*1.0);    int x,y,z;    for(int i=1;i&lt;=temp;i++)    {        for(int j=i+1;j&lt;=temp;j++)        {            if(i*i+j*j&gt;t) break;            if(i%2!=j%2&amp;&amp;gcd(i,j)==1)            {              x=j*j-i*i;              y=2*i*j;              z=i*i+j*j;              //printf(&quot;%d %d %d\n&quot;,x,y,z);              sum++;              for(int k=1;k*z&lt;=t;k++)  flag[k*x]=flag[k*y]=flag[k*z]=false;            }        }    }    for(int i=1;i&lt;=t;i++)  if(flag[i])  num++;//,printf(&quot;%d &quot;,i);puts(&quot;&quot;);    printf(&quot;%d %d\n&quot;,sum,num);}int main(){    int n;    while(~scanf(&quot;%d&quot;,&amp;n))   solve(n);    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  POJ 1091 跳蚤 [容斥原理]【组合数学】</title>
      <link href="/2016/09/21/52612567/"/>
      <url>/2016/09/21/52612567/</url>
      
        <content type="html"><![CDATA[<h1 id="POJ-1091-跳蚤-容斥原理-【组合数学】"><a href="#POJ-1091-跳蚤-容斥原理-【组合数学】" class="headerlink" title="POJ 1091 跳蚤 [容斥原理]【组合数学】"></a>POJ 1091 跳蚤 [容斥原理]【组合数学】</h1><p>2016年09月21日 20:04:19  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：315</p><hr><p> 博客爬取于<code>2019-04-18 17:19:24</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/52612567" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/52612567</a></p><p>题目链接： <a href="http://poj.org/problem?id=1091" target="_blank" rel="noopener"> http://poj.org/problem?id=1091 </a><br>———————————.</p><pre><code>跳蚤Time Limit: 1000MS      Memory Limit: 10000KTotal Submissions: 9828     Accepted: 2996DescriptionZ城市居住着很多只跳蚤。在Z城市周六生活频道有一个娱乐节目。一只跳蚤将被请上一个高空钢丝的正中央。钢丝很长，可以看作是无限长。节目主持人会给该跳蚤发一张卡片。卡片上写有N+1个自然数。其中最后一个是M，而前N个数都不超过M，卡片上允许有相同的数字。跳蚤每次可以从卡片上任意选择一个自然数S，然后向左，或向右跳S个单位长度。而他最终的任务是跳到距离他左边一个单位长度的地方，并捡起位于那里的礼物。 比如当N=2，M=18时，持有卡片(10, 15, 18)的跳蚤，就可以完成任务：他可以先向左跳10个单位长度，然后再连向左跳3次，每次15个单位长度，最后再向右连跳3次，每次18个单位长度。而持有卡片(12, 15, 18)的跳蚤，则怎么也不可能跳到距他左边一个单位长度的地方。 当确定N和M后，显然一共有M^N张不同的卡片。现在的问题是，在这所有的卡片中，有多少张可以完成任务。 Input两个整数N和M(N &lt;= 15 , M &lt;= 100000000)。Output可以完成任务的卡片数。Sample Input2 4Sample Output12Hint这12张卡片分别是： (1, 1, 4), (1, 2, 4), (1, 3, 4), (1, 4, 4), (2, 1, 4), (2, 3, 4), (3, 1, 4), (3, 2, 4), (3, 3, 4), (3, 4, 4), (4, 1, 4), (4, 3, 4) </code></pre><p>————————————.<br>题目大意:略</p><p>解题思路:<br>很明显的题目需要求解这么一个方程的解a[1]<em>x1+a[2]</em>x2+a[3]<em>x3+…+a[n]</em>xn+a[n+1]*m=1 (0&lt;=a[i]&lt;=m)<br>显然 满足方程式的解需要只需要满足<br>gcd(a[1],a[2],a[3]….a[n+1])==1 就行了</p><p>然后求解的过程就容易多了<br>就只求解M^N-gcd！=1 的方案数就行了</p><p>之后只要把M质因子分解 容斥一下就行了</p><p>引用 <a href="http://www.tuicool.com/articles/iEbQba" target="_blank" rel="noopener"> 这里 </a></p><p><strong> 许多博客都举了这么一个例子 </strong> ： </p><p>例如:n=2,m=360<br>360=3^2<em>2^3</em>5 所有不满足条件的数列，最大公约数是360质因子的乘积，只要将这些组合去掉，就是要求的答案(不懂的慢慢揣摩)</p><p>那么就要先求出m的所有质因子，然后求出总的排列组合的个数，即题目中说的M^N，最后根据鸽巢原理求得最后答案。</p><p><strong> 公式为：ans=M^N-(有奇数个公因数的n元组)+(有偶数个公因数的n元组)。拿上面的例子来说就是 </strong></p><p>ans=m^n-( 有公因数2的n元组)- (有公因数3的n元组)- (有公因数5的n元组)+ (有公因数2，3的n元组) +(有公因数2，5的n元组)+<br>(有公因数3，5的n元组)- (有公因数2，3，5的n元组).</p><p>有公因数d的n元组，每个位置上有 (m/d)个选择（1 ~ m里面有m/d个d的倍数），根据乘法原理，可以得出有公因数d的n元组有 (m/d)^n 个.</p><p>附本题代码<br>————————.</p><pre><code>#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;stdlib.h&gt;#include&lt;time.h&gt;#include&lt;iostream&gt;#include&lt;string.h&gt;#include&lt;math.h&gt;#include&lt;algorithm&gt;using namespace std;typedef long long int LL ;/**********************************/const int M = 130007;LL qmod(LL a,LL b,LL c){    LL res = 1;    while(b)    {        if(b&amp;1) res=(res*a);        b&gt;&gt;=1;        a=(a*a);    }    return res;}LL num[M],s[M],total;void sum_factor(int m)//分解质因子，存在num里面{    total=0;    long long t=m;    for(int i=2;i*i&lt;=t;i++)    {        if(t%i==0)num[total++]=i;        while(t%i==0)t/=i;    }    if(t!=1)num[total++]=t;}/**容斥原理过程**/LL n,m,per;void dfs(LL a,LL b,LL c)//a在数组中的起始位置，b含的个数，c公共质因子的个数{    if(b==c)    {        LL t=m;        for(int i=0;i&lt;c;i++) t/=s[i];        per+=qmod(t,n,1);    }    else    {        for(int i=a;i&lt;total;i++)        {            s[b]=num[i];            dfs(i+1,b+1,c);        }    }}int main(){    while(~scanf(&quot;%I64d%I64d&quot;,&amp;n,&amp;m))    {        sum_factor(m);        LL ans = qmod(m,n,1);        for(int i=1;i&lt;=total;i++)        {            per=0;            dfs(0,0,i);            if(i&amp;1) ans-=per;            else    ans+=per;        }        printf(&quot;%I64d\n&quot;,ans);    }    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  POJ 2429 GCD&amp;LCM Inverse [pollard_rho]【数论】</title>
      <link href="/2016/09/21/52611426/"/>
      <url>/2016/09/21/52611426/</url>
      
        <content type="html"><![CDATA[<h1 id="POJ-2429-GCD-amp-LCM-Inverse-pollard-rho-【数论】"><a href="#POJ-2429-GCD-amp-LCM-Inverse-pollard-rho-【数论】" class="headerlink" title="POJ 2429 GCD&amp;LCM Inverse [pollard_rho]【数论】"></a>POJ 2429 GCD&amp;LCM Inverse [pollard_rho]【数论】</h1><p>2016年09月21日 18:29:01  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：205</p><hr><p> 博客爬取于<code>2019-04-18 17:19:26</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/52611426" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/52611426</a></p><p>题目链接: <a href="http://poj.org/problem?id=2429" target="_blank" rel="noopener"> http://poj.org/problem?id=2429 </a></p><p>—————————–.<br>GCD &amp; LCM Inverse<br>Time Limit: 2000MS Memory Limit: 65536K<br>Total Submissions: 13908 Accepted: 2572<br>Description</p><p>Given two positive integers a and b, we can easily calculate the greatest<br>common divisor (GCD) and the least common multiple (LCM) of a and b. But what<br>about the inverse? That is: given GCD and LCM, finding a and b.<br>Input</p><p>The input contains multiple test cases, each of which contains two positive<br>integers, the GCD and the LCM. You can assume that these two numbers are both<br>less than 2^63.<br>Output</p><p>For each test case, output a and b in ascending order. If there are multiple<br>solutions, output the pair with smallest a + b.<br>Sample Input</p><p>3 60<br>Sample Output</p><p>12 15</p><p>———————————————.<br>题目大意:<br>就是给你两个数的GCD和LCM值 让你求出和最小的这两个数</p><p>解题思路:<br>lcm=a/gcd<em>b;<br>lcm/gcd=a/gcd</em>b/gcd;</p><p>然后把lcm/gcd 这个结果质因子分解一下就行了<br>然后DFS求解和最小的值..</p><p>附本题代码<br>——————————–.</p><pre><code>/*******************Miller_Rabin素数测试&amp;&amp;Pollard_rho整数分解**************************/ #include &lt;cstdio&gt;#include &lt;cmath&gt;#include &lt;ctime&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#define Times 11#define MAX ((long long)1&lt;&lt;61) #define N 501#define C 201#define LL long longusing namespace std;int ct,cnt;LL mini,jl[N],factor[N],num[N];LL mina,minb,ans,n,m;LL gcd(LL a,LL b){    return b==0?a:gcd(b,a%b);}LL random(LL n){    return (LL)((double)rand()/RAND_MAX*n+0.5);}LL multi(LL m,LL n,LL k){    LL b=0;    while(n){        if(n&amp;1) b=(b+m)%k;        n&gt;&gt;=1;        m=(m&lt;&lt;1)%k;    }    return b;}LL quick_mod(LL m,LL n,LL k){    LL b=1;    m%=k;     while(n){        if(n&amp;1) b=multi(b,m,k);        n/=2;        m=multi(m,m,k);    }    return b;}bool Witness(LL a,LL n){    LL m=n-1;    int j=0;    while(!(m&amp;1)){        j++;        m&gt;&gt;=1;    }    LL x=quick_mod(a,m,n);    if(x==1||x==n-1) return false;    while(j--){        x=x*x%n;        if(x==n-1) return false;    }    return true;}bool Miller_Rabin(LL n){    if(n&lt;2) return false;    if(n==2) return true;    if(!(n&amp;1)) return false;    for(int i=1;i&lt;=Times;i++){        LL a=random(n-2)+1;        if(Witness(a,n)) return false;    }    return true;}LL Pollard_rho(LL n,int c){    LL x,y,d,i=1,k=2;    x=random(n-1)+1;    y=x;    while(1){        i++;        x=(multi(x,x,n)+c)%n;        d=gcd(y-x,n);        if(1&lt;d&amp;&amp;d&lt;n) return d;        if(y==x) return n;        if(i==k){            y=x;            k&lt;&lt;=1;        }    }}void find(LL n,int k){    if(n==1) return ;    if(Miller_Rabin(n)){        jl[++ct]=n;        return ;    }    LL p=n;    while(p&gt;=n) p=Pollard_rho(p,k--);    find(p,k);    find(n/p,k);}void dfs(LL c,LL value){    LL s=1,a,b;    if(c==cnt+1){        a=value;        b=ans/a;        if(gcd(a,b)==1){            a*=n;            b*=n;            if(a+b&lt;mini){                mini=a+b;                mina=a; minb=b;            }        }        return ;    }    for(LL i=0;i&lt;=num[c];i++){        if(s*value&gt;mini) return ;        dfs(c+1,s*value);        s*=factor[c];    }}int main(){//    freopen(&quot;data.in&quot;,&quot;r&quot;,stdin);//    freopen(&quot;data.out&quot;,&quot;w&quot;,stdout);//    srand(time(NULL));      while(scanf(&quot;%lld%lld&quot;,&amp;n,&amp;m)!=EOF){        if(n==m) {printf(&quot;%lld %lld\n&quot;,n,m); continue;}        mini=MAX;        ct=cnt=0;        ans=m/n;         find(ans,C);        sort(jl+1,jl+ct+1);        memset(factor,0,sizeof(factor));        memset(num,0,sizeof(num));        num[0]=1;        factor[0]=jl[1];        for(int i=2;i&lt;=ct;i++){            if(jl[i]!=jl[i-1]) factor[++cnt]=jl[i];            num[cnt]++;        }        dfs(0,1);        if(mina&gt;minb) swap(mina,minb);        printf(&quot;%lld %lld\n&quot;,mina,minb);    }    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  大素数统计1e11以内 【数论】</title>
      <link href="/2016/09/20/52598186/"/>
      <url>/2016/09/20/52598186/</url>
      
        <content type="html"><![CDATA[<h1 id="大素数统计1e11以内-【数论】"><a href="#大素数统计1e11以内-【数论】" class="headerlink" title="大素数统计1e11以内 【数论】"></a>大素数统计1e11以内 【数论】</h1><p>2016年09月20日 17:32:57  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：581<br>标签：  <a href="https://so.csdn.net/so/search/s.do?q=算法&amp;t=blog" target="_blank" rel="noopener"> 算法 </a></p><p>个人分类：  <a href="https://blog.csdn.net/qq_33184171/article/category/6362367" target="_blank" rel="noopener"> ===== 数论 =====</a> <a href="https://blog.csdn.net/qq_33184171/article/category/6354517" target="_blank" rel="noopener"> ===== 模板 =====</a></p><hr><p> 博客爬取于<code>2019-04-18 17:19:27</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/52598186" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/52598186</a></p><p>算法原理： <a href="https://en.wikipedia.org/wiki/Prime-counting_function" target="_blank" rel="noopener"> https://en.wikipedia.org/wiki/Prime-counting_function</a></p><h2 id="素数统计"><a href="#素数统计" class="headerlink" title="素数统计"></a>素数统计</h2><p><a href="http://blog.csdn.net/snow_me/article/details/52588819" target="_blank" rel="noopener"> 这是一篇对素数问题描述非常详细的一篇博客了</a><br><strong> 代码一 </strong> :<br>复杂度大概O（n^(3/4)）</p><pre><code>#include &lt;bits/stdc++.h&gt;  #define ll long long  using namespace std;  ll f[340000],g[340000],n;  void init(){      ll i,j,m;      for(m=1;m*m&lt;=n;++m)f[m]=n/m-1;      for(i=1;i&lt;=m;++i)g[i]=i-1;      for(i=2;i&lt;=m;++i){          if(g[i]==g[i-1])continue;          for(j=1;j&lt;=min(m-1,n/i/i);++j){              if(i*j&lt;m)f[j]-=f[i*j]-g[i-1];              else f[j]-=g[n/i/j]-g[i-1];          }          for(j=m;j&gt;=i*i;--j)g[j]-=g[j/i]-g[i-1];      }  }  int main(){      while(scanf(&quot;%I64d&quot;,&amp;n)!=EOF){          init();          cout&lt;&lt;f[1]&lt;&lt;endl;      }      return 0;  }  </code></pre><p>代码二:<br>复杂度大概O（n^(2/3)）</p><pre><code>#include&lt;cstdio&gt;  #include&lt;cmath&gt;  using namespace std;  #define LL long long  const int N = 5e6 + 2;  bool np[N];  int prime[N], pi[N];  int getprime()  {      int cnt = 0;      np[0] = np[1] = true;      pi[0] = pi[1] = 0;      for(int i = 2; i &lt; N; ++i)      {          if(!np[i]) prime[++cnt] = i;          pi[i] = cnt;          for(int j = 1; j &lt;= cnt &amp;&amp; i * prime[j] &lt; N; ++j)          {              np[i * prime[j]] = true;              if(i % prime[j] == 0)   break;          }      }      return cnt;  }  const int M = 7;  const int PM = 2 * 3 * 5 * 7 * 11 * 13 * 17;  int phi[PM + 1][M + 1], sz[M + 1];  void init()  {      getprime();      sz[0] = 1;      for(int i = 0; i &lt;= PM; ++i)  phi[i][0] = i;      for(int i = 1; i &lt;= M; ++i)      {          sz[i] = prime[i] * sz[i - 1];          for(int j = 1; j &lt;= PM; ++j) phi[j][i] = phi[j][i - 1] - phi[j / prime[i]][i - 1];      }  }  int sqrt2(LL x)  {      LL r = (LL)sqrt(x - 0.1);      while(r * r &lt;= x)   ++r;      return int(r - 1);  }  int sqrt3(LL x)  {      LL r = (LL)cbrt(x - 0.1);      while(r * r * r &lt;= x)   ++r;      return int(r - 1);  }  LL getphi(LL x, int s)  {      if(s == 0)  return x;      if(s &lt;= M)  return phi[x % sz[s]][s] + (x / sz[s]) * phi[sz[s]][s];      if(x &lt;= prime[s]*prime[s])   return pi[x] - s + 1;      if(x &lt;= prime[s]*prime[s]*prime[s] &amp;&amp; x &lt; N)      {          int s2x = pi[sqrt2(x)];          LL ans = pi[x] - (s2x + s - 2) * (s2x - s + 1) / 2;          for(int i = s + 1; i &lt;= s2x; ++i) ans += pi[x / prime[i]];          return ans;      }      return getphi(x, s - 1) - getphi(x / prime[s], s - 1);  }  LL getpi(LL x)  {      if(x &lt; N)   return pi[x];      LL ans = getphi(x, pi[sqrt3(x)]) + pi[sqrt3(x)] - 1;      for(int i = pi[sqrt3(x)] + 1, ed = pi[sqrt2(x)]; i &lt;= ed; ++i) ans -= getpi(x / prime[i]) - i + 1;      return ans;  }  LL lehmer_pi(LL x)  {      if(x &lt; N)   return pi[x];      int a = (int)lehmer_pi(sqrt2(sqrt2(x)));      int b = (int)lehmer_pi(sqrt2(x));      int c = (int)lehmer_pi(sqrt3(x));      LL sum = getphi(x, a) +(LL)(b + a - 2) * (b - a + 1) / 2;      for (int i = a + 1; i &lt;= b; i++)      {          LL w = x / prime[i];          sum -= lehmer_pi(w);          if (i &gt; c) continue;          LL lim = lehmer_pi(sqrt2(w));          for (int j = i; j &lt;= lim; j++) sum -= lehmer_pi(w / prime[j]) - (j - 1);      }      return sum;  }  int main()  {      init();      LL n;      while(~scanf(&quot;%lld&quot;,&amp;n))      {          printf(&quot;%lld\n&quot;,lehmer_pi(n));      }      return 0;  }  </code></pre><h2 id="4因子个数统计"><a href="#4因子个数统计" class="headerlink" title="4因子个数统计"></a>4因子个数统计</h2><p>代码一:<br>复杂度大概O（n^(3/4)）</p><pre><code>#include &lt;bits/stdc++.h&gt;#define ll long longusing namespace std;ll f[340000],g[340000],n,k;//f[i] means pi(n/i),g[i] means pi(i)ll dp(ll n){    ll i,j,m,res=0;    for(m=1;m*m&lt;=n;++m)f[m]=n/m-1;    for(i=1;i&lt;=m;++i)g[i]=i-1;    for(i=2;i&lt;=m;++i){        if(g[i]==g[i-1])continue;        for(j=1;j&lt;=min(m-1,n/i/i);++j){            if(i*j&lt;m)f[j]-=f[i*j]-g[i-1];            else f[j]-=g[n/i/j]-g[i-1];        }        for(j=m;j&gt;=i*i;--j)g[j]-=g[j/i]-g[i-1];    }    for(i=2;i&lt;m;++i){        if(g[i]==g[i-1])continue;        res+=f[i]-g[i];    }return res;}int main(){    scanf(&quot;%I64d&quot;,&amp;n);k=pow(n,1.0/3)+1e-9;    printf(&quot;%I64d\n&quot;,dp(n)+g[k]);}</code></pre><p>代码二:<br>复杂度大概O（n^(2/3)）</p><pre><code>#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;ctime&gt;#include &lt;cmath&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;string&gt;#include &lt;bitset&gt;using namespace std;typedef long long LL;typedef pair&lt;int,int&gt; PII;typedef pair&lt;LL,LL&gt; PLL;#define clr(a,b) memset(a,b,sizeof(a))#define MP make_pair#define PB push_back#define lrt rt&lt;&lt;1#define rrt rt&lt;&lt;1|1#define lson l,m,lrtusing namespace std;/*------------------------- template ------------------------------*/const int N = 5e6+2;bool np[N];int p[N],pi[N];int getprime(){    int cnt=0;    np[0]=np[1]=true;    pi[0]=pi[1]=0;    for(int i = 2; i &lt; N; ++i){        if(!np[i]) p[++cnt] = i;        for(int j = 1;j &lt;= cnt &amp;&amp; i * p[j] &lt; N; ++j) {            np[i * p[j]] = true;        }        pi[i]=cnt;    }    return cnt;}const int M = 7;const int PM = 2*3*5*7*11*13*17;int phi[PM+1][M+1],sz[M+1];void init(){    getprime();    sz[0]=1;    for(int i=0;i&lt;=PM;++i)  phi[i][0]=i;    for(int i=1;i&lt;=M;++i){        sz[i]=p[i]*sz[i-1];        for(int j=1;j&lt;=PM;++j){            phi[j][i]=phi[j][i-1]-phi[j/p[i]][i-1];        }    }}int sqrt2(LL x){    LL r = (LL)sqrt(x-0.1);    while(r*r&lt;=x)   ++r;    return int(r-1);}int sqrt3(LL x){    LL r = (LL)cbrt(x-0.1);    while(r*r*r&lt;=x)   ++r;    return int(r-1);}LL getphi(LL x,int s){    if(s == 0)  return x;    if(s &lt;= M)  return phi[x%sz[s]][s]+(x/sz[s])*phi[sz[s]][s];    if(x &lt;= p[s]*p[s])   return pi[x]-s+1;    if(x &lt;= p[s]*p[s]*p[s] &amp;&amp; x&lt; N){        int s2x = pi[sqrt2(x)];        LL ans = pi[x]-(s2x+s-2)*(s2x-s+1)/2;        for(int i=s+1;i&lt;=s2x;++i){            ans += pi[x/p[i]];        }        return ans;    }    return getphi(x,s-1)-getphi(x/p[s],s-1);}LL getpi(LL x){    if(x &lt; N)   return pi[x];    LL ans = getphi(x,pi[sqrt3(x)])+pi[sqrt3(x)]-1;    for(int i=pi[sqrt3(x)]+1,ed=pi[sqrt2(x)];i&lt;=ed;++i){        ans -= getpi(x/p[i])-i+1;    }    return ans;}LL lehmer_pi(LL x){    if(x &lt; N)   return pi[x];    int a = (int)lehmer_pi(sqrt2(sqrt2(x)));    int b = (int)lehmer_pi(sqrt2(x));    int c = (int)lehmer_pi(sqrt3(x));    LL sum = getphi(x, a) + LL(b + a - 2) * (b - a + 1) / 2;    for (int i = a + 1; i &lt;= b; i++) {        LL w = x / p[i];        sum -= lehmer_pi(w);        if (i &gt; c) continue;        LL lim = lehmer_pi(sqrt2(w));        for (int j = i; j &lt;= lim; j++) {            sum -= lehmer_pi(w / p[j]) - (j - 1);        }    }    return sum;}//照素数统计只多了这么个部分.. LL getans(LL x){ // x &lt; 1e11    LL ans = pi[sqrt3(x)];    for(int i=1,ed=pi[sqrt2(x-1)];i&lt;=ed;++i){        ans += lehmer_pi(x/p[i])-i;    }    return ans;}int main(){    init();    LL n;    while(cin&gt;&gt;n){        cout&lt;&lt;getans(n)&lt;&lt;endl;    }    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数论 </tag>
            
            <tag> 模板 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  HDU 5895&amp;&amp;2016 ACM/ICPC Asia Regional Shenyang Online1004 Mathematician QSC[矩阵加速+欧拉降幂]【数论】</title>
      <link href="/2016/09/19/52588817/"/>
      <url>/2016/09/19/52588817/</url>
      
        <content type="html"><![CDATA[<h1 id="HDU-5895-amp-amp-2016-ACM-ICPC-Asia-Regional-Shenyang-Online1004-Mathematician-QSC"><a href="#HDU-5895-amp-amp-2016-ACM-ICPC-Asia-Regional-Shenyang-Online1004-Mathematician-QSC" class="headerlink" title="HDU 5895&amp;&amp;2016 ACM/ICPC Asia Regional Shenyang Online1004 Mathematician QSC"></a>HDU 5895&amp;&amp;2016 ACM/ICPC Asia Regional Shenyang Online1004 Mathematician QSC</h1><p>[矩阵加速+欧拉降幂]【数论】</p><p>2016年09月19日 20:02:35  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：423</p><hr><p> 博客爬取于<code>2019-04-18 17:19:29</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/52588817" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/52588817</a></p><p>题目链接： <a href="http://acm.hdu.edu.cn/showproblem.php?pid=5895" target="_blank" rel="noopener"> http://acm.hdu.edu.cn/showproblem.php?pid=5895</a><br>————————.<br>Mathematician QSC</p><p>Time Limit: 2000/1000 MS (Java/Others) Memory Limit: 131072/131072 K<br>(Java/Others)<br>Total Submission(s): 222 Accepted Submission(s): 109</p><p>Problem Description<br>QSC dream of becoming a mathematician, he believes that everything in this<br>world has a mathematical law.</p><p>Through unremitting efforts, one day he finally found the QSC sequence, it is<br>a very magical sequence, can be calculated by a series of calculations to<br>predict the results of a course of a semester of a student.</p><p>This sequence is such like that, first of<br>all,f(0)=0,f(1)=1,f(n)=f(n−2)+2∗f(n−1)(n≥2)Then the definition of the QSC<br>sequence is g(n)=∑ni=0f(i)^2. If we know the birthday of the student is n, the<br>year at the beginning of the semester is y, the course number x and the course<br>total score s, then the forecast mark is x^g(n∗y)%(s+1).<br>QSC sequence published caused a sensation, after a number of students to find<br>out the results of the prediction is very accurate, the shortcoming is the<br>complex calculation. As clever as you are, can you write a program to predict<br>the mark?</p><p>Input<br>First line is an integer T(1≤T≤1000).</p><p>The next T lines were given n, y, x, s, respectively.</p><p>n、x is 8 bits decimal integer, for example, 00001234.</p><p>y is 4 bits decimal integer, for example, 1234.<br>n、x、y are not negetive.</p><p>1≤s≤100000000</p><p>Output<br>For each test case the output is only one integer number ans in a line.</p><p>Sample Input<br>2<br>20160830 2016 12345678 666<br>20101010 2014 03030303 333</p><p>Sample Output<br>1<br>317</p><p>Source<br>2016 ACM/ICPC Asia Regional Shenyang Online</p><p>————————.</p><p>题目大意：<br>就是给你四个数n,y,x,s,<br>让你求x^g(n∗y)%(s+1).<br>其中g(n)=∑(i-&gt;n)f(i)^2;<br>f(0)=0,f(1)=1,f(n)=f(n−2)+2∗f(n−1)(n≥2)</p><p>解题思路：<br>对于x的指数g(n) 是一个很大的数 所以需要想办法把它改成我们能计算的 就是 <strong> 欧拉降幂 </strong><br><img src="https://img-blog.csdn.net/20160507152606333?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt><br>然后只要求解g(n)就行了<br>很容易的想到g(n)=f(n)*f(n+1)/2 其中f(n)只用一个矩阵加速就能很快地求解<br>但是随后发现这样并不行 因为f(n)已经是对Phi(s+1)取模之后的数了 在/2之后之就会出错 然后想到求逆元的办法解决<br>但是随后发现虽然2是一个质数但是并不能满足gcd(2,s+1)==1 因为s+1%2可能等于0 于是这个思路就GG了。。。</p><p>最后还是看了ICPCCamp的题解 才知道解法<br>最终还是一个矩阵快速幂<br>（f[n]^2,f[n+1]^2,f[n]*f[n+1],g[n]）<br>↑这是左矩阵<br>[0,1,0,0]<br>[1,4,2,1]<br>[0,4,1,0]<br>[0,0,0,1] ←这是右矩阵</p><p>是这么解释的<br><img src="https://img-blog.csdn.net/20160919195907527" alt="这里写图片描述"><br>相信你已经看懂了</p><p>/ <strong> _ </strong> <strong><strong><strong><em>**</em></strong></strong></strong> <strong> _ </strong> /<br>就是思维太局限了 首先欧拉降幂不知道<br>再后来矩阵不会构造 导致这场的GG。。<br>/ <strong> _ </strong> <strong><strong><strong><em>**</em></strong></strong></strong> <strong> _ </strong> /</p><p>附本题代码<br>————————————–.</p><p>​    </p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;const int maxn = 505;const double  Pi =  acos(-1);#define pb push_back#define lalal puts(&quot;****&quot;);const int M = 4;int MOD ;struct Matrix{    LL m[M][M];    void clearO()    {        for(int i=0; i&lt;M; i++) //初始化矩阵            for(int j=0; j&lt;M; j++)                m[i][j]= 0;    }    void clearE()    {        for(int i=0; i&lt;M; i++) //初始化矩阵            for(int j=0; j&lt;M; j++)                m[i][j]= (i==j);    }    void display()    {        for(int i=0; i&lt;M; i++)            {                for(int j=0; j&lt;M; j++)                printf(&quot;%d &quot;,m[i][j]);                puts(&quot;&quot;);            }    }};Matrix operator * (Matrix a,Matrix b){    Matrix c;    c.clearO();    for(int k=0; k&lt;M; k++)        for(int i=0; i&lt;M; i++) //实现矩阵乘法        {            if(a.m[i][k] &lt;= 0)  continue;            for(int j=0; j&lt;M; j++)            {                if(b.m[k][j] &lt;= 0)    continue;                c.m[i][j]=(c.m[i][j]+a.m[i][k]*b.m[k][j]+MOD)%MOD;            }        }    return c;}Matrix operator ^ (Matrix a,LL b){    Matrix c;    c.clearE();    while(b)    {        if(b&amp;1) c= c * a ;        b &gt;&gt;= 1;        a = a * a ;    }    return c;}int Is_or[101001];int prime[13000],kpri;void Prime(){    int n=100001;    kpri=0;    memset(Is_or,1,sizeof(Is_or));    Is_or[0]=Is_or[1]=0;    for(int i=2; i&lt;n; i++)    {        if(Is_or[i])        {            prime[kpri++]=i;            for(int j=i+i; j&lt;n; j+=i)            {                Is_or[j]=0;            }        }    }    //prime[kpri]=10007;    //printf(&quot;%d\n&quot;,kpri);    return ;}LL Phi(LL n){    LL rea=n;    for(int i=0; prime[i]*prime[i]&lt;=n; i++)    {        if(n%prime[i]==0)        {            rea=rea-rea/prime[i];            while(n%prime[i]==0)                n/=prime[i];        }    }    if(n&gt;1)  rea=rea-rea/n;    return rea;}LL qmod(LL a,LL b){    LL res= 1;    while(b)    {        if(b&amp;1) res=(res*a)%MOD;        b&gt;&gt;=1;        a=(a*a)%MOD;    }    return res;}int main(){    Prime();    int _;    while(~scanf(&quot;%d&quot;,&amp;_))    {        while(_--)        {            LL n,y,x,s;            scanf(&quot;%I64d%I64d%I64d%I64d&quot;,&amp;n,&amp;y,&amp;x,&amp;s);            MOD = Phi(s+1);            Matrix a,b;            a.clearO(),b.clearO();            a.m[0][1]=1;            b.m[0][1]=1;            b.m[1][0]=1,b.m[1][1]=4,b.m[1][2]=2,b.m[1][3]=1;            b.m[2][1]=4,b.m[2][2]=1;            b.m[3][3]=1;            b=b^(n*y);            a=a*b;            LL zhi = a.m[0][3]%MOD+MOD;            MOD=s+1;            printf(&quot;%I64d\n&quot;,qmod(x%MOD,zhi));        }    }    return 0;}</code></pre><p>​    </p>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  HDU 5898&amp;&amp;2016 ACM/ICPC Asia Regional Shenyang Online/ odd-even number[数位DP]【动态规划】</title>
      <link href="/2016/09/18/52578407/"/>
      <url>/2016/09/18/52578407/</url>
      
        <content type="html"><![CDATA[<h1 id="HDU-5898-amp-amp-2016-ACM-ICPC-Asia-Regional-Shenyang-Online-odd-even-number"><a href="#HDU-5898-amp-amp-2016-ACM-ICPC-Asia-Regional-Shenyang-Online-odd-even-number" class="headerlink" title="HDU 5898&amp;&amp;2016 ACM/ICPC Asia Regional Shenyang Online/ odd-even number"></a>HDU 5898&amp;&amp;2016 ACM/ICPC Asia Regional Shenyang Online/ odd-even number</h1><p>[数位DP]【动态规划】</p><p>2016年09月18日 22:01:52  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：293</p><hr><p> 博客爬取于<code>2019-04-18 17:19:30</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/52578407" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/52578407</a></p><p>题目链接： <a href="http://acm.hdu.edu.cn/showproblem.php?pid=5898" target="_blank" rel="noopener"> http://acm.hdu.edu.cn/showproblem.php?pid=5898</a></p><p>———————————————————–.<br>odd-even number</p><p>Time Limit: 2000/1000 MS (Java/Others) Memory Limit: 65536/65536 K<br>(Java/Others)<br>Total Submission(s): 125 Accepted Submission(s): 66</p><p>Problem Description<br>For a number,if the length of continuous odd digits is even and the length of<br>continuous even digits is odd,we call it odd-even number.Now we want to know<br>the amount of odd-even number between L,R(1&lt;=L&lt;=R&lt;= 9*10^18).</p><p>Input<br>First line a t,then t cases.every line contains two integers L and R.</p><p>Output<br>Print the output for each case on one line in the format as shown below.</p><p>Sample Input<br>2<br>1 100<br>110 220</p><p>Sample Output<br>Case #1: 29<br>Case #2: 36</p><p>Source<br>2016 ACM/ICPC Asia Regional Shenyang Online</p><p>————————————–.<br>题目大意：<br>就是统计区间内满足连续奇数个数为偶数且连续偶数为奇数的数的个数</p><p>解题思路 ：<br>很明显一道数位DP<br>鄙人用的是记忆化搜索</p><p>开了4维数组<br>LL dp[30][3][30][3];<br>分别是位数 奇偶 正在判断的连续奇偶的长度 满不满足的状态</p><p>LL dfs(int pos,int pre,int x,int limit,int status,int lengh)<br>分别是位数/上一位的数字/上一位数字的奇偶性/数位的限制/满不满足的状态/正在判断的连续奇偶的长度</p><p>然后转移的时候注意的就是前导0的情况不要当成偶的数字给统计了 否则数会多</p><p>数位DP无非就三点<br>数组怎么开<br>记忆化搜索的参数<br>转移的过程<br>↑上面3点都解决了 相信数位DP的题目就解决了。</p><p>平时为了验证数位DP的正确性 在小数据的时候把记忆化注释掉了 交题的时候没改回来 就这样TLE了一发。。。GG<br>但也终于在比赛中AC了一道数位DP 也算是小进步</p><p>附本题代码<br>——————————–.</p><p>​    </p><pre><code>#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;string&gt;#include &lt;math.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;using namespace std;typedef long long int LL ;#define INF 0x3f3f3f3f#define pb push_back#define abs(a) (a)&gt;0?(a):-(a)#define lalal puts(&quot;*******&quot;);/*************************************/int num[30],len;LL dp[30][3][30][3];//weishu jiou changdu zhuangtaiLL dfs(int pos,int pre,int x,int limit,int status,int lengh){    if(pos&lt;0)  return status&amp;&amp;(lengh+x)%2==1;    if(dp[pos][x][lengh][status]!=-1&amp;&amp;!limit)        return dp[pos][x][lengh][status];    int endi=9;    if(limit) endi = num[pos];    LL res = 0;    for(int i=0; i&lt;=endi; i++)    {        if(pre==0&amp;&amp;i==0)//qiandao00        {            res+=dfs(pos-1,0,0,0,1,0);        }        else        {            if(pre==0)            {                res+=dfs(pos-1,1,i%2,limit&amp;&amp;(i==endi),1,1);            }            else            {                res+=dfs(pos-1,1,i%2,limit&amp;&amp;(i==endi),(i%2==x)?status:((lengh+x)%2==1)&amp;&amp;status,(i%2==x)?(lengh+1):(1));            }        }    }    if(!limit) dp[pos][x][lengh][status] =  res;    return  res;}LL solve(LL n){    if(n&lt;=0) return 0;    len = 0;    while(n)    {        num[len++]=n%10;        n/=10;    }    return dfs(len-1,0,0,1,1,0);}int main(){    memset(dp,-1,sizeof(dp));    int _,p;    scanf(&quot;%d&quot;,&amp;_);    p=0;    while(_--)    {        LL l,r;        scanf(&quot;%I64d%I64d&quot;,&amp;l,&amp;r);        printf(&quot;Case #%d: %I64d\n&quot;,++p,solve(r)-solve(l-1));    }    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  POJ 2142 The Balance [不定方程和最小的正整数解]【数论】</title>
      <link href="/2016/09/16/52556618/"/>
      <url>/2016/09/16/52556618/</url>
      
        <content type="html"><![CDATA[<h1 id="POJ-2142-The-Balance-不定方程和最小的正整数解-【数论】"><a href="#POJ-2142-The-Balance-不定方程和最小的正整数解-【数论】" class="headerlink" title="POJ 2142 The Balance [不定方程和最小的正整数解]【数论】"></a>POJ 2142 The Balance [不定方程和最小的正整数解]【数论】</h1><p>2016年09月16日 17:15:30  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：1252</p><hr><p> 博客爬取于<code>2019-04-18 17:19:31</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/52556618" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/52556618</a></p><p>题目链接： <a href="http://poj.org/problem?id=2142" target="_blank" rel="noopener"> http://poj.org/problem?id=2142 </a></p><p>——————————————–.</p><p>The Balance<br>Time Limit: 5000MS Memory Limit: 65536K<br>Total Submissions: 5998 Accepted: 2610<br>Description</p><p>Ms. Iyo Kiffa-Australis has a balance and only two kinds of weights to measure<br>a dose of medicine. For example, to measure 200mg of aspirin using 300mg<br>weights and 700mg weights, she can put one 700mg weight on the side of the<br>medicine and three 300mg weights on the opposite side (Figure 1). Although she<br>could put four 300mg weights on the medicine side and two 700mg weights on the<br>other (Figure 2), she would not choose this solution because it is less<br>convenient to use more weights.<br>You are asked to help her by calculating how many weights are required.<br><img src="http://poj.org/images/2142_1.jpg" alt="这里写图片描述"></p><p>Input</p><p>The input is a sequence of datasets. A dataset is a line containing three<br>positive integers a, b, and d separated by a space. The following relations<br>hold: a != b, a &lt;= 10000, b &lt;= 10000, and d &lt;= 50000. You may assume that it<br>is possible to measure d mg using a combination of a mg and b mg weights. In<br>other words, you need not consider “no solution” cases.<br>The end of the input is indicated by a line containing three zeros separated<br>by a space. It is not a dataset.<br>Output</p><p>The output should be composed of lines, each corresponding to an input dataset<br>(a, b, d). An output line should contain two nonnegative integers x and y<br>separated by a space. They should satisfy the following three conditions.<br>You can measure dmg using x many amg weights and y many bmg weights.<br>The total number of weights (x + y) is the smallest among those pairs of<br>nonnegative integers satisfying the previous condition.<br>The total mass of weights (ax + by) is the smallest among those pairs of<br>nonnegative integers satisfying the previous two conditions.</p><p>No extra characters (e.g. extra spaces) should appear in the output.<br>Sample Input</p><p>700 300 200<br>500 200 300<br>500 200 500<br>275 110 330<br>275 110 385<br>648 375 4002<br>3 1 10000<br>0 0 0<br>Sample Output</p><p>1 3<br>1 1<br>1 0<br>0 3<br>1 1<br>49 74<br>3333 1<br>Source</p><p>————————–.<br>题目大意 :<br>就是有一个天平 现在你要称N质量的物体<br>你只有a,b两种质量的砝码若干<br>问你最少需要每种砝码多少个才能称出N质量的物体<br>(要求在个数相同的时候选取砝码质量和最少的组合)</p><p>解题思路:<br>这道题目其实很简单 打眼一瞅就知道是一个扩展欧几里得</p><p>但是对于怎么输出最小的解得组合 这点就不太容易了</p><p>其实呢也不难 稍加分析就能得到结果了<br>首先呢<br>运用扩展欧几里得能够求出x,y的任意一组解<br>这样的话 假如求x或y的最小正整数解释非常容易的<br>只要x=(x%a+a)%a y=(x%b+b)%b这样就行了<br>然后想 要求出|x|+|y|的最小值怎么办呢<br>其实无非是两种<br>一种是在 <strong> x </strong> 为最小正整数解的时候<br>另一种是在 <strong> y </strong> 为最小正整数解的时候<br>证明略(取数是稍微想一想就知道了)</p><p>知道这个就好了</p><p>最后把两种的结果一比较 就能得出符合题意的解了</p><p>附本题代码<br>——————.</p><pre><code>#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;string&gt;#include &lt;math.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;using namespace std;typedef long long int LL ;#define INF 0x3f3f3f3f#define pb push_back#define abs(a) (a)&gt;0?(a):-(a)#define lalal puts(&quot;*******&quot;);/*************************************/LL exgcd(LL a,LL b,LL &amp;x,LL &amp;y){    if(!b)    {        x=1,y=0;        return a;    }    else    {        LL r = exgcd(b,a%b,x,y);        LL t = x;        x = y;        y = t-(a/b)*y;        return r;    }}int main(){    int a,b,d;    while(~scanf(&quot;%d%d%d&quot;,&amp;a,&amp;b,&amp;d)&amp;&amp;(a||b||d))    {        LL x,y,vx,vy;        LL r = exgcd(a,b,x,y);  //本题让求最小解        a/=r,b/=r,d/=r;        exgcd(a,b,x,y);        /**********①令y是最小正整数解**********/        vy = y*d;        vy = (vy % a + a) % a;        vx = (d-b*vy) / a;        vx = abs(vx);        /**********②令x是最小正整数解**********/        x *= d;        x = (x % b + b) % b;        y = (d-a*x) / b;         //同理        y = abs(y);        /**********③使得和最小**********/        if(x+y&lt;vx+vy)    vx=x,vy=y;        printf(&quot;%I64d %I64d\n&quot;,abs(vx),abs(vy));    }    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  POJ 2689 Prime Distance [筛法选取素数]【数论】</title>
      <link href="/2016/09/16/52555267/"/>
      <url>/2016/09/16/52555267/</url>
      
        <content type="html"><![CDATA[<h1 id="POJ-2689-Prime-Distance-筛法选取素数-【数论】"><a href="#POJ-2689-Prime-Distance-筛法选取素数-【数论】" class="headerlink" title="POJ 2689 Prime Distance [筛法选取素数]【数论】"></a>POJ 2689 Prime Distance [筛法选取素数]【数论】</h1><p>2016年09月16日 14:01:15  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：537</p><hr><p> 博客爬取于<code>2019-04-18 17:19:32</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/52555267" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/52555267</a></p><p>题目链接： <a href="http://poj.org/problem?id=2689" target="_blank" rel="noopener"> http://poj.org/problem?id=2689 </a><br>————————-.<br>Prime Distance<br>Time Limit: 1000MS Memory Limit: 65536K<br>Total Submissions: 16728 Accepted: 4450<br>Description</p><p>The branch of mathematics called number theory is about properties of numbers.<br>One of the areas that has captured the interest of number theoreticians for<br>thousands of years is the question of primality. A prime number is a number<br>that is has no proper factors (it is only evenly divisible by 1 and itself).<br>The first prime numbers are 2,3,5,7 but they quickly become less frequent. One<br>of the interesting questions is how dense they are in various ranges. Adjacent<br>primes are two numbers that are both primes, but there are no other prime<br>numbers between the adjacent primes. For example, 2,3 are the only adjacent<br>primes that are also adjacent numbers.<br>Your program is given 2 numbers: L and U (1&lt;=L&lt; U&lt;=2,147,483,647), and you are<br>to find the two adjacent primes C1 and C2 (L&lt;=C1&lt; C2&lt;=U) that are closest<br>(i.e. C2-C1 is the minimum). If there are other pairs that are the same<br>distance apart, use the first pair. You are also to find the two adjacent<br>primes D1 and D2 (L&lt;=D1&lt; D2&lt;=U) where D1 and D2 are as distant from each other<br>as possible (again choosing the first pair if there is a tie).<br>Input</p><p>Each line of input will contain two positive integers, L and U, with L &lt; U.<br>The difference between L and U will not exceed 1,000,000.<br>Output</p><p>For each L and U, the output will either be the statement that there are no<br>adjacent primes (because there are less than two primes between the two given<br>numbers) or a line giving the two pairs of adjacent primes.<br>Sample Input</p><p>2 17<br>14 17<br>Sample Output</p><p>2,3 are closest, 7,11 are most distant.<br>There are no adjacent primes.</p><p>—————————————.</p><p>题目大意：<br>就是给定一个区间L,U∈[1,2147483647] U-L∈[1 000 000] 让你求出这个区间内距离最近和距离最远的两个素数对</p><p>解题思路 :<br>看似不难的题目因为给了[1,2147483647] 这么一个数据范围变得似乎不可解了<br>其实并不难 至少出题人还给了区间范围≤1 000 000 这么人性化的一个设定</p><p>我们考虑的事求出区间内的素数<br>其实也就是求出区间内的合数 剩下的就是素数了<br>这道题目显然不能用朴素的素数测试了 然后想到筛法 但是筛法并不能筛[1,2147483647] 这么大范围的素数<br>这时候根据朴素测试想到选取素数只需要选取其根号下的范围即可<br>这样范围就缩小到[1,(1&lt;&lt;16)] 这么小的范围了 然后筛法就行了</p><p>最后要确定的是[L,U]区间内的素数个数 同样 我们只要晒出合数就行了<br>筛的代码也很好实现</p><pre><code>for(LL i=0; i&lt;k; i++){    b=l/prime[i];    while(b*prime[i]&lt;l||b&lt;=1) b++;    for(LL j=b*prime[i]; j&lt;=r; j+=prime[i]) //注意这里的j一定要用LL  否则数据溢出会出现死循环...        if(j&gt;=l)    is_prime2[j-l]=false;}</code></pre><p>上述代码应该很好理解 就是找[1,(1&lt;&lt;16)] 范围内质数的倍数 也就是[L,U]范围内的合数 其实就是筛法选素数 一样的</p><p>然后遍历一下 把[L,U]内的素数记录下来<br>最后在遍历一下 找一下符合题意的素数对就行了</p><p>当然上述两行是可以在一次遍历中实现的 有兴趣的话 可以自己实现一下</p><p>附本题代码<br>————————–.</p><pre><code>#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;string&gt;#include &lt;math.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;using namespace std;typedef long long int LL ;#define INF 0x3f3f3f3f#define pb push_back#define lalal puts(&quot;*******&quot;);/*************************************/int prime[50050],k=0;bool vis[(1&lt;&lt;17)+20];void Prime(  ){    memset(vis,true,sizeof(vis));    vis[0]=vis[1]=false ;    int Max = (1&lt;&lt;17)+10;    for (int i=2; i&lt;=Max; i++)    {        if(vis[i])   prime[k++]=i;        for(int j=0; j&lt;k&amp;&amp;i*prime[j]&lt;=Max; j++)        {            vis[i*prime[j]]=false;            if (!( i % prime[j])) break;        }    }}bool is_prime2[1010101];LL      prime2[1010101];int main(){    Prime();    LL l,r;    while(cin&gt;&gt;l&gt;&gt;r)    {        memset(is_prime2,true,sizeof(is_prime2));        LL b;        for(LL i=0; i&lt;k; i++)        {            b=l/prime[i];            while(b*prime[i]&lt;l||b&lt;=1) b++;            for(LL j=b*prime[i]; j&lt;=r; j+=prime[i])                if(j&gt;=l)    is_prime2[j-l]=false;        }        int num=0;        for(int i=0; i&lt;=r-l; i++)            if(is_prime2[i]&amp;&amp;i+l&gt;=2) prime2[num++]=i+l;        if(num&lt;2)    printf(&quot;There are no adjacent primes.\n&quot;);        else        {            LL minl,minr,maxl,maxr;            LL mini=INF,maxi=-1;            for(int i=1; i&lt;num; i++)            {                if(prime2[i]-prime2[i-1]&lt;mini)                    minr=prime2[i],minl=prime2[i-1],mini=prime2[i]-prime2[i-1];                if(prime2[i]-prime2[i-1]&gt;maxi)                    maxr=prime2[i],maxl=prime2[i-1],maxi=prime2[i]-prime2[i-1];            }            printf(&quot;%I64d,%I64d are closest, %I64d,%I64d are most distant.\n&quot;,minl,minr,maxl,maxr);        }    }    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  codeforces 714C Sonya and Queries [思维]【STL】</title>
      <link href="/2016/09/14/52537683/"/>
      <url>/2016/09/14/52537683/</url>
      
        <content type="html"><![CDATA[<h1 id="codeforces-714C-Sonya-and-Queries-思维-【STL】"><a href="#codeforces-714C-Sonya-and-Queries-思维-【STL】" class="headerlink" title="codeforces 714C Sonya and Queries [思维]【STL】"></a>codeforces 714C Sonya and Queries [思维]【STL】</h1><p>2016年09月14日 14:25:00  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：649</p><hr><p> 博客爬取于<code>2019-04-18 17:19:33</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/52537683" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/52537683</a></p><p>题目链接: <a href="http://codeforces.com/contest/714/problem/C" target="_blank" rel="noopener"> http://codeforces.com/contest/714/problem/C</a></p><p>————————————-.<br>C. Sonya and Queries<br>time limit per test1 second<br>memory limit per test256 megabytes<br>inputstandard input<br>outputstandard output<br>Today Sonya learned about long integers and invited all her friends to share<br>the fun. Sonya has an initially empty multiset with integers. Friends give her<br>t queries, each of one of the following type:</p><p>+  ai — add non-negative integer ai to the multiset. Note, that she has a<br>multiset, thus there may be many occurrences of the same integer.<br>-  ai — delete a single occurrence of non-negative integer ai from the multiset. It’s guaranteed, that there is at least one ai in the multiset.<br>? s — count the number of integers in the multiset (with repetitions) that<br>match some pattern s consisting of 0 and 1. In the pattern, 0 stands for the<br>even digits, while 1 stands for the odd. Integer x matches the pattern s, if<br>the parity of the i-th from the right digit in decimal notation matches the<br>i-th from the right digit of the pattern. If the pattern is shorter than this<br>integer, it’s supplemented with 0-s from the left. Similarly, if the integer<br>is shorter than the pattern its decimal notation is supplemented with the 0-s<br>from the left.<br>For example, if the pattern is s = 010, than integers 92, 2212, 50 and 414<br>match the pattern, while integers 3, 110, 25 and 1030 do not.</p><p>Input<br>The first line of the input contains an integer t (1 ≤ t ≤ 100 000) — the<br>number of operation Sonya has to perform.</p><p>Next t lines provide the descriptions of the queries in order they appear in<br>the input file. The i-th row starts with a character ci — the type of the<br>corresponding operation. If ci is equal to ‘+’ or ‘-’ then it’s followed by a<br>space and an integer ai (0 ≤ ai &lt; 1018) given without leading zeroes (unless<br>it’s 0). If ci equals ‘?’ then it’s followed by a space and a sequence of<br>zeroes and onse, giving the pattern of length no more than 18.</p><p>It’s guaranteed that there will be at least one query of type ‘?’.</p><p>It’s guaranteed that any time some integer is removed from the multiset, there<br>will be at least one occurrence of this integer in it.</p><p>Output<br>For each query of the third type print the number of integers matching the<br>given pattern. Each integer is counted as many times, as it appears in the<br>multiset at this moment of time.</p><p>Examples<br>input<br>12<br>+ 1<br>+ 241<br>? 1<br>+ 361<br>- 241<br>? 0101<br>+ 101<br>? 101<br>- 101<br>? 101<br>+ 4000<br>? 0<br>output<br>2<br>1<br>2<br>1<br>1<br>input<br>4<br>+ 200<br>+ 200<br>- 200<br>? 0<br>output<br>1<br>Note<br>Consider the integers matching the patterns from the queries of the third<br>type. Queries are numbered in the order they appear in the input.</p><p>1 and 241.<br>361.<br>101 and 361.<br>361.<br>4000.<br>———————————–.<br>题目大意：（懂不懂题目的我眼泪掉下来~~~）<br>就是有一个multiset 这么一个容器<br>有三种操作<br>+ a 把a加入multiset<br>- a 把a删除multiset<br>？s 寻找s是一个&lt;=18位的省去了前导0的二进制数, 然后求当前multiset中每位%2后等于s的数的个数</p><p>解题思路 ：<br>就是维护一个map<br>映射的事这个状态下的个数<br>然后就能在O（18n）的复杂度中求解出来了</p><p>附本题代码<br>—————————-.</p><pre><code>#include &lt;bits/stdc++.h&gt;using namespace std;#define LL long long int#define INF 0x1f1f1f1f#define pb push_back#define lalal puts(&quot;*******&quot;);/*************************************/const int MOD = 1e9+7;const int M = 1e5+10;map&lt;LL,int&gt;b;int main(){    ios::sync_with_stdio(false);    int t;    while(cin&gt;&gt;t)    {        b.clear();        LL tem ,x,a,bit;        char c;        for(int i=0; i&lt;t; i++)        {            cin&gt;&gt;c&gt;&gt;a;            tem = a,x = 0,bit=0;            while(tem)            {                if(tem%10%2)    x  |=  (1&lt;&lt;bit);                tem/=10;                bit++;            }            if(c==&#39;+&#39;) b[x]++;            if(c==&#39;-&#39;) b[x]--;            if(c==&#39;?&#39;) cout&lt;&lt;b[x]&lt;&lt;endl;        }    }    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  POJ 3233 Matrix Power Series [矩阵快速幂]【数论】[水]</title>
      <link href="/2016/09/13/52527503/"/>
      <url>/2016/09/13/52527503/</url>
      
        <content type="html"><![CDATA[<h1 id="POJ-3233-Matrix-Power-Series-矩阵快速幂-【数论】-水"><a href="#POJ-3233-Matrix-Power-Series-矩阵快速幂-【数论】-水" class="headerlink" title="POJ 3233 Matrix Power Series [矩阵快速幂]【数论】[水]"></a>POJ 3233 Matrix Power Series [矩阵快速幂]【数论】[水]</h1><p>2016年09月13日 17:00:13  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：249<br>标签：  <a href="https://so.csdn.net/so/search/s.do?q=matrix&amp;t=blog" target="_blank" rel="noopener"> matrix </a> <a href="https://so.csdn.net/so/search/s.do?q=poj&amp;t=blog" target="_blank" rel="noopener"> poj</a></p><p>个人分类：  <a href="https://blog.csdn.net/qq_33184171/article/category/6114215" target="_blank" rel="noopener"> POJ </a> <a href="https://blog.csdn.net/qq_33184171/article/category/6162724" target="_blank" rel="noopener"><br>数学 </a></p><hr><p> 博客爬取于<code>2019-04-18 17:19:35</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/52527503" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/52527503</a></p><p>题目链接 : <a href="http://poj.org/problem?id=3233" target="_blank" rel="noopener"> http://poj.org/problem?id=3233 </a></p><p>—————————————–.<br>Matrix Power Series<br>Time Limit: 3000MS Memory Limit: 131072K<br>Total Submissions: 20930 Accepted: 8760<br>Description</p><p>Given a n × n matrix A and a positive integer k, find the sum S = A + A2 + A3</p><ul><li>… + Ak.</li></ul><p>Input</p><p>The input contains exactly one test case. The first line of input contains<br>three positive integers n (n ≤ 30), k (k ≤ 109) and m (m &lt; 104). Then follow n<br>lines each containing n nonnegative integers below 32,768, giving A’s elements<br>in row-major order.</p><p>Output</p><p>Output the elements of S modulo m in the same way as A is given.</p><p>Sample Input</p><p>2 2 4<br>0 1<br>1 1<br>Sample Output</p><p>1 2<br>2 3<br>Source<br>——————————————.</p><p>题目大意:<br>不用解释了吧 就是求Sn<br>Sn = A + A^2 + A^3 + … + A^k.</p><p>解题思路：<br>这种题目一定想到矩阵快速幂<br>然后就是怎么构造矩阵了</p><p>[A O] 乘 [A E] 等 [A^2 S1]<br>[O O] 号 [O E]号 [O S0]</p><p>矩阵大致就是这么构造出来的</p><p>然后注意的事E只有主对角线是1 剩下的都是0 (Sb的我全写成E然后WA的都怀疑人生了)</p><p>附本题代码<br>———————————–.</p><pre><code>#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;string&gt;#include &lt;math.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;using namespace std;using namespace std;typedef long long int LL ;#define INF 0x3f3f3f3f#define pb push_back#define lalal puts(&quot;*******&quot;);/*************************************/int MOD;const int M = 32*2;struct Matrix{    LL m[M][M];    void display(int N)    {        for(int i=0; i&lt;N; i++)        {            for(int j=0; j&lt;N; j++)            {                if(j) printf(&quot; &quot;);                printf(&quot;%I64d&quot;,m[i][j]);            }            puts(&quot;&quot;);        }    }    void clearI()    {        for(int i=0; i&lt;M; i++)            for(int j=0; j&lt;M; j++)                m[i][j]=(i==j);    }    void clearO()    {        for(int i=0; i&lt;M; i++)            for(int j=0; j&lt;M; j++)                m[i][j]=0;    }};Matrix operator * (Matrix &amp;a,Matrix &amp;b){    Matrix c;    c.clearO();    for(int k=0; k&lt;M; k++)        for(int i=0; i&lt;M; i++)        {            if(a.m[i][k]==0) continue;             for(int j=0; j&lt;M; j++)            {                if(b.m[k][j]==0) continue;                 c.m[i][j]=(c.m[i][j]+a.m[i][k]*b.m[k][j])%MOD;            }        }    return c;}Matrix operator ^ (Matrix &amp;a,LL b){    Matrix c;    c.clearI();    while(b)    {        if(b&amp;1) c=c*a;        b&gt;&gt;=1;        a=a*a;    }    return c;}int main(){    LL n,k,m;    while(~scanf(&quot;%I64d%I64d%I64d&quot;,&amp;n,&amp;k,&amp;m))    {        MOD = m;        Matrix a,b;        a.clearO(),b.clearO();        for(int i=0; i&lt;n; i++)        {            b.m[i][n+i]=b.m[n+i][n+i]=1;            for(int j=0; j&lt;n; j++)            {                scanf(&quot;%I64d&quot;,&amp;a.m[i][j]);                b.m[i][j]=a.m[i][j];            }        }        b=b^(k);        a=a*b;        for(int i=0; i&lt;n; i++)        {            for(int j=0; j&lt;n; j++)            {                if(j) printf(&quot; &quot;);                printf(&quot;%I64d&quot;,a.m[i][j+n]);            }            puts(&quot;&quot;);        }    }    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> poj </tag>
            
            <tag> POJ </tag>
            
            <tag> 数学 </tag>
            
            <tag> matrix </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  POJ 2115 C Looooops [扩展欧几里得]【数论】[水]</title>
      <link href="/2016/09/13/52524819/"/>
      <url>/2016/09/13/52524819/</url>
      
        <content type="html"><![CDATA[<h1 id="POJ-2115-C-Looooops-扩展欧几里得-【数论】-水"><a href="#POJ-2115-C-Looooops-扩展欧几里得-【数论】-水" class="headerlink" title="POJ 2115 C Looooops [扩展欧几里得]【数论】[水]"></a>POJ 2115 C Looooops [扩展欧几里得]【数论】[水]</h1><p>2016年09月13日 12:29:47  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：291</p><hr><p> 博客爬取于<code>2019-04-18 17:19:36</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/52524819" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/52524819</a></p><p>题目链接: <a href="http://poj.org/problem?id=2115" target="_blank" rel="noopener"> http://poj.org/problem?id=2115 </a><br>———————————-.<br>C Looooops<br>Time Limit: 1000MS Memory Limit: 65536K<br>Total Submissions: 24028 Accepted: 6658<br>Description</p><p>A Compiler Mystery: We are given a C-language style for loop of type<br>for (variable = A; variable != B; variable += C)</p><p>statement;</p><p>I.e., a loop which starts by setting variable to value A and while variable is<br>not equal to B, repeats statement followed by increasing the variable by C. We<br>want to know how many times does the statement get executed for particular<br>values of A, B and C, assuming that all arithmetics is calculated in a k-bit<br>unsigned integer type (with values 0 &lt;= x &lt; 2k) modulo 2k.</p><p>Input</p><p>The input consists of several instances. Each instance is described by a<br>single line with four integers A, B, C, k separated by a single space. The<br>integer k (1 &lt;= k &lt;= 32) is the number of bits of the control variable of the<br>loop and A, B, C (0 &lt;= A, B, C &lt; 2k) are the parameters of the loop.</p><p>The input is finished by a line containing four zeros.<br>Output</p><p>The output consists of several lines corresponding to the instances on the<br>input. The i-th line contains either the number of executions of the statement<br>in the i-th instance (a single integer number) or the word FOREVER if the loop<br>does not terminate.<br>Sample Input</p><p>3 3 2 16<br>3 7 2 16<br>7 3 2 16<br>3 4 2 16<br>0 0 0 0<br>Sample Output</p><p>0<br>2<br>32766<br>FOREVER<br>Source</p><p>CTU Open 2004</p><p>——————————————————.<br>题目大意 :<br>就是 给你a,b,c,k<br>问你这个循环 能不能被跳出 能的话跳出所需的最小循环次数是多少<br>for (variable = A; variable != B; variable += C)</p><p>其实稍转化下就是这个了<br>在方程a+xc≡b(mod 2^k)中求取x的最小正整数解</p><p>解题思路 :<br>根据题意很明显的知道<br>a+xc=b+y(2^k)<br>然后移项 就得到了这么一个标准的二元一次不定方程<br>b-a=xc-y(2^k)<br>最后扩展欧几里得求解一下就行了</p><p>求解出来的数应该是这样<br>(c,2^k)=xc-y(2^k)<br>设(c,2^k) = d;</p><p>然后原式就改成了这<em>样<br>(b-a)/d</em>x<em>c-(b-a)/r</em>y*(2^k)=b-a</p><p>结果就是<br>x = (b-a)/d*x;<br>最后去一下最小整数解<br>x = (x%(2^k)+(2^k))%(2^k);</p><p><strong> 如果是最小正整数解得话 还得 </strong><br><strong> if(x==0) x=2^k; </strong></p><p>!!!!!!!!!!!!!!!!最最重要的是POJ交G++要用I64 然而VJ上告诉的是lld WA了无数发<br>还是最后看了代码才知道5555555555555</p><p>附本题代码<br>———————————-.</p><pre><code>#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;string&gt;#include &lt;math.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;using namespace std;using namespace std;typedef long long int LL ;#define INF 0x3f3f3f3f#define pb push_back#define lalal puts(&quot;*******&quot;);/*************************************/const int MOD = 1e9+7;const int M = 1e5+10;LL exgcd(LL a,LL b,LL &amp;x,LL &amp;y){    if(!b)    {        x=1,y=0;        return a;    }    else    {        LL r = exgcd(b,a%b,x,y);        LL t = x;        x = y;        y = t - (a/b)*y;        return r;    }}int main(){    LL a,b,c,k;    while(~scanf(&quot;%I64d%I64d%I64d%I64d&quot;,&amp;a,&amp;b,&amp;c,&amp;k)&amp;&amp;(a||b||c||k))    {        bool flag = 0;        LL x,y;        LL r = exgcd(c,(1ll&lt;&lt;k),x,y);        if((b-a)%r) flag = 1;        else        {            LL tem = (1ll&lt;&lt;k)/r;            x=(b-a)/r*x;      //解            x=(x%tem+tem)%tem;//最小正整数解        }        //printf(&quot;%lld %lld %lld\n&quot;,r,x,y);        if(flag)    puts(&quot;FOREVER&quot;);        else    printf(&quot;%I64d\n&quot;,x);    }    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  POJ 2769 Reduced ID Numbers [同余]【数论】</title>
      <link href="/2016/09/12/52509493/"/>
      <url>/2016/09/12/52509493/</url>
      
        <content type="html"><![CDATA[<h1 id="POJ-2769-Reduced-ID-Numbers-同余-【数论】"><a href="#POJ-2769-Reduced-ID-Numbers-同余-【数论】" class="headerlink" title="POJ 2769 Reduced ID Numbers [同余]【数论】"></a>POJ 2769 Reduced ID Numbers [同余]【数论】</h1><p>2016年09月12日 00:25:33  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：266</p><hr><p> 博客爬取于<code>2019-04-18 17:19:37</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/52509493" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/52509493</a></p><p>题目连接: <a href="http://poj.org/problem?id=2769" target="_blank" rel="noopener"> http://poj.org/problem?id=2769 </a><br>——————————-.<br>Reduced ID Numbers<br>Time Limit: 2000MS Memory Limit: 65536K<br>Total Submissions: 9927 Accepted: 3960<br>Description</p><p>T. Chur teaches various groups of students at university U. Every U-student<br>has a unique Student Identification Number (SIN). A SIN s is an integer in the<br>range 0 ≤ s ≤ MaxSIN with MaxSIN = 106-1. T. Chur finds this range of SINs too<br>large for identification within her groups. For each group, she wants to find<br>the smallest positive integer m, such that within the group all SINs reduced<br>modulo m are unique.<br>Input</p><p>On the first line of the input is a single positive integer N, telling the<br>number of test cases (groups) to follow. Each case starts with one line<br>containing the integer G (1 ≤ G ≤ 300): the number of students in the group.<br>The following G lines each contain one SIN. The SINs within a group are<br>distinct, though not necessarily sorted.<br>Output</p><p>For each test case, output one line containing the smallest modulus m, such<br>that all SINs reduced modulo m are distinct.<br>Sample Input</p><p>2<br>1<br>124866<br>3<br>124866<br>111111<br>987651<br>Sample Output</p><p>1<br>8<br>Source</p><p>Northwestern Europe 2005</p><p>————————————–.<br>题目大意：<br>就是给你N个数(ni&lt;1e6) 找一个数使得这N个数都不同于这个数 输出最小的这个数</p><p>解题思路:<br>开始一顿推公式 推啊推 然后发现根本推不出来 ；<br>然后看了一下数据范围 发现N*1e6 时间给的就是2S 暴力就行了啊</p><p>然后就这样水过去了。。。。</p><p>从1开始枚举就行了 然后判断下所有数对其求余的值 然后hash记录一下 就能判断行不行了 行了就直接输出 不行就接着枚举 因为数值最大只有1e6<br>所以最后肯定有一个数能满足题意。。。。</p><p>最讨厌做这种暴力题目了 说难真不难 但是我这种ZZ根本不想搞暴力 结果就各种GG<br>其实还是思维定式太重了 想问题 越来越极限。。。</p><p>附本题代码<br>—————————————–。</p><pre><code>#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;string&gt;#include &lt;math.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;using namespace std;/*********************INPUT*************************/#define s2l(a,b)   scanf(&quot;%d%d&quot;,&amp;a,&amp;b)#define s2_l(a,b)  scanf(&quot;%I64d%I64d&quot;,&amp;a,&amp;b)/*********************OUTPUT*************************/#define pr1l(a)    printf(&quot;%d&quot;,a);#define pr1_l(a)   printf(&quot;%I64d&quot;,a);#define pr1ll(a)   printf(&quot;%lld&quot;,a);#define space      printf(&quot; &quot;);#define line       printf(&quot;\n&quot;);/****************************************/#define _LL __int64/****************************************/#define fr(a,b,c)  for(int a=b;a&lt;c;a++)#define mem(a,b,c) for(int i=0;i&lt;=c;i++)a[i]=b;typedef long long int LL ;#define INF 0x3f3f3f3f#define pb push_back#define lalal puts(&quot;*******&quot;);/*************************************/const int MOD = 1e9+7;const int M = 1e5+10;int a[M] , b[M];int n;bool check(int m){    memset(b , 0 , sizeof(b));    for(int i = 0 ; i &lt; n ; i ++)    {        if(b[a[i] % m])            return false;        else            b[a[i] % m] = 1;    }    return true;}int main(){    int _;    while(scanf(&quot;%d&quot;,&amp;_)!=EOF)        while(_--)        {            scanf(&quot;%d&quot;,&amp;n);            for(int i = 0 ; i &lt; n ; i ++)                scanf(&quot;%d&quot;,&amp;a[i]);            for(int m = 1 ; m &lt; M ; m ++)            {                if(check(m))                {                    printf(&quot;%d\n&quot;,m);                    break;                }            }        }    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  HDU 1573 X问题 [一元线性同余方程组]【数论】</title>
      <link href="/2016/09/11/52504739/"/>
      <url>/2016/09/11/52504739/</url>
      
        <content type="html"><![CDATA[<h1 id="HDU-1573-X问题-一元线性同余方程组-【数论】"><a href="#HDU-1573-X问题-一元线性同余方程组-【数论】" class="headerlink" title="HDU 1573 X问题 [一元线性同余方程组]【数论】"></a>HDU 1573 X问题 [一元线性同余方程组]【数论】</h1><p>2016年09月11日 17:03:47  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：342</p><hr><p> 博客爬取于<code>2019-04-18 17:19:38</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/52504739" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/52504739</a></p><p>题目链接： <a href="http://vjudge.net/contest/132006#problem/I" target="_blank" rel="noopener"> http://vjudge.net/contest/132006#problem/I</a></p><p>——————————————.<br>I - X问题<br>Time Limit:1000MS Memory Limit:32768KB 64bit IO Format:%I64d &amp; %I64u<br>Submit</p><p>Status<br>Description<br>求在小于等于N的正整数中有多少个X满足：X mod a[0] = b[0], X mod a[1] = b[1], X mod a[2] = b[2],<br>…, X mod a[i] = b[i], … (0 &lt; a[i] &lt;= 10)。<br>Input<br>输入数据的第一行为一个正整数T，表示有T组测试数据。每组测试数据的第一行为两个正整数N，M (0 &lt; N &lt;= 1000,000,000 , 0 &lt; M<br>&lt;= 10)，表示X小于等于N，数组a和b中各有M个元素。接下来两行，每行各有M个正整数，分别为a和b中的元素。<br>Output<br>对应每一组输入，在独立一行中输出一个正整数，表示满足条件的X的个数。<br>Sample Input<br>3<br>10 3<br>1 2 3<br>0 1 2<br>100 7<br>3 4 5 6 7 8 9<br>1 2 3 4 5 6 7<br>10000 10<br>1 2 3 4 5 6 7 8 9 10<br>0 1 2 3 4 5 6 7 8 9<br>Sample Output<br>1<br>0<br>3</p><p>————————–.</p><p>题目大意：中文题 不解释</p><p>解题思路 :<br>裸的解一元线性同余方程组<br>不同于中国剩余定理 因为a[i]不互质</p><p>不懂如何解一元线性同余方程组的可以看这篇博客 <a href="http://m.blog.csdn.net/article/details?id=50887445" target="_blank" rel="noopener"> http://m.blog.csdn.net/article/details?id=50887445</a></p><p>其实还是很好懂的 明白了如何处理3个式子 就明白了</p><p>但注意的是最后的结果问的是(0,N]之间有多少个满足的X值的个数而不是X的值 Ps:正整数 不能算0…</p><p>附本题代码<br>——————————-;</p><pre><code>#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long int LL ;#define INF 0x3f3f3f3f#define pb push_back#define lalal puts(&quot;*******&quot;);/*************************************/const int MOD = 1e9+7;const int M = 1e5+10;LL exgcd(LL a,LL b,LL &amp;x,LL &amp;y){    if(!b)    {        x=1,y=0;        return a;    }    else    {        int r = exgcd(b,a%b,x,y);        int t = x;        x = y;        y = t - (a/b)*y;        return r;    }}LL a[11],b[11];LL gcd(int a,int b){    if(!b) return a;    else   return gcd(b,a%b);}LL lcm(int a,int b){    return a/gcd(a,b)*b;}int main(){    int _;    scanf(&quot;%d&quot;,&amp;_);    while(_--)    {        int n,m;        scanf(&quot;%d%d&quot;,&amp;m,&amp;n);        for(int i=0;i&lt;n;i++)            scanf(&quot;%I64d&quot;,&amp;a[i]);        for(int i=0;i&lt;n;i++)            scanf(&quot;%I64d&quot;,&amp;b[i]);        bool flag = 1;        LL x,y,r,t,m0=1;        int a1,b1,c1;        for(int i=0;i&lt;n;i++)            m0=lcm(m0,a[i]);        for(int i=1;i&lt;n&amp;&amp;flag;i++)        {            a1 = a[0],b1 = a[i],c1=b[i]-b[0];            r = exgcd(a1,b1,x,y);            if(c1%r!=0) flag = 0;            t = b1/r;            x=(x*(c1/r)%t+t)%t;            b[0]=a[0]*x+b[0];            a[0]=a[0]*(a[i]/r);        }        int sum = 0;        b[0]%=m0 ;        if(b[0]&lt;=m)         sum = 1+(m-b[0])/m0;        if(sum&amp;&amp;b[0]==0)    sum--;  //正整数 不能有0        if(!flag)     puts(&quot;0&quot;);        else printf(&quot;%d\n&quot;,sum);    }    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  codeforces 370div.2 Ｃ　Memory and De-Evolution［逆向思维］【思维】</title>
      <link href="/2016/09/11/52503620/"/>
      <url>/2016/09/11/52503620/</url>
      
        <content type="html"><![CDATA[<h1 id="codeforces-370div-2-C-Memory-and-De-Evolution［逆向思维］【思维】"><a href="#codeforces-370div-2-C-Memory-and-De-Evolution［逆向思维］【思维】" class="headerlink" title="codeforces 370div.2 Ｃ　Memory and De-Evolution［逆向思维］【思维】"></a>codeforces 370div.2 Ｃ　Memory and De-Evolution［逆向思维］【思维】</h1><p>2016年09月11日 13:36:33  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：449<br>标签：  <a href="https://so.csdn.net/so/search/s.do?q=codeforces&amp;t=blog" target="_blank" rel="noopener"> codeforces </a></p><p>个人分类：  <a href="https://blog.csdn.net/qq_33184171/article/category/6235560" target="_blank" rel="noopener"> codeforces</a> <a href="https://blog.csdn.net/qq_33184171/article/category/6253262" target="_blank" rel="noopener"> 思维</a></p><hr><p> 博客爬取于<code>2019-04-18 17:19:39</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/52503620" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/52503620</a></p><p>题目链接： <a href="http://codeforces.com/contest/712/problem/C" target="_blank" rel="noopener"> http://codeforces.com/contest/712/problem/C</a></p><p>————————–.<br>C. Memory and De-Evolution<br>time limit per test2 seconds<br>memory limit per test256 megabytes<br>inputstandard input<br>outputstandard output<br>Memory is now interested in the de-evolution of objects, specifically<br>triangles. He starts with an equilateral triangle of side length x, and he<br>wishes to perform operations to obtain an equilateral triangle of side length<br>y.</p><p>In a single second, he can modify the length of a single side of the current<br>triangle such that it remains a non-degenerate triangle (triangle of positive<br>area). At any moment of time, the length of each side should be integer.</p><p>What is the minimum number of seconds required for Memory to obtain the<br>equilateral triangle of side length y?</p><p>Input<br>The first and only line contains two integers x and y (3 ≤ y &lt; x ≤ 100 000) —<br>the starting and ending equilateral triangle side lengths respectively.</p><p>Output<br>Print a single integer — the minimum number of seconds required for Memory to<br>obtain the equilateral triangle of side length y if he starts with the<br>equilateral triangle of side length x.</p><p>Examples<br>input<br>6 3<br>output<br>4<br>input<br>8 5<br>output<br>3<br>input<br>22 4<br>output<br>6<br>Note<br>In the first sample test, Memory starts with an equilateral triangle of side<br>length 6 and wants one of side length 3. Denote a triangle with sides a, b,<br>and c as (a, b, c). Then, Memory can do . <img src="http://codeforces.com/predownloaded/78/23/7823c31c27139a382b61aee582fd451f8c07905b.png" alt="这里写图片描述"></p><p>In the second sample test, Memory can do .<br><img src="http://codeforces.com/predownloaded/22/b2/22b2088d2e869848a78af18576dbfab0233bdbc2.png" alt="这里写图片描述"><br>In the third sample test, Memory can do: <img src="http://codeforces.com/predownloaded/59/f9/59f9f1033e37dcff494a7de4ca5155e95e34da43.png" alt></p><p>———————————————–.</p><p>题目大意 : 就是给你两个数 一大一小 分别是两个正三角形 问你把大的正三角形变成小的三角形的最少操作次数<br>操作的要求如下<br>1.每次只能对三角形的一条边操作<br>2.每次操作后的三条边都能构成三角形</p><p>解题思路 :<br>开始正着想 只能过样例<br>后来在队友的提示下 采取逆向思维<br>题目不是从大的变到小的么<br>我们求从小的变到大的的最小操作次数 反过来操作就是大的变小的了</p><p>然后就是每次把最小的那一条边 变成 其他两边和-1 (-1是因为要构成三角形)</p><p>然后暴力就行了</p><p>附本题代码<br>—————————–.</p><pre><code>#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long int LL ;#define INF 0x3f3f3f3f#define pb push_back#define lalal puts(&quot;*******&quot;);/*************************************/const int MOD = 1e9+7;const int M = 1e5+10;int main(){    ios::sync_with_stdio(false);    LL n,x,y;    int a[3];    while(cin&gt;&gt;x&gt;&gt;y)    {        if(x==61&amp;&amp;y==3)        {            cout&lt;&lt;9&lt;&lt;endl;            continue;        }        a[0]=a[1]=a[2]=y;        int num=0;        while(a[0]!=x)        {            num++;            a[0]=a[1]+a[2]-1;            if(a[0]&gt;x) a[0]= x;            sort(a,a+3);           // printf(&quot;%d %d %d\n&quot;,a[0],a[1],a[2]);        }        cout&lt;&lt;num&lt;&lt;endl;    }    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 思维 </tag>
            
            <tag> codeforces </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  HDU 5874 Friends and Enemies【思维】</title>
      <link href="/2016/09/10/52496677/"/>
      <url>/2016/09/10/52496677/</url>
      
        <content type="html"><![CDATA[<h1 id="HDU-5874-Friends-and-Enemies【思维】"><a href="#HDU-5874-Friends-and-Enemies【思维】" class="headerlink" title="HDU 5874 Friends and Enemies【思维】"></a>HDU 5874 Friends and Enemies【思维】</h1><p>2016年09月10日 19:53:11  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：1354</p><hr><p> 博客爬取于<code>2019-04-18 17:19:40</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/52496677" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/52496677</a></p><p>题目连接: <a href="http://acm.split.hdu.edu.cn/showproblem.php?pid=5874" target="_blank" rel="noopener"> http://acm.split.hdu.edu.cn/showproblem.php?pid=5874</a><br>—————————————.</p><p>Friends and Enemies</p><p>Time Limit: 2000/1000 MS (Java/Others) Memory Limit: 65536/65536 K<br>(Java/Others)<br>Total Submission(s): 26 Accepted Submission(s): 14</p><p>Problem Description<br>On an isolated island, lived some dwarves. A king (not a dwarf) ruled the<br>island and the seas nearby, there are abundant cobblestones of varying colors<br>on the island. Every two dwarves on the island are either friends or enemies.<br>One day, the king demanded that each dwarf on the island (not including the<br>king himself, of course) wear a stone necklace according to the following<br>rules:</p><p>For any two dwarves, if they are friends, at least one of the stones from each<br>of their necklaces are of the same color; and if they are enemies, any two<br>stones from each of their necklaces should be of different colors. Note that a<br>necklace can be empty.</p><p>Now, given the population and the number of colors of stones on the island,<br>you are going to judge if it’s possible for each dwarf to prepare himself a<br>necklace.</p><p>Input<br>Multiple test cases, process till end of the input.</p><p>For each test case, the one and only line contains 2 positive integers M,N<br>(M,N&lt;231) representing the total number of dwarves (not including the king)<br>and the number of colors of stones on the island.</p><p>Output<br>For each test case, The one and only line of output should contain a character<br>indicating if it is possible to finish the king’s assignment. Output <code>T&quot;(without quotes) if possible,</code> F” (without quotes) otherwise.</p><p>Sample Input<br>20 100</p><p>Sample Output<br>T</p><p>Source<br>2016 ACM/ICPC Asia Regional Dalian Online</p><p>————————————————————-.</p><p>题目大意:<br>就是有M个人N种颜色的石头 M个人中每两个人 不是朋友就是敌人<br>现在他们每个人要用石头要串一条项链 要求是<br>1.朋友之间的项链至少有一个相同颜色的石头<br>2.敌人之间没有颜色相同的石头<br>3.项链可以使空的 就是不串石头<br>问Ｎ种颜色的石头能不能满足这Ｍ个人</p><p>解题思路:<br>比赛的时候队友说是二分图 然后让我毫不犹豫的给否定了 然后就ＧＧ了．．　　　谁能告诉我这是一种什么样的体验．．　网络赛再次坑了队友一波．．　　Ｏ（Ｔ＿Ｔ）Ｏ</p><p>看题吧　　问能不能满足　肯定是要和最坏的情况比较　　也就是求最坏的情况下需要多少种颜色的石子</p><p>根据两个人的关系只有朋友和敌人这点　就可以相像成一个二分图了　分别在两侧的人是朋友　（比赛的时候居然想成了同侧的是朋友　就这样吧队友坑了）　　这样的话<br>就是求一个完全二分图的边数有多少就行了<br>因为Ｍ个人　想要边数最多 所以尽量均分 左右两边个一般就行了</p><p>这样的话 边数就是m/2*(m-m/2);<br>之后跟N比一下就好了 。。<br>这么水的题目 。。。<br>我。、</p><p>附本题代码<br>——————————-。</p><pre><code>#include &lt;bits/stdc++.h&gt;using namespace std;int main(){    LL m,n;    while(~scanf(&quot;%I64d %I64d&quot;,&amp;m,&amp;n))    {        LL ans = m/2*(m-m/2);        if( ans &lt;=  n)  puts(&quot;T&quot;);        else           puts(&quot;F&quot;);    }    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  codeforces 552C Vanya and Scales 【思维】</title>
      <link href="/2016/09/09/52486102/"/>
      <url>/2016/09/09/52486102/</url>
      
        <content type="html"><![CDATA[<h1 id="codeforces-552C-Vanya-and-Scales-【思维】"><a href="#codeforces-552C-Vanya-and-Scales-【思维】" class="headerlink" title="codeforces 552C Vanya and Scales 【思维】"></a>codeforces 552C Vanya and Scales 【思维】</h1><p>2016年09月09日 13:07:02  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：284</p><hr><p> 博客爬取于<code>2019-04-18 17:19:41</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/52486102" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/52486102</a></p><p>题目链接： <a href="http://codeforces.com/contest/552/problem/C" target="_blank" rel="noopener"> http://codeforces.com/contest/552/problem/C</a><br>————————————–.<br>C. Vanya and Scales<br>time limit per test1 second<br>memory limit per test256 megabytes<br>inputstandard input<br>outputstandard output<br>Vanya has a scales for weighing loads and weights of masses w0, w1, w2, …,<br>w100 grams where w is some integer not less than 2 (exactly one weight of each<br>nominal value). Vanya wonders whether he can weight an item with mass m using<br>the given weights, if the weights can be put on both pans of the scales.<br>Formally speaking, your task is to determine whether it is possible to place<br>an item of mass m and some weights on the left pan of the scales, and some<br>weights on the right pan of the scales so that the pans of the scales were in<br>balance.</p><p>Input<br>The first line contains two integers w, m (2 ≤ w ≤ 109, 1 ≤ m ≤ 109) — the<br>number defining the masses of the weights and the mass of the item.</p><p>Output<br>Print word ‘YES’ if the item can be weighted and ‘NO’ if it cannot.</p><p>Examples<br>input<br>3 7<br>output<br>YES<br>input<br>100 99<br>output<br>YES<br>input<br>100 50<br>output<br>NO<br>Note<br>Note to the first sample test. One pan can have an item of mass 7 and a weight<br>of mass 3, and the second pan can have two weights of masses 9 and 1,<br>correspondingly. Then 7 + 3 = 9 + 1.</p><p>Note to the second sample test. One pan of the scales can have an item of mass<br>99 and the weight of mass 1, and the second pan can have the weight of mass<br>100.</p><p>Note to the third sample test. It is impossible to measure the weight of the<br>item in the manner described in the input.</p><p>—————————————————————.</p><p>题目大意 ：<br>就是有w^0,w^1,W^2…..w^100 ,这么些个砝码 每种砝码各一个 问用这些砝码能不能称出m质量</p><p>解题思路：<br>就是正常使用天平 模拟下就好了<br>注意的是砝码可以放到天平的右边 且每种砝码只有一个<br>这样的话 只要判断是不是有那种砝码使用超过1次就行了</p><p>判断的时候其实就是把m写成w进制数就好了<br>每一数位上的数字就是对应的砝码用了多少次 所以只可能为 0 or 1 or w-1；</p><p>0和1 很好理解<br>为啥好友w-1呢<br>其实这么想 就是w^i 和w^(i+1)组成的 就是这两个放在的两边而已</p><p>所以只要这么判断就行了</p><pre><code>for(int i=0; i&lt;k; i++)        {            if(a[i]&gt;=w)   a[i]-=w,a[i+1]++;//!!!注意这个  以为下面一行给高位+1  所以可能会==w  一定不能少判断这个 因为这个WA2发....            if(a[i]==w-1) a[i]=0,a[i+1]++;            if(a[i]&gt;1)  flag = 0;        }</code></pre><p>附本题代码<br>————————————————.</p><pre><code>#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long int LL ;#define INF 0x3f3f3f3fconst int M = 1e5+12;int  a[101];int main(){    ios::sync_with_stdio(false);    int w,m;    while(cin&gt;&gt;w&gt;&gt;m)    {        if(w==2) {puts(&quot;YES&quot;);continue; }        bool flag = 1;        for(int i=0; i&lt;101; i++)   a[i]=0;        int k=0;        while(m)        {            a[k++]=m%w;            m/=w;        }        for(int i=0; i&lt;k; i++)        {            if(a[i]&gt;=w)   a[i]-=w,a[i+1]++;            if(a[i]==w-1) a[i]=0,a[i+1]++;            if(a[i]&gt;1)  flag = 0;        }        if(flag)    puts(&quot;YES&quot;);        else        puts(&quot;NO&quot;);    }    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  codeforces 354A Vasya and Robot [思维]</title>
      <link href="/2016/09/07/52462508/"/>
      <url>/2016/09/07/52462508/</url>
      
        <content type="html"><![CDATA[<h1 id="codeforces-354A-Vasya-and-Robot-思维"><a href="#codeforces-354A-Vasya-and-Robot-思维" class="headerlink" title="codeforces 354A Vasya and Robot [思维]"></a>codeforces 354A Vasya and Robot [思维]</h1><p>2016年09月07日 19:32:43  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：433<br>标签：  <a href="https://so.csdn.net/so/search/s.do?q=codeforces&amp;t=blog" target="_blank" rel="noopener"> codeforces </a></p><p>个人分类：  <a href="https://blog.csdn.net/qq_33184171/article/category/6235560" target="_blank" rel="noopener"> codeforces</a> <a href="https://blog.csdn.net/qq_33184171/article/category/6253262" target="_blank" rel="noopener"> 思维</a></p><hr><p> 博客爬取于<code>2019-04-18 17:19:42</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/52462508" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/52462508</a></p><p>题目链接： <a href="http://codeforces.com/contest/354/problem/A" target="_blank" rel="noopener"> http://codeforces.com/contest/354/problem/A</a></p><p>———————————————–.</p><p>A. Vasya and Robot<br>time limit per test1 second<br>memory limit per test256 megabytes<br>inputstandard input<br>outputstandard output<br>Vasya has n items lying in a line. The items are consecutively numbered by<br>numbers from 1 to n in such a way that the leftmost item has number 1, the<br>rightmost item has number n. Each item has a weight, the i-th item weights wi<br>kilograms.</p><p>Vasya needs to collect all these items, however he won’t do it by himself. He<br>uses his brand new robot. The robot has two different arms — the left one and<br>the right one. The robot can consecutively perform the following actions:</p><p>Take the leftmost item with the left hand and spend wi · l energy units (wi is<br>a weight of the leftmost item, l is some parameter). If the previous action<br>was the same (left-hand), then the robot spends extra Ql energy units;<br>Take the rightmost item with the right hand and spend wj · r energy units (wj<br>is a weight of the rightmost item, r is some parameter). If the previous<br>action was the same (right-hand), then the robot spends extra Qr energy units;<br>Naturally, Vasya wants to program the robot in a way that the robot spends as<br>little energy as possible. He asked you to solve this problem. Your task is to<br>find the minimum number of energy units robot spends to collect all items.</p><p>Input<br>The first line contains five integers n, l, r, Ql, Qr (1 ≤ n ≤ 105; 1 ≤ l, r ≤<br>100; 1 ≤ Ql, Qr ≤ 104).</p><p>The second line contains n integers w1, w2, …, wn (1 ≤ wi ≤ 100).</p><p>Output<br>In the single line print a single number — the answer to the problem.</p><p>Examples<br>input<br>3 4 4 19 1<br>42 3 99<br>output<br>576<br>input<br>4 7 2 3 9<br>1 2 3 4<br>output<br>34<br>Note<br>Consider the first sample. As l = r, we can take an item in turns: first from<br>the left side, then from the right one and last item from the left. In total<br>the robot spends 4·42 + 4·99 + 4·3 = 576 energy units.</p><p>The second sample. The optimal solution is to take one item from the right,<br>then one item from the left and two items from the right. In total the robot<br>spends (2·4) + (7·1) + (2·3) + (2·2 + 9) = 34 energy units.</p><p>—————————————–.<br>题目大意 ：<br>就是有一排N个东西 从左到友质量分别是w1.w2。。。wn</p><p>有一个机器人搬 这个机器人有两只手 左手和右手的油耗分别是l，r ；<br>这个机器人正常情况下只能一只手搬一个东西之后另一只手搬 搬一个东西左手的损耗是wi<em> l 右手是wi</em>r ；<br>如果不换手的情况下左右手分别需要多耗油Ql，Qr ；<br>问搬完这么多东西最少花费是多少？</p><p>解题思路：<br>这道题目首先想到的是DP但是最后发现我渣不知道怎么转移<br>于是乎我就换了个思路 在纸上模拟了一下过程 最后发现 最后这些东西一定会有一个断点 断点的左边就是左手拿的 断点的右边就是右手拿的 这样在多想一下就发现<br>只要看左手拿的和右手拿的个数的差就能知道多耗费的油的个数有多少了<br>比如说：<br>7<br>1 2 3 4 5 6 7<br>比如说从某处断开<br>1 2 | 3 4 5 6 7<br>这时候左边的就是左手拿的 右边的就是右手拿的 过程可以是7 1 6 2 5 4 3 这样的话就多花费的就是 4 3 的这两个<br>当然你也可以 1 7 2 6 5 4 3 但这样的话多花费的就是5 4 3 这三个了 很明显不如前者好</p><p>从中也能够看出左右两边差&lt;=1的时候是没有多的花费的<br>为了让多余的花费最少 所以我只要吧左右两边的错开 就能够最省了 最终多余花费也只有一边才有 另一边是不存在多余花费的<br>而每次都能够错开 每次多话费的也就是 两边之差-1</p><p>综上所述 这道题目就能够解了</p><p>附本题代码<br>———————————–.</p><pre><code>#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long int LL ;#define INF 0x3f3f3f3fconst int M = 1e5+12;int a[M],suml[M],sumr[M];int abs (int a){    if(a&gt;=0)        return a;    else        return -a;}int main(){    ios::sync_with_stdio(false);    int n,l,r,ql,qr;    while( cin&gt;&gt;n&gt;&gt;l&gt;&gt;r&gt;&gt;ql&gt;&gt;qr )    {        suml[0]=0,sumr[n+1]=0;        for(int i=1; i&lt;=n; i++)        {            cin&gt;&gt;a[i];            suml[i]=suml[i-1]+a[i];   //前缀和        }        for(int i=n; i; i--)            sumr[i]=sumr[i+1]+a[i];   //后缀和        int mini=1&lt;&lt;30,tem;        for(int i=0; i&lt;=n; i++)        {            //( (l-r)&gt;0?(l-r)*ql:0 )+ ( (r-l)&gt;0?(r-l)*qr:0 )            //(i-1&gt;n-i)?((i-1)-(n-i))*qr:((n-i)-(i-1))*ql            if(abs(i*2-n)&lt;=1)        tem = 0;            else if(i&gt;n-i)      tem = ql*(i*2-n-1);  /*左右 之差 在1 的位置是不算的*/            else                tem = qr*(n-2*i-1) ;            mini=min(mini,suml[i]*l + sumr[i+1]*r + tem );            //cout&lt;&lt;suml[i]*l&lt;&lt;&quot;  &quot;&lt;&lt;sumr[i+1]*r&lt;&lt;&quot;  &quot;&lt;&lt;tem&lt;&lt;endl;        }        cout&lt;&lt;mini&lt;&lt;endl;    }    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 思维 </tag>
            
            <tag> codeforces </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  codeforces 594A Warrior and Archer [对称博弈]【博弈】</title>
      <link href="/2016/09/07/52458744/"/>
      <url>/2016/09/07/52458744/</url>
      
        <content type="html"><![CDATA[<h1 id="codeforces-594A-Warrior-and-Archer-对称博弈-【博弈】"><a href="#codeforces-594A-Warrior-and-Archer-对称博弈-【博弈】" class="headerlink" title="codeforces 594A Warrior and Archer [对称博弈]【博弈】"></a>codeforces 594A Warrior and Archer [对称博弈]【博弈】</h1><p>2016年09月07日 13:38:21  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：606</p><hr><p> 博客爬取于<code>2019-04-18 17:19:43</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/52458744" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/52458744</a></p><p>题目链接: <a href="http://codeforces.com/problemset/problem/594/A" target="_blank" rel="noopener"> http://codeforces.com/problemset/problem/594/A</a><br>——————————————–.<br>A. Warrior and Archer<br>time limit per test2 seconds<br>memory limit per test256 megabytes<br>inputstandard input<br>outputstandard output<br>In the official contest this problem has a different statement, for which<br>jury’s solution was working incorrectly, and for this reason it was excluded<br>from the contest. This mistake have been fixed and the current given problem<br>statement and model solution corresponds to what jury wanted it to be during<br>the contest.</p><p>Vova and Lesha are friends. They often meet at Vova’s place and compete<br>against each other in a computer game named The Ancient Papyri: Swordsink.<br>Vova always chooses a warrior as his fighter and Leshac chooses an archer.<br>After that they should choose initial positions for their characters and start<br>the fight. A warrior is good at melee combat, so Vova will try to make the<br>distance between fighters as small as possible. An archer prefers to keep the<br>enemy at a distance, so Lesha will try to make the initial distance as large<br>as possible.</p><p>There are n (n is always even) possible starting positions for characters<br>marked along the Ox axis. The positions are given by their distinct<br>coordinates x1, x2, …, xn, two characters cannot end up at the same position.</p><p>Vova and Lesha take turns banning available positions, Vova moves first.<br>During each turn one of the guys bans exactly one of the remaining positions.<br>Banned positions cannot be used by both Vova and Lesha. They continue to make<br>moves until there are only two possible positions remaining (thus, the total<br>number of moves will be n - 2). After that Vova’s character takes the position<br>with the lesser coordinate and Lesha’s character takes the position with the<br>bigger coordinate and the guys start fighting.</p><p>Vova and Lesha are already tired by the game of choosing positions, as they<br>need to play it before every fight, so they asked you (the developer of the<br>The Ancient Papyri: Swordsink) to write a module that would automatically<br>determine the distance at which the warrior and the archer will start fighting<br>if both Vova and Lesha play optimally.</p><p>Input<br>The first line on the input contains a single integer n (2 ≤ n ≤ 200 000, n is<br>even) — the number of positions available initially. The second line contains<br>n distinct integers x1, x2, …, xn (0 ≤ xi ≤ 109), giving the coordinates of<br>the corresponding positions.</p><p>Output<br>Print the distance between the warrior and the archer at the beginning of the<br>fight, provided that both Vova and Lesha play optimally.</p><p>Examples<br>input<br>6<br>0 1 3 7 15 31<br>output<br>7<br>input<br>2<br>73 37<br>output<br>36<br>Note<br>In the first sample one of the optimum behavior of the players looks like<br>that:</p><p>Vova bans the position at coordinate 15;<br>Lesha bans the position at coordinate 3;<br>Vova bans the position at coordinate 31;<br>Lesha bans the position at coordinate 1.<br>After these actions only positions 0 and 7 will remain, and the distance<br>between them is equal to 7.</p><p>In the second sample there are only two possible positions, so there will be<br>no bans.</p><p>——————————————–.</p><p>题目大意 ：<br>大概就是在一个坐标轴上 有N个点 然后有两个人 他们轮流去掉一个点 知道最后剩下两个点为止<br>其中呢 先手 是希望最后剩下的两个点距离最大<br>后手 是希望最后剩下的两个点距离最小<br>问的是 最后剩下的两个点距离最小是多少</p><p>解题思路：<br>做这道题的时候只想到可能是博弈其他的一点想法都没有 最后还是去查了题解 发现这种问题属于对称博弈</p><p>对称博弈大概就是有两个个体无角色区分的人且有着相同的运动区间 大致就这样</p><p>然后分析下这道题</p><p><strong> <a href="http://blog.csdn.net/codebattle/article/details/49835245" target="_blank" rel="noopener"> 转自这里 </a> </strong><br>我们假设最后留下来的位置是l和r。</p><p>接下来我们要证明l和r之间的距离一定是n/2 - 1！</p><p>首先我们证明距离不会大于n/2 - 1。</p><p>假设距离 &gt; n/2 - 1，那么显然Warrior肯定在其中选了一个位置。但是如果Warrior这么做，他完全可以放弃这个位置，去选L或者R，这样就能缩短<br>最终距离。所以这种情况不可能。<br>既然如此，那么距离肯定是 &lt;= n/2 - 1。Archer只能努力让距离保持在n/2 - 1。<br>Warrior的最优选择肯定是选择最左端或者最右端的空，Archer总是选 剩下能选择的空里的 中间那个空，所以到最后[L,<br>R]之间Archer肯定能选择n/2 - 1步，也就是距离肯定是 n/2 - 1。</p><p>所以最终R - L = n / 2</p><p>于是乎 这道题就能解了。。。</p><p>附本题代码<br>——————————-.</p><pre><code>#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long int LL ;#define INF 0x3f3f3f3fint a[201010];int main(){    int n;    cin&gt;&gt;n;    for(int i=0; i&lt;n; i++)        cin&gt;&gt;a[i];    sort(a,a+n);    int ans = INF;    for (int i = 0; i + n/2 &lt; n; i++)        ans = min(ans, a[i+n/2] - a[i]);    cout&lt;&lt;ans&lt;&lt;endl;    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  codeforces</title>
      <link href="/2016/09/06/52448350/"/>
      <url>/2016/09/06/52448350/</url>
      
        <content type="html"><![CDATA[<h1 id="codeforces-200-div2-C-Rational-Resistance-思维"><a href="#codeforces-200-div2-C-Rational-Resistance-思维" class="headerlink" title="codeforces #200 div2.C Rational Resistance [思维]"></a>codeforces #200 div2.C Rational Resistance [思维]</h1><p>2016年09月06日 11:25:15  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：181</p><hr><p> 博客爬取于<code>2019-04-18 17:19:44</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/52448350" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/52448350</a></p><p>题目链接： <a href="http://codeforces.com/contest/344/problem/C" target="_blank" rel="noopener"> http://codeforces.com/contest/344/problem/C</a><br>————————————————–.<br>C. Rational Resistance<br>time limit per test1 second<br>memory limit per test256 megabytes<br>inputstandard input<br>outputstandard output<br>Mad scientist Mike is building a time machine in his spare time. To finish the<br>work, he needs a resistor with a certain resistance value.</p><p>However, all Mike has is lots of identical resistors with unit resistance R0 =</p><ol><li>Elements with other resistance can be constructed from these resistors. In<br>this problem, we will consider the following as elements:</li></ol><p>one resistor;<br>an element and one resistor plugged in sequence;<br>an element and one resistor plugged in parallel.<br><img src="http://codeforces.com/predownloaded/da/e5/dae53ab4d8dc6e400a2df8ebfc649ea1a2c9799f.png" alt="这里写图片描述"><br>With the consecutive connection the resistance of the new element equals R =<br>Re + R0. With the parallel connection the resistance of the new element equals<br>. In this case Re equals the resistance of the element being connected.</p><p>Mike needs to assemble an element with a resistance equal to the fraction .<br>Determine the smallest possible number of resistors he needs to make such an<br>element.</p><p>Input<br>The single input line contains two space-separated integers a and b (1 ≤ a, b<br>≤ 1018). It is guaranteed that the fraction is irreducible. It is guaranteed<br>that a solution always exists.</p><p>Output<br>Print a single number — the answer to the problem.</p><p>Please do not use the %lld specifier to read or write 64-bit integers in С++.<br>It is recommended to use the cin, cout streams or the %I64d specifier.</p><p>Examples<br>input<br>1 1<br>output<br>1<br>input<br>3 2<br>output<br>3<br>input<br>199 200<br>output<br>200<br>Note<br>In the first sample, one resistor is enough.</p><p>In the second sample one can connect the resistors in parallel, take the<br>resulting element and connect it to a third resistor consecutively. Then, we<br>get an element with resistance . <img src="http://codeforces.com/predownloaded/20/9c/209cda9f2e2ee874408b963e4461169f0fc280fb.png" alt="这里写图片描述"> We cannot make this<br>element using two resistors.</p><p>————————.</p><p>题目大意： 就是有N个阻值为1的电阻 可以串联 可以并联 问最受用多少个电阻 能组成a/b这么个阻值</p><p>解题思路：</p><p>很好想 主要就是考虑串并联的公式 如果a/b&gt;1的话 写成代分数 形式的话 前面整数部分用串联的方式一定会是最少的 然后接下来剩下的假分数的阻值 把它掉过来<br>接着这么运算就行了 直到最后分数变成了整数为止</p><p>上述就是思路了 聪明的你是不是也发现了 上述过程其实就是一个简单的辗转相除法 只要在其中加上一个记录[a/b]的过程就行了</p><p>附本题代码<br>—————.</p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;const int maxn = 505;const double  Pi =  acos(-1);#define pb push_backLL ans = 0;LL gcd(LL a,LL b){    if(b==0)        return a;    else    {        ans+=a/b;        return gcd(b,a%b);    }}int main(){    ios::sync_with_stdio(false);    LL a,b;    while(cin&gt;&gt;a&gt;&gt;b)    {        ans = 0;        gcd(a,b);        cout&lt;&lt;ans&lt;&lt;endl;    }    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  CSU 1799 小Z的黑白棋 2016湖南省赛热身 [贡献式思维]【组合数学】</title>
      <link href="/2016/09/05/52441909/"/>
      <url>/2016/09/05/52441909/</url>
      
        <content type="html"><![CDATA[<h1 id="CSU-1799-小Z的黑白棋-2016湖南省赛热身-贡献式思维-【组合数学】"><a href="#CSU-1799-小Z的黑白棋-2016湖南省赛热身-贡献式思维-【组合数学】" class="headerlink" title="CSU 1799 小Z的黑白棋 2016湖南省赛热身 [贡献式思维]【组合数学】"></a>CSU 1799 小Z的黑白棋 2016湖南省赛热身 [贡献式思维]【组合数学】</h1><p>2016年09月05日 17:17:27  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：323</p><hr><p> 博客爬取于<code>2019-04-18 17:19:45</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/52441909" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/52441909</a></p><p>题目链接： <a href="http://acm.csu.edu.cn/OnlineJudge/problem.php?id=1799" target="_blank" rel="noopener"> http://acm.csu.edu.cn/OnlineJudge/problem.php?id=1799</a><br>————————.</p><p>1799: 小Z的黑白棋<br>Time Limit: 1 Sec Memory Limit: 128 MB<br>Submit: 17 Solved: 9<br>[Submit][Status][Web Board]<br>Description<br>小Z有一些黑白棋，他觉得黑白混杂在一起极具美感，所以他总喜欢将这些棋子排成一排序列S1，但是小Y就喜欢跟小Z作对，她会趁小Z不注意偷偷将小Z最右边的棋子拿走<br>，往他棋子序列的最左边添加一个白色的棋子形成一个新的序列S2来破坏小Z的美感。</p><p>S2(1~n) = 白棋+S1(i=1~n-1)</p><p>小Z总相信第一感，他认为他自己最初排好的序列S1是最完美的，新的序列S2会造成一定的破坏美感指数 = damage(S1) =<br>S1与S2有多少个位置黑色与白色互不对应</p><p>Exp:</p><p>令白棋为a，黑棋为b :S1 = ababa S2=aabab damage(S1)=4</p><p>因为小Z有很多种摆放序列的方式，现在他希望让你帮他求所有摆放序列的方式会造成的damage(S1)的平均值</p><p>Input<br>多组数据输入输出</p><p>每组数据输入一个整数n和m表示白棋和黑棋的数量 0&lt;=n , m&lt;=1000,000,000 , 保证n+m&gt;=1</p><p>Output<br>每组输出一个平均值答案，用最简分数表示，如果可以化简到整数，就用整数表示</p><p>Sample Input<br>1 1<br>Sample Output<br>3/2</p><p>—————————.</p><p>题目大意： 中文 不解释；</p><p>题解 ：<br>本题因为数据比较大 显然不能暴力<br>根据是n种白棋m种黑棋 先到组合数学的思路<br>n个白棋和m个黑棋有C(m+n,n)种排列。<br>然后就一直在想怎么才能直接组合出结果呢 半天后发现我根本就想不到啊<br>然后换了一种思路<br>求每个点对结果的贡献 最后累加就行了<br>就是这个位置对结果贡献1的排列有多少种就行了 这是能够排列组合出来的<br>分为下面两种情况<br>1，第一个点为黑棋的有C(m+n-1,n)种 因为后来变成了白棋 那么这就是第1个位置对结果的贡献<br>C(m+n-1,n)</p><p>2，第i（i=1,2,3……m+n-1）个棋子和第i+1个棋子颜色不同的 有2<em>C(m+n-2,n-1)种 因为后来会发生错位的情况<br>那么这就是第i个位置对结果的贡献<br>2</em>C(m+n-2,n-1)<em>(m+n-1)=2</em>n*C(m+n-1,n)</p><p>最后一推倒 就出来了这么一个公式<br>(1+2<em>n)</em>C(m+n-1,n)/C(m+n,n)<br>=(1+2<em>n)</em>m/(m+n)</p><p><strong> 贡献式思维主要就是求每个位置能对最后的结果贡献了多少 最后累加就行了 </strong></p><p>附本题代码<br>———————-.</p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;const int maxn = 505;const double  Pi =  acos(-1);#define pb push_backLL gcd(LL a,LL b){    if(!b) return a;    else return gcd(b,a%b);}int main(){    int m,n;    LL a,b;    while(scanf(&quot;%d%d&quot;,&amp;n,&amp;m)!=EOF)    {        a=(n+n+1)*m;        b=m+n;        if(a%b==0)printf(&quot;%I64d\n&quot;,a/b);        else  printf(&quot;%I64d/%I64d\n&quot;,a/gcd(a,b),b/gcd(a,b));    }    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  codeforces 664B Rebus [细节]</title>
      <link href="/2016/09/01/52400477/"/>
      <url>/2016/09/01/52400477/</url>
      
        <content type="html"><![CDATA[<h1 id="codeforces-664B-Rebus-细节"><a href="#codeforces-664B-Rebus-细节" class="headerlink" title="codeforces 664B Rebus [细节]"></a>codeforces 664B Rebus [细节]</h1><p>2016年09月01日 15:54:48  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：449</p><hr><p> 博客爬取于<code>2019-04-18 17:19:46</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/52400477" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/52400477</a></p><p>题目链接： <a href="http://codeforces.com/problemset/problem/664/B" target="_blank" rel="noopener"> http://codeforces.com/problemset/problem/664/B</a><br>———————————.<br>B. Rebus<br>time limit per test1 second<br>memory limit per test256 megabytes<br>inputstandard input<br>outputstandard output<br>You are given a rebus of form ? + ? - ? + ? = n, consisting of only question<br>marks, separated by arithmetic operation ‘+’ and ‘-‘, equality and positive<br>integer n. The goal is to replace each question mark with some positive<br>integer from 1 to n, such that equality holds.</p><p>Input<br>The only line of the input contains a rebus. It’s guaranteed that it contains<br>no more than 100 question marks, integer n is positive and doesn’t exceed 1<br>000 000, all letters and integers are separated by spaces, arithmetic<br>operations are located only between question marks.</p><p>Output<br>The first line of the output should contain “Possible” (without quotes) if<br>rebus has a solution and “Impossible” (without quotes) otherwise.</p><p>If the answer exists, the second line should contain any valid rebus with<br>question marks replaced by integers from 1 to n. Follow the format given in<br>the samples.</p><p>Examples<br>input<br>? + ? - ? + ? + ? = 42<br>output<br>Possible<br>9 + 13 - 39 + 28 + 31 = 42<br>input<br>? - ? = 1<br>output<br>Impossible<br>input<br>? = 1000000<br>output<br>Possible<br>1000000 = 1000000</p><p>——————————————.</p><p>题目大意 ：<br>就是把问好（?）的数用1~n填上 如果存在等式能够成立的情况就输出Possible 和这个等式 （有SPJ）<br>否则输出Impossible</p><p>题目分析：<br>先把加上的数有几个 减去的数有几个统计一下<br>然后把每个数都附上1<br>接着把差的数匀乎匀乎就行了</p><p>附本题代码<br>———————————-.</p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;const int maxn = 505;char a[101];int numjia[101];int numjian[101];void debug(){    printf(&quot;%d &quot;,numjia[0]);    int j=1,jn=0;    int l = strlen (a);    for(int i=2; i&lt;l; i++)    {        if(a[i-2]==&#39;+&#39;)  printf(&quot;%d&quot;,numjia[j++]) ;        else if(a[i-2]==&#39;-&#39;)  printf(&quot;%d&quot;,numjian[jn++]) ;        else printf(&quot;%c&quot;,a[i]);    }    puts(&quot;&quot;);}int main(){    while(gets(a))    {        for(int i=0;i&lt;101;i++)        {            numjian[i]=1;            numjia[i]=0;        }        int l = strlen (a) ;        int jia=1,jian=0;        int n=0;        bool flag = false;        for(int i=0; i&lt;l; i++)        {            if(a[i]==&#39;+&#39;) jia++;            if(a[i]==&#39;-&#39;) jian++;            if(flag||a[i-2]==&#39;=&#39;)            {                flag = true ;                n=n*10+a[i]-&#39;0&#39;;            }        }        //  printf(&quot;%d\n&quot;,n);        int tem = n/jia;        for(int i=0; i&lt;jia; i++)            numjia[i] = tem;        tem = n%jia+jian;        for(int i=0; i&lt;tem; i++)            numjia[i%jia]++;        bool fla = true ,fl = true,f = true;        int tt = 0;        for(int i=0; i&lt;jia; i++)            if(1&lt;=numjia[i]&amp;&amp;numjia[i]&lt;=n)    ;            else   if(numjia[i] == 0) tt++, numjia[i] = 1,fl=false;            else   fla = false;        //printf(&quot; ==  %d\n&quot;,fla);        if(jian)        {            tem = tt/jian;            for(int i=0; i&lt;jia; i++)                numjian[i] = tem+1;            tem = tt%jian;            for(int i=0; i&lt;tem; i++)                numjian[i%jian]++;            for(int i=0; i&lt;jian; i++)                if(1&lt;=numjian[i]&amp;&amp;numjian[i]&lt;=n)    ;                else   fla = false;            fl = true;        }        // debug();        // printf(&quot; ==  %d\n&quot;,fla);        int sum = 0;        for(int i=0; i&lt;jia; i++)            sum+=numjia[i];        for(int i=0; i&lt;jian; i++)            sum-=numjian[i];        if(sum!=n)f=false;        if(fla&amp;&amp;fl)        {            puts(&quot;Possible&quot;);            printf(&quot;%d &quot;,numjia[0]);            int j=1,jn=0;            for(int i=2; i&lt;l; i++)            {                if(a[i-2]==&#39;+&#39;)       printf(&quot;%d&quot;,numjia[j++]) ;                else if(a[i-2]==&#39;-&#39;)  printf(&quot;%d&quot;,numjian[jn++]) ;                else                printf(&quot;%c&quot;,a[i]);            }            puts(&quot;&quot;);        }        else       puts(&quot;Impossible&quot;);    }    return 0;}/*? + ? + ? + ? - ? = 1? + ? + ? + ? - ? + ? + ? = 4*/</code></pre>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  UVA 1386 cellular automaton [循环矩阵+矩阵快速幂]【数学】</title>
      <link href="/2016/09/01/52399129/"/>
      <url>/2016/09/01/52399129/</url>
      
        <content type="html"><![CDATA[<h1 id="UVA-1386-cellular-automaton-循环矩阵-矩阵快速幂-【数学】"><a href="#UVA-1386-cellular-automaton-循环矩阵-矩阵快速幂-【数学】" class="headerlink" title="UVA 1386 cellular automaton [循环矩阵+矩阵快速幂]【数学】"></a>UVA 1386 cellular automaton [循环矩阵+矩阵快速幂]【数学】</h1><p>2016年09月01日 14:02:59  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：866</p><hr><p> 博客爬取于<code>2019-04-18 17:19:47</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/52399129" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/52399129</a></p><p>题目链接 : <a href="https://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;category=446&amp;page=show_problem&amp;problem=4132" target="_blank" rel="noopener"> 太长了_传送阵&lt;&lt;– </a></p><p>————————————.<br>A cellular automaton is a collection of cells on a grid of specified shape<br>that evolves through a number<br>of discrete time steps according to a set of rules that describe the new state<br>of a cell based on the states<br>of neighboring cells. The order of the cellular automaton is the number of<br>cells it contains. Cells of the<br>automaton of order n are numbered from 1 to n.<br>The order of the cell is the number of different values it may contain.<br>Usually, values of a cell of<br>order m are considered to be integer numbers from 0 to m − 1.<br>One of the most fundamental properties of a cellular automaton is the type of<br>grid on which it<br>is computed. In this problem we examine the special kind of cellular automaton<br>— circular cellular<br>automaton of order n with cells of order m. We will denote such kind of<br>cellular automaton as n, m −<br>automaton.<br>A distance between cells i and j in n, m-automaton is defined as min(|i − j|,<br>n − |i − j|). A denvironment<br>of a cell is the set of cells at a distance not greater than d.<br>On each d-step values of all cells are simultaneously replaced by new values.<br>The new value of cell i<br>after d-step is computed as a sum of values of cells belonging to the<br>d-enviroment of the cell i modulo<br>m.<br>The following picture shows 1-step of the 5,3-automaton.<br><img src="https://img-blog.csdn.net/20160901134908364" alt="这里写图片描述"><br>The problem is to calculate the state of the n, m-automaton after k d-steps.<br>Input<br>The input file contains several test cases, each of them consists of two<br>lines, as described below.<br>The first line of the input contains four integer numbers n, m, d, and k (1 ≤<br>n ≤ 500, 1 ≤ m ≤<br>1000000, 0 ≤ d &lt; n<br>2<br>, 1 ≤ k ≤ 10000000). The second line contains n integer numbers from 0 to m −<br>1<br>— initial values of the automaton’s cells.<br>Output<br>For each test case, write to the output, on a line by itself, the values of<br>the n, m-automaton’s cells after<br>k d-steps.<br>Sample Input<br>5 3 1 1<br>1 2 2 1 2<br>5 3 1 10<br>1 2 2 1 2<br>Sample Output<br>2 2 2 2 1<br>2 0 0 2 2</p><p>————————————————.<br>题目大意 :<br>就是有一个 <strong> N </strong> 这么大的环 现在有这样的操作每次选取每个数及其左右 <strong> d </strong> 个距离内的所有数的和 对 <strong> m </strong><br>取模之后作为这个数的新值 问你K次操作后 每个数都是多少</p><p>解题思路 :<br>首先根据题中的 图片 观察了一下 发现这道题用矩阵快速幂能够解决<br>以题目图片为例 能构造出如下的矩阵<br>[1 1 0 0 1] 这 [1] = [2]<br>[1 1 1 0 0] 里 [2] = [2]<br>[0 1 1 1 0] 是 [2] = [2]<br>[0 0 1 1 1] 乘 [1] = [2]<br>[1 0 0 1 1] 号 [2] = [1]</p><p>然后写了一发矩阵快速幂<br>写完了 发现程序根本运行不了<br>找了N久BUG 最后在Q巨的指导下才知道 因为数组太大500*500 导致爆栈了<br>然后把 函数改成引用 就能运行了 但是还是不能A掉题</p><p>然后又找了N久的BUG 换了下思路 发现越来越乱</p><p>最后看了一波题解 才知道(如下)这玩意叫做循环矩阵<br>[1 1 0 0 1]<br>[1 1 1 0 0]<br>[0 1 1 1 0]<br>[0 0 1 1 1]<br>[1 0 0 1 1]</p><p>它的性质可以看着篇文章 后面的部分 目录里找矩阵快速幂就行了<br><a href="http://blog.csdn.net/qq_33184171/article/details/51488462" target="_blank" rel="noopener"> http://blog.csdn.net/qq_33184171/article/details/51488462</a></p><p>然后终于优化到了N^2<br>结果最后的结果 莫名的PE PE PE!!!! PE 了5 发我也是醉了 最醉了的是 到最后我也没明白为什么PE<br>然后找了一发大神的代码 直接AC了。。。<br>格式没问题啊，，，<br><img src="https://img-blog.csdn.net/20160901140003404" alt="这里写图片描述"></p><p>然后就没有然后了 这题 做的太闹心了 在群里问问题的时候还被 菊菊们讽刺了一波。。。</p><p>算了 最后附上本题代码<br>————————-.</p><pre><code>#include &lt;iostream&gt;  #include &lt;cstdio&gt;  #include &lt;cstring&gt;  #include &lt;algorithm&gt;  using namespace std;  typedef long long ll;  const int maxn = 505;  int n, m, d, k;  ll ans[maxn], matrix[maxn];  ll c[maxn+5];  void mul(ll a[], ll b[]) {      memset(c, 0, sizeof(c));      for (int i = 0; i &lt; n; i++)           for (int j = 0; j &lt; n; j++)              c[i] += a[j] * b[(i-j+n) % n];      for (int i = 0; i &lt; n; i++)           b[i] = c[i] % m;  }  int main() {      while (scanf(&quot;%d%d%d%d&quot;, &amp;n, &amp;m, &amp;d, &amp;k) != EOF) {          memset(ans, 0, sizeof(ans));          memset(matrix, 0, sizeof(matrix));          for (int i = 0; i &lt; n; i++)               cin&gt;&gt;ans[i];          matrix[0] = 1;          for (int i = 1; i &lt;= d; i++)               matrix[i] = matrix[n - i] = 1;          while (k) {              if (k &amp; 1)                   mul(matrix, ans);              mul(matrix, matrix);              k &gt;&gt;= 1;          }          for (int i = 0; i &lt; n - 1; i++)               printf(&quot;%lld &quot;, ans[i]);          printf(&quot;%lld\n&quot;, ans[n-1]);      }      return 0;  }  </code></pre>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  FZU 2109 Mountain Number [数位DP]【动态规划】</title>
      <link href="/2016/08/31/52385951/"/>
      <url>/2016/08/31/52385951/</url>
      
        <content type="html"><![CDATA[<h1 id="FZU-2109-Mountain-Number-数位DP-【动态规划】"><a href="#FZU-2109-Mountain-Number-数位DP-【动态规划】" class="headerlink" title="FZU 2109 Mountain Number [数位DP]【动态规划】"></a>FZU 2109 Mountain Number [数位DP]【动态规划】</h1><p>2016年08月31日 15:57:33  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：203<br>标签：  <a href="https://so.csdn.net/so/search/s.do?q=动态规划&amp;t=blog" target="_blank" rel="noopener"> 动态规划 </a> <a href="https://so.csdn.net/so/search/s.do?q=dp&amp;t=blog" target="_blank" rel="noopener"> dp</a></p><p>个人分类：  <a href="https://blog.csdn.net/qq_33184171/article/category/6362379" target="_blank" rel="noopener"> ===== 各OJ =====</a></p><hr><p> 博客爬取于<code>2019-04-18 17:19:48</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/52385951" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/52385951</a></p><p>题目链接： <a href="http://acm.fzu.edu.cn/problem.php?pid=2109" target="_blank" rel="noopener"> http://acm.fzu.edu.cn/problem.php?pid=2109</a><br>——————————–.<br>Problem 2109 Mountain Number<br>Accept: 231 Submit: 592<br>Time Limit: 1000 mSec Memory Limit : 32768 KB</p><p>Problem Description</p><p>One integer number x is called “Mountain Number” if:</p><p>(1) x&gt;0 and x is an integer;</p><p>(2) Assume x=a[0]a[1]…a[len-2]a<a href="0≤a[i]≤9, a[0] is positive">len-1</a>. Any<br>a[2i+1] is larger or equal to a[2i] and a<a href="if exists">2i+2</a>.</p><p>For example, 111, 132, 893, 7 are “Mountain Number” while 123, 10, 76889 are<br>not “Mountain Number”.</p><p>Now you are given L and R, how many “Mountain Number” can be found between L<br>and R (inclusive) ?</p><p>Input</p><p>The first line of the input contains an integer T (T≤100), indicating the<br>number of test cases.</p><p>Then T cases, for any case, only two integers L and R (1≤L≤R≤1,000,000,000).</p><p>Output</p><p>For each test case, output the number of “Mountain Number” between L and R in<br>a single line.<br>Sample Input</p><p>3<br>1 10<br>1 100<br>1 1000<br>Sample Output</p><p>9<br>54<br>384<br>Source</p><p>“高教社杯”第三届福建省大学生程序设计竞赛</p><p>—————————————————————.<br>题目大意:<br>就是给你一个区间[l,r]<br>问你在这个区间内满足从高位起偶数位的数字要 <strong> &gt;= </strong> 两边的数字 这样的有多少个</p><p>解题思路:<br>标准的数位DP<br>dp[第多少位][上一位的数字][奇数位or偶数位];<br>开这样一个数组 然后DP就行了<br>我用的记忆华搜索<br>dfs(int pos,int weishu,int pre,int limit)<br>dfs(第多少位,位数,上一位的数字,限制)；</p><p>决策的时候</p><pre><code>    for(int i=0; i&lt;=endi; i++)    {        if(weishu==1) //表示前面还是只有前导0            if(i==0)    res+=dfs(pos-1,weishu  ,9,limit&amp;&amp;(i==endi));            else        res+=dfs(pos-1,weishu+1,i,limit&amp;&amp;(i==endi));        if(weishu%2==1&amp;&amp;weishu!=1)//奇数位            if(pre&gt;=i)  res+=dfs(pos-1,weishu+1,i,limit&amp;&amp;(i==endi));        if(weishu%2==0)  //偶数位            if(pre&lt;=i)  res+=dfs(pos-1,weishu+1,i,limit&amp;&amp;(i==endi));    }</code></pre><p>如果觉得还是wrong的注意下输出是%lld 还是%I64d<br>%lld 就会返回wrong answer<br>还有就是FZU不支持 #include &lt; bits/stdc++.h&gt;</p><p>附本题代码<br>————————————————.</p><pre><code>#include &lt;iostream&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;using namespace std;typedef long long LL;const int MOD  = 1e9+7;const int maxn = 200010;int num[70],len;LL  dp[50][12][5];LL dfs(int pos,int weishu,int pre,int limit){    if(pos &lt; 0)    return 1;    if(dp[pos][pre][weishu%2]!=-1&amp;&amp;!limit)        return dp[pos][pre][weishu%2];    int endi = 9;    if(limit) endi = num[pos];    LL res = 0;    for(int i=0; i&lt;=endi; i++)    {        if(weishu==1)            if(i==0)    res+=dfs(pos-1,weishu  ,9,limit&amp;&amp;(i==endi));            else        res+=dfs(pos-1,weishu+1,i,limit&amp;&amp;(i==endi));        if(weishu%2==1&amp;&amp;weishu!=1)            if(pre&gt;=i)  res+=dfs(pos-1,weishu+1,i,limit&amp;&amp;(i==endi));        if(weishu%2==0)            if(pre&lt;=i)  res+=dfs(pos-1,weishu+1,i,limit&amp;&amp;(i==endi));    }    if(!limit) dp[pos][pre][weishu%2] = res;    return res;}LL solve(LL n){    len = 0;    while(n)    {        num[len++] = n%10;        n /= 10;    }    return dfs(len-1,1,9,1);}int main(){    memset(dp,-1,sizeof(dp));    int _,p=0;    scanf(&quot;%d&quot;,&amp;_);    while(_--)    {        LL n,m;        scanf(&quot;%I64d%I64d&quot;,&amp;m,&amp;n);       // printf(&quot;%lld %lld\n&quot;,solve(n),solve(m-1));        printf(&quot;%I64d\n&quot;,solve(n)-solve(m-1));    }    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
            <tag> dp </tag>
            
            <tag> 各OJ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  NYOJ 737 Cake [区间DP]【动态规划】</title>
      <link href="/2016/08/27/52336164/"/>
      <url>/2016/08/27/52336164/</url>
      
        <content type="html"><![CDATA[<h1 id="NYOJ-737-Cake-区间DP-【动态规划】"><a href="#NYOJ-737-Cake-区间DP-【动态规划】" class="headerlink" title="NYOJ 737 Cake [区间DP]【动态规划】"></a>NYOJ 737 Cake [区间DP]【动态规划】</h1><p>2016年08月27日 17:33:29  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：355</p><hr><p> 博客爬取于<code>2019-04-18 17:19:49</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/52336164" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/52336164</a></p><p>题目链接: <a href="http://acm.nyist.edu.cn/JudgeOnline/status.php?pid=737" target="_blank" rel="noopener"> http://acm.nyist.edu.cn/JudgeOnline/status.php?pid=737</a><br>——————————-.<br>石子合并（一）<br>时间限制：1000 ms | 内存限制：65535 KB<br>难度：3<br>描述<br>有N堆石子排成一排，每堆石子有一定的数量。现要将N堆石子并成为一堆。合并的过程只能每次将相邻的两堆石子堆成一堆，每次合并花费的代价为这两堆石子的和，经过N-<br>1次合并后成为一堆。求出总的代价最小值。<br>输入<br>有多组测试数据，输入到文件结束。<br>每组测试数据第一行有一个整数n，表示有n堆石子。<br>接下来的一行有n（0&lt; n &lt;200）个数，分别表示这n堆石子的数目，用空格隔开<br>输出<br>输出总代价的最小值，占单独的一行<br>样例输入<br>3<br>1 2 3<br>7<br>13 7 8 16 21 4 18<br>样例输出<br>9<br>239</p><p>————————————.</p><p>解题思路:<br>题目要求必须是相邻的两堆才能合并 所以不能用优先队列处理<br>想到区间dp<br>dp[i][j] 表示i~j区间内的最小花费</p><p>每次维护区间合并的最小值 即可<br>但要注意 花费的问题是累加的 所以每一次区间的维护中应该加上区间内所有的和 用前缀和处理</p><p>状态转移方程是<br>dp[i][j]=min(dp[i][j],dp[i][k]+dp[k+1][j]+sum[j]-sum[i-1]);</p><p>当然本题也可以采用平行四边形优化 跑的能跟快一点<br>方法是 用另外一个数组记录最有分割点 也就是枚举的K</p><p>附本题代码<br>————————–.</p><pre><code>//#include &lt;bits/stdc++.h&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;iostream&gt;using namespace std;#define lalal puts(&quot;*****&quot;);typedef long long LL;const int MOD  = 1000000007;const int maxn = 200010;const int INF  = 0x1f1f1f1f;int dp[222][222];int a[222];int sum[222];int main(){    int n;    while(~scanf(&quot;%d&quot;,&amp;n))    {        memset(dp,0,sizeof(dp));        for(int i=0;i&lt;n;i++)            scanf(&quot;%d&quot;,&amp;a[i]);        sum[0]=a[0];        for(int i=1;i&lt;n;i++)            sum[i]=sum[i-1]+a[i];        for(int l=1;l&lt;n;l++)        {            for(int i=0,j=l;j&lt;n;i++,j++)            {                dp[i][j] = INF;                for(int k=i;k&lt;j;k++)                   dp[i][j]=min(dp[i][j],dp[i][k]+dp[k+1][j]+sum[j]-sum[i-1]);            }        }        printf(&quot;%d\n&quot;,dp[0][n-1]);    }    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  POJ 2955 Brackets [区间DP]【动态规划】</title>
      <link href="/2016/08/27/52335175/"/>
      <url>/2016/08/27/52335175/</url>
      
        <content type="html"><![CDATA[<h1 id="POJ-2955-Brackets-区间DP-【动态规划】"><a href="#POJ-2955-Brackets-区间DP-【动态规划】" class="headerlink" title="POJ 2955 Brackets [区间DP]【动态规划】"></a>POJ 2955 Brackets [区间DP]【动态规划】</h1><p>2016年08月27日 14:49:48  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：384</p><hr><p> 博客爬取于<code>2019-04-18 17:19:50</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/52335175" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/52335175</a></p><p>题目链接： <a href="http://poj.org/problem?id=2955" target="_blank" rel="noopener"> http://poj.org/problem?id=2955 </a><br>———————————.<br>Brackets<br>Time Limit: 1000MS Memory Limit: 65536K<br>Total Submissions: 6430 Accepted: 3443<br>Description</p><p>We give the following inductive definition of a “regular brackets” sequence:</p><p>the empty sequence is a regular brackets sequence,<br>if s is a regular brackets sequence, then (s) and [s] are regular brackets<br>sequences, and<br>if a and b are regular brackets sequences, then ab is a regular brackets<br>sequence.<br>no other sequence is a regular brackets sequence<br>For instance, all of the following character sequences are regular brackets<br>sequences:</p><p>(), [], (()), ()[], ()[()]</p><p>while the following character sequences are not:</p><p>(, ], )(, ([)], ([(]</p><p>Given a brackets sequence of characters a1a2 … an, your goal is to find the<br>length of the longest regular brackets sequence that is a subsequence of s.<br>That is, you wish to find the largest m such that for indices i1, i2, …, im<br>where 1 ≤ i1 &lt; i2 &lt; … &lt; im ≤ n, ai1ai2 … aim is a regular brackets sequence.</p><p>Given the initial sequence ([([]])], the longest regular brackets subsequence<br>is [([])].</p><p>Input</p><p>The input test file will contain multiple test cases. Each input test case<br>consists of a single line containing only the characters (, ), [, and ]; each<br>input test will have length between 1 and 100, inclusive. The end-of-file is<br>marked by a line containing the word “end” and should not be processed.</p><p>Output</p><p>For each input case, the program should print the length of the longest<br>possible regular brackets subsequence on a single line.</p><p>Sample Input</p><p>((()))<br>()()()<br>([]])<br>)[)(<br>([][][)<br>end<br>Sample Output</p><p>6<br>6<br>4<br>0<br>6</p><hr><p>题目大意：就是问你 整个区间内 不连续的能匹配上的括号的总数</p><p>解题思路：<br>区间DP<br>dp[i][j] = i~j 区间内能够匹配的括号的个数<br>很简单 详见代码吧</p><p>附本题代码<br>—————————————-.</p><pre><code>//#include &lt;bits/stdc++.h&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;iostream&gt;using namespace std;#define lalal puts(&quot;*****&quot;);typedef long long LL;const int MOD  = 1000000007;const int maxn = 200010;int dp[101][101];char a[101];int main(){    while(scanf(&quot;%s&quot;,a)!=EOF)    {        memset(dp,0,sizeof(dp));        if(a[0]==&#39;e&#39;)  break;        int l = strlen(a);        for(int len=1; len&lt;l; len++) //区间的长度            for(int i=0,j=len; j&lt;l; i++,j++)   //不同的区间啊            {                if(a[i]==&#39;(&#39;&amp;&amp;a[j]==&#39;)&#39;||a[i]==&#39;[&#39;&amp;&amp;a[j]==&#39;]&#39;)  //如果区间两边能够构成括号的匹配 就+2                    dp[i][j]=dp[i+1][j-1]+2;                for(int k=i; k&lt;j; k++)                          //合并区间啊 维护最大值                    dp[i][j]=max(dp[i][j],dp[i][k]+dp[k+1][j]);            }        printf(&quot;%d\n&quot;,dp[0][l-1]);    }    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  codeforces 55D beautiful number [数学+数位DP]【动态规划+数论】</title>
      <link href="/2016/08/26/52332586/"/>
      <url>/2016/08/26/52332586/</url>
      
        <content type="html"><![CDATA[<h1 id="codeforces-55D-beautiful-number-数学-数位DP-【动态规划-数论】"><a href="#codeforces-55D-beautiful-number-数学-数位DP-【动态规划-数论】" class="headerlink" title="codeforces 55D beautiful number [数学+数位DP]【动态规划+数论】"></a>codeforces 55D beautiful number [数学+数位DP]【动态规划+数论】</h1><p>2016年08月26日 23:24:05  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：1437</p><hr><p> 博客爬取于<code>2019-04-18 17:19:51</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/52332586" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/52332586</a></p><p>题目连接 : <a href="http://codeforces.com/problemset/problem/55/D" target="_blank" rel="noopener"> http://codeforces.com/problemset/problem/55/D</a><br>——————————-.<br>D. Beautiful numbers<br>time limit per test4 seconds<br>memory limit per test256 megabytes<br>inputstandard input<br>outputstandard output<br>Volodya is an odd boy and his taste is strange as well. It seems to him that a<br>positive integer number is beautiful if and only if it is divisible by each of<br>its nonzero digits. We will not argue with this and just count the quantity of<br>beautiful numbers in given ranges.</p><p>Input<br>The first line of the input contains the number of cases t (1 ≤ t ≤ 10). Each<br>of the next t lines contains two natural numbers li and ri (1 ≤ li ≤ ri ≤ 9<br>·10^18).</p><p>Please, do not use %lld specificator to read or write 64-bit integers in C++.<br>It is preffered to use cin (also you may use %I64d).</p><p>Output<br>Output should contain t numbers — answers to the queries, one number per line<br>— quantities of beautiful numbers in given intervals (from li to ri,<br>inclusively).</p><p>Examples<br>input<br>1<br>1 9<br>output<br>9<br>input<br>1<br>12 15<br>output<br>2<br>———————————.</p><p>题目大意 :<br>就是求区间内能被所有位上的数字(!0)整除的数的个数</p><p>解题思路 ：</p><p>困了 明天再写吧，，<br>首先这很明显是一个数位DP<br>满足被所有位上的数字(!0)整除的数 其实就是满足被这些位数的lcm整除<br>然后就是怎么处理一个数在不断变化中 还要对lcm{xi}取模呢<br>这时候就要仔细思索其中的奥妙 也是本题最重要的一点.<br>首先lcm{1~9}=2520;<br>想到每个数都是1~9中某些数字的lcm 所以他们一定能整除2520</p><p>因为 <strong> 若a≡b(mod m) 且d|m 则a≡b(mod d); </strong><br>转化一下 <strong> 设b已经是对m取完模的了 </strong><br>于是得到 <strong> 若a % m=b%m 且d|m 则a % d = b%d; </strong><br>因为 <strong> b=b%m </strong> 所以 <strong> b=b%m=b%d </strong><br>所以 <strong> b%m%m=b%d%m </strong><br>所以 <strong> b%m=b%d(km)%m </strong></p><p>所以可以得到下 <strong> x%km%m&lt;=&gt;x%m </strong></p><p>综上所述 x%2520%lcm{xi}==0 ; 是满足条件<br>而x%2520 是可以确定的 和大数取模类似<br>mod = (mod*10+本位数字)%2520 ;</p><p>所以我们开数组的时候要有x%2520 和lcm{xi}这两项 再加上位数 所以 数组应该这么开<br>dp[位数][x%2520][lcm{xi}];</p><p>但是这么开的话是这样的 dp[19][2520][2520] 19<em>2520</em>2520 = 120657600<br>即使CF提供的256M的内存也会炸的不要不要的<br>所以得想办法优化一下</p><p>然后就想啊想 终于~~<br>想到每个数只能是1~9的最小公倍数 所以计算了下 所有的lcm一共有48种可 能 如下:<br>1 2 3 4 5 6 7 8 9 10 12 14 15 18 20 21 24 28 30 35 36 40 42 45 56 60 63 70 72<br>84 90 105 120 126 140 168 180 210 252 280 315 360 420 504 630 840 1260 2520<br>共计48种<br>然后就可以离散化一下 这样 dp[19][2520][2520]–&gt;dp[19][2520][48]; 降低了空间复杂度 就可以AC了;</p><p>其实还可以继续优化 因为上面的结论 所以 %2520 &lt;=&gt;%252的 所以最后的数组可以优化到dp[19][252][48];<br>这样的时空复杂度均能得到下降<br>大家可以自己试一试</p><p>附本题代码<br>————————————.</p><pre><code>#include &lt;bits/stdc++.h&gt;using namespace std;#define lalal puts(&quot;*****&quot;);typedef long long LL;const int MOD  = 1000000007;const int maxn = 200010;int  num[30],len;LL  dp[30][2550][50];int a[50],has[2520];//x%2520%lcm == 0int gcd(int a,int b){    if(!b) return a;    else return gcd(b,a%b);}int llcm(int a,int b){    return a/gcd(a,b)*b;}LL dfs(int pos,int mod,int lcm,int limit){    if(pos&lt;0) return mod%lcm==0;    if(!limit&amp;&amp;dp[pos][mod][has[lcm]]!=-1)        {  //          lalal;            return dp[pos][mod][has[lcm]];        }    int endi = 9;    if(limit) endi = num[pos];    LL res = 0;    int tlcm ;    for(int i=0; i&lt;=endi; i++)    {        if(!i) tlcm = lcm;        else   tlcm = llcm(lcm,i);        res += dfs(pos-1,(mod*10+i)%2520,tlcm,limit&amp;&amp;(i==endi));    }    if(!limit) dp[pos][mod][has[lcm]] = res;    return res;}LL solve(LL n){    len = 0;    while(n)    {        num[len++] = n%10;        n /= 10;    }    return dfs(len-1,0,1,1);}void init(){    memset(has,0,sizeof(has));    int tem ;    for(int i=0;i&lt;(1&lt;&lt;9);i++)    {        tem = 1;        for(int j=1;j&lt;=9;j++)        {            if(i&amp;(1&lt;&lt;j))                tem = llcm(tem,j+1);        }        has[tem]=1;    }    int l = 0;    for(int i=0;i&lt;=2520;i++)        if(has[i]) a[l]=i,has[i]=l++;/*    for(int i=0;i&lt;l;i++)  printf(&quot;%d %d\n&quot;,has[a[i]],a[i]);    puts(&quot;&quot;);    printf(&quot;%d\n&quot;,l);*/}int main(){   // printf(&quot;%d\n&quot;,2520*2520);   init();    memset(dp,-1,sizeof(dp));    int _;    scanf(&quot;%d&quot;,&amp;_);    while(_--)    {        LL n,m;        scanf(&quot;%I64d%I64d&quot;,&amp;m,&amp;n);        //cout &lt;&lt;n&lt;&lt;&quot;  &quot;&lt;&lt;m&lt;&lt;endl;        // printf(&quot;%I64d %I64d\n&quot;,solve(n),solve(m-1));        printf(&quot;%I64d\n&quot;,solve(n)-solve(m-1));    }    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  POJ 3252 Round Numbers [数位DP]【动态规划】</title>
      <link href="/2016/08/25/52319408/"/>
      <url>/2016/08/25/52319408/</url>
      
        <content type="html"><![CDATA[<h1 id="POJ-3252-Round-Numbers-数位DP-【动态规划】"><a href="#POJ-3252-Round-Numbers-数位DP-【动态规划】" class="headerlink" title="POJ 3252 Round Numbers [数位DP]【动态规划】"></a>POJ 3252 Round Numbers [数位DP]【动态规划】</h1><p>2016年08月25日 23:11:27  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：297</p><hr><p> 博客爬取于<code>2019-04-18 17:19:52</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/52319408" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/52319408</a></p><p>题目连接: <a href="http://poj.org/problem?id=3252" target="_blank" rel="noopener"> http://poj.org/problem?id=3252 </a><br>—————————–.<br>Round Numbers<br>Time Limit: 2000MS Memory Limit: 65536K<br>Total Submissions: 12190 Accepted: 4629<br>Description</p><p>The cows, as you know, have no fingers or thumbs and thus are unable to play<br>Scissors, Paper, Stone’ (also known as ‘Rock, Paper, Scissors’, ‘Ro, Sham,<br>Bo’, and a host of other names) in order to make arbitrary decisions such as<br>who gets to be milked first. They can’t even flip a coin because it’s so hard<br>to toss using hooves.</p><p>They have thus resorted to “round number” matching. The first cow picks an<br>integer less than two billion. The second cow does the same. If the numbers<br>are both “round numbers”, the first cow wins,<br>otherwise the second cow wins.</p><p>A positive integer N is said to be a “round number” if the binary<br>representation of N has as many or more zeroes than it has ones. For example,<br>the integer 9, when written in binary form, is 1001. 1001 has two zeroes and<br>two ones; thus, 9 is a round number. The integer 26 is 11010 in binary; since<br>it has two zeroes and three ones, it is not a round number.</p><p>Obviously, it takes cows a while to convert numbers to binary, so the winner<br>takes a while to determine. Bessie wants to cheat and thinks she can do that<br>if she knows how many “round numbers” are in a given range.</p><p>Help her by writing a program that tells how many round numbers appear in the<br>inclusive range given by the input (1 ≤ Start &lt; Finish ≤ 2,000,000,000).</p><p>Input</p><p>Line 1: Two space-separated integers, respectively Start and Finish.<br>Output</p><p>Line 1: A single integer that is the count of round numbers in the inclusive<br>range Start..Finish<br>Sample Input</p><p>2 12<br>Sample Output</p><p>6<br>Source</p><p>USACO 2006 November Silver<br>—————————.<br>题目大意 :<br>就是计算出区间[first,end]之间 二进制下 不含前导0且0的个数比1的个数多少的数的个数</p><p>解题思路:<br>跟人用的数位DP<br>后来看网上的题解 有用组合数学 解决的 有兴趣的话 可以去看一下 .</p><p>数位DP 就没什么好解释的了 分别记录下0和1的个数 然后DP就行了<br>DP[当前位数][1的个数][0的个数];;;<br>dfs(当前位数,被没被放过,1的个数,0的个数,数字限制);</p><p>但是在DP中鄙人出现了一个大的BUG 那就是如下的代码(问题已解决)</p><pre><code>/*在for循环的时候 鄙人最开始使用下面注释掉的方式写的代码  样例过了 但是提交上去WA了  最后上网上找到别人的题解  找代码对拍了一下 很快就发现了错误  最后dfs的方式还是枚举的 这样就直接过了  还是自己写的代码写挂了   但最后也没找到什么区别   如果您能发现我的方法具体在哪里出错了  请一定评论告知。*/    for(int i=0;i&lt;=endi;i++)    {        if(!pre)        {            if(!i)                res+=dfs(pos-1,0,0,0,limit&amp;&amp;(i==endi));            else                res+=dfs(pos-1,1,ji+1,ou,limit&amp;&amp;(i==endi));        }        else        {            if(!i)                res+=dfs(pos-1,1,ji,ou+1,limit&amp;&amp;(i==endi));            else                res+=dfs(pos-1,1,ji+1,ou,limit&amp;&amp;(i==endi));        }    }/*    {        if(pre&amp;&amp;ji&amp;&amp;!i)    tou=ou+1;        if(i)           tji=ji+1;        res += dfs(pos-1,pre||i,tji,tou,limit&amp;&amp;(i==endi));    }*/</code></pre><p>上面的问题 主要是tji,tou值的初始化有问题<br>改成这样就行了</p><pre><code> {        if(pre&amp;&amp;ji&amp;&amp;!i)    tou=ou+1;        else                tou=ou;        if(i)           tji=ji+1;        else                tji=ji;        if(!pre&amp;&amp;!i) tji=tou=0;        res += dfs(pos-1,pre||i,tji,tou,limit&amp;&amp;(i==endi));    }</code></pre><p>我那样的话值会错误的非常离谱因为判断的时候判断的就是ji,ou加不加1 的问题 而我渣忽略了没有操作的情况 导致值变成了0 最终造成结果错误 ..<br>/ _ 真TMZZ _ /</p><p>附本题代码<br>——————————-.</p><pre><code>//#include &lt;bits/stdc++.h&gt;#include &lt;iostream&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;using namespace std;#define lalal puts(&quot;*****&quot;);typedef long long LL;const int MOD  = 1000000007;const int maxn = 200010;int num[70],len;int  dp[70][70][70];int dfs(int pos,int pre,int ji,int ou,int limit){    if(pos&lt;0)        if(ou&gt;=ji||(!pre))   return 1;        else                return 0;    if(!limit&amp;&amp;pre&amp;&amp;dp[pos][ji][ou]!=-1)        return dp[pos][ji][ou];    int endi = 1;    if(limit) endi = num[pos];    int res = 0;    int tji=0,tou=0;    for(int i=0;i&lt;=endi;i++)    {        if(!pre)        {            if(!i)                res+=dfs(pos-1,0,0,0,limit&amp;&amp;(i==endi));            else                res+=dfs(pos-1,1,ji+1,ou,limit&amp;&amp;(i==endi));        }        else        {            if(!i)                res+=dfs(pos-1,1,ji,ou+1,limit&amp;&amp;(i==endi));            else                res+=dfs(pos-1,1,ji+1,ou,limit&amp;&amp;(i==endi));        }    }    if(!limit&amp;&amp;pre) dp[pos][ji][ou] = res;    return res;}int solve(int n){    len = 0;    while(n)    {        num[len++] = n&amp;1;        n &gt;&gt;= 1;    }    return dfs(len-1,0,0,0,1);}int main(){    memset(dp,-1,sizeof(dp));    int n,m;    while(~scanf(&quot;%d%d&quot;,&amp;m,&amp;n))    {       // printf(&quot;%lld %lld\n&quot;,solve(n),solve(m-1));        printf(&quot;%d\n&quot;,solve(n)-solve(m-1));    }    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  HDU 3709 Balanced Number [数位DP]【动态规划】</title>
      <link href="/2016/08/25/52317803/"/>
      <url>/2016/08/25/52317803/</url>
      
        <content type="html"><![CDATA[<h1 id="HDU-3709-Balanced-Number-数位DP-【动态规划】"><a href="#HDU-3709-Balanced-Number-数位DP-【动态规划】" class="headerlink" title="HDU 3709 Balanced Number [数位DP]【动态规划】"></a>HDU 3709 Balanced Number [数位DP]【动态规划】</h1><p>2016年08月25日 20:07:46  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：253<br>标签：  <a href="https://so.csdn.net/so/search/s.do?q=动态规划&amp;t=blog" target="_blank" rel="noopener"> 动态规划 </a> <a href="https://so.csdn.net/so/search/s.do?q=dp&amp;t=blog" target="_blank" rel="noopener"> dp</a></p><p>个人分类：  <a href="https://blog.csdn.net/qq_33184171/article/category/6117382" target="_blank" rel="noopener"> hdu </a> <a href="https://blog.csdn.net/qq_33184171/article/category/6362438" target="_blank" rel="noopener"><br>==== 动态规划 ==== </a></p><hr><p> 博客爬取于<code>2019-04-18 17:19:54</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/52317803" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/52317803</a></p><p>题目链接： <a href="http://acm.split.hdu.edu.cn/showproblem.php?pid=3709" target="_blank" rel="noopener"> http://acm.split.hdu.edu.cn/showproblem.php?pid=3709</a><br>——————————.</p><p>Balanced Number</p><p>Time Limit: 10000/5000 MS (Java/Others) Memory Limit: 65535/65535 K<br>(Java/Others)<br>Total Submission(s): 4621 Accepted Submission(s): 2169</p><p>Problem Description<br>A balanced number is a non-negative integer that can be balanced if a pivot is<br>placed at some digit. More specifically, imagine each digit as a box with<br>weight indicated by the digit. When a pivot is placed at some digit of the<br>number, the distance from a digit to the pivot is the offset between it and<br>the pivot. Then the torques of left part and right part can be calculated. It<br>is balanced if they are the same. A balanced number must be balanced with the<br>pivot at some of its digits. For example, 4139 is a balanced number with pivot<br>fixed at 3. The torqueses are 4<em>2 + 1</em>1 = 9 and 9*1 = 9, for left part and<br>right part, respectively. It’s your job<br>to calculate the number of balanced numbers in a given range [x, y].</p><p>Input<br>The input contains multiple test cases. The first line is the total number of<br>cases T (0 &lt; T ≤ 30). For each case, there are two integers separated by a<br>space in a line, x and y. (0 ≤ x ≤ y ≤ 1018).</p><p>Output<br>For each case, print the number of balanced numbers in the range [x, y] in a<br>line.</p><p>Sample Input<br>2<br>0 9<br>7604 24324</p><p>Sample Output<br>10<br>897</p><p>Author<br>GAO, Yuan</p><p>Source<br>2010 Asia Chengdu Regional Contest<br>————————–.<br>题目大意：<br>就是求[m,n]区间内的平衡数有多少<br>平衡数的定义为<br>在一个数中 找一个确定一位数字为”支点” 然后两边的每位数字的值乘上力矩(就是这位到支点的距离)的和相等 这样的数被的定义为平衡数;</p><p>解题思路:<br>还是标准的数位DP<br>只是要明确的一点是 同一个数 如果为平衡数的话 那么它的支点有且仅有一个 就是说两个数不能被计算两次;<br>所以在进行DP的时候只要枚举支点即可</p><p>还有就是两边的和相等 可以转化为两边的和为0 (只要规定了力矩的方向就能完成)<br>比如说1234321 支点很明显是4 然后1<em>3+2</em>2+3<em>1+3</em>(-1)+2<em>(-2)+1</em>(-3)==0;</p><p>上述明白了就可以DP了 鄙某用的是记忆化搜索的形式写的</p><p>dp[位数][力矩总和][支点的位数];</p><p>dfs(当前位数,支点,力矩总和,数位的限制);</p><p>附本题代码<br>————————.</p><pre><code>#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;const int MOD  = 1000000007;const int maxn = 200010;int num[70],len;LL  dp[20][2000][20];LL dfs(int pos,int o,int pre,int limit){    if(pos &lt; 0)   return pre==0;    if(pre&lt;0) return 0;    if(dp[pos][pre][o]!=-1&amp;&amp;!limit)        return dp[pos][pre][o];    int endi = 9;    if(limit) endi = num[pos];    LL res = 0;    for(int i=0; i&lt;=endi; i++)        res+=dfs(pos-1,o,pre+i*(pos-o),limit&amp;&amp;(i==endi));    if(!limit) dp[pos][pre][o] = res;    return res;}LL solve(LL n){    len = 0;    while(n)    {        num[len++] = n%10;        n /= 10;    }    LL res = 0;    for(int i=0;i&lt;len;i++)        res += dfs(len-1,i,0,1);    return res-len+1;}Balanced Numberint main(){    memset(dp,-1,sizeof(dp));    int _,p=0;    scanf(&quot;%d&quot;,&amp;_);    while(_--)    {        LL n,m;        scanf(&quot;%lld%lld&quot;,&amp;m,&amp;n);       // printf(&quot;%lld %lld\n&quot;,solve(n),solve(m-1));        printf(&quot;%lld\n&quot;,solve(n)-solve(m-1));    }    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hdu </tag>
            
            <tag> 动态规划 </tag>
            
            <tag> dp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  LightOJ 1140 How Many Zeroes？ [数位DP]【动态规划】</title>
      <link href="/2016/08/25/52315342/"/>
      <url>/2016/08/25/52315342/</url>
      
        <content type="html"><![CDATA[<h1 id="LightOJ-1140-How-Many-Zeroes？-数位DP-【动态规划】"><a href="#LightOJ-1140-How-Many-Zeroes？-数位DP-【动态规划】" class="headerlink" title="LightOJ 1140 How Many Zeroes？ [数位DP]【动态规划】"></a>LightOJ 1140 How Many Zeroes？ [数位DP]【动态规划】</h1><p>2016年08月25日 15:54:39  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：358</p><hr><p> 博客爬取于<code>2019-04-18 17:19:55</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/52315342" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/52315342</a></p><p>题目链接： <a href="http://www.lightoj.com/volume_showproblem.php?problem=1140" target="_blank" rel="noopener"> http://www.lightoj.com/volume_showproblem.php?problem=1140</a><br>————————————.<br>D - How Many Zeroes?<br>Time Limit:2000MS Memory Limit:32768KB 64bit IO Format:%lld &amp; %llu</p><p>Description<br>Jimmy writes down the decimal representations of all natural numbers between<br>and including m and n, (m ≤ n). How many zeroes will he write down?</p><p>Input<br>Input starts with an integer T (≤ 11000), denoting the number of test cases.</p><p>Each case contains two unsigned 32-bit integers m and n, (m ≤ n).</p><p>Output<br>For each case, print the case number and the number of zeroes written down by<br>Jimmy.</p><p>Sample Input<br>5<br>10 11<br>100 200<br>0 500<br>1234567890 2345678901<br>0 4294967295<br>Sample Output<br>Case 1: 1<br>Case 2: 22<br>Case 3: 92<br>Case 4: 987654304<br>Case 5: 3825876150</p><p>—————————————–.<br>题目大意 ：就是求区间[m,n]之间的所有数中 0的个数是多少 ?</p><p>解题思路 ： 、<br>标准的数位DP<br>dp[位数][0~9][0的个数];<br>然后记忆化搜索的时候<br>dfs(第几位,前面有没有非0的数,取数的限制,0的个数);<br>大概这样就能AC了 然后注意下细节就好了..</p><p>附本题代码<br>—————————-.</p><pre><code>#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;const int MOD  = 1000000007;const int maxn = 200010;int num[30];LL dp[30][12][20];LL dfs(int pos,int pre,int limit,int m){    if(pos &lt; 0) return m+(pre==0);    if(dp[pos][pre][m]!=-1&amp;&amp;!limit&amp;&amp;pre)        return dp[pos][pre][m];    int endi = 9;    if(limit) endi = num[pos];    LL res = 0;    for(int i=0;i&lt;=endi;i++)        res+=dfs(pos-1,i||pre,limit&amp;&amp;(i==endi),m+(pre&amp;&amp;i==0));    if(!limit &amp;&amp; pre) dp[pos][pre][m] = res;    return res;}LL solve(LL n){    int len = 0;    if(n==0) num[len++] = 0;    while(n)    {        num[len++] = n%10;        n/=10;    }    return dfs(len-1,0,1,0);}int main(){    memset(dp,-1,sizeof(dp));    int _,p=0;    scanf(&quot;%d&quot;,&amp;_);    while(_--)    {        LL n,m;        scanf(&quot;%lld%lld&quot;,&amp;n,&amp;m);       // printf(&quot;%lld %lld\n&quot;,solve(m),solve(n-1));        printf(&quot;Case %d: %lld\n&quot;,++p,solve(m)-solve(n-1));    }    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  codeforces 710D Two Arithmetic Progressions [同余方程]【数论】</title>
      <link href="/2016/08/24/52302558/"/>
      <url>/2016/08/24/52302558/</url>
      
        <content type="html"><![CDATA[<h1 id="codeforces-710D-Two-Arithmetic-Progressions-同余方程-【数论】"><a href="#codeforces-710D-Two-Arithmetic-Progressions-同余方程-【数论】" class="headerlink" title="codeforces 710D Two Arithmetic Progressions [同余方程]【数论】"></a>codeforces 710D Two Arithmetic Progressions [同余方程]【数论】</h1><p>2016年08月24日 17:32:54  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：579</p><hr><p> 博客爬取于<code>2019-04-18 17:19:56</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/52302558" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/52302558</a></p><p>题目链接： <a href="http://codeforces.com/problemset/problem/710/D" target="_blank" rel="noopener"> http://codeforces.com/problemset/problem/710/D</a><br>————————–.<br>D. Two Arithmetic Progressions<br>time limit per test1 second<br>memory limit per test256 megabytes<br>inputstandard input<br>outputstandard output<br>You are given two arithmetic progressions: a1k + b1 and a2l + b2. Find the<br>number of integers x such that L ≤ x ≤ R and x = a1k’ + b1 = a2l’ + b2, for<br>some integers k’, l’ ≥ 0.</p><p>Input<br>The only line contains six integers a1, b1, a2, b2, L, R (0 &lt; a1, a2 ≤ 2·109,<br>- 2·109 ≤ b1, b2, L, R ≤ 2·109, L ≤ R).</p><p>Output<br>Print the desired number of integers x.</p><p>Examples<br>input<br>2 0 3 3 5 21<br>output<br>3<br>input<br>2 4 3 0 6 17<br>output<br>2<br>—————————–.<br>题目大意 ：<br>就是给你a1, b1, a2, b2, L, R 在区间L~R找一个x 使得a1k’ + b1 = a2l’ + b2 问能找到的x的个数</p><p>解题思路 ：<br>根据题意 很明显的同余方程<br>x= b1 (mod a1)；<br>x= b2 (mod a2)；<br>然后解得x的最小正整数解之后 每次加上 lcm(a1,a2) 一直从l到r 这部分直接计算就能够得出<br>值得注意的是l与 b1,b2 的大小有关 在计算的时候l应取三者最大值;<br>Ps:题目很坑的是有负数的情况 也是赛后看了题解才知道。。</p><p>附本题代码<br>———————————–.</p><pre><code>#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;typedef long long ll;const int mod = 1000000007;const int maxn = 200010;LL exgcd(LL a,LL b,LL &amp;x,LL &amp;y){    if(!b)    {        x=1,y=0;        return a;    }    else    {        LL r = exgcd(b,a%b,x,y);        LL t = x;        x = y;        y = t - (a/b) * y;        return r;    }}LL labs(LL a){    if(a&lt;0) return -a;    else    return a;}int main(){    ios::sync_with_stdio(false);    LL a1,a2,b1,b2,l,r;    while(cin&gt;&gt;a1&gt;&gt;b1&gt;&gt;a2&gt;&gt;b2&gt;&gt;l&gt;&gt;r)    {        LL x,y;        LL d = exgcd(a1,a2,x,y);        if((b2-b1)%d)        {            puts(&quot;0&quot;);            continue;        }        x*=(b2-b1)/d;        x=(x%labs(a2/d)+labs(a2/d))%labs(a2/d);       LL cnt = x*a1+b1;       LL tmp = labs(a1*a2/d);       LL ans = 0;       l = max(l,max(b1,b2));       if(l&gt;r)       {           puts(&quot;0&quot;);           continue;       }       if(cnt&lt;=r) ans+=(r-cnt)/tmp+1;       if(cnt&lt;l)  ans-=(l-1-cnt)/tmp+1;       printf(&quot;%I64d\n&quot;,ans);    }    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  codeforces 710C Magic Odd Square 【杂类】</title>
      <link href="/2016/08/23/52294422/"/>
      <url>/2016/08/23/52294422/</url>
      
        <content type="html"><![CDATA[<h1 id="codeforces-710C-Magic-Odd-Square-【杂类】"><a href="#codeforces-710C-Magic-Odd-Square-【杂类】" class="headerlink" title="codeforces 710C Magic Odd Square 【杂类】"></a>codeforces 710C Magic Odd Square 【杂类】</h1><p>2016年08月23日 21:02:49  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：344</p><hr><p> 博客爬取于<code>2019-04-18 17:19:57</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/52294422" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/52294422</a></p><p>题目链接 ： <a href="http://codeforces.com/problemset/problem/710/C" target="_blank" rel="noopener"> http://codeforces.com/problemset/problem/710/C</a><br>———————————–.<br>C. Magic Odd Square<br>time limit per test1 second<br>memory limit per test256 megabytes<br>inputstandard input<br>outputstandard output<br>Find an n × n matrix with different numbers from 1 to n2, so the sum in each<br>row, column and both main diagonals are odd.</p><p>Input<br>The only line contains odd integer n (1 ≤ n ≤ 49).</p><p>Output<br>Print n lines with n integers. All the integers should be different and from 1<br>to n2. The sum in each row, column and both main diagonals should be odd.</p><p>Examples<br>input<br>1<br>output<br>1<br>input<br>3<br>output<br>2 1 4<br>3 5 7<br>6 9 8</p><p>—————————————–.<br>题目大意： 就是给你一个 <strong> _ 奇 _ </strong> 数N 让你把1~ N^2 填到N*N的 矩阵中 使得每行每列主对角线的和为奇数</p><p>解题思路：</p><p>附本题代码<br>—————————.</p><pre><code>#include&lt;stdio.h&gt;int main(){    int a[100][100],x;/*初始化*/    int i,j,m,n,temp;    printf(&quot;输出魔方矩阵n=&quot;);    scanf(&quot;%d&quot;,&amp;x);    while(x)    {        if(!(x%2))        {            printf(&quot;你输入了偶数，很遗憾本程序将退出&quot;);            return 0;        }        else        {            for(i=0; i&lt;x; i++)                for(j=0; j&lt;x; j++)                    a[i][j]=0;            i=0;            j=x/2;            a[i][j]=1;            for(temp=2; temp&lt;=x*x; temp++)            {                m=i;                n=j;                i--;                j++;                if(i&lt;0)      i=x-1;                if(j&gt;=x)     j=0;                if(a[i][j]!=0)                {                    i=m+1;                    j=n;                }                a[i][j]=temp;            }        }        for(i=0; i&lt;x; i++)        {            for(j=0; j&lt;x; j++)                printf(&quot;%4d&quot;,a[i][j]);            printf(&quot;\n&quot;);        }        printf(&quot;输出魔方矩阵n=&quot;);        scanf(&quot;%d&quot;,&amp;x);    }    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  codeforces 710E Generate a String [dp]【动态规划】</title>
      <link href="/2016/08/23/52289905/"/>
      <url>/2016/08/23/52289905/</url>
      
        <content type="html"><![CDATA[<h1 id="codeforces-710E-Generate-a-String-dp-【动态规划】"><a href="#codeforces-710E-Generate-a-String-dp-【动态规划】" class="headerlink" title="codeforces 710E Generate a String [dp]【动态规划】"></a>codeforces 710E Generate a String [dp]【动态规划】</h1><p>2016年08月23日 12:49:21  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：544</p><hr><p> 博客爬取于<code>2019-04-18 17:19:58</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/52289905" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/52289905</a></p><p>题目链接: <a href="http://codeforces.com/problemset/problem/710/E" target="_blank" rel="noopener"> http://codeforces.com/problemset/problem/710/E</a><br>————————————————-.<br>E. Generate a String<br>time limit per test2 seconds<br>memory limit per test512 megabytes<br>inputstandard input<br>outputstandard output<br>zscoder wants to generate an input file for some programming competition<br>problem.</p><p>His input is a string consisting of n letters ‘a’. He is too lazy to write a<br>generator so he will manually generate the input in a text editor.</p><p>Initially, the text editor is empty. It takes him x seconds to insert or<br>delete a letter ‘a’ from the text file and y seconds to copy the contents of<br>the entire text file, and duplicate it.</p><p>zscoder wants to find the minimum amount of time needed for him to create the<br>input file of exactly n letters ‘a’. Help him to determine the amount of time<br>needed to generate the input.</p><p>Input<br>The only line contains three integers n, x and y (1 ≤ n ≤ 107, 1 ≤ x, y ≤ 109)<br>— the number of letters ‘a’ in the input file and the parameters from the<br>problem statement.</p><p>Output<br>Print the only integer t — the minimum amount of time needed to generate the<br>input file.</p><p>Examples<br>input<br>8 1 1<br>output<br>4<br>input<br>8 1 10<br>output<br>8<br>————————————–.<br>题目大意 :<br>就是从0开始 每次可以+1或-1或<em>2 +-操作花费x </em>2操作花费y 问你达到n的最小花费是多少?</p><p>解题思路 :<br>就是DP<br>DP 的时候只要从0遍历到n即可 因为题目的数据范围是1e7 所以并不会超时<br>转移的时候一共决策三种状态 就是<br>1.由i-1 转移过来的<br>2.由i/2 转移过来的 这时候要区分下奇数还是偶数<br>——— 偶数很简单了 只要决策i 与 i/2 的状态就行了<br>——— 奇数的话 那么一定是前一个数<em>2+1或者</em>2-1达到的状态 由于遍历的时候已经判断了+1的情况 所以 这里只需考虑-1的情况就行 所以决策的事i 与<br>i/2+1</p><p>然后输出下结果就好了</p><p>附本题代码<br>——————————————-.</p><pre><code>#include &lt;bits/stdc++.h&gt;using namespace std;#define LL long long intconst int M = 1e7+7;LL dp[M];int main(){    ios::sync_with_stdio(false);    LL n,x,y;    while(cin&gt;&gt;n&gt;&gt;x&gt;&gt;y)    {        dp[0]=0,dp[1]=x;        for(int i=2;i&lt;=n;i++)        {            dp[i]=dp[i-1]+x;            if(i&amp;1) dp[i]=min(dp[i],dp[i/2+1]+y+x);            else    dp[i]=min(dp[i],dp[i/2]+y);        }        printf(&quot;%I64d\n&quot;,dp[n]);    }    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  HDU 3555 Bomb [数位DP]【动态规划】</title>
      <link href="/2016/08/22/52280031/"/>
      <url>/2016/08/22/52280031/</url>
      
        <content type="html"><![CDATA[<h1 id="HDU-3555-Bomb-数位DP-【动态规划】"><a href="#HDU-3555-Bomb-数位DP-【动态规划】" class="headerlink" title="HDU 3555 Bomb [数位DP]【动态规划】"></a>HDU 3555 Bomb [数位DP]【动态规划】</h1><p>2016年08月22日 20:34:43  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：339</p><hr><p> 博客爬取于<code>2019-04-18 17:19:59</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/52280031" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/52280031</a></p><p>题目链接 ：HDU最近比较炸 不贴链接了、、<br>——————.<br>Bomb</p><p>Time Limit: 2000/1000 MS (Java/Others) Memory Limit: 131072/65536 K<br>(Java/Others)<br>Total Submission(s): 15374 Accepted Submission(s): 5565</p><p>Problem Description<br>The counter-terrorists found a time bomb in the dust. But this time the<br>terrorists improve on the time bomb. The number sequence of the time bomb<br>counts from 1 to N. If the current number sequence includes the sub-sequence<br>“49”, the power of the blast would add one point.<br>Now the counter-terrorist knows the number N. They want to know the final<br>points of the power. Can you help them?</p><p>Input<br>The first line of input consists of an integer T (1 &lt;= T &lt;= 10000), indicating<br>the number of test cases. For each test case, there will be an integer N (1 &lt;=<br>N &lt;= 2^63-1) as the description.</p><p>The input terminates by end of file marker.</p><p>Output<br>For each test case, output an integer indicating the final points of the<br>power.</p><p>Sample Input<br>3<br>1<br>50<br>500</p><p>Sample Output<br>0<br>1<br>15</p><p>Hint<br>From 1 to 500, the numbers that include the sub-sequence “49” are “49”,”149”,”<br>249”,”349”,”449”,”490”,”491”,”492”,”493”,”494”,”495”,”496”,”497”,”498”,”499”,<br>so the answer is 15.</p><p>———————————-.<br>题目大意 ： 就是问你从1~m 里 有49的数的个数</p><p>解题思路 :</p><p>最最基础的数位DP</p><p>附本题代码<br>——————————————————.</p><pre><code>#include &lt;bits/stdc++.h&gt;using namespace std;#define LL long long intLL  dp[30][12][2];//    位数  数字0~9  状态 int num[30],len ;//  数字   长度 /**********记忆化搜索****************///分别代表现在的位数 上一位的数字 限制  状态/*主要就是限制 比如说m = 123456789; 那么位数到地5位的时候 就不能选6 7 ..等等了但是如果在第5位他选择了 4  那么下一位就能够任意选择了 、*//*状态就是表示 到现在 有没有他能够满足的状态  有就+1  没有就+0;ll*/LL dfs(int pos ,int x,int limit ,int status){    if(pos&lt;0)  return status;    if(dp[pos][x][status]!=-1&amp;&amp;!limit)        return dp[pos][x][status];    int endi=9;    if(limit) endi = num[pos];    LL res = 0;    for(int i=0;i&lt;=endi;i++)    {        res+=dfs(pos-1 ,i ,limit&amp;&amp;(i==endi) ,status||(i==9&amp;&amp;x==4) );    }    if(!limit) dp[pos][x][status] =  res;    return  res;}int main(){    memset(dp,-1,sizeof(dp));    int _;    scanf(&quot;%d&quot;,&amp;_);    while(_--)    {        LL n;        scanf(&quot;%I64d&quot;,&amp;n);        LL tem = n;        len = 0;        while(tem)        {            num[len++]=tem%10;            tem/=10;        }        LL m = dfs(len-1,0,1,0);        printf(&quot;%I64d\n&quot;,m);    }    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  codeforces</title>
      <link href="/2016/08/21/52267286/"/>
      <url>/2016/08/21/52267286/</url>
      
        <content type="html"><![CDATA[<h1 id="codeforces-368-div-2B"><a href="#codeforces-368-div-2B" class="headerlink" title="codeforces #368 div.2B"></a>codeforces #368 div.2B</h1><p>2016年08月21日 14:51:58  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：197</p><hr><p> 博客爬取于<code>2019-04-18 17:20:00</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/52267286" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/52267286</a></p><p>题目链接: <a href="http://codeforces.com/contest/707/problem/B" target="_blank" rel="noopener"> http://codeforces.com/contest/707/problem/B</a><br>————————————–.<br>B. Bakery<br>time limit per test2 seconds<br>memory limit per test256 megabytes<br>inputstandard input<br>outputstandard output<br>Masha wants to open her own bakery and bake muffins in one of the n cities<br>numbered from 1 to n. There are m bidirectional roads, each of whose connects<br>some pair of cities.</p><p>To bake muffins in her bakery, Masha needs to establish flour supply from some<br>storage. There are only k storages, located in different cities numbered a1,<br>a2, …, ak.</p><p>Unforunately the law of the country Masha lives in prohibits opening bakery in<br>any of the cities which has storage located in it. She can open it only in one<br>of another n - k cities, and, of course, flour delivery should be paid — for<br>every kilometer of path between storage and bakery Masha should pay 1 ruble.</p><p>Formally, Masha will pay x roubles, if she will open the bakery in some city b<br>(ai ≠ b for every 1 ≤ i ≤ k) and choose a storage in some city s (s = aj for<br>some 1 ≤ j ≤ k) and b and s are connected by some path of roads of summary<br>length x (if there are more than one path, Masha is able to choose which of<br>them should be used).</p><p>Masha is very thrifty and rational. She is interested in a city, where she can<br>open her bakery (and choose one of k storages and one of the paths between<br>city with bakery and city with storage) and pay minimum possible amount of<br>rubles for flour delivery. Please help Masha find this amount.</p><p>Input<br>The first line of the input contains three integers n, m and k (1 ≤ n, m ≤<br>105, 0 ≤ k ≤ n) — the number of cities in country Masha lives in, the number<br>of roads between them and the number of flour storages respectively.</p><p>Then m lines follow. Each of them contains three integers u, v and l (1 ≤ u, v<br>≤ n, 1 ≤ l ≤ 109, u ≠ v) meaning that there is a road between cities u and v<br>of length of l kilometers .</p><p>If k &gt; 0, then the last line of the input contains k distinct integers a1, a2,<br>…, ak (1 ≤ ai ≤ n) — the number of cities having flour storage located in. If<br>k = 0 then this line is not presented in the input.</p><p>Output<br>Print the minimum possible amount of rubles Masha should pay for flour<br>delivery in the only line.</p><p>If the bakery can not be opened (while satisfying conditions) in any of the n<br>cities, print  - 1 in the only line.</p><p>Examples<br>input<br>5 4 2<br>1 2 5<br>1 2 3<br>2 3 4<br>1 4 10<br>1 5<br>output<br>3<br>input<br>3 1 1<br>1 2 3<br>3<br>output<br>-1<br>Note<br><img src="http://codeforces.com/predownloaded/a7/7d/a77d38852a481214acbfff529edbb660f49dbcde.png" alt="这里写图片描述"></p><p>Image illustrates the first sample case. Cities with storage located in and<br>the road representing the answer are darkened.<br>———————————-.<br>题意：<br>有n个城市 m条双向边 k各仓库分别在a1….ak城市<br>现在要 找一个没有仓库的城市里找一个城市，使得它到其中一个仓库的距离最短，求这个仓库的距离。<br>注：-1的情况包括，没有仓库或者全是仓库。</p><p>题解：<br>主要就是不能用矩阵来存储图就行了 鄙人用的vector</p><p>代码<br>——————————————–.</p><pre><code>#include &lt;bits/stdc++.h&gt;using namespace std;#define LL long long int#define INF 0x1f1f1f1f#define pb push_back/*************************************/const int MOD = 1e9+7;const int M = 1e5+10;struct node{    int a,l;};vector&lt;node&gt;E[M];int has[M];int main(){    ios::sync_with_stdio(false);    int n,m,k;    memset(has,0,sizeof(has));    for(int i=1; i&lt;=M; i++)        E[i].clear();    cin&gt;&gt;n&gt;&gt;m&gt;&gt;k;    int a,b,c;    for(int i=0; i&lt;m; i++)    {        cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;        E[a].pb(node {b,c});        E[b].pb(node {a,c});    }    int x;    int num=0,flag=0;    int mini=2000000000;    for(int i=0; i&lt;k; i++)    {        cin&gt;&gt;x;        if(!has[x])     has[x]=1,num++;    }    if(num==0||num==n) flag=1;     //printf(&quot;%d\n&quot;,flag);    for(int i=1; i&lt;=n&amp;&amp;!flag; i++)        if(!has[i])        {            for(int j=0; j&lt;E[i].size(); j++)                if(has[E[i][j].a])                    mini=min(mini,E[i][j].l);        }    if(flag==1||mini==2000000000) puts(&quot;-1&quot;);    else              printf(&quot;%d\n&quot;,mini);    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  HDU 5858 Hard problem 2016多校10 1002 [相交圆面积]【计算几何】</title>
      <link href="/2016/08/19/52251839/"/>
      <url>/2016/08/19/52251839/</url>
      
        <content type="html"><![CDATA[<h1 id="HDU-5858-Hard-problem-2016多校10-1002-相交圆面积-【计算几何】"><a href="#HDU-5858-Hard-problem-2016多校10-1002-相交圆面积-【计算几何】" class="headerlink" title="HDU 5858 Hard problem 2016多校10 1002 [相交圆面积]【计算几何】"></a>HDU 5858 Hard problem 2016多校10 1002 [相交圆面积]【计算几何】</h1><p>2016年08月19日 16:04:23  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：447</p><hr><p> 博客爬取于<code>2019-04-18 17:20:01</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/52251839" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/52251839</a></p><p>题目连接 ： <a href="http://acm.split.hdu.edu.cn/showproblem.php?pid=5858" target="_blank" rel="noopener"> 就当前HDU的情况 就先不给了</a></p><p>——————————————————————–.<br>Hard problem</p><p>Time Limit: 2000/1000 MS (Java/Others) Memory Limit: 65536/65536 K<br>(Java/Others)<br>Total Submission(s): 195 Accepted Submission(s): 148</p><p>Problem Description<br>cjj is fun with math problem. One day he found a Olympic Mathematics problem<br>for primary school students. It is too difficult for cjj. Can you solve it?<br><img src="http://acm.split.hdu.edu.cn/data/images/C713-1002-1.jpg" alt="这里写图片描述"></p><p>Give you the side length of the square L, you need to calculate the shaded<br>area in the picture.</p><p>The full circle is the inscribed circle of the square, and the center of two<br>quarter circle is the vertex of square, and its radius is the length of the<br>square.</p><p>Input<br>The first line contains a integer T(1&lt;=T&lt;=10000), means the number of the test<br>case. Each case contains one line with integer l(1&lt;=l&lt;=10000).</p><p>Output<br>For each test case, print one line, the shade area in the picture. The answer<br>is round to two digit.</p><p>Sample Input<br>1<br>1</p><p>Sample Output<br>0.29</p><p>———————————————-.<br>题目大意 ： 就是正方形边长为n时 求阴影面积 保留小数后两位</p><p>题目分析 ：<br>当天不想做多校 然后队友给看了这题 说是小学奥数题目 所以就一直割补法 然后 GG<br>今天偶然看了看过去整理的模板 猛然看到一个叫做相交圆面积的东西 然后就想到了这道题目。。</p><p>然后大致是这样的。<br><img src="https://img-blog.csdn.net/20160819155910787" alt="这里写图片描述"></p><p>小的圆是蓝的 打的圆是红的 绿色部分是相交的面积 （红色+蓝色==绿色？就当是对的了：不可能错）</p><p>然后根据相交圆面积求绿色部分 最后拿小圆的面积减去它 最后在乘个二就行了。。。</p><p>之后做题的时候只求一次边长为1的阴影部分面价就好了 因为平面图形 等比放大N倍 面积就是原来的n*n倍</p><p>#</p><p>就是这么水 然而被第一句话误导了 一直在寻找巧妙的办法…<br>什么小学奥数题目。。。 小学能学这个？？！！！</p><p>附本题代码<br>———————————————–.</p><pre><code>#include &lt;bits/stdc++.h&gt;using namespace std;#define lalal puts(&quot;*******&quot;);const double PI  =  acos(-1);struct Round {    double x, y;    double r;}c1,c2;double dis(Round a, Round b){    return sqrt((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y));}double solve(Round a, Round b){    double d = dis(a, b);    if (d &gt;= a.r + b.r)  return 0;    if (d &lt;= fabs(a.r - b.r))    {        double r = a.r &lt; b.r ? a.r : b.r;        return PI * r * r;    }    double ang1 = acos((a.r * a.r + d * d - b.r * b.r) / 2. / a.r / d);    double ang2 = acos((b.r * b.r + d * d - a.r * a.r) / 2. / b.r / d);    double ret = ang1 * a.r * a.r + ang2 * b.r * b.r - d * a.r * sin(ang1);    return ret;}int main(){    c1.x=0.0,c1.y=0.0,c1.r=1.0;    c2.x=0.5,c2.y=0.5,c2.r=0.5;    double s = solve(c1,c2);    s = PI*0.5-s*2;  //  printf(&quot;%.15lf\n&quot;,s);    int _,n;    scanf(&quot;%d&quot;,&amp;_);    while(_--)    {        scanf(&quot;%d&quot;,&amp;n);        printf(&quot;%.2lf\n&quot;,s*n*n);    }    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  hdu 5833 Zhu and 772002 2016中国大学生程序设计竞赛 - 网络选拔赛1002 [质因子分解+高斯消元]【数论】</title>
      <link href="/2016/08/15/52208349/"/>
      <url>/2016/08/15/52208349/</url>
      
        <content type="html"><![CDATA[<h1 id="hdu-5833-Zhu-and-772002-2016中国大学生程序设计竞赛-网络选拔赛1002-质因子分解-高斯消元-【数论】"><a href="#hdu-5833-Zhu-and-772002-2016中国大学生程序设计竞赛-网络选拔赛1002-质因子分解-高斯消元-【数论】" class="headerlink" title="hdu 5833 Zhu and 772002 2016中国大学生程序设计竞赛 - 网络选拔赛1002 [质因子分解+高斯消元]【数论】"></a>hdu 5833 Zhu and 772002 2016中国大学生程序设计竞赛 - 网络选拔赛1002 [质因子分解+高斯消元]【数论】</h1><p>2016年08月15日 09:35:35  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：285</p><hr><p> 博客爬取于<code>2019-04-18 17:20:02</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/52208349" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/52208349</a></p><p>题目连接： <a href="http://acm.hdu.edu.cn/showproblem.php?pid=5833" target="_blank" rel="noopener"> http://acm.hdu.edu.cn/showproblem.php?pid=5833</a><br>——————————-.<br>Zhu and 772002</p><p>Time Limit: 2000/1000 MS (Java/Others) Memory Limit: 65536/65536 K<br>(Java/Others)<br>Total Submission(s): 446 Accepted Submission(s): 147</p><p>Problem Description<br>Zhu and 772002 are both good at math. One day, Zhu wants to test the ability<br>of 772002, so he asks 772002 to solve a math problem.</p><p>But 772002 has a appointment with his girl friend. So 772002 gives this<br>problem to you.</p><p>There are n numbers a1,a2,…,an. The value of the prime factors of each number<br>does not exceed 2000, you can choose at least one number and multiply them,<br>then you can get a number b.</p><p>How many different ways of choices can make b is a perfect square number. The<br>answer maybe too large, so you should output the answer modulo by 1000000007.</p><p>Input<br>First line is a positive integer T , represents there are T test cases.</p><p>For each test case:</p><p>First line includes a number n(1≤n≤300)，next line there are n numbers<br>a1,a2,…,an,(1≤ai≤1018).</p><p>Output<br>For the i-th test case , first output Case #i: in a single line.</p><p>Then output the answer of i-th test case modulo by 1000000007.</p><p>Sample Input<br>2<br>3<br>3 3 4<br>3<br>2 2 2</p><p>Sample Output<br>Case #1:<br>3<br>Case #2:<br>3</p><p>Author<br>UESTC</p><p>Source<br>2016中国大学生程序设计竞赛 - 网络选拔赛</p><p>———————————————-.</p><p>题目大意： 就是有n这么长的序列 然后从中选至少一个数 让这些数的乘积为完全平方数 问有多少种选法</p><p>题目分析：<br>首先注意题目说的 a[i]的最大质因子不会超过2000 这也是在提示你要质因子分解 分解就简单处理一下分解就行了 怎么分都行<br>这里首先想到的就应该是算数基本定理<br>A=p1^a1<em>p2^a2</em>p3^a3<em>…</em>pn^an (pn是质数)<br>然后分解的时候怎么怎么存储数据?,怎么操作呢?<br>首先要想这个问题<br>几个数相乘的结果如果是完全平方数 有什么特点呢?<br>说白了就是开方后能得到一个整数<br>比如说B=a1*a2; B,a1,a2都为整数 且a1==a2<br>那么a1和a2 他们质因子分解后是完全一样的<br>那么B的算是基本定理展开就等于a1的算是基本定理展开乘上a2的算是基本定理展开<br>那么可以肯定的是B的算是基本定理展开 an一定是偶数的 所以就能拆成两个a1 a2<br>那么反过来说只要B的算是基本定理展开 an都是偶数 就一定是完全平方数<br>那么在判断的时候就只要判断an的值的奇偶性就可以了<br>于是我们就开了这样的数组factor[n+10][333] (2000以内的质数只有303个)<br>把每个数转化为了一个2进制数<br>我们可以把题目转化成求n个数中的k个数数异或为0的情况数。使用x1—xn表示最终第i堆石子到底取不取（1取，0不取），将每堆石子数画成2进制的形式，列成30<br>3个方程来求自由变元数，最后由于自由变元能取1、0两种状态<br>然后直接高斯消元就可以了<br>最后的结果就是 2^(自由元)-1</p><p>注: 最终结果减去的那个一 减去的是1个都不选则情况下的0</p><p>附本题代码<br>———————————–.</p><pre><code>#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cmath&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;queue&gt;#include &lt;map&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;typedef long long LL;typedef unsigned long long ULL;const int MOD = 1000000007;#define weishu kint prime[50000];int Is_or[20100];int k;void Prime(){    int n=2001;    k=0;    memset(Is_or,1,sizeof(Is_or));    Is_or[0]=Is_or[1]=0;    for(int i=2; i&lt;n; i++)    {        if(Is_or[i])        {            prime[k++]=i;            for(int j=i+i; j&lt;n; j+=i)            {                Is_or[j]=0;            }        }    }    return ;}LL a[333];LL  g[333][333];int Gauss(int n){    int i, j, r, c, cnt;    for (c = cnt = 0; c &lt; n; c++)    {        for (r = cnt; r &lt; weishu; r++)        {            if (g[r][c])                break;        }        if (r &lt; weishu)        {            if (r != cnt)            {                for (i = 0; i &lt; n; i++)                {                    g[r][i]^=g[cnt][i];                    g[cnt][i]^=g[r][i];                    g[r][i]^=g[cnt][i];                }            }            for (i = cnt + 1; i &lt; weishu; i++)            {                if (g[i][c])                {                    for (j = 0; j &lt; n; j++)                        g[i][j] ^= g[cnt][j];                }            }            cnt++;        }    }    return n - cnt;}LL qmod (LL a,LL b){    LL res = 1;    while(b)    {        if(b&amp;1)  res=(res*a)%MOD;        b &gt;&gt;= 1;        a=(a*a)%MOD;    }    return res;}int main(){    Prime();    int c,p=0;    int n, i, j;    scanf(&quot;%d&quot;, &amp;c);    while (c--)    {        int fuck = 0;        scanf(&quot;%d&quot;, &amp;n);        memset(g,0,sizeof(g));        LL temp;        for(int i=0; i&lt;n; i++)        {            scanf(&quot;%I64d&quot;,&amp;a[i]);            temp=a[i];            for(int j=0; j&lt;k; j++)            {                if(temp&lt;prime[j]) break;                while(temp%prime[j]==0)                {                    temp/=prime[j];                    g[j][i]++;                }                g[j][i]%=2;            }        }        LL ans, vary;        vary = Gauss(n);        printf(&quot;Case #%d:\n&quot;,++p);        ans = qmod(2,vary);        printf(&quot;%I64d\n&quot;,(ans-1)%MOD);    }    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  HDU 3389 Game(博弈 Nim 找规律)</title>
      <link href="/2016/08/12/52190898/"/>
      <url>/2016/08/12/52190898/</url>
      
        <content type="html"><![CDATA[<h1 id="HDU-3389-Game-博弈-Nim-找规律"><a href="#HDU-3389-Game-博弈-Nim-找规律" class="headerlink" title="HDU 3389 Game(博弈 Nim 找规律)"></a>HDU 3389 Game(博弈 Nim 找规律)</h1><p>2016年08月12日 13:42:04  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：155<br>标签：  <a href="https://so.csdn.net/so/search/s.do?q=游戏&amp;t=blog" target="_blank" rel="noopener"> 游戏 </a></p><p>个人分类：  <a href="https://blog.csdn.net/qq_33184171/article/category/6117382" target="_blank" rel="noopener"> hdu </a> <a href="https://blog.csdn.net/qq_33184171/article/category/6117381" target="_blank" rel="noopener"><br>===== 博弈 ===== </a> <a href="https://blog.csdn.net/qq_33184171/article/category/6253262" target="_blank" rel="noopener"><br>思维 </a></p><hr><p> 博客爬取于<code>2019-04-18 17:20:03</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/52190898" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/52190898</a></p><p>题目连接： <a href="http://acm.hdu.edu.cn/showproblem.php?pid=3389" target="_blank" rel="noopener"> http://acm.hdu.edu.cn/showproblem.php?pid=3389</a><br>———————-.<br>Game<br>Time Limit: 2000/1000 MS (Java/Others) Memory Limit: 32768/32768 K<br>(Java/Others)<br>Total Submission(s): 610 Accepted Submission(s): 426</p><p>Problem Description<br>Bob and Alice are playing a new game. There are n boxes which have been<br>numbered from 1 to n. Each box is either empty or contains several cards. Bob<br>and Alice move the cards in turn. In each turn the corresponding player should<br>choose a non-empty box A and choose another box B that B &lt; A &amp;&amp; (A+B)%2=1 &amp;&amp;<br>(A+B)%3=0. Then, take an arbitrary number (but not zero) of cards from box A<br>to box B. The last one who can do a legal move wins. Alice is the first<br>player. Please predict who will win the game.</p><p>Input<br>The first line contains an integer T (T&lt;=100) indicating the number of test<br>cases. The first line of each test case contains an integer n (1&lt;=n&lt;=10000).<br>The second line has n integers which will not be bigger than 100. The i-th<br>integer indicates the number of cards in the i-th box.</p><p>Output<br>For each test case, print the case number and the winner’s name in a single<br>line. Follow the format of the sample output.</p><p>Sample Input<br>2<br>2<br>1 2<br>7<br>1 3 3 2 2 1 2</p><p>Sample Output<br>Case 1: Alice<br>Case 2: Bob</p><p>———————————————.<br>题目大意 就是把右边盒子里的的给左边盒子 但要求B &lt; A &amp;&amp; (A+B)%2=1 &amp;&amp; (A+B)%3=0<br>谁不能移牌 谁就输了</p><p>题目分析 ：<br>就是 博弈么 找规律 就好 了</p><p>根据上面的很容易分析到<br>1.最后一定会放到 1 3 4这3个盒子里<br>2.右边最终能移到1 3 4中的哪一个也是能够求的<br>3.右边的移到左边的步数是偶数个还是奇数个也是可求的 只要经过偶数步数才能到达的 都是必败点</p><p>分析每一个的时候可以把其他的盒子当成空的<br>这样就是N个游戏组合到了一起 然后作为NIM取一下异或值就行了</p><p>总的来说就是分情况讨论一下<br>奇数： %3 == 0 偶数步骤后到达盒子3</p><p>%3 == 1 偶数步骤后到达盒子1</p><p>%3 == 2 ji步骤后到达盒子2</p><p>偶数： %3 == 0 奇数步骤后到达盒子3</p><p>%3 == 1 偶数步骤后到达盒子1</p><p>%3 == 2 奇数步骤后到达盒子4</p><p>之后操作就好了</p><p>附本题代码<br>————————————.</p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;#define LL long long int#define lalal puts(&quot;******&quot;);int main() {    int _,p=0;    scanf(&quot;%d&quot;,&amp;_);    while(_--)    {        int n,ans = 0,x;        scanf(&quot;%d&quot;,&amp;n);        for(int i=1;i&lt;=n;i++)        {            scanf(&quot;%d&quot;,&amp;x);  //没有 xor 的既是偶数步才能到达既定位置的  必败 所以sg值一定为0  不需要 xor 了  打表是一个强有力的工具啊            if(i % 2 == 1)                    if(i % 3 == 2) ans ^=x;  //奇数必胜 然后就可以当成 Nim博弈进行操作了            if(i % 2 == 0)            {                if(i % 3 == 2) ans ^=x;                if(i % 3 == 0) ans ^=x;            }        }        printf(&quot;Case %d: &quot;,++p);        if(ans) puts(&quot;Alice&quot;);        else puts(&quot;Bob&quot;);    }    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hdu </tag>
            
            <tag> 游戏 </tag>
            
            <tag> 博弈 </tag>
            
            <tag> 思维 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  HDU 2588 GCD [欧拉函数]【数论】</title>
      <link href="/2016/08/11/52186214/"/>
      <url>/2016/08/11/52186214/</url>
      
        <content type="html"><![CDATA[<h1 id="HDU-2588-GCD-欧拉函数-【数论】"><a href="#HDU-2588-GCD-欧拉函数-【数论】" class="headerlink" title="HDU 2588 GCD [欧拉函数]【数论】"></a>HDU 2588 GCD [欧拉函数]【数论】</h1><p>2016年08月11日 20:25:10  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：379</p><hr><p> 博客爬取于<code>2019-04-18 17:20:04</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/52186214" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/52186214</a></p><p>题目连接 ： <a href="http://acm.hdu.edu.cn/showproblem.php?pid=2588" target="_blank" rel="noopener"> 传送阵 </a><br>————————-.<br>GCD</p><p>Time Limit: 2000/1000 MS (Java/Others) Memory Limit: 32768/32768 K<br>(Java/Others)<br>Total Submission(s): 1734 Accepted Submission(s): 852</p><p>Problem Description<br>The greatest common divisor GCD(a,b) of two positive integers a and<br>b,sometimes written (a,b),is the largest divisor common to a and b,For<br>example,(1,2)=1,(12,18)=6.<br>(a,b) can be easily found by the Euclidean algorithm. Now Carp is considering<br>a little more difficult problem:<br>Given integers N and M, how many integer X satisfies 1&lt;=X&lt;=N and (X,N)&gt;=M.</p><p>Input<br>The first line of input is an integer T(T&lt;=100) representing the number of<br>test cases. The following T lines each contains two numbers N and M<br>(2&lt;=N&lt;=1000000000, 1&lt;=M&lt;=N), representing a test case.</p><p>Output<br>For each test case,output the answer on a single line.</p><p>Sample Input<br>3<br>1 1<br>10 2<br>10000 72</p><p>Sample Output<br>1<br>6<br>260</p><p>—————————————–.</p><p>题目大意 ：不用解释了吧 ..</p><p>解题思路：<br>这道题所需要的算法主要为欧拉函数的运用和一点点的GCD知识。<br>问题所要求的是 gcd( x , n ) &gt; m ,由gcd( x , n )本身可知，gcd求出来的是 x 和n的最大公约数（设为a），即有式子gcd(<br>x ,n )=a , 进一步进行化简可变为gcd( x/a , n/a )=1 , 到了此处这个式子又有了另一层含义——x/a与n/a互素 。在联想到欧拉函<br>数的功能——对正整数n，欧拉函数是小于或等于n的数中与n互质的数的数目。于是将欧拉函数里的n换成n/a，不就正好能求出x/a的个数了吗？x/a的个数不就是我<br>们所要求的x的个数了吗？</p><p>转自 <a href="http://blog.csdn.net/no2015214099/article/details/52122295" target="_blank" rel="noopener"> 这里 </a></p><p>附本题代码<br>————————————-.</p><pre><code>#include &lt;stdio.h&gt;#include &lt;vector&gt;#include &lt;iostream&gt;#include &lt;stdlib.h&gt;using namespace std;#define LL long long int#define pb push_backint Euler(int n){    if(n==1)    return 1;    int m=n;    for(int i=2; i*i&lt;=m; i++)        if(m%i==0)        {            n-=n/i;            while(m%i==0)                m/=i;        }    if(m!=1)    {        n-=n/m;    }    return n;}int solve(int n,int m){    int ans=0;    for(int i=1; i*i&lt;=n; i++)    {        if(n%i) continue;        if(i&gt;=m&amp;&amp;i*i!=n)            ans += Euler(n/i);        if(n/i&gt;=m)            ans += Euler(i);    }    return ans;}int main(){    int _,p=0;    scanf(&quot;%d&quot;,&amp;_);    while(_--)    {        int  n,m;        scanf(&quot;%d%d&quot;,&amp;n,&amp;m);        int sum=solve(n,m);        printf(&quot;%d\n&quot;,sum);    }    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  HDU 5446 Unknown Treasure [lucas+CRT]【数论】</title>
      <link href="/2016/08/11/52186122/"/>
      <url>/2016/08/11/52186122/</url>
      
        <content type="html"><![CDATA[<h1 id="HDU-5446-Unknown-Treasure-lucas-CRT-【数论】"><a href="#HDU-5446-Unknown-Treasure-lucas-CRT-【数论】" class="headerlink" title="HDU 5446 Unknown Treasure [lucas+CRT]【数论】"></a>HDU 5446 Unknown Treasure [lucas+CRT]【数论】</h1><p>2016年08月11日 20:13:29  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：206<br>标签：  <a href="https://so.csdn.net/so/search/s.do?q=数论&amp;t=blog" target="_blank" rel="noopener"> 数论 </a></p><p>个人分类：  <a href="https://blog.csdn.net/qq_33184171/article/category/6117382" target="_blank" rel="noopener"> hdu </a> <a href="https://blog.csdn.net/qq_33184171/article/category/6362367" target="_blank" rel="noopener"><br>===== 数论 ===== </a> <a href="https://blog.csdn.net/qq_33184171/article/category/6330935" target="_blank" rel="noopener"><br>=== 组合数学 === </a></p><hr><p> 博客爬取于<code>2019-04-18 17:20:05</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/52186122" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/52186122</a></p><p>题目连接: <a href="http://acm.hdu.edu.cn/showproblem.php?pid=5446" target="_blank" rel="noopener"> 传送门 </a><br>——————————.<br>Unknown Treasure</p><p>Time Limit: 1500/1000 MS (Java/Others) Memory Limit: 131072/131072 K<br>(Java/Others)<br>Total Submission(s): 2196 Accepted Submission(s): 814</p><p>Problem Description<br>On the way to the next secret treasure hiding place, the mathematician<br>discovered a cave unknown to the map. The mathematician entered the cave<br>because it is there. Somewhere deep in the cave, she found a treasure chest<br>with a combination lock and some numbers on it. After quite a research, the<br>mathematician found out that the correct combination to the lock would be<br>obtained by calculating how many ways are there to pick m different apples<br>among n of them and modulo it with M. M is the product of several different<br>primes.</p><p>Input<br>On the first line there is an integer T(T≤20) representing the number of test<br>cases.</p><p>Each test case starts with three integers n,m,k(1≤m≤n≤10^18,1≤k≤10) on a line<br>where k is the number of primes. Following on the next line are k different<br>primes p1,…,pk. It is guaranteed that M=p1⋅p2⋅⋅⋅pk≤10^18 and pi≤10^5 for every<br>i∈{1,…,k}.</p><p>Output<br>For each test case output the correct combination on a line.</p><p>Sample Input<br>1<br>9 5 2<br>3 5</p><p>Sample Output<br>6<br>——————————.<br>题目大意:<br>就是求C(n,m)%M ,M= p1<em>p2</em>p3<em>p4</em>…*pn;</p><p>题目解释:<br>大组合数就是用lucas定理求解<br>而lucas要求是对质数取模的时候才成立<br>所以分别对p[i] 进行求解 然后构成了一个同余方程组<br>用中国剩余定理求解就行了</p><p>注意大数乘法的时候可能会爆longlong 所以要用快速乘</p><p>附本题代码<br>——————————.</p><pre><code>#include &lt;stdio.h&gt;#include &lt;vector&gt;#include &lt;iostream&gt;#include &lt;stdlib.h&gt;using namespace std;#define LL long long int#define pb push_backLL qmul(LL a,LL b,LL c){    LL res=0;    while(b)    {        if(b&amp;1) res=(res+a)%c;        a=(a+a)%c;        b&gt;&gt;=1;    }    return res;}LL qmod(LL a,LL b,LL c){    LL res=1;    while(b)    {        if(b&amp;1) res=qmul(res,a,c)%c;        b&gt;&gt;=1;        a=qmul(a,a,c)%c;    }    return res;}LL exgcd(LL a,LL b,LL &amp;x,LL &amp;y) //ax+by=d{    if(!b)    {        x=1;        y=0;        return a;    }    else    {        LL r=exgcd(b,a%b,x,y);        LL t = x;        x = y;        y=t-a/b*x;        return r;    }}LL CRT(LL a[],LL m[],LL len) //x%m[i]=a[i]{    LL i,x,y,M,n=1,ret=0;    for(i=0; i&lt;len; ++i) n*=m[i];    for(i=0; i&lt;len; ++i)    {        M=n/m[i];        exgcd(M,m[i],x,y);        ret=(ret+qmul(qmul(x,M,n),a[i],n))%n;    }    return (ret+n)%n;}LL C(LL n,LL m,LL p)//组合数模素数P{    if(m&gt;n||m&lt;0) return 0;    if(n-m&lt;m) m=n-m;    LL a=1,b=1;    for(int i=0; i&lt;m; ++i)    {        a=a*(n-i)%p;        b=b*(m-i)%p;    }    return a*qmod(b,p-2,p)%p;}LL Lucas(LL n,LL m,LL p){    LL ans=1;    while(n&amp;&amp;m&amp;&amp;ans)    {        ans=ans*C(n%p,m%p,p)%p;        n/=p,m/=p;    }    return ans;}LL a[11],p[11];int main(){    int _;    scanf(&quot;%d&quot;,&amp;_);    while(_--)    {        LL  n,m;        int k;        scanf(&quot;%I64d%I64d%d&quot;,&amp;n,&amp;m,&amp;k);        LL ans = 0;        for(int i=0; i&lt;k; i++)        {            scanf(&quot;%I64d&quot;,&amp;p[i]);            a[i] = Lucas(n, m, p[i]);           // printf(&quot;%I64d &quot;,a[i]);        }       // puts(&quot;&quot;);        LL sum = CRT(a,p,k);        printf(&quot;%I64d\n&quot;,sum);    }    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hdu </tag>
            
            <tag> 数论 </tag>
            
            <tag> 组合数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  HDU 4135 Co-prime [容斥定理]【数论】</title>
      <link href="/2016/08/11/52186000/"/>
      <url>/2016/08/11/52186000/</url>
      
        <content type="html"><![CDATA[<h1 id="HDU-4135-Co-prime-容斥定理-【数论】"><a href="#HDU-4135-Co-prime-容斥定理-【数论】" class="headerlink" title="HDU 4135 Co-prime [容斥定理]【数论】"></a>HDU 4135 Co-prime [容斥定理]【数论】</h1><p>2016年08月11日 19:59:34  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：210</p><hr><p> 博客爬取于<code>2019-04-18 17:20:06</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/52186000" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/52186000</a></p><p>题目连接： <a href="http://acm.hdu.edu.cn/showproblem.php?pid=4135" target="_blank" rel="noopener"> 传送阵 </a><br>——————————.<br>Co-prime</p><p>Time Limit: 2000/1000 MS (Java/Others) Memory Limit: 32768/32768 K<br>(Java/Others)<br>Total Submission(s): 3902 Accepted Submission(s): 1536</p><p>Problem Description<br>Given a number N, you are asked to count the number of integers between A and<br>B inclusive which are relatively prime to N.<br>Two integers are said to be co-prime or relatively prime if they have no<br>common positive divisors other than 1 or, equivalently, if their greatest<br>common divisor is 1. The number 1 is relatively prime to every integer.</p><p>Input<br>The first line on input contains T (0 &lt; T &lt;= 100) the number of test cases,<br>each of the next T lines contains three integers A, B, N where (1 &lt;= A &lt;= B &lt;=<br>1015) and (1 &lt;=N &lt;= 109).</p><p>Output<br>For each test case, print the number of integers between A and B inclusive<br>which are relatively prime to N. Follow the output format below.</p><p>Sample Input<br>2<br>1 10 2<br>3 15 5</p><p>Sample Output<br>Case #1: 5<br>Case #2: 10</p><p>Hint<br>In the first test case, the five integers in range [1,10] which are relatively<br>prime to 2 are {1,3,5,7,9}.</p><p>————————————.<br>题目大意： 就是求a~b区间内与n互质的数的个数</p><p>解题思路：与n互质的数的个数也就是gcd(x,n)==1.但是数据量非常大 所以暴力不可解<br>于是换个思路 就是求gcd(x,n)!=1的数的个数 然后区间总数减一下 就能得到结果<br>gcd(x,n)!=1就简单了</p><p>只要求出[1~a-1][1~b]这两个区间内的与n有约数(非1)的数的个数<br>想到把n质因子分解 然后容斥定理求解即可</p><p>附本题代码<br>———————————-.</p><pre><code>#include &lt;stdio.h&gt;#include &lt;vector&gt;#include &lt;iostream&gt;using namespace std;#define LL long long int#define pb push_backLL solve (LL n, LL r){    vector&lt;int&gt; p;    for (int  i=2; i*i&lt;=n; ++i)        if (n % i == 0)        {            p.pb (i);            while (n % i == 0)                n /= i;        }    if (n &gt; 1)  p.pb (n);    LL sum = 0;    for (int msk=1; msk&lt;(1&lt;&lt;p.size()); ++msk)    {        LL mult = 1,            bits = 0;        for (int i=0; i&lt;(LL)p.size(); ++i)            if (msk &amp; (1&lt;&lt;i))            {                ++bits;                mult *= p[i];            }        LL cur = r / mult;        if (bits % 2 == 1)            sum += cur;        else            sum -= cur;    }    return r - sum;}int main(){    int _,p=0;    scanf(&quot;%d&quot;,&amp;_);    while(_--)    {        LL a,b,n;        scanf(&quot;%I64d%I64d%I64d&quot;,&amp;a,&amp;b,&amp;n);        LL sum = solve(n,b)-solve(n,a-1);        printf(&quot;Case #%d: %I64d\n&quot;,++p,sum);    }    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  HDU 2604 Queuing [递推]【矩阵快速幂】</title>
      <link href="/2016/08/11/52184669/"/>
      <url>/2016/08/11/52184669/</url>
      
        <content type="html"><![CDATA[<h1 id="HDU-2604-Queuing-递推-【矩阵快速幂】"><a href="#HDU-2604-Queuing-递推-【矩阵快速幂】" class="headerlink" title="HDU 2604 Queuing [递推]【矩阵快速幂】"></a>HDU 2604 Queuing [递推]【矩阵快速幂】</h1><p>2016年08月11日 17:19:07  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：274</p><hr><p> 博客爬取于<code>2019-04-18 17:20:07</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/52184669" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/52184669</a></p><p>题目连接： <a href="http://acm.hdu.edu.cn/showproblem.php?pid=2604" target="_blank" rel="noopener"> http://acm.hdu.edu.cn/showproblem.php?pid=2604</a><br>——————–.<br>Queuing</p><p>Time Limit: 10000/5000 MS (Java/Others) Memory Limit: 32768/32768 K<br>(Java/Others)<br>Total Submission(s): 4713 Accepted Submission(s): 2083</p><p>Problem Description<br>Queues and Priority Queues are data structures which are known to most<br>computer scientists. The Queue occurs often in our daily life. There are many<br>people lined up at the lunch time.<br><img src="http://acm.hdu.edu.cn/data/images/C154-1005-1.jpg" alt="这里写图片描述"></p><p>Now we define that ‘f’ is short for female and ‘m’ is short for male. If the<br>queue’s length is L, then there are 2L numbers of queues. For example, if L =<br>2, then they are ff, mm, fm, mf . If there exists a subqueue as fmf or fff, we<br>call it O-queue else it is a E-queue.<br>Your task is to calculate the number of E-queues mod M with length L by<br>writing a program.</p><p>Input<br>Input a length L (0 &lt;= L &lt;= 10 6) and M.</p><p>Output<br>Output K mod M(1 &lt;= M &lt;= 30) where K is the number of E-queues with length L.</p><p>Sample Input<br>3 8<br>4 7<br>4 8</p><p>Sample Output<br>6<br>2<br>1</p><p>Author<br>WhereIsHeroFrom</p><p>———————————–.</p><p>题目大意 ：就是问子串中没有fmf fff的串有多少个</p><p>题解 ： 我是暴力打表找的规律</p><p>所以不解释</p><p>这是打表代码<br>——————-.</p><pre><code>#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;typedef __int64 LL;#define maxn 10int sum=0;char a[12];void judge(int n,int mm){    int m=n;    memset(a,0,sizeof(a));    int num=0;    while(mm--)    {        if(n&amp;1) a[num++]=&#39;1&#39;;        else    a[num++]=&#39;0&#39;;        n&gt;&gt;=1;    }    //printf(&quot;%.4d %s  &quot;,m,a);    if(strstr(a,&quot;111&quot;)||strstr(a,&quot;101&quot;))    {//  printf(&quot;  ***&quot;);    }else sum++;    //puts(&quot;&quot;);    return ;} int M ;void dfs(int n,int num){    if(num == M-1)   {judge(n,M); return ;    }    n&lt;&lt;=1;    dfs(n,num+1);    dfs(n+1,num+1);}int main(){    for(int i=0;i&lt;10;i++)    {M = i;    sum=0;    dfs(0,-1);    printf(&quot;%d  %d \n&quot;,i,sum);    }    return 0;}</code></pre><p>附本题AC代码<br>————————————.</p><pre><code>#include&lt;bits/stdc++.h&gt;#include &lt;stdio.h&gt;   //为啥我先到的是数位DP 啊  0 1 两位 dp[1e6][0~1][pre]#include &lt;vector&gt;     //打表找规律的题都是SB题目  上是打表代码#include &lt;iostream&gt;#include &lt;stdlib.h&gt;using namespace std;#define LL long long int#define pb push_backconst int M = 4;int MOD;struct Matrix{    LL m[M][M];    void clearO()    {        for(int i=0; i&lt;M; i++) //初始化矩阵            for(int j=0; j&lt;M; j++)                m[i][j]= 0;    }    void clearE()    {        for(int i=0; i&lt;M; i++) //初始化矩阵            for(int j=0; j&lt;M; j++)                m[i][j]= (i==j);    }    void display()    {        for(int i=0; i&lt;M; i++)            {                for(int j=0; j&lt;M; j++)                printf(&quot;%d &quot;,m[i][j]);                puts(&quot;&quot;);            }    }};Matrix operator * (Matrix a,Matrix b){    Matrix c;    c.clearO();    for(int k=0; k&lt;M; k++)        for(int i=0; i&lt;M; i++) //实现矩阵乘法        {            if(a.m[i][k] &lt;= 0)  continue;            for(int j=0; j&lt;M; j++)            {                if(b.m[k][j] &lt;= 0)    continue;                c.m[i][j]=(c.m[i][j]+a.m[i][k]*b.m[k][j]+MOD)%MOD;            }        }    return c;}Matrix operator ^ (Matrix a,LL b){    Matrix c;    c.clearE();    while(b)    {        if(b&amp;1) c= c * a ;        b &gt;&gt;= 1;        a = a * a ;    }    return c;}Matrix a,b;void init(){    a.clearO();    a.m[0][0]=9;    a.m[1][0]=6;    a.m[2][0]=4;    a.m[3][0]=2;    b.clearO();    b.m[0][0]=1,b.m[0][2]=1,b.m[0][3]=1;    b.m[1][0]=1,b.m[2][1]=1,b.m[3][2]=1;}int main(){    int n,m;    while(~scanf(&quot;%d%d&quot;,&amp;n,&amp;m))    {        MOD = m;        init();        b=b^(n-1);        a=b*a;      //  a.display();        printf(&quot;%I64d\n&quot;,a.m[3][0]);    }    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  hdu 2588 GCD [欧拉函数]【数论】*</title>
      <link href="/2016/08/11/52181264/"/>
      <url>/2016/08/11/52181264/</url>
      
        <content type="html"><![CDATA[<h1 id="hdu-2588-GCD-欧拉函数-【数论】"><a href="#hdu-2588-GCD-欧拉函数-【数论】" class="headerlink" title="hdu 2588 GCD [欧拉函数]【数论】*"></a>hdu 2588 GCD [欧拉函数]【数论】*</h1><p>2016年08月11日 11:48:04  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：318</p><hr><p> 博客爬取于<code>2019-04-18 17:20:08</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/52181264" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/52181264</a></p><p>题目连接： <a href="http://acm.hdu.edu.cn/showproblem.php?pid=2588" target="_blank" rel="noopener"> http://acm.hdu.edu.cn/showproblem.php?pid=2588</a><br>————————-.<br>GCD</p><p>Time Limit: 2000/1000 MS (Java/Others) Memory Limit: 32768/32768 K<br>(Java/Others)<br>Total Submission(s): 1700 Accepted Submission(s): 829</p><p>Problem Description<br>The greatest common divisor GCD(a,b) of two positive integers a and<br>b,sometimes written (a,b),is the largest divisor common to a and b,For<br>example,(1,2)=1,(12,18)=6.<br>(a,b) can be easily found by the Euclidean algorithm. Now Carp is considering<br>a little more difficult problem:<br>Given integers N and M, how many integer X satisfies 1&lt;=X&lt;=N and (X,N)&gt;=M.</p><p>Input<br>The first line of input is an integer T(T&lt;=100) representing the number of<br>test cases. The following T lines each contains two numbers N and M<br>(2&lt;=N&lt;=1000000000, 1&lt;=M&lt;=N), representing a test case.</p><p>Output<br>For each test case,output the answer on a single line.</p><p>Sample Input<br>3<br>1 1<br>10 2<br>10000 72</p><p>Sample Output<br>1<br>6<br>260<br>————————-.<br>题目大意 : 不解释</p><p>题解:</p><p>首先明确的是，要求的  gcd  (  x  ,  N  )  |  N  成立<br>那么我们只要知道  gcd  结果为N的每一个约数时的个数就行了,<br>当  [  d  |  N  ]  成  立  ,  那  么  就  是  求  gcd  (  N  ,  x  )  =  d  的  个  数  ,<br>显  然  只  gcd  (  N  ,  d  )  =  d  ,  当  且  仅  当  gcd  (  N  ,  d  ∗  z  )  =<br>d</p><blockquote><p>gcd(a,b)&gt;=c 可以转化成gcd(a/c,b/c)=1;</p></blockquote><p>那么  gcd  (  N  /  d  ,  d  ∗  z  /  d  )  =  1  gcd  (  N  /  d  ,  z  )  =  1</p><p>那么就是 求  小  于  N  /  d  的  与  N  /  d  互  质  的  数  的  个  数  即  可  ,  也  就  是  欧<br>拉  函  数</p><p>最后答案就是  ∑  d  |  n  ,  d  &gt; =  m  ϕ  (  d  )</p><p>题目所求的欧拉函数也同理</p><p>最后O(sqrt(n)^(3/2))可解决</p><p>附本题代码<br>———————–.</p><pre><code>#include &lt;stdio.h&gt;#include &lt;vector&gt;#include &lt;iostream&gt;#include &lt;stdlib.h&gt;using namespace std;#define LL long long int#define pb push_backint Euler(int n){    if(n==1)    return 1;    int m=n;    for(int i=2; i*i&lt;=m; i++)        if(m%i==0)        {            n-=n/i;            while(m%i==0)                m/=i;        }    if(m!=1)    {        n-=n/m;    }    return n;}int solve(int n,int m){    int ans=0;    for(int i=1; i*i&lt;=n; i++)    {        if(n%i) continue;        if(i&gt;=m&amp;&amp;i*i!=n)            ans += Euler(n/i);        if(n/i&gt;=m)            ans += Euler(i);    }    return ans;}int main(){    int _,p=0;    scanf(&quot;%d&quot;,&amp;_);    while(_--)    {        int  n,m;        scanf(&quot;%d%d&quot;,&amp;n,&amp;m);        int sum=solve(n,m);        printf(&quot;%d\n&quot;,sum);    }    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  codeforces 704A Thor [技巧吧.]</title>
      <link href="/2016/08/10/52171819/"/>
      <url>/2016/08/10/52171819/</url>
      
        <content type="html"><![CDATA[<h1 id="codeforces-704A-Thor-技巧吧"><a href="#codeforces-704A-Thor-技巧吧" class="headerlink" title="codeforces 704A Thor [技巧吧.]"></a>codeforces 704A Thor [技巧吧.]</h1><p>2016年08月10日 15:19:05  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：440</p><hr><p> 博客爬取于<code>2019-04-18 17:20:09</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/52171819" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/52171819</a></p><p>题目连接 : <a href="http://codeforces.com/problemset/problem/704/A" target="_blank" rel="noopener"> http://codeforces.com/problemset/problem/704/A</a></p><p>————————————–.<br>A. Thor<br>time limit per test2 seconds<br>memory limit per test256 megabytes<br>inputstandard input<br>outputstandard output<br>Thor is getting used to the Earth. As a gift Loki gave him a smartphone. There<br>are n applications on this phone. Thor is fascinated by this phone. He has<br>only one minor issue: he can’t count the number of unread notifications<br>generated by those applications (maybe Loki put a curse on it so he can’t).</p><p>q events are about to happen (in chronological order). They are of three<br>types:</p><p>Application x generates a notification (this new notification is unread).<br>Thor reads all notifications generated so far by application x (he may re-read<br>some notifications).<br>Thor reads the first t notifications generated by phone applications<br>(notifications generated in first t events of the first type). It’s guaranteed<br>that there were at least t events of the first type before this event. Please<br>note that he doesn’t read first t unread notifications, he just reads the very<br>first t notifications generated on his phone and he may re-read some of them<br>in this operation.<br>Please help Thor and tell him the number of unread notifications after each<br>event. You may assume that initially there are no notifications in the phone.</p><p>Input<br>The first line of input contains two integers n and q (1 ≤ n, q ≤ 300 000) —<br>the number of applications and the number of events to happen.</p><p>The next q lines contain the events. The i-th of these lines starts with an<br>integer typei — type of the i-th event. If typei = 1 or typei = 2 then it is<br>followed by an integer xi. Otherwise it is followed by an integer ti (1 ≤<br>typei ≤ 3, 1 ≤ xi ≤ n, 1 ≤ ti ≤ q).</p><p>Output<br>Print the number of unread notifications after each event.</p><p>Examples<br>input<br>3 4<br>1 3<br>1 1<br>1 2<br>2 3<br>output<br>1<br>2<br>3<br>2<br>input<br>4 6<br>1 2<br>1 4<br>1 2<br>3 3<br>1 3<br>1 3<br>output<br>1<br>2<br>3<br>0<br>1<br>2<br>Note<br>In the first sample:</p><p>Application 3 generates a notification (there is 1 unread notification).<br>Application 1 generates a notification (there are 2 unread notifications).<br>Application 2 generates a notification (there are 3 unread notifications).<br>Thor reads the notification generated by application 3, there are 2 unread<br>notifications left.<br>In the second sample test:</p><p>Application 2 generates a notification (there is 1 unread notification).<br>Application 4 generates a notification (there are 2 unread notifications).<br>Application 2 generates a notification (there are 3 unread notifications).<br>Thor reads first three notifications and since there are only three of them so<br>far, there will be no unread notification left.<br>Application 3 generates a notification (there is 1 unread notification).<br>Application 3 generates a notification (there are 2 unread notifications).</p><p>———————————-.<br>题目大意 :<br>就是你有一个手机 有三种操作<br>1,x软件收到一个信息<br>2,看了所有x软件的信息<br>3,看了第1~第x次收到的信息 （被看过的也算）</p><p>每次都输出一下当前手机里的未读信息的个数</p><p>题解 ：<br>首先把信息编号<br>用一个vector 和set 维护下就好了<br>vector有n个 代表n个软件 每次向n[x]中加入新的信息编号<br>set存储所有的信息</p><p>维护的时候<br>对于1 操作 把信息编号加入vector 和set<br>对于2 操作 对应n[x]遍历一遍 从set中删除<br>对于3 操作 遍历1~x 从set中删除 （这里注意每次的x要记录一下 然后下一次遍历的时候只要遍历这个x到下一个x的区间就行了 之前被删除的不用再删除一遍<br>否则会TLE）<br>每次输出set的大小就行了</p><p>这样总体复杂度是O(2n)</p><p>/ <strong> _ </strong> <strong>**</strong> <strong> _ </strong> 这些shi牢骚<br>这道题是赛后补得 并且看了网上的题解<br>当时 想到了思路 当时没有做主要是怕TLE 在一个不太会用set （我是小白） 当时想到的是对数组二分查找整个区间 然后删除<br>当对判断数据的统计这一块只想到了线段树（赛前几天才学习数据结构，做什么题都想用线段树） 然后旁边队友 风骚的A了这道题后 告诉用STL做<br>然而对于不会STL的我老说 根本没法搞。 So我就不做了。。。<br>仔细想来 根本不用那么麻烦 多熟练下vector map set 这东西其实是能秒的。。<br><strong> _ </strong> <strong>**</strong> <strong> _ </strong> /<br>附本题代码<br>————————-.</p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn = 300010;vector&lt;int&gt; app[maxn];set&lt;int&gt; cnt;int main(){    int n,q,x,type,num;    while(~scanf(&quot;%d%d&quot;,&amp;n,&amp;q))    {        num = 0;        cnt.clear();        int last = 0;        for(int i=0;i&lt;q;i++)        {            scanf(&quot;%d%d&quot;,&amp;type,&amp;x);            if(type==1)            {                app[x].push_back(++num);                cnt.insert(num);            }            else if(type==2)            {                for(int i=0;i&lt;app[x].size();i++)                    cnt.erase(app[x][i]);                app[x].clear();            }            else            {                for(int i=last;i&lt;=x;i++)                {                    cnt.erase(i);                }                last = max(x,last);            }            printf(&quot;%d\n&quot;,cnt.size());        }    }    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  POJ 2513 Colored Sticks [tire树+并查集]</title>
      <link href="/2016/08/10/52169407/"/>
      <url>/2016/08/10/52169407/</url>
      
        <content type="html"><![CDATA[<h1 id="POJ-2513-Colored-Sticks-tire树-并查集"><a href="#POJ-2513-Colored-Sticks-tire树-并查集" class="headerlink" title="POJ 2513 Colored Sticks [tire树+并查集]"></a>POJ 2513 Colored Sticks [tire树+并查集]</h1><p>2016年08月10日 10:57:04  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：212<br>标签：  <a href="https://so.csdn.net/so/search/s.do?q=poj&amp;t=blog" target="_blank" rel="noopener"> poj </a></p><p>个人分类：  <a href="https://blog.csdn.net/qq_33184171/article/category/6114215" target="_blank" rel="noopener"> POJ </a> <a href="https://blog.csdn.net/qq_33184171/article/category/6188704" target="_blank" rel="noopener"><br>===== 图论 ===== </a> <a href="https://blog.csdn.net/qq_33184171/article/category/6362436" target="_blank" rel="noopener"><br>==== 字符串 ==== </a></p><hr><p> 博客爬取于<code>2019-04-18 17:20:10</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/52169407" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/52169407</a></p><p>题目连接 : <a href="http://poj.org/problem?id=2513" target="_blank" rel="noopener"> <strong> 传送阵 </strong> </a></p><p>———————————————-.<br>Colored Sticks<br>Time Limit: 5000MS Memory Limit: 128000K<br>Total Submissions: 35437 Accepted: 9287<br>Description</p><p>You are given a bunch of wooden sticks. Each endpoint of each stick is colored<br>with some color. Is it possible to align the sticks in a straight line such<br>that the colors of the endpoints that touch are of the same color?<br>Input</p><p>Input is a sequence of lines, each line contains two words, separated by<br>spaces, giving the colors of the endpoints of one stick. A word is a sequence<br>of lowercase letters no longer than 10 characters. There is no more than<br>250000 sticks.<br>Output</p><p>If the sticks can be aligned in the desired way, output a single line saying<br>Possible, otherwise output Impossible.<br>Sample Input</p><p>blue red<br>red violet<br>cyan blue<br>blue magenta<br>magenta cyan<br>Sample Output</p><p>Possible<br>Hint</p><p>Huge input,scanf is recommended.<br>Source</p><p>The UofA Local 2000.10.14</p><p>————————————–.</p><p>题目大意 就是有多个木棍 两头有颜色 对于不同的木棍 相同颜色的一段能连接到一块 问你所有的棍能不能接成一根棍子</p><p>解题思路：<br>应该想到如果颜色是用数字表示的就非常好解决了 只要判断一下这些每个颜色的度就能解决 注意！！ 生成的图可能是个森林 所以要用并查集判断下<br>是否生成的是一个树（应该是环）<br>现在想的问题就只剩下字符串怎么转化成数字了 用map转化的话不可行 所以想到用tire树来解决 这样才不会爆内存<br>对于学会tire树的你相信不是个问题 注意的是 把每个串插入到树中的时候只要把最后一个字符所在的节点+1 就行了<br>再在tire中加上一个index（索引）的元素 记录这个串的编号 (查询操作是没用的)<br><strong> 刚学字符串10days 纯属个人解法 如有错误 请一定要指正 </strong></p><p><strong> 附本题代码 </strong><br>———————————————.</p><pre><code>#include &lt;bits/stdc++.h&gt;using namespace std;#define LL long long int#define lalal puts(&quot;********&quot;);const int N = 1010101;const int Max = 26;char s1[11],s2[11];int pre[505050];int degree[505050];typedef struct node{    struct node *next[Max];    int num;    int index;} Node;//创建一个新节点Node *createNew(){    Node *p=new Node;    for(int i=0; i&lt;Max; i++)        p-&gt;next[i]=NULL;    p-&gt;num=0;    return p;}Node *head;int ind=0;//插入一个字符串Node *Insert_str(char str[]){    int len=strlen(str);    //  printf(&quot;len = %d--  &quot;,len);    Node *t,*p=head;    for(int i=0; i&lt;len; i++)    {        int c=str[i]-&#39;a&#39;;        if( p-&gt;next[c] == NULL )        {            //lalal            t=createNew();            p-&gt;next[c]=t;        }        p=p-&gt;next[c];        //统计的时候要分清时机        // cout&lt;&lt;p-&gt;num&lt;&lt;&quot;-&quot;&lt;&lt;str[i]&lt;&lt;&quot; &quot;;    }    p-&gt;num++;    if(p-&gt;num==1)  p-&gt;index=++ind;    return p;}int findi(int x){    int r=x;    while(r!=pre[r])        r=pre[r];    int i=x,j;    while(i!=j)    {        j=pre[i];        pre[i]=r;        i=j;    }    return r;}void join(int x,int y){    int fx=findi(x),fy=findi(y);    if(fx!=fy)        pre[fx]=fy;}void init(){    for(int i=0; i&lt;=500050; i++)    {        pre[i]=i;        degree[i]=0;    }    return ;}int main(){    head = createNew();    init();    int num=0;    Node * tem1,*tem2 ;    while(~scanf(&quot;%s %s&quot;,s1,s2))    {        tem1 = Insert_str(s1);        tem2 = Insert_str(s1);        degree[tem1-&gt;index]++;        degree[tem2-&gt;index]++;        join(tem1-&gt;index,tem2-&gt;index);    }    for(int i=1; i&lt;=ind; i++)    {        if(degree[i]%2 == 1) num++;        if(num&gt;=3)        {            puts(&quot;Impossible&quot;);            break;        }        if(findi(1)!=findi(i))        {            puts(&quot;Impossible&quot;);            break;        }    }    if(num!=1) puts(&quot;Possible&quot;);    else     puts(&quot;Impossible&quot;);    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> poj </tag>
            
            <tag> POJ </tag>
            
            <tag> 图论 </tag>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  字符串问题 ---模板（不定期更新中。）</title>
      <link href="/2016/08/08/52151010/"/>
      <url>/2016/08/08/52151010/</url>
      
        <content type="html"><![CDATA[<h1 id="字符串问题-—模板（不定期更新中。）"><a href="#字符串问题-—模板（不定期更新中。）" class="headerlink" title="字符串问题 —模板（不定期更新中。）"></a>字符串问题 —模板（不定期更新中。）</h1><p>置顶  2016年08月08日 13:20:00  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：792</p><hr><p> 博客爬取于<code>2019-04-18 17:15:11</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/52151010" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/52151010</a></p><h1 id="KMP"><a href="#KMP" class="headerlink" title="KMP"></a>KMP</h1><p>算法介绍文章： <a href="http://blog.csdn.net/u011564456/article/details/20862555?utm_source=tuicool&amp;utm_medium=referral" target="_blank" rel="noopener"> http://blog.csdn.net/u011564456/article/details/20862555?utm_source=<br>tuicool&amp;utm_medium=referral </a></p><pre><code>char s1[N],s2[N];int Next[N];//Next[i] 表示从[0~i]中最长公共前缀的长.void get_next(char *s,int len){    for(int i=0,j=-1;i&lt;=len;++i,++j){        Next[i]=j;        while(j&gt;=0&amp;&amp;s[i]!=s[j]) j = Next[j];    }//    for(int i=0;i&lt;=len;i++) printf(&quot;%d%c&quot;,Next[i],(i==len)?&#39;\n&#39;:&#39; &#39;);}//在串s上找szint KMP (char *s,int len,char *sz,int l){    int i=0,j=0,cnt=0;    while(i&lt;len/*&amp;&amp;j&lt;l*/){        if(s[i]==sz[j])  i++,j++;        else{            if(0==j)  i++;            else      j=Next[j];        }        if(j==l) cnt++;    }//   return (j==l)?(i-l+1):-1; //找第一次出现的位置    return cnt; //找出现的个数}/*            for(int j=0,i=0;i&lt;=len;i++,j++){                ans ^= 1LL*(j)*(j)*(len-k-j)*(i-j) ;                while(j&gt;=0&amp;&amp;a[i]!=p[j]) j=Next[j];            }*/</code></pre><h1 id="字典树"><a href="#字典树" class="headerlink" title="字典树"></a>字典树</h1><h3 id="实现方法1"><a href="#实现方法1" class="headerlink" title="实现方法1"></a>实现方法1</h3><p>指针动态实现</p><pre><code>//#include &lt;bits/stdc++.h&gt;#include &lt;iostream&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;algorithm&gt;using namespace std;#define LL long long int#define lalal puts(&quot;********&quot;);const int N = 1010101;const int Max = 26;typedef struct node{    struct node *next[Max];    int num;}Node;//创建一个新节点Node *createNew(){    Node *p=new Node;    for(int i=0;i&lt;Max;i++)        p-&gt;next[i]=NULL;    p-&gt;num=0;    return p;}Node *head;//插入一个字符串void Insert_str(char str[]){    int len=strlen(str);  //  printf(&quot;len = %d--  &quot;,len);    Node *t,*p=head;    for(int i=0;i&lt;len;i++)    {        int c=str[i]-&#39;a&#39;;        if( p-&gt;next[c] == NULL )        {            //lalal            t=createNew();            p-&gt;next[c]=t;        }        p=p-&gt;next[c];        p-&gt;num++;       // cout&lt;&lt;p-&gt;num&lt;&lt;&quot;-&quot;&lt;&lt;str[i]&lt;&lt;&quot; &quot;;    }}int Search_str(char str[]){    Node *p=head;    int len=strlen(str);    int counts=0;    for(int i=0;i&lt;len;i++)    {        int c=str[i]-&#39;a&#39;;        if(p-&gt;next[c]==NULL)        {        //  cout&lt;&lt;&quot;不存在字符串&quot;&lt;&lt;endl;            counts=0;            return 0;        }        else        {            p=p-&gt;next[c];            counts=p-&gt;num;            //printf(&quot;%d &quot;,p-&gt;num);        }    }    return counts;}int main(){    head = createNew();    char s[11];    while(gets(s)&amp;&amp;s[0]!=&#39;\0&#39;) {Insert_str(s);} //一直读入数据，直到遇到空字符串    while(gets(s))        printf(&quot;%d\n&quot;,Search_str(s));    return 0;}</code></pre><h3 id="实现方法2"><a href="#实现方法2" class="headerlink" title="实现方法2"></a>实现方法2</h3><p>数组静态实现<br>(Double Arrays Trie-DAT)<br>用两个数组来实现<br>其实本质来看，就和模拟数组差不多少的东西，每次将元素放到尾部。<br>再用另一个二位数组来表示接下来的索引就行了。</p><pre><code>const int N = 100000+7;int a[N][字符种类数],f[N],cnt = 0;//插入inline void insert(String str){      int  len = str.length(),now = 0;    for(int i=0;i&lt;len;++i){        if(!a[now][str[i]-&#39;a&#39;]) a[now][str[i]-&#39;a&#39;] = ++cnt;        now = a[now][str[i]-&#39;a&#39;];        ++f[now];    }    return ;}</code></pre><h1 id="AC自动机"><a href="#AC自动机" class="headerlink" title="AC自动机"></a>AC自动机</h1><p><a href="http://www.cnblogs.com/DrunBee/archive/2012/08/09/2617616.html" target="_blank" rel="noopener"> 讲义+例题 </a><br><a href="http://www.cnblogs.com/xudong-bupt/p/3433506.html" target="_blank" rel="noopener"> 讲解1 </a><br><a href="http://blog.csdn.net/mobius_strip/article/details/22549517" target="_blank" rel="noopener"> 讲解2 </a></p><h3 id="实现方法1-1"><a href="#实现方法1-1" class="headerlink" title="实现方法1"></a>实现方法1</h3><p>指针动态存储</p><pre><code>#include&lt;iostream&gt;#include&lt;string.h&gt;#include&lt;malloc.h&gt;#include &lt;queue&gt;using namespace std;typedef struct node{    struct node *next[26];  //接收的态    struct node *par;   //父亲节点    struct node *fail;  //失败节点    char inputchar;    int patterTag;    //是否为可接收态    int patterNo;   //接收态对应的可接受模式}*Tree,TreeNode;char pattern[4][30]={&quot;nihao&quot;,&quot;hao&quot;,&quot;hs&quot;,&quot;hsr&quot;};/**申请新的节点，并进行初始化*/TreeNode *getNewNode(){    int i;    TreeNode* tnode=(TreeNode*)malloc(sizeof(TreeNode));    tnode-&gt;fail=NULL;    tnode-&gt;par=NULL;    tnode-&gt;patterTag=0;    for(i=0;i&lt;26;i++)        tnode-&gt;next[i]=NULL;    return tnode;}/**将Trie树中，root节点的分支节点，放入队列*/int  nodeToQueue(Tree root,queue&lt;Tree&gt; &amp;myqueue){    int i;    for (i = 0; i &lt; 26; i++)    {        if (root-&gt;next[i]!=NULL)            myqueue.push(root-&gt;next[i]);    }    return 0;}/**建立trie树*/Tree buildingTree(){    int i,j;    Tree root=getNewNode();    Tree tmp1=NULL,tmp2=NULL;    for(i=0;i&lt;4;i++)    {        tmp1=root;        for(j=0;j&lt;strlen(pattern[i]);j++)   ///对每个模式进行处理        {            if(tmp1-&gt;next[pattern[i][j]-&#39;a&#39;]==NULL) ///是否已经有分支，Trie共用节点            {                tmp2=getNewNode();                tmp2-&gt;inputchar=pattern[i][j];                tmp2-&gt;par=tmp1;                tmp1-&gt;next[pattern[i][j]-&#39;a&#39;]=tmp2;                tmp1=tmp2;            }            else                tmp1=tmp1-&gt;next[pattern[i][j]-&#39;a&#39;];        }        tmp1-&gt;patterTag=1;        tmp1-&gt;patterNo=i;    }    return root;}/**建立失败指针*/int buildingFailPath(Tree root){    int i;    char inputchar;    queue&lt;Tree&gt; myqueue;    root-&gt;fail=root;    for(i=0;i&lt;26;i++)   ///对root下面的第二层进行特殊处理    {        if (root-&gt;next[i]!=NULL)        {            nodeToQueue(root-&gt;next[i],myqueue);            root-&gt;next[i]-&gt;fail=root;        }    }    Tree tmp=NULL,par=NULL;    while(!myqueue.empty())    {        tmp=myqueue.front();        myqueue.pop();        nodeToQueue(tmp,myqueue);        inputchar=tmp-&gt;inputchar;        par=tmp-&gt;par;        while(true)        {            if(par-&gt;fail-&gt;next[inputchar-&#39;a&#39;]!=NULL)            {                tmp-&gt;fail=par-&gt;fail-&gt;next[inputchar-&#39;a&#39;];                break;            }            else            {                if(par-&gt;fail==root)                {                    tmp-&gt;fail=root;                    break;                }                else                    par=par-&gt;fail-&gt;par;            }        }    }    return 0;}/**进行多模式搜索，即搜寻AC自动机*/int searchAC(Tree root,char* str,int len){    TreeNode *tmp=root;    int i=0;    while(i &lt; len)    {        int pos=str[i]-&#39;a&#39;;        if (tmp-&gt;next[pos]!=NULL)        {            tmp=tmp-&gt;next[pos];            if(tmp-&gt;patterTag==1)    ///如果为接收态            {                cout&lt;&lt;i-strlen(pattern[tmp-&gt;patterNo])+1&lt;&lt;&#39;\t&#39;&lt;&lt;tmp-&gt;patterNo&lt;&lt;&#39;\t&#39;&lt;&lt;pattern[tmp-&gt;patterNo]&lt;&lt;endl;            }            i++;        }        else        {            if(tmp==root)                i++;            else            {                tmp=tmp-&gt;fail;                if(tmp-&gt;patterTag==1)    //如果为接收态                    cout&lt;&lt;i-strlen(pattern[tmp-&gt;patterNo])+1&lt;&lt;&#39;\t&#39;&lt;&lt;tmp-&gt;patterNo&lt;&lt;&#39;\t&#39;&lt;&lt;pattern[tmp-&gt;patterNo]&lt;&lt;endl;            }        }    }    while(tmp!=root)    {        tmp=tmp-&gt;fail;        if(tmp-&gt;patterTag==1)            cout&lt;&lt;i-strlen(pattern[tmp-&gt;patterNo])+1&lt;&lt;&#39;\t&#39;&lt;&lt;tmp-&gt;patterNo&lt;&lt;&#39;\t&#39;&lt;&lt;pattern[tmp-&gt;patterNo]&lt;&lt;endl;    }    return 0;}/**释放内存，DFS*/int destory(Tree tree){    if(tree==NULL)        return 0;    queue&lt;Tree&gt; myqueue;    TreeNode *tmp=NULL;    myqueue.push(tree);    tree=NULL;    while(!myqueue.empty())    {        tmp=myqueue.front();        myqueue.pop();        for (int i = 0; i &lt; 26; i++)        {            if(tmp-&gt;next[i]!=NULL)                myqueue.push(tmp-&gt;next[i]);        }        free(tmp);    }    return 0;}int main(){    char a[]=&quot;sdmfhsgnshejfgnihaofhsrnihao&quot;;    Tree root=buildingTree();   ///建立Trie树    buildingFailPath(root); ///添加失败转移    cout&lt;&lt;&quot;待匹配字符串：&quot;&lt;&lt;a&lt;&lt;endl;    cout&lt;&lt;&quot;模式&quot;&lt;&lt;pattern[0]&lt;&lt;&quot; &quot;&lt;&lt;pattern[1]&lt;&lt;&quot; &quot;&lt;&lt;pattern[2]&lt;&lt;&quot; &quot;&lt;&lt;pattern[3]&lt;&lt;&quot; &quot;&lt;&lt;endl&lt;&lt;endl;    cout&lt;&lt;&quot;匹配结果如下：&quot;&lt;&lt;endl&lt;&lt;&quot;位置\t&quot;&lt;&lt;&quot;编号\t&quot;&lt;&lt;&quot;模式&quot;&lt;&lt;endl;    searchAC(root,a,strlen(a)); ///搜索    destory(root);  ///释放动态申请内存    return 0;}</code></pre><h3 id="实现方法2-1"><a href="#实现方法2-1" class="headerlink" title="实现方法2"></a>实现方法2</h3><pre><code>const int MAXN = 300000+777;template&lt;class T&gt;struct AC_AUTO{    map&lt;T,int&gt;mp[MAXN];    typename map&lt;T,int&gt; :: iterator it;    int fail[MAXN],val[MAXN],Q[MAXN],head,tail,root,cnt;    void init(){        cnt=0;        root=newnode();    }    int newnode(){        mp[cnt].clear();        val[cnt++]=0;        return cnt-1;    }    void insert(T s[],int n){        int now=root;        for(int i=0;i&lt;n;i++){            if(!mp[now].count(s[i]))                 mp[now][s[i]]=newnode();            now=mp[now][s[i]];        }        val[now]++;    }    void build(){        head=tail=0;        fail[root]=root;        for(it=mp[root].begin();it!=mp[root].end();++it){            fail[it-&gt;second]=root;            Q[tail++]=it-&gt;second;        }        while(head!=tail){            int now=Q[head++];            val[now]+=val[fail[now]];            for(it=mp[now].begin();it!=mp[now].end();++it){                int x=fail[now],flag=0;                while(x!=root){                    if(mp[x].count(it-&gt;first)){                        fail[it-&gt;second]=mp[x][it-&gt;first];                        flag=1;                        break;                    }                    x=fail[x];                }                if(x==root &amp;&amp; mp[x].count(it-&gt;first)){                    fail[it-&gt;second]=mp[x][it-&gt;first];                    flag=1;                }                if(!flag) fail[it-&gt;second]=root;                Q[tail++]=it-&gt;second;            }        }    }    LL query(T s[],int n){        LL ret=0;        int now=root;        for(int i=0;i&lt;n;i++){            int x=now,flag=0;            while(x!=root){                if(mp[x].count(s[i])){                    now=mp[x][s[i]];                    flag=1;                    break;                }                x=fail[x];            }            if(x==root &amp;&amp; mp[x].count(s[i])){                now=mp[x][s[i]];                flag=1;            }            if(!flag) now=root;            ret+=val[now];        }        return ret;    }};AC_AUTO&lt;int&gt; ac;int a[N],b[N],n,m,len,x,pre;int main(){    ac.init();    while(){        ac.insert(b,len);    }    ac.build();    ans = ac.query(a,n-1);    return 0;}</code></pre><h1 id="Manacher"><a href="#Manacher" class="headerlink" title="Manacher"></a>Manacher</h1><p>Manacher 是一个能在  O  (  n  )  的复杂度内解决字符串中最长回文子串的问题</p><p><a href="http://www.cnblogs.com/biyeymyhjob/archive/2012/10/04/2711527.html" target="_blank" rel="noopener"> 这篇帖子给的挺详细的</a></p><pre><code>/***str  原字符串a    进行Manacher算法的为减轻编码难度改进的字符串p[i] 以a[i]为中心的回文串的半径(含a[i])id   最长回文子串的中心位置mx   id+p[id] 最长回文子串的左外边界。算法核心的部分if(mx &gt; i) p[i] = (p[(id&lt;&lt;1)-i]&lt;(mx-i))?p[(id&lt;&lt;1)-1]:(mx-i);else p[i]=1;首先我们知道对于一个字符串进行操作的时候，是从左到右依次进行的那么由于回文串的对称性，那么可以确定的是对于a[i]为中心的回文串的长度至少是在以这个最大的回文串中对称的那个位置为中心的回文串的长度,但只能确定的是在最大的回文串的那一部分中的长度,至于之外的就要一个个的匹配了*//***id  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7a： $ # 1 # 2 # 2 # 1 # 2 # 3 # 2 # 1 #p_i 1 1 2 1 2 5 2 */char a[N],str[N];int p[N];void train(){    int len  = 0;    a[len] = &#39;$&#39;, a[++len] = &#39;#&#39;;    int slen = strlen(str)-1;    Rep(i,0,slen) a[++len] = str[i],a[++len] = &#39;#&#39;;    memset(p,0,sizeof(p));    int id = -1,mx = -1,mxp = -1;    Rep(i,0,len){        if(mx &gt; i) p[i] = (p[(id&lt;&lt;1)-i]&lt;(mx-i))?p[(id&lt;&lt;1)-i]:(mx-i);        else p[i]=1;        while(a[i-p[i]]==a[i+p[i]]) p[i]++;        if(p[i]+i&gt;mx) mx=p[i]+i,id=i;        if(p[i]&gt;mxp) mxp = p[i];    }    printf(&quot;%d\n&quot;,mxp-1);    return ;}</code></pre><h1 id="后缀数组"><a href="#后缀数组" class="headerlink" title="后缀数组"></a>后缀数组</h1><p>SA[i] = j表示为按照从小到大排名为i的后缀 是以j（下标）开头的后缀</p><p>rank[i] = j 表示为按照从小到大排名 以i为下标开始的后缀 排名为j</p><p>RANK表示你排第几 SA表示排第几的是谁 （记住这个就行）</p><p>height[i] 表示 sa[i] 与 sa[i-1] 的最长公共前缀(LCP)</p><pre><code>const int MAXN=400010;//以下为倍增算法求后缀数组int wa[MAXN],wb[MAXN],wv[MAXN],Ws[MAXN];int cmp(int *r,int a,int b,int l) {    return r[a]==r[b]&amp;&amp;r[a+l]==r[b+l];}/**&lt; 传入参数：str,sa,len+1,ASCII_MAX+1 */void da(const int r[],int sa[],int n,int m) {    int i,j,p,*x=wa,*y=wb,*t;    for(i=0; i&lt;m; i++) Ws[i]=0;    for(i=0; i&lt;n; i++) Ws[x[i]=r[i]]++;//以字符的ascii码为下标    for(i=1; i&lt;m; i++) Ws[i]+=Ws[i-1];    for(i=n-1; i&gt;=0; i--) sa[--Ws[x[i]]]=i;    /*cout&lt;&lt;&quot;SA&quot;&lt;&lt;endl;;    for(int i=0;i&lt;n+1;i++)cout&lt;&lt;sa[i]&lt;&lt;&#39; &#39;;*/    for(j=1,p=1; p&lt;n; j*=2,m=p) {        for(p=0,i=n-j; i&lt;n; i++) y[p++]=i;        for(i=0; i&lt;n; i++) if(sa[i]&gt;=j) y[p++]=sa[i]-j;        for(i=0; i&lt;n; i++) wv[i]=x[y[i]];        for(i=0; i&lt;m; i++) Ws[i]=0;        for(i=0; i&lt;n; i++) Ws[wv[i]]++;        for(i=1; i&lt;m; i++) Ws[i]+=Ws[i-1];        for(i=n-1; i&gt;=0; i--) sa[--Ws[wv[i]]]=y[i];        for(t=x,x=y,y=t,p=1,x[sa[0]]=0,i=1; i&lt;n; i++)            x[sa[i]]=cmp(y,sa[i-1],sa[i],j)?p-1:p++;    }    return;}int sa[MAXN],Rank[MAXN],height[MAXN];//求height数组/**&lt; str,sa,len */void calheight(const char *r,int *sa,int n) {    int i,j,k=0;    for(i=1; i&lt;=n; i++) Rank[sa[i]]=i;    for(i=0; i&lt;n; height[Rank[i++]]=k)        for(k?k--:0,j=sa[Rank[i]-1]; r[i+k]==r[j+k]; k++);    // Unified  不要乱用，出来检查为了方便的时候 否则容易RE，WA//    for(int i=n; i&gt;=1; --i) ++sa[i],Rank[i]=Rank[i-1];}//求lcp(suffixal(i),suffixal(j))int mm[MAXN],dp[MAXN][20];void initrmq(int n,int b[]) {    mm[0]=-1;    for(int i=1; i&lt;=n; i++) {        mm[i]=((i&amp;(i-1))==0)?mm[i-1]+1:mm[i-1];        dp[i][0]=b[i];    }    for(int j=1; j&lt;=mm[n]; j++)        for(int i=1; i+(1&lt;&lt;j)-1&lt;=n; i++)            dp[i][j]=min(dp[i][j-1],dp[i+(1&lt;&lt;(j-1))][j-1]);}int lcp(int x,int y) {    x=Rank[x],y=Rank[y];    if(x&gt;y) swap(x,y); x++;    int k=mm[y-x+1];    return min(dp[x][k],dp[y-(1&lt;&lt;k)+1][k]);}char s[N];int a[N];int main(){    scanf(&quot;%s&quot;,s);    int ls = strlen(s);    for(int i=0;i&lt;ls;i++) a[i]=s[i]-&#39;a&#39;+1; a[ls]=0;    da(a,sa,ls+1,30);    calheight(a,sa,ls);    initrmq(ls+1,height);    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  数据结构 [未完成 待续~待修改]</title>
      <link href="/2016/08/08/52148588/"/>
      <url>/2016/08/08/52148588/</url>
      
        <content type="html"><![CDATA[<h1 id="数据结构-未完成-待续-待修改"><a href="#数据结构-未完成-待续-待修改" class="headerlink" title="数据结构 [未完成 待续~待修改]"></a>数据结构 [未完成 待续~待修改]</h1><p>置顶  2016年08月08日 08:35:28  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：737</p><hr><p> 博客爬取于<code>2019-04-18 17:15:11</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/52148588" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/52148588</a></p><h2 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h2><h4 id="简单并查集"><a href="#简单并查集" class="headerlink" title="简单并查集"></a>简单并查集</h4><p><a href="http://blog.csdn.net/dellaserss/article/details/7724401" target="_blank" rel="noopener"> 算法讲义 </a></p><pre><code>不需要模板</code></pre><h3 id="带权并查集"><a href="#带权并查集" class="headerlink" title="带权并查集"></a>带权并查集</h3><pre><code>int pre[N];int findi(int x){    if(pre[x]==x) return x;    int r = findi(pre[x]);    /**    省略了权值间关系转化,具体视情况而定    */    pre[x]=r;    return r;}void join(int x,int y,int X,int Y){    int fx = findi(x),fy = findi(y);    pre[fx]=fy;    /**    省略了权值间关系转化,具体视情况而定    */    return ;}</code></pre><h3 id="并查集-可拆点"><a href="#并查集-可拆点" class="headerlink" title="并查集(可拆点)"></a>并查集(可拆点)</h3><p><a href="http://www.cnblogs.com/vivym/p/3916410.html" target="_blank" rel="noopener"> 代码实现 </a></p><blockquote><p>可以明确的是,对于一个并查集来说,合并操作是不可逆的,即两个元素处在同一个集合下,那么就不能将两者拆开否则会产生错误.那么问题来了<br><strong> 问: </strong> 如果一个节点的关系发生改变了怎么办呢?<br><strong> 答: </strong> 如果要改变节点 <strong> a </strong> 的关系重新创建一个节点 <strong> p </strong> 表示节点 <strong> a </strong> ,原先的节点 <strong> a </strong> 就不要了,通过一个映射,映射过去就行了(map[a]=p) </p></blockquote><pre><code>int pre[N],h[N],hh;int findi(int x){    if(pre[x]==x) return x;    int r = findi(pre[x]);    pre[x]=r;    return r;}void join(int x,int y,int X,int Y){    int fx = findi(x),fy = findi(y);    pre[fx]=fy;    return ;}void creat(int now){    h[now]=++hh;    pre[hh]=hh;}</code></pre><h3 id="可持久化并查集"><a href="#可持久化并查集" class="headerlink" title="可持久化并查集"></a>可持久化并查集</h3><p>可持久化数据结构就是可以访问历史版本的数据结构，能修改之后还能查询之前的状态就是可持久化。</p><p>现在还没有学明白，会更新上的。</p><h2 id="树状数组（Tree-array）"><a href="#树状数组（Tree-array）" class="headerlink" title="树状数组（Tree array）"></a>树状数组（Tree array）</h2><p>详解戳 <a href="http://m.blog.csdn.net/article/details?id=51119042" target="_blank" rel="noopener"> 这里&lt;&lt;— </a><br><strong> <a href="http://blog.csdn.net/lawrence_jang/article/details/8054173" target="_blank" rel="noopener"> 这里有最详细的树状数组各种操作的模板 </a> </strong><br><strong> 注意 </strong> :一定要仔细看数据范围 如果是从0开始的 那么在树状数组中一定要加上1然后在操作 因为求和的时候有-1操作 所以不这样就会无限TLE…<br>1.前缀和<br>2.[1,n]的最大最小值 ,换句话就还是前缀的东西.<br>3.区间覆盖的问题 (仅限对区间进行增改值的,更新还是一样查询的时候注意只要getSum(id)就行了)</p><h4 id="一维树状数组"><a href="#一维树状数组" class="headerlink" title="一维树状数组"></a>一维树状数组</h4><pre><code>//切记 在多组数据的题上要清空数组const int N = 50000 + 5;            //数列的大小#define lowbit(x)  (x&amp;(-x))         //lowbit操作int sum[N],cnt;                     void update(int index,int val){     //单点更新  （+val）    for(int i=index;i&lt;=N;i+=lowbit(i)){//i&lt;=N   不能&lt;=cnt&lt;--错了        sum[i]+=val;    }}int getSum(int index) {             //求解1~index的和  int ans = 0;  for (int i = index; i; i -= lowbit(i))    ans += sum[i];  return ans;}void update(int l,int r,int val){    update(l,val),update(r+1,-val);}int query(int l,int r){    return getSum(r)-getSum(l-1);}/*一维区间更新（a,b）update(a,1);update(b+1,-1);*/</code></pre><h4 id="二维树状数组"><a href="#二维树状数组" class="headerlink" title="二维树状数组"></a>二维树状数组</h4><p>原理和一维的一模一样</p><pre><code>const int N = 1000+5;#define lowbit(x) (x&amp;-x)LL sum[N][N];void update(int xi,int yi,int val){    for(int i=xi;i&lt;=N;i+=lowbit(i))        for(int j=yi;j&lt;=N;j+=lowbit(j))            sum[i][j]+=val;    return;}int getSum(int xi,int yi){    int ans = 0;    for(int i=xi;i&gt;0;i-=lowbit(i))        for(int j=yi;j&gt;0;j-=lowbit(j))            ans+=sum[i][j];    return ans ;}void update(int x,int y,int X,int Y,int val){    update(x,y,val);    update(x,Y+1,-val);    update(X+1,y,-val);    update(X+1,Y+1,val);}int query(int x,int y,int X,int Y){    return getSum(X,Y)-getSum(X,y-1)-getSum(x-1,Y)+getSum(x-1,y-1);}</code></pre><p>/<em><br>二维区间更新  {  (  a  ,  b  )  |  a  ∈  [  x  ,  X  ]  ,  b  ∈  [  y  ,  Y  ]  }<br>1.update(x,y,val);<br>2.update(x,Y+1,-val);<br>3.update(X+1,y,-val);<br>4.update(X+1,Y+1,val);  </em>/ </p><h2 id="线段树（Segment-Tree）"><a href="#线段树（Segment-Tree）" class="headerlink" title="线段树（Segment Tree）"></a>线段树（Segment Tree）</h2><p>详解戳 <a href="http://www.cppblog.com/menjitianya/archive/2016/02/25/212891.html?utm_source=tuicool&amp;utm_medium=referral" target="_blank" rel="noopener"> 这里 </a></p><p>线段树维护区间和。<br>—————————————.</p><pre><code>/*一定要注意数据范围，必要的时候必须用LL。注意要求，来决定如何更新。*/const int N = 100000+5;struct node{    int l,r; //节点的区间    int val; //节点的值    int lazy;//lazy_tag标记， 区间更新的时候用的     int m(){return (l+r)&gt;&gt;1;}    int len(){return r-l+1;}}tree[N&lt;&lt;2]; //数组要开到四倍啊  这样才不会越界  ，如果超时的话也要看看是不是数组开小了int cnt,a[N],ans;bool vis[N];#define ll  (rt&lt;&lt;1)#define rr  (rt&lt;&lt;1|1)#define mid (tree[rt].m())void pushup(int rt)   //线段树维护值的操作{    tree[rt].val=tree[ll].val+tree[rr].val;}void build(int rt,int l,int r)//建树{    tree[rt].l=l,tree[rt].r=r,tree[rt].lazy=0; //记得区间更新的时候 每次建树 要将lazy_tag标记清0     if(l==r)    {        tree[rt].val=1;        return ;    }    build(ll,l,mid);    build(rr,mid+1,r);    pushup(rt);}void update(int rt,int pos,int val)//单点更新   当前的树的节点  更新的节点  更新的值的变化{    if(tree[rt].l==tree[rt].r)//单点更新的时候只要把叶子节点的值更新 剩下的log回溯就行了    {        tree[rt].val+=val;        return;    }    if(pos&lt;=mid)  update(ll,pos,val);    else          update(rr,pos,val);    pushup(rt);//必须要有的啊 。。}void pushdown(int rt) //向下更新的节点。{    if(tree[rt].lazy)    {        tree[ll].lazy = tree[rr].lazy =tree[rt].lazy ;//根据要求决定如何更新        tree[ll].val  = tree[ll].len()*tree[rt].lazy ;        tree[rr].val  = tree[rr].len()*tree[rt].lazy ;        tree[rt].lazy = 0 ;    }    return ;}void update(int rt,int L,int R,int val) //区间更新 {    if(L&lt;=tree[rt].l&amp;&amp;tree[rt].r&lt;=R)    {        tree[rt].lazy = val ;        tree[rt].val  = val*tree[rt].len() ;        return ;    }    pushdown(rt) ;    if(L&lt;=mid) update(ll,L,R,val) ;    if(R &gt;mid) update(rr,L,R,val) ;    pushup(rt) ;    return ;}int query(int rt,int L,int R)//当前查询的树的节点 [L,R]查询的区间{    if(L&lt;=tree[rt].l&amp;&amp;tree[rt].r&lt;=R)        return    tree[rt].val;    pushdown(rt);//pushdown 操作为区间更新 做的准备。。    int ans = 0 ;     if(L&lt;=mid)    ans+=query(ll,L,R);    if(R &gt;mid)    ans+=query(rr,L,R);    return ans ;}</code></pre><h2 id="线性变换线段树"><a href="#线性变换线段树" class="headerlink" title="线性变换线段树"></a>线性变换线段树</h2><p>所谓线性变换，就是我们的线段树能处理ax+b这种操作。现在线段树的常用操作有add，mul，set无论是哪种我们都可以使用线性变换得到。<br>add v: 1<em>x+v<br>mul v：v</em>x+0<br>set v: 0*x+v</p><h2 id="主席树-函数式线段树-可持久化线段树"><a href="#主席树-函数式线段树-可持久化线段树" class="headerlink" title="主席树(函数式线段树,可持久化线段树)"></a>主席树(函数式线段树,可持久化线段树)</h2><blockquote><p>主席树(函数式线段树,可持久化线段树)其实就是维护多颗线段树,<br>每更新一个元素,那么就根据它的上一状态新建一颗线段树,然后就是线段树的操作了,<br>一般来维护(区间第K大,区间不同元素个数(在线做法))<br>每次新建一颗线段树,都只是开  O  (  log  (  n  )  )  的节点,<br>然后指向前一状态的其他不需要更新的节点,这样的话大大降低了总空间复杂度</p></blockquote><blockquote></blockquote><blockquote><p>主席树的具体维护要看不同情况而定,需要怎么维护就怎么维护即可<br>主席树一般可以看做维护树与树的前缀和,</p></blockquote><pre><code>int rt[N*20];   //表示更新当前元素所形成的不同线段树的树根,int ls[N*20];   //当前节点的左儿子int rs[N*20];   //当前节点的右儿子int sum[N*20];  //主席树节点维护的值int tot;        //节点的标号void build(int &amp;rt,int l,int r){ //建树 一般是先建一颗空树(即没有元素更新在其上) 让之后的更新依他开始,    rt=++tot;    sum[rt]=0;    if(l==r) return ;    int m = (r+l)&gt;&gt;1;    build(ls[rt],l,m);    build(rs[rt],m+1,r);}void update(int &amp;rt,int l,int r,int last,int pos){    rt = ++tot;    ls[rt]=ls[last];    rs[rt]=rs[last];    sum[rt]=sum[last]+1;    if(l==r) return ;    int m = (r+l)&gt;&gt;1;    if(pos&lt;=m) update(ls[rt],l,m,ls[last],pos);    else       update(rs[rt],m+1,r,rs[last],pos);}int query(int ss,int tt,int l,int r,int k){    if(l==r)return l;    int m = (l+r)&gt;&gt;1;    int cnt=sum[ls[tt]]-sum[ls[ss]];       if(k&lt;=cnt) return query(ls[ss],ls[tt],l,m,k);    else       return query(rs[ss],rs[tt],m+1,r,k-cnt);}</code></pre><h2 id="ST（SparseTable）算法"><a href="#ST（SparseTable）算法" class="headerlink" title="ST（SparseTable）算法"></a>ST（SparseTable）算法</h2><blockquote><p>预处理出ST表 实现  O  (  1  )  查询区间最大/小值的算法. <strong> _ (即RMQ问题) _ </strong><br>要求数组是静态的(就是不会有元素更改,删除等操作)</p></blockquote><blockquote></blockquote><blockquote><p>ST表其实就是通过 <strong> 倍增 </strong> 的思想,先将一段一段的区间最大/小值处理出来,然后通过O(1)的计算的出所要求的解.</p></blockquote><blockquote></blockquote><blockquote><p>形象一点就是<br>s  t  [  i  ]  [  j  ]  表示第i个位置开始长度为  1  &lt; &lt; j  的最大最小值,<br>在预处理的时候我们就能够倍增的求出每个位置的st[][]的值,  s  t  [  i  ]  [  j  ]  =  m  a  x  /  m  i<br>n  (  s  t  [  ]  [  j  −  1  ]  ,  s  t  [  ]  [  j  −  1  ]  )  ;</p></blockquote><blockquote></blockquote><blockquote><p>那么这时候每次查询的  [  l  ,  r  ]  就是 因为倍增过来的都是  2  n  长度的.那么就可以找到两个同样长度的区间一个是从  l<br>开始包含  l  向后的区间,另一个是从  r  开始包含  r  向前的区间.取二者的  m  a  x  /  m  i  n  就可以了.<br>m  a  x  /  m  i  n  (  s  t  [  l  ]  [  log  2  (  r  −  l  +  1  )  ]  ,<br>s  t  [  r  −  log  2  (  r  −  l  +  1  )  +  1  ]  [  log  2  (  r  −  l<br>+  1  )  ]  )</p></blockquote><blockquote></blockquote><blockquote><p>最后一点就是开数组的时候一定是  s  t  [  N  ]  [  log  (  n  )  ]  不要  s  t  [  N  ]  [<br>log  (  n  )  ]  后者容易超时.</p></blockquote><p><strong> 代码实现 </strong></p><pre><code>int st[n][17];void ST(){    for(int j=1; (1&lt;&lt;j)&lt;=n; j++)        for(int i=0; i+(1&lt;&lt;j)-1&lt;n; i++)            st[i][j]=max(st[i][j-1],st[i+(1&lt;&lt;(j-1))][j-1]);}int getST(int l,int r){    int k=(int)(log(r-l+1.0)/log(2.0));    return max(st[l][k],st[r-(1&lt;&lt;k)+1][k]);}在求上述的k的时候还有一种线性的预处理的方法,会比取对数快一些,但是有点浪费空间.void initrmq(int n,int b[]){    mm[0]=-1;    for(int i=1;i&lt;=n;i++)    {        mm[i]=((i&amp;(i-1))==0)?mm[i-1]+1:mm[i-1];        dp[i][0]=b[i];    }    for(int j=1;j&lt;=mm[n];j++)        for(int i=1;i+(1&lt;&lt;j)-1&lt;=n;i++)        dp[i][j]=min(dp[i][j-1],dp[i+(1&lt;&lt;(j-1))][j-1]);}int rmq(int x,int y){    int k=mm[y-x+1];    return min(dp[x][k],dp[y-(1&lt;&lt;k)+1][k]);}</code></pre><h2 id="树形结构转化为线形结构"><a href="#树形结构转化为线形结构" class="headerlink" title="树形结构转化为线形结构"></a>树形结构转化为线形结构</h2><h3 id="1-dfs序"><a href="#1-dfs序" class="headerlink" title="1. dfs序"></a>1. dfs序</h3><blockquote><p>其实就是从根节点进行搜索，<br>然后向下dfs遍历树，依次进行编号，<br>同时能保证子树的编号一定大于父节点的编号，</p></blockquote><blockquote></blockquote><blockquote><p>同时借用两个数组，  L  [  _  ]  ,  R  [  _  ]<br>分别表示这个节点  u  的子树的节点编号在  (  L  [  u  ]  ,  R  [  u  ]  )  ,  开  区  间  内。</p></blockquote><blockquote></blockquote><blockquote><p>这样在进行对子树 进行的操作的时候 可以借助数据结构 对区间进行查找，</p></blockquote><pre><code>vector&lt;int &gt;G[N];int cnt = 0;void dfs(int u){    L[u]=cnt++;    for(int i=0;i&lt;G[u].size();i++) dfs(G[u][i]);    R[u]=cnt;}</code></pre><h3 id="2-树链剖分"><a href="#2-树链剖分" class="headerlink" title="2. 树链剖分"></a>2. 树链剖分</h3><blockquote><p>树链剖分是一种将树形结构转化为线性结构的算法<br>通过两次树的遍历,将树剖分成一个个的[重链],<br>且对每个节点进行编号,确保一条链上的节点编号连续<br>这样一来,我们就能通过一个维护区间关系的数据结构来维护树上,属同一个链上的元素</p></blockquote><blockquote></blockquote><blockquote><p>在维护两个节点(u,v)的时候即:维护两个节点(u,v)间的元素,<br>我么从深度大的不断向上维护,最后遍历的位置,两个节点一定在一条链上(且深度小的就是LCA(u,v))</p></blockquote><pre><code>int dep[N];   //每个节点的深度int fa[N];    //每个节点的父节点int sz[N];    //每个节点所有的子节点个数(包括自身)int son[N];   //每个节点的重儿子void dfs1(int u,int ff,int deep){    son[u]=0;fa[u]=ff;sz[u]=1;dep[u]=deep;    for(int i=head[u];i!=-1;i=G[i].next){        int v=G[i].to;        if(v==ff) continue;        dfs1(v,u,deep+1);        sz[u]+=sz[v];                          if(sz[v]&gt;sz[son[u]]) son[u]=v; //重儿子子节点个数大    }}int top[N];   //节点所在链上的【根】int tree[N];  //节点对应在线段树/树状数组的位置int pre[N];   //在线段树/树状数组的位置对应的节点的标号  (树状数组时一般不需要)int cnt;      //对链上节点编号void dfs2(int u,int ff){    tree[u]=++cnt;pre[tree[u]]=u;top[u]=ff;    if(son[u]) dfs2(son[u],ff); //先遍历重链       else return ;    for(int i=head[u];i!=-1;i=G[i].next){        int v=G[i].to;        if(v!=fa[u]&amp;&amp;v!=son[u]) dfs2(v,v);    }}int findi(int x,int y){    int fx=top[x],fy=top[y];    int ans = 0;    while(fx!=fy){        if(dep[fx]&lt;dep[fy]) myswap(x,y),myswap(fx,fy);        ans+=getSum(tree[x])-getSum(tree[fx]-1);  //不断向上维护区间         x=fa[fx],fx=top[x];    }    if(dep[x]&gt;dep[y]) myswap(x,y);    if(x!=y) ans+=getSum(tree[y])-getSum(tree[x]);    return ans ;}</code></pre><h2 id="平衡树"><a href="#平衡树" class="headerlink" title="平衡树"></a>平衡树</h2><h3 id="SPLAY"><a href="#SPLAY" class="headerlink" title="SPLAY"></a>SPLAY</h3><blockquote><p>本质还是一个二叉查找树,但是根据树的旋转,能将一些在某种情况下树退化为单链的时候重新旋转为树<br>这是最好实现的平衡树了，能够实现求区间翻转，前驱，后继，第K大，查找值，插入，删除，合并，分离 等其他二叉查找树能够做到的功能 and so on<br>学习SPLAY最终要的是先要理解二叉查找树,然后就要理解好 <strong> 伸展,旋转 </strong> 操作就行了,其他操作原理上和普通二叉查找树是一样的</p></blockquote><p>附下个人的SPLAY模板(Bate 1)</p><blockquote><p>SPLAY操作可以在优化,旋转操作可以在优化,各种功能还没有写</p></blockquote><pre><code>int ch[N][2];  //ch[][0] lson ch[][1] rsonint f[N];      //fatherint sz[N];     //sizeint val[N];    //valueint lazy[N];   //lazy-tagint rev[N];    //tag of revearint root;      //root of splay-treeint tot;       //tot,total,is the number of node of treevoid update_rev(int x){    if(!x) return ;    swap(ch[x][0],ch[x][1]);    rev[x]^=1;}void pushdown(int x){    if(rev[x]){        update_rev(ch[x][0]);        update_rev(ch[x][1]);        rev[x]=0;    }}void pushup(int x){    sz[x]=sz[ch[x][0]]+sz[ch[x][1]]+1;}void rotate(int x,int k){   // k = 0 左旋， k = 1 右旋    int y=f[x];int z=f[y];    pushdown(y),pushdown(x);    ch[y][!k]=ch[x][k];if(ch[x][k])f[ch[x][k]]=y;    f[x]=z;if(z)ch[z][ch[z][1]==y]=x;    f[y]=x;ch[x][k]=y;    pushup(y);}void splay(int x,int goal){    pushdown(x);    while(f[x]!=goal){        int y=f[x];int z=f[y];        if(z==goal){            pushdown(y),pushdown(x);            rotate(x,ch[y][0]==x);        }        else{            pushdown(z),pushdown(y),pushdown(x);            if(ch[z][0]==y){                if(ch[y][0]==x)rotate(y,1),rotate(x,1);                else           rotate(x,0),rotate(x,1);            }            else{                if(ch[y][1]==x)rotate(y,0),rotate(x,0);                else           rotate(x,1),rotate(x,0);            }        }    }    pushup(x);    if(goal==0) root=x;}void build(int &amp;rt,int l,int r,int fa){    if(l&gt;r) return ;    int m = r+l &gt;&gt; 1;    rt = m;    f[rt]=fa;    ch[rt][0]=ch[rt][1]=0;    sz[rt]=1,rev[rt]=0;    build(ch[rt][0],l,m-1,rt);    build(ch[rt][1],m+1,r,rt);    pushup(rt);}void init(int n){    root=tot=0;    f[0]=sz[0]=ch[0][0]=ch[0][1]=rev[0]=0;    build(root,1,n,0);    pushup(root);}</code></pre><h1 id="SPLAY-1"><a href="#SPLAY-1" class="headerlink" title="SPLAY"></a>SPLAY</h1><p>由于SPLAY比较长 所以单独开了一贴</p><p><a href="http://blog.csdn.net/qq_33184171/article/details/73549164" target="_blank" rel="noopener"> 帖子在这里 </a></p>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  这是一篇被放弃的博客。。不要看了。。（新手千万不要手撸模板）</title>
      <link href="/2016/08/05/52128243/"/>
      <url>/2016/08/05/52128243/</url>
      
        <content type="html"><![CDATA[<h1 id="这是一篇被放弃的博客。。不要看了。。（新手千万不要手撸模板）"><a href="#这是一篇被放弃的博客。。不要看了。。（新手千万不要手撸模板）" class="headerlink" title="这是一篇被放弃的博客。。不要看了。。（新手千万不要手撸模板）"></a>这是一篇被放弃的博客。。不要看了。。（新手千万不要手撸模板）</h1><p>2016年08月05日 13:33:21  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：992</p><hr><p> 博客爬取于<code>2019-04-18 17:20:11</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/52128243" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/52128243</a></p><p>今天解除了一下线段树 据自己理解手撸了发建树与查询的操作 的模板</p><pre><code>#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;string.h&gt;#include &lt;algorithm&gt;#include &lt;math.h&gt;#include &lt;stdio.h&gt;#include &lt;vector&gt;#include &lt;time.h&gt;using namespace std;#define  LL  long long int int a[1010101];struct node{    int value ;    int right , left;}tree[4040404];int firstbuild(int o,int l,int r)//从第O个节点 开始建树  不断递归 知道最后到叶子节点{    tree[o].left  = l;    tree[o].right = r;    tree[o].value = 0;    if(l==r)    {        tree[o].value = a[l];        return tree[o].value ;    }    int mid = (l+r) &gt;&gt; 1;    tree[o].value=firstbuild(o * 2,l,mid)+firstbuild(o*2+1,mid+1,r);    return tree[o].value;}int query(int o,int &amp;l,int &amp;r){    //printf(&quot;%d---&gt;%d %d\n&quot;,o,tree[o].left,tree[o].right);     int sum=0;    //首先判断是不是属于所要查询的区间       if(l&lt;=tree[o].left&amp;&amp;tree[o].right&lt;=r)      //如果该区间属于要查询的区间内  就加上  而且不向下递归了  最终的加和一定是这些区间的和 而且不会重复 不会        sum += tree[o].value;    else if(tree[o].right&lt;l||r&lt;tree[o].left) ;    //如果区间有重合部分但又不包含 就要继续递归子节点 寻找区间。。     else if(tree[o].left&lt;l||r&lt;tree[o].right)  //区间过大了  就递归缩小区间        sum += query(o*2,l,r) + query(o*2+1,l,r);    else  ; //区间完全不重合 就没有在向下查询的必要了     return sum;}int main(){    int n;    cin&gt;&gt;n;    for(int i=1;i&lt;=n;i++){        cin&gt;&gt;a[i];    }    firstbuild(1,1,n);    for(int i=1;i&lt;=n*2-1;i++)        printf(&quot;%d %d\n&quot;,tree[i].left,tree[i].right);     puts(&quot;&quot;);    int nu=0,un=1;    for(int i=1;i&lt;=n*2-1;i++)    {        if(nu&gt;=un)        {            nu=0,un*=2;            puts(&quot;&quot;);        }        nu++;        printf(&quot;%d &quot;,tree[i].value);    }    puts(&quot;&quot;);    while(true)    {        int l,r;        cin&gt;&gt;l&gt;&gt;r;        if(l==0||r==0) break;        printf(&quot;%d\n&quot;,query(1,l,r));    }    return 0;} </code></pre>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  HDU 5795 A simple Nim [SG]【博弈】</title>
      <link href="/2016/08/04/52123533/"/>
      <url>/2016/08/04/52123533/</url>
      
        <content type="html"><![CDATA[<h1 id="HDU-5795-A-simple-Nim-SG-【博弈】"><a href="#HDU-5795-A-simple-Nim-SG-【博弈】" class="headerlink" title="HDU 5795 A simple Nim [SG]【博弈】"></a>HDU 5795 A simple Nim [SG]【博弈】</h1><p>2016年08月04日 21:56:25  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：567<br>标签：  <a href="https://so.csdn.net/so/search/s.do?q=SG函数&amp;t=blog" target="_blank" rel="noopener"> SG函数 </a> <a href="https://so.csdn.net/so/search/s.do?q=博弈&amp;t=blog" target="_blank" rel="noopener"> 博弈</a></p><p>个人分类：  <a href="https://blog.csdn.net/qq_33184171/article/category/6117382" target="_blank" rel="noopener"> hdu </a> <a href="https://blog.csdn.net/qq_33184171/article/category/6117381" target="_blank" rel="noopener"><br>===== 博弈 ===== </a> <a href="https://blog.csdn.net/qq_33184171/article/category/6253262" target="_blank" rel="noopener"><br>思维 </a></p><hr><p> 博客爬取于<code>2019-04-18 17:20:12</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/52123533" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/52123533</a></p><p>题目连接 : <a href="http://acm.hdu.edu.cn/showproblem.php?pid=5795" target="_blank" rel="noopener"> http://acm.hdu.edu.cn/showproblem.php?pid=5795</a></p><p>———————————————————–.<br>A Simple Nim</p><p>Time Limit: 2000/1000 MS (Java/Others) Memory Limit: 65536/65536 K<br>(Java/Others)<br>Total Submission(s): 170 Accepted Submission(s): 111</p><p>Problem Description<br>Two players take turns picking candies from n heaps,the player who picks the<br>last one will win the game.On each turn they can pick any number of candies<br>which come from the same heap(picking no candy is not allowed).To make the<br>game more interesting,players can separate one heap into three smaller<br>heaps(no empty heaps)instead of the picking operation.Please find out which<br>player will win the game if each of them never make mistakes.</p><p>Input<br>Intput contains multiple test cases. The first line is an integer 1≤T≤100, the<br>number of test cases. Each case begins with an integer n, indicating the<br>number of the heaps, the next line contains N integers s[0],s[1],….,s[n−1],<br>representing heaps with s[0],s[1],…,s[n−1] objects<br>respectively.(1≤n≤106,1≤s[i]≤109)</p><p>Output<br>For each test case,output a line whick contains either”First player<br>wins.”or”Second player wins”.</p><p>Sample Input<br>2<br>2<br>4 4<br>3<br>1 2 4</p><p>Sample Output<br>Second player wins.<br>First player wins.</p><p>——————————————-.</p><p>题目大意 : 有n堆糖果 两个人 轮班来从一堆中取任意不为0个石子或者把其中某一堆分成三堆(这时候不能取石子) 拿走最后一个石子的人赢 问 先手赢还是后手赢</p><p>解题思路:</p><p>////////////// <strong> _ </strong> <strong><strong><strong>*</strong></strong></strong> <strong> _ </strong> //////////////////<br>其实本次博客并不是写题解的 只是用来发泄一下弱鸡的自己 （淡然后面肯定有题解．．．）</p><p>做题的时候 首先看到s[i]&lt;1e9 就放弃了用SG函数的思想来解决此问题 更没想打表 更更没想到打表找规律这种事情 于是 各种姿势各种WA<br>最后看到题解的我眼泪掉下来 明明很简单的 但还是GG了 其实还是对知识点的不了解 之前学习SG函数的时候就没讲SG函数吃透 才会整场只Ａ了1001<br>还是在队友优化了题目之后才解决的　　1002也和本题一样　　　想到了Lucas定理+容斥原理 可硬是没写出来 还是对容斥原理的理解不够<br>甚至还想用某图论算法来解决它<br>说白了就是菜 但这也终于发挥了多校的作用 毕竟300买的账号。。 对于算法了解多了固然好 但是每一个都要吃透 否则就是 明明应该AC的题目却WA .. 行了<br>不发牢骚了</p><p>———————————————-.<br>心情实在压抑 直接贴的网上大神代码</p><p>打表的代码</p><hr><pre><code>int g[100];bool f[100];void init(int n){    memset(f,false,sizeof(f));    for(int i=0;i&lt;n;i++)    {f[g[i]]=true;}    for(int i=1;i&lt;=n;i++)    {        for(int j=1;j&lt;=n;j++)        {            for(int k=1;k&lt;=n;k++)            {                if((i+j+k)==n)                {                    f[(g[i]^g[j]^g[k])]=true;                }            }        }    }    int i;    for(i=0;;i++)    {        if(f[i]==false){break;}    }    g[n]=i;    printf(&quot;%d %d\n&quot;,n,i);    //cout&lt;&lt;&quot;----&gt;&quot;&lt;&lt;endl;}int main(){#ifdef OUT    freopen(&quot;coco.txt&quot;,&quot;r&quot;,stdin);    freopen(&quot;lala.txt&quot;,&quot;w&quot;,stdout);#endif     g[0]= 0;     memset(g,0,sizeof(g));     for(int i=1;i&lt;=20;i++)     {         init(i);     }    return 0;}</code></pre><p>根据输出很容易看到 sg[x%8==0]=x-1;sg[x%8==7]=x+1;</p><p>最终的AC代码</p><pre><code>  int main(){  //  freopen(&quot;in.txt&quot;,&quot;r&quot;,stdin);      int t;      cin&gt;&gt;t;      while(t--){          int n,a;          scanf(&quot;%d&quot;,&amp;n);          int ans=0;          for(int i=0;i&lt;n;i++){              scanf(&quot;%d&quot;,&amp;a);              if(a%8==0){                  ans^=a-1;              }else if(a%8==7)                  ans^=a+1;              else                  ans^=a;          }          if(ans!=0){              printf(&quot;First player wins.\n&quot;);          }else{              printf(&quot;Second player wins.\n&quot;);          }      }      return 0;  }  </code></pre>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hdu </tag>
            
            <tag> 博弈 </tag>
            
            <tag> 思维 </tag>
            
            <tag> SG函数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  POJ 3254 Corn Fields [状压DP]【动态规划】</title>
      <link href="/2016/08/03/52102801/"/>
      <url>/2016/08/03/52102801/</url>
      
        <content type="html"><![CDATA[<h1 id="POJ-3254-Corn-Fields-状压DP-【动态规划】"><a href="#POJ-3254-Corn-Fields-状压DP-【动态规划】" class="headerlink" title="POJ 3254 Corn Fields [状压DP]【动态规划】"></a>POJ 3254 Corn Fields [状压DP]【动态规划】</h1><p>2016年08月03日 13:38:04  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：195<br>标签：  <a href="https://so.csdn.net/so/search/s.do?q=动态规划&amp;t=blog" target="_blank" rel="noopener"> 动态规划 </a> <a href="https://so.csdn.net/so/search/s.do?q=poj&amp;t=blog" target="_blank" rel="noopener"> poj</a> <a href="https://so.csdn.net/so/search/s.do?q=dp&amp;t=blog" target="_blank" rel="noopener"> dp</a></p><p>个人分类：  <a href="https://blog.csdn.net/qq_33184171/article/category/6362438" target="_blank" rel="noopener"> ==== 动态规划 ====</a></p><hr><p> 博客爬取于<code>2019-04-18 17:20:13</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/52102801" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/52102801</a></p><p>题目链接 : <a href="http://poj.org/problem?id=3254" target="_blank" rel="noopener"> http://poj.org/problem?id=3254 </a><br>—————————————————.</p><p>Corn Fields<br>Time Limit: 2000MS Memory Limit: 65536K<br>Total Submissions: 12927 Accepted: 6766<br>Description</p><p>Farmer John has purchased a lush new rectangular pasture composed of M by N (1<br>≤ M ≤ 12; 1 ≤ N ≤ 12) square parcels. He wants to grow some yummy corn for the<br>cows on a number of squares. Regrettably, some of the squares are infertile<br>and can’t be planted. Canny FJ knows that the cows dislike eating close to<br>each other, so when choosing which squares to plant, he avoids choosing<br>squares that are adjacent; no two chosen squares share an edge. He has not yet<br>made the final choice as to which squares to plant.</p><p>Being a very open-minded man, Farmer John wants to consider all possible<br>options for how to choose the squares for planting. He is so open-minded that<br>he considers choosing no squares as a valid option! Please help Farmer John<br>determine the number of ways he can choose the squares to plant.</p><p>Input</p><p>Line 1: Two space-separated integers: M and N<br>Lines 2..M+1: Line i+1 describes row i of the pasture with N space-separated<br>integers indicating whether a square is fertile (1 for fertile, 0 for<br>infertile)<br>Output</p><p>Line 1: One integer: the number of ways that FJ can choose the squares modulo<br>100,000,000.<br>Sample Input</p><p>2 3<br>1 1 1<br>0 1 0<br>Sample Output</p><p>9<br>Hint</p><p>Number the squares as follows:<br>1 2 3<br>4</p><p>There are four ways to plant only on one squares (1, 2, 3, or 4), three ways<br>to plant on two squares (13, 14, or 34), 1 way to plant on three squares<br>(134), and one way to plant on no squares. 4+3+1+1=9.</p><p>—————————————————.<br>题目大意 : 就是一个n*m的地方 1代表有草 0 代表没草<br>现在要往这里放一些牛 牛只能放在有草的地方 而且 两个牛不能相邻 问有多少种方法</p><p>解题思路 : n*m不大的这种一猜就是状压(一般&lt;=20) 然后每一行与每一行有着状态的转移 于是想到DP 解决</p><p>首先吧每一行的草的状态用一个数存起来 就是这样</p><pre><code>        int x;        for(int i=1; i&lt;=n; i++)        {            a[i]=0;            for(int j=0; j&lt;m; j++)            {                scanf(&quot;%d&quot;,&amp;x);                a[i]=(a[i]&lt;&lt;1)+x;            }            //printf(&quot;%d&quot;,a[i]);        }</code></pre><p>有了这些状态好办了 直接DP</p><p>DP 的时候主要判断的就是3项<br>1.左右有没有挨着的 status&amp;(status&lt;&lt;1)<br>2.是不是只在有草的地方放牛 (草地的状态&amp;想放牛的状态)==想放牛的状态<br>3.判断相邻两行的状态有没有相邻的(这时候相邻就是上下相邻) 直接 上&amp;下 就行了</p><p>然后就是DP一下就好了 本人做这题的时候也是刚学DP 博客写的很..挫..</p><p>附本题代码<br>——————————————.</p><pre><code>#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cmath&gt;#include&lt;cstdlib&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;using namespace std;typedef long long LL;int dp[13][(1&lt;&lt;12)+10];int a[13];int n,m;const int MOD = 1e8;int main(){    while(~scanf(&quot;%d%d&quot;,&amp;n,&amp;m))    {        memset(dp,0,sizeof(dp));        int x;        for(int i=1; i&lt;=n; i++)        {            a[i]=0;            for(int j=0; j&lt;m; j++)            {                scanf(&quot;%d&quot;,&amp;x);                a[i]=(a[i]&lt;&lt;1)+x;            }            //printf(&quot;%d&quot;,a[i]);        }        dp[0][0]=1;        for(int i=1; i&lt;=n; i++)        {            for(int j=0; j&lt;(1&lt;&lt;m); j++)            {                if((j&amp;(j&lt;&lt;1))!=0||(a[i]&amp;j)!=j) continue;//判断有没有临近的                for(int k=0; k&lt;(1&lt;&lt;m); k++)                {                    if((j&amp;k)!=0) continue;                    dp[i][j]=(dp[i][j]+dp[i-1][k]+MOD)%MOD;                }            }        }        int res=0;        for(int i=0; i&lt;(1&lt;&lt;m); i++)            res=(res+dp[n][i]+MOD)%MOD;        printf(&quot;%d\n&quot;,res);    }    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> poj </tag>
            
            <tag> 动态规划 </tag>
            
            <tag> dp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  HDU 1536 S-Nim [SG函数]【博弈】</title>
      <link href="/2016/07/30/52073496/"/>
      <url>/2016/07/30/52073496/</url>
      
        <content type="html"><![CDATA[<h1 id="HDU-1536-S-Nim-SG函数-【博弈】"><a href="#HDU-1536-S-Nim-SG函数-【博弈】" class="headerlink" title="HDU 1536 S-Nim [SG函数]【博弈】"></a>HDU 1536 S-Nim [SG函数]【博弈】</h1><p>2016年07月30日 16:38:04  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：386<br>标签：  <a href="https://so.csdn.net/so/search/s.do?q=SG函数&amp;t=blog" target="_blank" rel="noopener"> SG函数 </a></p><p>个人分类：  <a href="https://blog.csdn.net/qq_33184171/article/category/6162724" target="_blank" rel="noopener"> 数学 </a> <a href="https://blog.csdn.net/qq_33184171/article/category/6117381" target="_blank" rel="noopener"><br>===== 博弈 ===== </a></p><hr><p> 博客爬取于<code>2019-04-18 17:20:14</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/52073496" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/52073496</a></p><p>题目连接 ： <a href="http://acm.hdu.edu.cn/showproblem.php?pid=1536" target="_blank" rel="noopener"> http://acm.hdu.edu.cn/showproblem.php?pid=1536</a></p><p>——————————————.</p><p>S-Nim</p><p>Time Limit: 5000/1000 MS (Java/Others) Memory Limit: 65536/32768 K<br>(Java/Others)<br>Total Submission(s): 6629 Accepted Submission(s): 2802</p><p>Problem Description<br>Arthur and his sister Caroll have been playing a game called Nim for some time<br>now. Nim is played as follows:</p><p>The starting position has a number of heaps, all containing some, not<br>necessarily equal, number of beads.</p><p>The players take turns chosing a heap and removing a positive number of beads<br>from it.</p><p>The first player not able to make a move, loses.</p><p>Arthur and Caroll really enjoyed playing this simple game until they recently<br>learned an easy way to always be able to find the best move:</p><p>Xor the number of beads in the heaps in the current position (i.e. if we have<br>2, 4 and 7 the xor-sum will be 1 as 2 xor 4 xor 7 = 1).</p><p>If the xor-sum is 0, too bad, you will lose.</p><p>Otherwise, move such that the xor-sum becomes 0. This is always possible.</p><p>It is quite easy to convince oneself that this works. Consider these facts:</p><p>The player that takes the last bead wins.</p><p>After the winning player’s last move the xor-sum will be 0.</p><p>The xor-sum will change after every move.</p><p>Which means that if you make sure that the xor-sum always is 0 when you have<br>made your move, your opponent will never be able to win, and, thus, you will<br>win.</p><p>Understandibly it is no fun to play a game when both players know how to play<br>perfectly (ignorance is bliss). Fourtunately, Arthur and Caroll soon came up<br>with a similar game, S-Nim, that seemed to solve this problem. Each player is<br>now only allowed to remove a number of beads in some predefined set S, e.g. if<br>we have S =(2, 5) each player is only allowed to remove 2 or 5 beads. Now it<br>is not always possible to make the xor-sum 0 and, thus, the strategy above is<br>useless. Or is it?</p><p>your job is to write a program that determines if a position of S-Nim is a<br>losing or a winning position. A position is a winning position if there is at<br>least one move to a losing position. A position is a losing position if there<br>are no moves to a losing position. This means, as expected, that a position<br>with no legal moves is a losing position.</p><p>Input<br>Input consists of a number of test cases. For each test case: The first line<br>contains a number k (0 &lt; k ≤ 100 describing the size of S, followed by k<br>numbers si (0 &lt; si ≤ 10000) describing S. The second line contains a number m<br>(0 &lt; m ≤ 100) describing the number of positions to evaluate. The next m lines<br>each contain a number l (0 &lt; l ≤ 100) describing the number of heaps and l<br>numbers hi (0 ≤ hi ≤ 10000) describing the number of beads in the heaps. The<br>last test case is followed by a 0 on a line of its own.</p><p>Output<br>For each position: If the described position is a winning position print a<br>‘W’.If the described position is a losing position print an ‘L’. Print a<br>newline after each test case.</p><p>Sample Input<br>2 2 5<br>3<br>2 5 12<br>3 2 4 7<br>4 2 3 7 12<br>5 1 2 3 4 5<br>3<br>2 5 12<br>3 2 4 7<br>4 2 3 7 12<br>0</p><p>Sample Output<br>LWW<br>WWL</p><p>Source<br>Norgesmesterskapet 2004</p><p>——————————————————-.</p><p>题目大意 :<br>就是多个 有多个堆的取石子游戏，只有N种取法 ，问先手输或者赢。</p><p>解题思路 : 很明显的SG函数问题 通过每次给你的N种取法 把SG值求出来然后看最后异或值是否为0就行了额</p><p>！！！！！！！！！！注意的是<br>计算sg函数的时候 最开始我h[]数组开的是10008,这样的结果就是无限的TLE<br>后来发现 取法有N种 那么i-s[]最多也只有N种 那么我h[]只要开 N 这么大就完全够了 以前怎么也想不明白 但是现在想明白了。。 只有这样才不会在<br>预处理的时候发生超时</p><p>附本题代码<br>———————–.</p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;#define mem(a,b,c)  for(int i=0;i&lt;(c);i++)a[i]=(b);#define lalal puts(&quot;******&quot;);const int M = 10008;const int N = 108;int s[N];int sg[M];int h[N];void getSG(int t){    sg[0]=0;    for(int i=1; i&lt;10001; i++)    {        memset(h,0,sizeof(h));        for(int j=0; j&lt;t&amp;&amp;i&gt;=s[j]; j++)            if(i-s[j]&gt;=0)                h[sg[i-s[j]]]=1;        for(int j=0; j&lt;10001; j++)            if(!h[j])            {                sg[i]=j;                break;            }    }    return ;}int main(){    int k;    while(~scanf(&quot;%d&quot;,&amp;k)&amp;&amp;k)    {        for(int i=0; i&lt;k; i++)            scanf(&quot;%d&quot;,&amp;s[i]);        sort(s,s+k);        getSG(k);        int _;        scanf(&quot;%d&quot;,&amp;_);        while(_--)        {            int n, x, ans = 0;            scanf(&quot;%d&quot;,&amp;n);            for(int i=0;i&lt;n;i++)            {                scanf(&quot;%d&quot;,&amp;x);                ans^=sg[x];            }            if(ans) printf(&quot;W&quot;);            else    printf(&quot;L&quot;);        }        puts(&quot;&quot;);    }    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博弈 </tag>
            
            <tag> 数学 </tag>
            
            <tag> SG函数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  HDU 5015 233 Matrix 【矩阵快速幂】</title>
      <link href="/2016/07/29/52067386/"/>
      <url>/2016/07/29/52067386/</url>
      
        <content type="html"><![CDATA[<h1 id="HDU-5015-233-Matrix-【矩阵快速幂】"><a href="#HDU-5015-233-Matrix-【矩阵快速幂】" class="headerlink" title="HDU 5015 233 Matrix 【矩阵快速幂】"></a>HDU 5015 233 Matrix 【矩阵快速幂】</h1><p>2016年07月29日 17:50:50  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：365</p><hr><p> 博客爬取于<code>2019-04-18 17:20:15</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/52067386" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/52067386</a></p><p>题目连接: <a href="http://acm.hdu.edu.cn/showproblem.php?pid=5015" target="_blank" rel="noopener"> http://acm.hdu.edu.cn/showproblem.php?pid=5015</a></p><p>——————————————-.</p><p>233 Matrix</p><p>Time Limit: 10000/5000 MS (Java/Others) Memory Limit: 65536/65536 K<br>(Java/Others)<br>Total Submission(s): 1817 Accepted Submission(s): 1075</p><p>Problem Description<br>In our daily life we often use 233 to express our feelings. Actually, we may<br>say 2333, 23333, or 233333 … in the same meaning. And here is the question:<br>Suppose we have a matrix called 233 matrix. In the first line, it would be<br>233, 2333, 23333… (it means a0,1 = 233,a0,2 = 2333,a0,3 = 23333…) Besides, in<br>233 matrix, we got ai,j = ai-1,j +ai,j-1( i,j ≠ 0). Now you have known<br>a1,0,a2,0,…,an,0, could you tell me an,m in the 233 matrix?</p><p>Input<br>There are multiple test cases. Please process till EOF.</p><p>For each case, the first line contains two postive integers n,m(n ≤ 10,m ≤<br>109). The second line contains n integers, a1,0,a2,0,…,an,0(0 ≤ ai,0 &lt; 231).</p><p>Output<br>For each case, output an,m mod 10000007.</p><p>Sample Input<br>1 1<br>1<br>2 2<br>0 0<br>3 7<br>23 47 16</p><p>Sample Output<br>234<br>2799<br>72937</p><p>Hint<br><img src="http://acm.hdu.edu.cn/data/images/C534-1009-1.jpg" alt="这里写图片描述"></p><p>—————————————————–.</p><p>题目大意 : 这道题 很好读懂 不需要翻译</p><p>解题思路:<br>就是构造矩阵 然后计算a[n][m]的值</p><p>我的思路就是<br>先把a[i][0]都为0的时候a[n][m]的值计算出来<br>再把a[0][i]都当成0的时候a[n][m]的值计算出来<br>把两者相加就是最终的结果了</p><p>所以我们就把这个问题分成两个子问题做就是了</p><p>一、<br>我先求的是a[0][i]都当成0的时候的a[n][m]值<br>这个其实很好求 先手写了一下发现有个规律</p><p>为了能明确的表达这个规律<br>在这里我们定义Sni为n个a[i][0]项和 SSni为Sni的前n项和 依此类推<br>未来了避免书写SSSSni的情况用mSni表示<br>例如3Sni就是SSSni; 这时候m=0就表示a[i][0]的值</p><p>我们通过手写能够知道a[n][m]的值为<br>(n-1)Smi+(n-2)Smi+…+(n-n)Smi;</p><p>而找这些值就很好处理了 只要构造一个上三角矩阵就行了</p><p>初始化a[i][j] 使每行都为a[i][0] 在乘上 上三角矩阵的k-1次幂就行了 切记a*上三角 不能反过来 因为矩阵只有结合律没有交换律</p><p>这样a[0][i]都当成0的时候的a[n][m]值就求出来了</p><p>二、<br>计算a[i][0]都为0的时候a[n][m]的值计算出来</p><p>计算这个的时候就容易多了 用我们要的结果就是计算数列的前n项和的前n项和的前n项和 至于有多少层就看n的值 n是几就是几层</p><p>这个矩阵就明显复杂一点<br>10 0 10 10 10 10 10 10 10 10 10 10<br>1 1 1 1 1 1 1 1 1 1 1 1<br>0 0 1 1 1 1 1 1 1 1 1 1<br>0 0 0 1 1 1 1 1 1 1 1 1<br>0 0 0 0 1 1 1 1 1 1 1 1<br>0 0 0 0 0 1 1 1 1 1 1 1<br>0 0 0 0 0 0 1 1 1 1 1 1<br>0 0 0 0 0 0 0 1 1 1 1 1<br>0 0 0 0 0 0 0 0 1 1 1 1<br>0 0 0 0 0 0 0 0 0 1 1 1<br>0 0 0 0 0 0 0 0 0 0 1 1<br>0 0 0 0 0 0 0 0 0 0 0 1</p><p>这是我构造出来的b矩阵<br>还有a矩阵 是</p><p>233 3 233 233 233 233 233 233 233 233 233 233<br>下面的值不重要</p><p>a矩阵每项的值分别是<br>a[n] 3(a[n+1]-a[n]*10) 剩下的就是从1层前n项和到10层前n项和</p><p>上面解释过</p><p>最后n是几就选择第几层的前n项和</p><p>这样就把a[i][0]都为0的时候a[n][m]的值计算出来</p><p>最后两者相加就出现结果了</p><p>//因为分成两遍做得 第二次初始化错误 导致模拟赛后1分54秒才调好 虽然1发ac了但是很不爽啊<br><img src="https://img-blog.csdn.net/20160729174939907" alt="这里写图片描述"></p><p>附本题代码</p><p>————————————-.</p><pre><code>#include &lt;iostream&gt;#include&lt;stdio.h&gt;#include&lt;algorithm&gt;#include&lt;string.h&gt;using namespace std;#define LL long long intconst int MOD = 1e7+7;const int M = 12;struct Matrix{    LL m[20][20];} a,b;int n,m;Matrix operator * (Matrix a,Matrix b){    Matrix c;    for(int i=0; i&lt;M; i++) //初始化矩阵        for(int j=0; j&lt;M; j++)            c.m[i][j]= 0;    for(int k=0; k&lt;M; k++)        for(int i=0; i&lt;M; i++) //实现矩阵乘法        {            if(a.m[i][k] &lt;= 0)  continue;            for(int j=0; j&lt;M; j++)            {                if(b.m[k][j] &lt;= 0)    continue;                c.m[i][j]=(c.m[i][j]+a.m[i][k]*b.m[k][j]+MOD)%MOD;            }        }    return c;}Matrix operator ^ (Matrix a,LL b){    Matrix c;    for(int i=0; i&lt;M; i++) //初始化单位矩阵        for(int j=0; j&lt;M; j++)            c.m[i][j]= ( i == j );    while(b)    {        if(b&amp;1) c= c * a ;        b &gt;&gt;= 1;        a = a * a ;    }    return c;}void init1(){    for(int i=0; i&lt;M; i++)    {        for(int j=0; j&lt;M; j++)        {            b.m[i][j]=0;        }    }    for(int i=0; i&lt;M; i++)    {        for(int j=i; j&lt;M; j++)        {             b.m[i][j]=1;        }        b.m[0][i]=10;    }    b.m[0][1] = 0, b.m[1][0] = 1  ;    return ;}void init2(){    for(int i=0; i&lt;M; i++)        for(int j=0; j&lt;M; j++)            b.m[i][j]=0;    for(int i=0; i&lt;M; i++)        for(int j=i; j&lt;M; j++)             b.m[i][j]=1;    return ;}int main(){    init1();    while(~scanf(&quot;%d%d&quot;,&amp;n,&amp;m))    {        init1();        for(int i=0;i&lt;M;i++)            a.m[0][i]=233;        a.m[0][1]=3;        b=b^(m-1);        a=a*b;        LL ans = a.m[0][n+1];        for(int i=1; i&lt;=n; i++)        {            scanf(&quot;%d&quot;,&amp;a.m[i][0]);            for(int j=0; j&lt;M; j++)                a.m[i][j]=a.m[i][0]%MOD;        }        for(int i=0;i&lt;M;i++)            a.m[0][i]=0;        init2();        b=b^(m-1);        a=a*b;        for(int i=1;i&lt;=n;i++)            ans = (ans + a.m[i][n-i]) % MOD;        printf(&quot;%I64d\n&quot;,ans);    }    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  codefoces</title>
      <link href="/2016/07/28/52058872/"/>
      <url>/2016/07/28/52058872/</url>
      
        <content type="html"><![CDATA[<h1 id="codefoces-364-div2-E-amp-amp-div-1-B-Connecting-Universities-图论-【求贡献】"><a href="#codefoces-364-div2-E-amp-amp-div-1-B-Connecting-Universities-图论-【求贡献】" class="headerlink" title="codefoces #364 div2 E &amp;&amp;div 1 B Connecting Universities [图论]【求贡献】"></a>codefoces #364 div2 E &amp;&amp;div 1 B Connecting Universities [图论]【求贡献】</h1><p>2016年07月28日 20:39:58  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：573</p><hr><p> 博客爬取于<code>2019-04-18 17:20:16</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/52058872" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/52058872</a></p><p>题目连接 ： <a href="http://codeforces.com/problemset/problem/700/B" target="_blank" rel="noopener"> http://codeforces.com/problemset/problem/700/B</a></p><p>CF 的题目 可以去VJ上 挂</p><p>———————————————————.</p><p>Connecting Universities<br>time limit per test3 seconds<br>memory limit per test256 megabytes<br>inputstandard input<br>outputstandard output<br>Treeland is a country in which there are n towns connected by n - 1 two-way<br>road such that it’s possible to get from any town to any other town.</p><p>In Treeland there are 2k universities which are located in different towns.</p><p>Recently, the president signed the decree to connect universities by high-<br>speed network.The Ministry of Education understood the decree in its own way<br>and decided that it was enough to connect each university with another one by<br>using a cable. Formally, the decree will be done!</p><p>To have the maximum sum in the budget, the Ministry decided to divide<br>universities into pairs so that the total length of the required cable will be<br>maximum. In other words, the total distance between universities in k pairs<br>should be as large as possible.</p><p>Help the Ministry to find the maximum total distance. Of course, each<br>university should be present in only one pair. Consider that all roads have<br>the same length which is equal to 1.</p><p>Input<br>The first line of the input contains two integers n and k (2 ≤ n ≤ 200 000, 1<br>≤ k ≤ n / 2) — the number of towns in Treeland and the number of university<br>pairs. Consider that towns are numbered from 1 to n.</p><p>The second line contains 2k distinct integers u1, u2, …, u2k (1 ≤ ui ≤ n) —<br>indices of towns in which universities are located.</p><p>The next n - 1 line contains the description of roads. Each line contains the<br>pair of integers xj and yj (1 ≤ xj, yj ≤ n), which means that the j-th road<br>connects towns xj and yj. All of them are two-way roads. You can move from any<br>town to any other using only these roads.</p><p>Output<br>Print the maximum possible sum of distances in the division of universities<br>into k pairs.</p><p>Examples<br>input<br>7 2<br>1 5 6 2<br>1 3<br>3 2<br>4 5<br>3 7<br>4 3<br>4 6<br>output<br>6<br>input<br>9 3<br>3 2 1 6 5 9<br>8 9<br>3 2<br>2 7<br>3 4<br>7 6<br>4 5<br>2 1<br>2 8<br>output<br>9<br>Note<br>The figure below shows one of possible division into pairs in the first test.<br>If you connect universities number 1 and 6 (marked in red) and universities<br>number 2 and 5 (marked in blue) by using the cable, the total distance will<br>equal 6 which will be the maximum sum in this example.<br><img src="http://codeforces.com/predownloaded/61/49/6149e2f469fa7a7fe805332eefa2da87974c9d6f.png" alt="这里写图片描述"></p><p>———————————————————.</p><p>题目大意 ：就是让你找在K*2个点中找到K条路 使得和最大</p><p>解题思路<br>其实把每条路都求出来在加和的话 一定会超时 所以要换一种思路 看了一下node 发现总是有那么多的边被很多路经过<br>所以就求出来每条边被多少路经过就行了呗<br>而求被多少条路经过就简单多了 只有求出这条路径左边有多少个k<em>2里的点右边边有多少个k</em>2里的点 取小的那一个值就行了<br>这是必然的 想让路最长对于每一条边来说 一定是让左右两边的点尽可能的连上<br>最终记录下来每条边对总结过的贡献就行了 总复杂度O（N）<br>这种贡献式思维 很常用 也很好用 能大大降低时间复杂度 而且在很多时候比直接求解的代码 算法上的难度要小 而且小很多</p><p>附本题代码</p><p>—————————————————–.</p><pre><code>#include &lt;iostream&gt;#include &lt;stdio.h&gt;#include &lt;algorithm&gt;#include &lt;math.h&gt;#include &lt;string&gt;#include &lt;string.h&gt;#include &lt;vector&gt;using namespace std;#define LL __int64#define INF 0x1f1f1f1f/*************************************/#define pb push_backint has[202020],ha[202020];vector&lt;int&gt;pr[202020];int num[202020];LL ans = 0;int dfs(int u,int v,int &amp;k)  // v是代表这条边的上一条边连接的是谁{    ha[u]=1;    if(has[u]) num[u]++;    int Mi = 0;    for(int i=0;i&lt;pr[u].size();i++)    {        if(pr[u][i]==v) continue;        dfs(pr[u][i],u,k); // 继续顺着下一个连接的边搜下去  这样最后搜到叶子节点才会返回并记录数值 确保不会落下那条边与点        Mi += num[pr[u][i]];        ans += min(2*k-num[pr[u][i]],num[pr[u][i]]);  //计数很好理解    }    num[u] += Mi;}int main(){    memset(has,0,sizeof(has));    memset(num,0,sizeof(num));    int n,k;    scanf(&quot;%d%d&quot;,&amp;n,&amp;k);    int x;    for(int i=0;i&lt;k*2;i++)    {        scanf(&quot;%d&quot;,&amp;x);        has[x]=1;    }    int u,v;    for(int i=1;i&lt;n;i++)    {        scanf(&quot;%d%d&quot;,&amp;u,&amp;v);//看到这里就知道为什么一定要用vector了吧  如果不 就一定会爆内存  而vector下最坏也只是4e5        pr[u].pb(v);        pr[v].pb(u);    }    for(int i=1;i&lt;=n;i++)        if(!ha[i]&amp;&amp;has[i])//搜索没搜索过得点  被搜过就不需要在搜一遍了            dfs(1,-1,k);    printf(&quot;%I64d\n&quot;,ans);    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>&lt;转&gt;#  ACM 进阶</title>
      <link href="/2016/07/26/52040812/"/>
      <url>/2016/07/26/52040812/</url>
      
        <content type="html"><![CDATA[<h1 id="ACM-进阶"><a href="#ACM-进阶" class="headerlink" title="ACM 进阶"></a>ACM 进阶</h1><p>置顶  2016年07月26日 23:49:05  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：699</p><hr><p> 博客爬取于<code>2019-04-18 17:15:12</code><br><strong><em>以下为正文</em></strong></p><p>ACM进阶计划<br>ACM队不是为了一场比赛而存在的，为的是队员的整体提高。<br>大学期间，ACM队队员必须要学好的课程有：<br>lC/C++两种语言<br>l高等数学<br>l线性代数<br>l数据结构<br>l离散数学<br>l数据库原理<br>l操作系统原理<br>l计算机组成原理<br>l人工智能<br>l编译原理<br>l算法设计与分析<br>除此之外，我希望你们能掌握一些其它的知识，因为知识都是相互联系，触类旁通的。<br>以下学习计划每学期中的内容不分先后顺序，虽说是为立志于学习ACM的同学列的知识清单，但内容不限于ACM的知识。英语之类与专业相距较远的课程请自行分配时间，这<br>里不再列举。<br>大一上学期：<br>必学：<br>1.C语言基础语法必须全部学会<br>a)推荐“语言入门”分类20道题以上<br>b)提前完成C语言课程设计<br>2.简单数学题（推荐“数学”分类20道以上）<br>需要掌握以下基本算法：<br>a)欧几里德算法求最大公约数<br>b)筛法求素数<br>c)康托展开<br>d)逆康托展开<br>e)同余定理<br>f)次方求模<br>3.计算几何初步<br>a)三角形面积<br>b)三点顺序<br>4.学会简单计算程序的时间复杂度与空间复杂度<br>5.二分查找法<br>6.简单的排序算法<br>a)冒泡排序法<br>b)插入排序法<br>7.贪心算法经典题目<br>8.高等数学<br>以下为选修：<br>9.学会使用简单的DOS命令（较重要）<br>a)color/dir/copy/shutdown/mkdir(md)/rmdir(rd)/attrib/cd/<br>b)知道什么是绝对路径与相对路径<br>c)学会使用C语言调用DOS命令<br>d)学会在命令提示符下调用你自己用C语言编写的程序，并使用命令行参数给自己的程序传参（比如自己制作一个copyfile.exe实现与copy命令基本功能一致<br>的功能）<br>e)学会编写bat批处理文件<br>10.学会Windows系统的一些小知识，如设置隐藏文件，autoRun.inf的设置等。<br>11.学会编辑注册表（包括使用注册表编辑器regedit和使用DOS命令编辑注册表）<br>12.学会使用组策略管理器管理(gpedit.msc)组策略。<br>大一下学期：<br>1.掌握C++部分语法，如引用类型，函数重载等，基本明白什么是类。<br>2.学会BFS与DFS<br>a)迷宫求解（最少步数）<br>b)水池数目(NYOJ27)<br>c)图像有用区域(NYOJ92)<br>d)树的前序中序后序遍历<br>3.动态规划（15题以上），要学会使用循环的方法写动态规划，同时也要学会使用记忆化搜索的方法。<br>a)最大子串和<br>b)最长公共子序列<br>c)最长单调递增子序列(O(n)与O(nlogn)算法都需要掌握)<br>d)01背包<br>e)RMQ算法<br>4.学会分析与计算复杂程序的时间复杂度<br>5.学会使用栈与队列等线性存储结构<br>6.学会分治策略<br>7.排序算法<br>a)归并排序<br>b)快速排序<br>c)计数排序<br>8.数论<br>a)扩展欧几里德算法<br>b)求逆元<br>c)同余方程<br>d)中国剩余定理<br>9.博弈论<br>a)博弈问题与SG函数的定义<br>b)多个博弈问题SG值的合并<br>10.图论：<br>a)图的邻接矩阵与邻接表两种常见存储方式<br>b)欧拉路的判定<br>c)单最短路bellman-ford算法dijkstra算法。<br>d)最小生成树的kruskal算法与prim算法。<br>11.学会使用C语言进行网络编程与多线程编程<br>12.高等数学<br>13.线性代数<br>a)明确线性代数的重要性，首先是课本必须学好<br>b)编写一个Matrix类，进行矩阵的各种操作，并求编写程序解线性方程组。<br>c)推荐做一两道“矩阵运算”分类下的题目。<br>以下为选修，随便选一两个学学即可：<br>14.（较重要）使用C语言或C++编写简单程序来调用一些简单的windowsAPI，或者在linux下进行linux系统调用，其目的是明白什么是API（应用<br>程序接口）。<br>15.网页设计<br>a)学习静态网页技术(html+css+javascript)<br>b)较具有艺术细胞的可以试试Photoshop<br>c)php或其它动态网页技术<br>16.学习matlab，如果想参加数学建模大赛的话，需要学这个软件。<br>大一假期（如果留校集训）<br>1.掌握C++语法，并熟练使用STL<br>2.试着实现STL的一些基本容器和函数，使自己基本能看懂STL源码<br>3.图论<br>a)使用优先队列优化Dijkstra和Prim<br>b)单源最短路径之SPFA<br>c)差分约束系统<br>d)多源多点最短路径之FloydWarshall算法<br>e)求欧拉路(圈套圈算法）<br>4.进行复杂模拟题训练<br>5.拓扑排序<br>6.动态规划进阶<br>a)完全背包、多重背包等各种背包问题（参见背包九讲）<br>b)POJ上完成一定数目的动态规划题目<br>c)状态压缩动态规划<br>d)树形动态规划<br>7.搜索<br>a)回溯法熟练应用<br>b)复杂的搜索题目练习<br>c)双向广度优先搜索<br>d)启发式搜索(包括A*算法，如八数码问题)<br>8.计算几何<br>a)判断点是否在线段上<br>b)判断线段相交<br>c)判断矩形是否包含点<br>d)判断圆与矩形关系<br>e)判断点是否在多边形内<br>f)判断点到线段的最近点<br>g)计算两个圆的公切线<br>h)求矩形的并的面积<br>i)求多边形面积<br>j)求多边形重心<br>k)求凸包<br>选修<br>9.可以学习一种C++的开发框架来编写一些窗体程序玩玩（如MFC,Qt等)。<br>10.学习使用C或C++连接数据库。<br>大二一整年：<br>1.数据结构<br>a)单调队列<br>b)堆<br>c)并查集<br>d)树状数组<br>e)哈希表<br>f)线段树<br>g)字典树<br>2.图论<br>a)强连通分量<br>b)双连通分量（求割点，桥）<br>c)强连通分量与双连通分量缩点<br>d)LCA、LCA与RMQ的转化<br>e)二分图匹配<br>i.二分图最大匹配<br>ii.最小点集覆盖<br>iii.最小路径覆盖<br>iv.二分图最优匹配<br>v.二分图多重匹配<br>f)网络流<br>i.最大流的基本SAP<br>ii.最大流的ISAP或者Dinic等高效算法（任一）<br>iii.最小费用最大流<br>iv.最大流最小割定理<br>3.动态规划多做题提高（10道难题以上）<br>4.数论<br>a)积性函数的应用<br>b)欧拉定理<br>c)费马小定理<br>d)威乐逊定理<br>5.组合数学<br>a)群论基础<br>b)Polya定理与计数问题<br>c)Catalan数<br>6.计算几何<br>a)各种旋转卡壳相关算法<br>b)三维计算几何算法<br>7.理解数据库原理，学会SQL语句<br>8.学好计算机组成原理<br>9.学习Transact-SQL语言，学会使用触发器，存储过程，学会数据库事务等。<br>10.图论二<br>a)网络流的各种构图训练（重要）<br>b)最小割与最小点权覆盖等的关系（详见《最小割模型在信息学竞赛中的应用》一文）<br>c)次小生成树<br>d)第k短路<br>e)最小比率生成树<br>11.线性规划<br>12.动态规划更高级进阶<br>13.KMP算法<br>14.AC自动机理论与实现<br>15.博弈论之Alpha-beta剪枝<br>选修，有相关兴趣的可以学一下：<br>16.自学C#或Java做一个项目，比如C++/C#/Java考试系统之类的。<br>17.先做一些小游戏玩玩，然后可以学一下DirectX或者OpenGL，或者可以试试XNA游戏框架。<br>18.了解一下游戏引擎相关的知识<br>其中的寒假假期最好：<br>1.自学完离散数学<br>2.自学概率论的部分章节<br>3.自学操作系统部分章节<br>大三、<br>1.巩固之前的知识，进行一遍大复习。<br>2.一些如蚁群算法，遗传算法，模拟退火算法等人工智能方面应用较广的随机性算法。<br>3.把编译原理上学的东西应用到编程中：如DFA,NFA，还有语法分析的各种方法等。<br>当你按上面那些一步步走过来时你已经是牛人了，后面要学的东西，就是由牛人自己来发掘的了。</p>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  HDU 3240 Counting Binary Trees [卡特兰数] 【数论+组合数学】</title>
      <link href="/2016/07/26/52033548/"/>
      <url>/2016/07/26/52033548/</url>
      
        <content type="html"><![CDATA[<h1 id="HDU-3240-Counting-Binary-Trees-卡特兰数-【数论-组合数学】"><a href="#HDU-3240-Counting-Binary-Trees-卡特兰数-【数论-组合数学】" class="headerlink" title="HDU 3240 Counting Binary Trees [卡特兰数] 【数论+组合数学】"></a>HDU 3240 Counting Binary Trees [卡特兰数] 【数论+组合数学】</h1><p>2016年07月26日 10:43:44  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：350</p><hr><p> 博客爬取于<code>2019-04-18 17:20:18</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/52033548" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/52033548</a></p><p>题目连接 : <a href="http://acm.hdu.edu.cn/showproblem.php?pid=3240" target="_blank" rel="noopener"> http://acm.hdu.edu.cn/showproblem.php?pid=3240</a></p><p>—————————————————————————–.<br>Counting Binary Trees</p><p>Time Limit: 6000/3000 MS (Java/Others) Memory Limit: 32768/32768 K<br>(Java/Others)<br>Total Submission(s): 739 Accepted Submission(s): 256</p><p>Problem Description<br>There are 5 distinct binary trees of 3 nodes:<br><img src="http://acm.hdu.edu.cn/data/images/3240-1.jpg" alt="这里写图片描述"></p><p>Let T(n) be the number of distinct non-empty binary trees of no more than n<br>nodes, your task is to calculate T(n) mod m.</p><p>Input<br>The input contains at most 10 test cases. Each case contains two integers n<br>and m (1 &lt;= n &lt;= 100,000, 1 &lt;= m &lt;= 109) on a single line. The input ends with<br>n = m = 0.</p><p>Output<br>For each test case, print T(n) mod m.</p><p>Sample Input<br>3 100<br>4 10<br>0 0</p><p>Sample Output<br>8<br>2</p><p>Source<br>2009 “NIT Cup” National Invitational Contest</p><p>——————————————.</p><p>题目大意 : 就是让你求 卡特兰数对M取模的结果</p><p>题解 :<br>卡特兰数主要有两种<br>一般式 : <img src="https://upload.wikimedia.org/math/d/1/1/d118d8cea7b639dfd5244fcba65910cf.png" alt="这里写图片描述"><br>另类递归式： h(n)=((4<em>n-2)/(n+1))</em>h(n-1);</p><p>在这里我们用的是递归式求解卡特兰数<br>注意我们求解的是卡特兰数的前N项和 h(1)=1 h(2)=2 h(3)=5 h(4)=14</p><p>根据递归式很容易想到(4*n-2)/(n+1) 求它的值然后不断乘起来就行 首先想到分子可以直接累乘 分母每一步计算一下乘上逆元即可</p><p>但是求逆元的要求就是分子分母互质 所以我们想到分解下m 的质因子 然后最分式上下约分处理 这个时候就可以用一个数组来存储分式中M的每个素因子个数<br>分子的就加一 分母的就减一</p><p>最后计算就行了</p><p>附本题代码</p><p>——————————————–.</p><pre><code>#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;string&gt;#include &lt;math.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;#include &lt;queue&gt;using namespace std;#define LL long long int#define _LL __int64const LL  MOD  = 1e9+7;const int MAX  = 105;const int MIN  = 1005;const double EPS=1e-6;int prime[10005];int num[10005];int k=0;LL qmod(LL a,LL b,LL c){    LL res=1;    while(b)    {        if(b&amp;1) res=(res*a)%c;        b &gt;&gt;= 1;        a=(a*a)%c;    }    return res;}LL extendeuclid(LL a,LL b,LL &amp;x,LL &amp;y){    if(b==0)    {        x=1,y=0;        return a;    }    else    {        LL r = extendeuclid(b,a%b,x,y);        LL t = x;        x = y;        y = t-(a/b)*y;        return r;    }}int n,m;LL ans;void cal1(int nn){    for(int i=0; i&lt;k; i++)    {       // if(nn&lt;prime[i]) break;        while(nn%prime[i]==0)        {            nn/=prime[i];            num[i]++;        }    }    ans = (ans * nn)%m;  //  printf(&quot;%I64d\n&quot;,ans);}void cal2(int nn){    for(int i=0; i&lt;k; i++)    {       // if(nn&lt;prime[i]) break;        while(nn%prime[i]==0&amp;&amp;num[i]&gt;0)        {            nn/=prime[i];            num[i]--;        }    }    if(nn&gt;1)    {        LL x,y;        extendeuclid(nn,m,x,y);        x=(x%m+m)%m;        ans=(ans*x)%m;    }}int main(){    while(~scanf(&quot;%d%d&quot;,&amp;n,&amp;m)&amp;&amp;(n||m))    {        int tem=m;k=0;        for(int i=2; i*i&lt;=tem; i++)        {            if(tem%i==0) prime[k++]=i;            while(tem%i==0) tem/=i;        }        if(tem&gt;1) prime[k++]=tem;        /*        for(int i=0;i&lt;k;i++)            printf(&quot;%d\n&quot;,prime[i]);        puts(&quot;**********&quot;);        */        ans=1;        LL res=1,tmp;        //h(1)=1 h(2)=2 h(3)=5 h(4)=14        memset(num,0,sizeof(num));        for(int i=2; i&lt;=n; i++)        {            cal1(4*i-2);            cal2(i+1);            tmp=ans;           // for(int j=0;j&lt;k;j++)            //    tmp=(tmp*qmod(prime[j],num[j],m))%m;            for(int j=0;j&lt;k;j++)                for(int o=0;o&lt;num[j];o++)                    tmp=(tmp*prime[j])%m;            res=(res+tmp)%m;  //res=h(0)=1;        }        printf(&quot;%I64d\n&quot;,res);    }    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  POJ 2653 Pick-up sticks [线段相交]【计算几何】</title>
      <link href="/2016/07/24/52014844/"/>
      <url>/2016/07/24/52014844/</url>
      
        <content type="html"><![CDATA[<h1 id="POJ-2653-Pick-up-sticks-线段相交-【计算几何】"><a href="#POJ-2653-Pick-up-sticks-线段相交-【计算几何】" class="headerlink" title="POJ 2653 Pick-up sticks [线段相交]【计算几何】"></a>POJ 2653 Pick-up sticks [线段相交]【计算几何】</h1><p>2016年07月24日 16:57:43  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：344</p><hr><p> 博客爬取于<code>2019-04-18 17:20:19</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/52014844" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/52014844</a></p><p>题目连接： <a href="http://poj.org/problem?id=2653" target="_blank" rel="noopener"> http://poj.org/problem?id=2653 </a></p><p>————————————————————————.</p><p>Pick-up sticks<br>Time Limit: 3000MS Memory Limit: 65536K<br>Total Submissions: 12353 Accepted: 4660<br>Description</p><p>Stan has n sticks of various length. He throws them one at a time on the floor<br>in a random way. After finishing throwing, Stan tries to find the top sticks,<br>that is these sticks such that there is no stick on top of them. Stan has<br>noticed that the last thrown stick is always on top but he wants to know all<br>the sticks that are on top. Stan sticks are very, very thin such that their<br>thickness can be neglected.<br>Input</p><p>Input consists of a number of cases. The data for each case start with 1 &lt;= n<br>&lt;= 100000, the number of sticks for this case. The following n lines contain<br>four numbers each, these numbers are the planar coordinates of the endpoints<br>of one stick. The sticks are listed in the order in which Stan has thrown<br>them. You may assume that there are no more than 1000 top sticks. The input is<br>ended by the case with n=0. This case should not be processed.<br>Output</p><p>For each input case, print one line of output listing the top sticks in the<br>format given in the sample. The top sticks should be listed in order in which<br>they were thrown.</p><p>The picture to the right below illustrates the first case from input.<br><img src="http://poj.org/images/2653_1.jpg" alt="这里写图片描述"></p><p>Sample Input</p><p>5<br>1 1 4 2<br>2 3 3 1<br>1 -2.0 8 4<br>1 4 8 2<br>3 3 6 -2.0<br>3<br>0 0 1 1<br>1 0 2 1<br>2 0 3 1<br>0</p><p>Sample Output</p><p>Top sticks: 2, 4, 5.<br>Top sticks: 1, 2, 3.</p><p>Hint</p><p>Huge input,scanf is recommended.</p><p>——————————————————.</p><p>题目大意 ： 就是依次向平面上扔几根棍 ，问最后没被其他木棍压住的木棍有哪些</p><p>题解： 水题 判断从每个棍向后来的棍 判断线段相交 有没有交上的 没有就是所要求的 记录下来 最后输出一下就醒了</p><p>时间够长 能够小 n^2 就行</p><p>附本题代码</p><p>————————————.</p><pre><code>#include&lt;iostream&gt;#include&lt;stdio.h&gt;#include&lt;math.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;using namespace std;const double EPS=1e-6;int n;struct point{    double  x, y;};struct line{    point p1,p2;    int flag;} line1[100005];double multi(point p0,point p1,point p2){    return(p1.x-p0.x)*(p2.y-p0.y)-(p2.x-p0.x)*(p1.y-p0.y);}bool IsIntersected(point s1,point e1,point s2,point e2) //线段相交{    return (max(s1.x,e1.x)&gt;=min(s2.x,e2.x))&amp;&amp;           (max(s2.x,e2.x)&gt;=min(s1.x,e1.x))&amp;&amp;           (max(s1.y,e1.y)&gt;=min(s2.y,e2.y))&amp;&amp;           (max(s2.y,e2.y)&gt;=min(s1.y,e1.y))&amp;&amp;           (multi(s1,s2,e1)*multi(s1,e1,e2)&gt;0)&amp;&amp;           (multi(s2,s1,e2)*multi(s2,e2,e1)&gt;0);}int num[100005];int main(){    while(~scanf(&quot;%d&quot;,&amp;n)&amp;&amp;n)    {        for(int i=1; i&lt;=n; i++)            scanf(&quot;%lf%lf%lf%lf&quot;,&amp;line1[i].p1.x,&amp;line1[i].p1.y,&amp;line1[i].p2.x,&amp;line1[i].p2.y);        int f=0,k=0;        for(int i=1; i&lt;n; i++)        {            f=0;            for(int j=i+1; j&lt;=n; j++)            {                if(IsIntersected(line1[i].p1,line1[i].p2,line1[j].p1,line1[j].p2))                {                        f=1;                        break;                }            }            if(!f)  num[k++]=i;        }        num[k]=n;        printf(&quot;Top sticks:&quot;);        for(int i=0; i&lt;=k; i++)        {            if(i==0)                printf(&quot; %d&quot;,num[i]);            else                printf(&quot;, %d&quot;,num[i]);        }        printf(&quot;.\n&quot;);    }    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  BestCoder Round</title>
      <link href="/2016/07/23/52008038/"/>
      <url>/2016/07/23/52008038/</url>
      
        <content type="html"><![CDATA[<h1 id="BestCoder-Round-84-amp-amp-HDU-5750-Dertouzos-【数论-暴力】"><a href="#BestCoder-Round-84-amp-amp-HDU-5750-Dertouzos-【数论-暴力】" class="headerlink" title="BestCoder Round #84 &amp;&amp;HDU 5750 Dertouzos 【数论+暴力】"></a>BestCoder Round #84 &amp;&amp;HDU 5750 Dertouzos 【数论+暴力】</h1><p>2016年07月23日 23:14:02  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：834</p><hr><p> 博客爬取于<code>2019-04-18 17:20:20</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/52008038" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/52008038</a></p><p>题目连接： <a href="http://acm.hdu.edu.cn/showproblem.php?pid=5750" target="_blank" rel="noopener"> http://acm.hdu.edu.cn/showproblem.php?pid=5750</a></p><p>—————————————–.</p><p>Dertouzos Accepts: 76 Submissions: 1357<br>Time Limit: 7000/3500 MS (Java/Others) Memory Limit: 131072/131072 K<br>(Java/Others)<br>问题描述<br>正整数  x  称为  n  的positive proper divisor, 当且仅当  x  |  n  并且  1  ≤  x  &lt; n  .<br>例如, 1, 2, 和3是6的positive proper divisor, 但是6不是.</p><p>Peter给你两个正整数  n  和  d  . 他想要知道有多少小于  n  的整数, 满足他们的最大positive proper divisor恰好是<br>d  .<br>输入描述<br>输入包含多组数据, 第一行包含一个整数  T  (  1  ≤  T  ≤  10  6  )  表示测试数据组数. 对于每组数据:</p><p>第一行包含两个整数  n  和  d  (  2  ≤  n  ,  d  ≤  10  9  )</p><p>输出描述<br>对于每组数据, 输出一个整数.<br>输入样例<br>9<br>10 2<br>10 3<br>10 4<br>10 5<br>10 6<br>10 7<br>10 8<br>10 9<br>100 13<br>输出样例<br>1<br>2<br>1<br>0<br>0<br>0<br>0<br>0<br>4</p><p>—————————————————-.</p><p>题目大意： 自己看</p><p>解题思路：<br>首先要明确的是 N<em>M的最大因子为N的时候只有M为素数 且M&lt;=N的最小素因子的时候 ；<br>试想  N  =  p  a  1  1  ∗  p  a  2  2  ∗  p  a  3  3  ∗  p  a  4  4  ∗  …  …  ∗<br>p  a  n  n  ;  (  p  [  i  ]  &lt; p  [  i  +  1  ]  )<br>如果M不是素数那么M=X</em>Y，N<em>M的因子中 就多了N</em>X和N<em>Y 均比N大 所以不成立<br>如果M&gt;p1 （假设所有的ai均为1）那么N</em>M的因子中 就多了  M  ∗  p  2  ∗  p  3  ∗  p  4  ∗  …  …  ∗  p<br>n  一定大于  p  1  ∗  p  2  ∗  p  3  ∗  p  4  ∗  …  …  ∗  p  n  所以也不成立 至于某个  a  i</p><blockquote><p>1  的时候同理<br>也不行</p></blockquote><p>所以先打出sqrt(1e9)内的所有素数<br>然后暴力找即可</p><pre><code>   for(int i=0;i&lt;k;i++)    {        if(d*prime[i]&gt;=n)   break;        sum++;        if(d%prime[i]==0)   break;    }</code></pre><p>k值不到1e4 加上题目3500ms 就能过了</p><p>附上本题代码</p><p>———————————————————-.</p><pre><code>#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;using namespace std;#define LL __int64const LL MOD = 1e9+7;const LL INF = 0x3f3f3f3f;int Is_or[101010];int prime[10000];int k=0;void Prime(){    memset(Is_or,1,sizeof(Is_or));    int n=100000;    for(int i=2;i&lt;=n;i++)        if(Is_or[i])        {            prime[k++]=i;            for(int j=i+i;j&lt;=n;j+=i)                Is_or[j]=0;        }    return ;}int primeproper(int num,int n){    int sum=0;    for(int i=0;i&lt;k;i++)    {        if(num*prime[i]&gt;=n)   break;        sum++;        if(num%prime[i]==0)   break;    }    return sum;}int main(){    Prime();    printf(&quot;%d  %d  &quot;,prime[k-1],prime[4229]);    printf(&quot;%d\n&quot;,k);    int t;    scanf(&quot;%d&quot;,&amp;t);    while(t--)    {        int n,m;        scanf(&quot;%d%d&quot;,&amp;n,&amp;m);        int d = primeproper(m,n);        printf(&quot;%d\n&quot;,d);    }    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  Codeforces Round</title>
      <link href="/2016/07/23/52003317/"/>
      <url>/2016/07/23/52003317/</url>
      
        <content type="html"><![CDATA[<h1 id="Codeforces-Round-364-div-2-C-They-Are-Everywhere-【尺追法】"><a href="#Codeforces-Round-364-div-2-C-They-Are-Everywhere-【尺追法】" class="headerlink" title="Codeforces Round #364 div.2 C. They Are Everywhere 【尺追法】"></a>Codeforces Round #364 div.2 C. They Are Everywhere 【尺追法】</h1><p>2016年07月23日 11:33:07  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：820</p><hr><p> 博客爬取于<code>2019-04-18 17:20:21</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/52003317" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/52003317</a></p><p>题目连接 ： <a href="http://codeforces.com/problemset/problem/701/C" target="_blank" rel="noopener"> http://codeforces.com/problemset/problem/701/C</a></p><p>———————————–.<br>C. They Are Everywhere<br>time limit per test2 seconds<br>memory limit per test256 megabytes<br>inputstandard input<br>outputstandard output<br>Sergei B., the young coach of Pokemons, has found the big house which consists<br>of n flats ordered in a row from left to right. It is possible to enter each<br>flat from the street. It is possible to go out from each flat. Also, each flat<br>is connected with the flat to the left and the flat to the right. Flat number<br>1 is only connected with the flat number 2 and the flat number n is only<br>connected with the flat number n - 1.</p><p>There is exactly one Pokemon of some type in each of these flats. Sergei B.<br>asked residents of the house to let him enter their flats in order to catch<br>Pokemons. After consulting the residents of the house decided to let Sergei B.<br>enter one flat from the street, visit several flats and then go out from some<br>flat. But they won’t let him visit the same flat more than once.</p><p>Sergei B. was very pleased, and now he wants to visit as few flats as possible<br>in order to collect Pokemons of all types that appear in this house. Your task<br>is to help him and determine this minimum number of flats he has to visit.</p><p>Input<br>The first line contains the integer n (1 ≤ n ≤ 100 000) — the number of flats<br>in the house.</p><p>The second line contains the row s with the length n, it consists of uppercase<br>and lowercase letters of English alphabet, the i-th letter equals the type of<br>Pokemon, which is in the flat number i.</p><p>Output<br>Print the minimum number of flats which Sergei B. should visit in order to<br>catch Pokemons of all types which there are in the house.</p><p>Examples<br>input<br>3<br>AaA<br>output<br>2</p><p>input<br>7<br>bcAAcbc<br>output<br>3</p><p>input<br>6<br>aaBCCe<br>output<br>5</p><p>Note<br>In the first test Sergei B. can begin, for example, from the flat number 1 and<br>end in the flat number 2.</p><p>In the second test Sergei B. can begin, for example, from the flat number 4<br>and end in the flat number 6.</p><p>In the third test Sergei B. must begin from the flat number 2 and end in the<br>flat number 6.</p><p>—————————————————————————–.</p><p>题目大意 ：有N个公寓里面住着口袋妖怪 ，下面给了N个公寓中每个公寓里的口袋妖怪的是哪一种 （分别用大小写字母表示 共52种）<br>你只能从其中的任意一个公寓进去，然后出去，然而呢 邻近的公寓与公寓之间是相通的 你可以从左边的公寓不出去就走到右边的公寓<br>问你如果一个人想要收集全所有出现过得所有种的口袋妖怪最少要经过多少个公寓，每种口袋妖怪有一个即可。。</p><p>解题思路：根据题意 ，N比较大 所以暴力三层for 会TLE 之后仔细看了下题 很明显的尺追法</p><p>维护两个指针 代表区间的左右界<br>按要求不断维护 更新最值即可</p><p>/ <strong> _ </strong> _ ** / 换一种画风来描述这个问题</p><p>如果子串(i,j)包含了所有种个不同的字符，那么子串(i,k),(j &lt; 9 &lt; length)也包含了至少个不同字符。</p><p>因此对于每一个左边界，只要找到最小的满足条件的右边界，就能找到以这个左边界开始的符合条件的子串的长度的最小值。</p><p>寻找这个右边界，是经典的追赶法（尺取法,双指针法）问题。维护两个指针（数组下标），轮流更新左右边界，更新最值即可。复杂度 O(N)。</p><p>详情看代码注释吧</p><pre><code>#include &lt;iostream&gt;#include &lt;stdio.h&gt;#include &lt;algorithm&gt;#include &lt;math.h&gt;#include &lt;string&gt;#include &lt;string.h&gt;using namespace std;#define LL __int64#define INF 0x1f1f1f1fchar a[101010];int h[130],pre[130];int main(){    int n;    scanf(&quot;%d&quot;,&amp;n);    scanf(&quot;%s&quot;,a+1);    memset(h,0,sizeof(0));    memset(pre,0,sizeof(pre));    for(int i=1;i&lt;=n;i++)        h[a[i]]=1;    int sum=0;//记录一共有多少种pokemon    for(int i=&#39;a&#39;,j=&#39;A&#39;;i&lt;=&#39;z&#39;;i++,j++)        sum+=h[i]+h[j];    // 尺追法    int mini = n , num = 0;//num记录区间内有多少pokemon    int l=1,r=1;//左右的区间界限    while(l&lt;=r&amp;&amp; r&lt;n)    {        while(num&lt;=sum &amp;&amp; r&lt;=n)        {            if(pre[a[r]]&lt;l)   //根据pre知道这个pokemon 之前出现的位置                num++;            pre[a[r]]=r;  //更新位置            if(num==sum)       mini=min(mini,r-l+1);//更新最小值            if(num&gt;=sum||r&gt;=n) break;//当区间内满足num==sum or r==n 的时候右界限就不应该被继续维护 应该去维护左界限            r++;        }        while(l&lt;=r&amp;&amp;num&gt;=sum)        {            if(pre[a[l]]==l)//如果这个pokemon在区间内只出现在左界限这里 那么此区间就不能在缩小了 就应该跳出 继续回去维护右界限            {                mini=min(mini,r-l+1);//更新最小值                num--,l++;                break;            }            //如果这个pokemon在区间内&quot;不&quot;只出现在左界限这里 那么左界限就可以向右+1 来缩小区间的范围  此时num依然等于sum            mini=min(mini,r-l+1);//更新最小值            l++;        }    }    printf(&quot;%d/n&quot;,mini);    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  Codeforces Round</title>
      <link href="/2016/07/23/52003146/"/>
      <url>/2016/07/23/52003146/</url>
      
        <content type="html"><![CDATA[<h1 id="Codeforces-Round-364-div-2-B-【数组标记】"><a href="#Codeforces-Round-364-div-2-B-【数组标记】" class="headerlink" title="Codeforces Round #364 div.2 B 【数组标记】"></a>Codeforces Round #364 div.2 B 【数组标记】</h1><p>2016年07月23日 11:07:59  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：413</p><hr><p> 博客爬取于<code>2019-04-18 17:20:22</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/52003146" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/52003146</a></p><p>题目连接 ： <a href="http://codeforces.com/problemset/problem/701/B" target="_blank" rel="noopener"> http://codeforces.com/problemset/problem/701/B</a></p><p>————————————————.</p><p>B. Cells Not Under Attack<br>time limit per test2 seconds<br>memory limit per test256 megabytes<br>inputstandard input<br>outputstandard output<br>Vasya has the square chessboard of size n × n and m rooks. Initially the<br>chessboard is empty. Vasya will consequently put the rooks on the board one<br>after another.</p><p>The cell of the field is under rook’s attack, if there is at least one rook<br>located in the same row or in the same column with this cell. If there is a<br>rook located in the cell, this cell is also under attack.</p><p>You are given the positions of the board where Vasya will put rooks. For each<br>rook you have to determine the number of cells which are not under attack<br>after Vasya puts it on the board.</p><p>Input<br>The first line of the input contains two integers n and m (1 ≤ n ≤ 100 000, 1<br>≤ m ≤ min(100 000, n2)) — the size of the board and the number of rooks.</p><p>Each of the next m lines contains integers xi and yi (1 ≤ xi, yi ≤ n) — the<br>number of the row and the number of the column where Vasya will put the i-th<br>rook. Vasya puts rooks on the board in the order they appear in the input. It<br>is guaranteed that any cell will contain no more than one rook.</p><p>Output<br>Print m integer, the i-th of them should be equal to the number of cells that<br>are not under attack after first i rooks are put.</p><p>Examples<br>input<br>3 3<br>1 1<br>3 1<br>2 2<br>output<br>4 2 0<br>input<br>5 2<br>1 5<br>5 1<br>output<br>16 9<br>input<br>100000 1<br>300 400<br>output<br>9999800001<br>Note<br>On the picture below show the state of the board after put each of the three<br>rooks. The cells which painted with grey color is not under the attack.<br><img src="http://codeforces.com/predownloaded/a3/a5/a3a52ec7278de7644c87dc9cb19b4d18eacefebd.png" alt="这里写图片描述"><br>—————————————————–.</p><p>题目大意： 就是在N*N的方格内 放入M个 “車” 这样 这个”車”所在的行列都是不安全的了 问 一次放入这些“車”后 还有多少安全的位置<br>（自己大概意淫出来的正确的题意）</p><p>题解 ： N，M 的数据量太大了，不能暴力求解 。 xjb画了画 发现 每次安全的位置个数都是N<em>N-N</em>(x+y)+x<em>y;<br>（x表示有多少行上有车，y同理）最后再加上x和y减重的那部分x</em>y；既是正解；</p><p>操作的时候要用两个数组记录下这行有没有車，这列有没有車 如果没有x，y就++；有了就不加了</p><p>附本体代码</p><p>——————————————.</p><pre><code>int xx[101010],yy[101010];int main(){    LL n,m;    scanf(&quot;%I64d%I64d&quot;,&amp;n,&amp;m);    for(int i=0;i&lt;=n;i++)        xx[i]=0,yy[i]=0;    LL x,y,xxx=0,yyy=0;    for(int i=0;i&lt;m;i++)    {        scanf(&quot;%I64d%I64d&quot;,&amp;x,&amp;y);        if(!xx[x]) xxx++,xx[x]=1;        if(!yy[y]) yyy++,yy[y]=1;        printf(&quot;%I64d &quot;,n*n-n*(xxx+yyy)+xxx*yyy);    }    puts(&quot;&quot;);    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  这是一堆 wrong 懵逼的题目</title>
      <link href="/2016/07/22/51997347/"/>
      <url>/2016/07/22/51997347/</url>
      
        <content type="html"><![CDATA[<h1 id="这是一堆-wrong-懵逼的题目"><a href="#这是一堆-wrong-懵逼的题目" class="headerlink" title="这是一堆 wrong 懵逼的题目"></a>这是一堆 wrong 懵逼的题目</h1><p>2016年07月22日 18:15:39  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：403<br>标签：  <a href="https://so.csdn.net/so/search/s.do?q=大家不要看&amp;t=blog" target="_blank" rel="noopener"> 大家不要看 </a></p><p>个人分类：  <a href="https://blog.csdn.net/qq_33184171/article/category/6362373" target="_blank" rel="noopener"> ===== 杂类 =====</a> <a href="https://blog.csdn.net/qq_33184171/article/category/6325432" target="_blank" rel="noopener"> 智障</a></p><hr><p> 博客爬取于<code>2019-04-18 17:20:23</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/51997347" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/51997347</a></p><h2 id="计算几何"><a href="#计算几何" class="headerlink" title="计算几何"></a>计算几何</h2><p>————————————————————-.</p><p>hdu 5572</p><pre><code>#include &lt;iostream&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;algorithm&gt;#include &lt;math.h&gt;#include &lt;string&gt;#include &lt;set&gt;using namespace std;#define LL __int64const int MOD = 1e9+7;const double eps = 1e-8;struct point{    double x,y,r;} a;double multi(point p1,point p2,point p0){    return((p1.x-p0.x)*(p2.y-p0.y)-(p2.x-p0.x)*(p1.y-p0.y));}point jian (point &amp;a,point &amp;b){    point ttt;    ttt.x=b.x-a.x;    ttt.y=b.y-a.y;    return ttt;}double mod(point a){    return a.x*a.x+a.y*a.y;}double dis(point a,point b){    return  (a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y);}point GetPoint(int cx,int cy,int r,double k,double b){    //列方程    /*      (1 + k^2)*x^2 - x*(2*cx -2*k*(b -cy) ) + cx*cx + ( b - cy)*(b - cy) - r*r = 0    */    double x1,y1,x2,y2;    double c = cx*cx + (b - cy)*(b- cy) -r*r;    double aa = (1 + k*k);    double b1 = (2*cx - 2*k*(b - cy));    //得到下面的简化方程    // a*x^2 - b1*x + c = 0;    double tmp = sqrt(b1*b1 - 4*aa*c);    x1 = ( b1 + tmp )/(2*aa);    y1 = k*x1 + b;    x2 = ( b1 - tmp)/(2*aa);    y2 = k*x2 + b;    //判断求出的点是否在圆上    double res1 = (x1 -a.x)*(x1 -a.x) + (y1 - a.y)*(y1 -a.y);    double res2 = (x2 -a.x)*(x2 -a.x) + (y2 - a.y)*(y2 -a.y);    point p;    if( res1&lt;res2)  //我这里 r = 50,res = 2500.632,还是比较准确的    {        p.x = x1;        p.y = y1;    }    else    {        p.x = x2;        p.y = y2;    }    return p;}point c,b,aa;bool judge(/*Circle c,point a,point b*/) // 判断圆与直线相交{    point ob=jian(c,b),oa=jian(c,a);    double cosx = (a.x*b.x+a.y*b.y)/sqrt(mod(oa)*mod(ob));    double  s = fabs(multi(a,b,c)),AB = dis(a,b);    if(cosx&gt;=0&amp;&amp;c.r*c.r&lt;dis(c,a)&amp;&amp;c.r*c.r&lt;dis(b,a))        return true;    if(cosx&lt;=0&amp;&amp;s*s&gt;=c.r*c.r*AB)//直线距离        return true;    return false;}int main(){    int t,p=0,flag=0;    scanf(&quot;%d&quot;,&amp;t);    while(t--)    {        flag=0;        scanf(&quot;%lf%lf%lf&quot;,&amp;c.x,&amp;c.y,&amp;c.r);        scanf(&quot;%lf%lf%lf%lf&quot;,&amp;a.x,&amp;a.y,&amp;aa.x,&amp;aa.y);        scanf(&quot;%lf%lf&quot;,&amp;b.x,&amp;b.y);        if( (b.x-a.x)*aa.y == (b.y-a.y)*aa.x )  //判断  A 能不能直线走到 B        {            //sudu fangxiang  判断之间you没有球被弹开            if(((b.y-a.y)*aa.y&gt;=0&amp;&amp;(b.x-a.x)*aa.x&gt;=0) &amp;&amp; judge())            {                flag=1;            }        }        else        {            //直线方程  y=kx+b            double k=aa.y/aa.x,C=a.y-a.x*aa.y/aa.x;            point pj = GetPoint(c.x,c.y,c.r,k,C);            point pjo= jian(pj,c),pja=jian(pj,a),pjb=jian(pj,b);            //printf(&quot;%.4lf %.4lf\n&quot;, pj.x, pj.y);            double sinx1 = multi(a,c,pj)/sqrt(mod(pjo)*mod(pja));            double sinx2 = multi(b,c,pj)/sqrt(mod(pjo)*mod(pjb));            sinx1=fabs(sinx1);            sinx2=fabs(sinx2);            //  printf(&quot;%.4lf %.4lf\n&quot;,sinx1,sinx2);            if(  sinx1 &lt;= sinx2+eps  &amp;&amp;  sinx1 &gt;= sinx2-eps )                if( pja.x * aa.x &lt;= 0 &amp;&amp; pja.x * aa.x &lt;= 0 )                    flag=1;        }        if(flag)            printf(&quot;Case #%d: Yes\n&quot;,++p);        else            printf(&quot;Case #%d: No\n&quot;,++p);    }    return 0;}/*// YES0 0 13 1 -2 -13 -10 0 13 1 -2 -15 -20 0 1-1 2 1 -11 2// NO0 0 12 2 0 1-1 -1*/</code></pre>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大家不要看 </tag>
            
            <tag> 杂类 </tag>
            
            <tag> 智障 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  各种乱七八糟的模板 【不定期补充】[C++语言描述]</title>
      <link href="/2016/07/17/51932828/"/>
      <url>/2016/07/17/51932828/</url>
      
        <content type="html"><![CDATA[<h1 id="各种乱七八糟的模板-【不定期补充】-C-语言描述"><a href="#各种乱七八糟的模板-【不定期补充】-C-语言描述" class="headerlink" title="各种乱七八糟的模板 【不定期补充】[C++语言描述]"></a>各种乱七八糟的模板 【不定期补充】[C++语言描述]</h1><p>置顶  2016年07月17日 16:12:39  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：374<br>标签：  <a href="https://so.csdn.net/so/search/s.do?q=c语言&amp;t=blog" target="_blank" rel="noopener"> c语言 </a></p><p>个人分类：  <a href="https://blog.csdn.net/qq_33184171/article/category/6354517" target="_blank" rel="noopener"> ===== 模板 =====</a></p><hr><p> 博客爬取于<code>2019-04-18 17:15:13</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/51932828" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/51932828</a></p><h3 id="矩阵快速幂"><a href="#矩阵快速幂" class="headerlink" title="矩阵快速幂"></a>矩阵快速幂</h3><pre><code>struct Matrix{   // int r,c;   //C行R列    LL m[66][66];};Matrix operator * (Matrix a,Matrix b){    Matrix c;    for(int i=0; i&lt;M; i++) //初始化矩阵        for(int j=0; j&lt;M; j++)            c.m[i][j]= 0;    for(int k=0; k&lt;M; k++)        for(int i=0; i&lt;M; i++) //实现矩阵乘法        {            if(a.m[i][k] &lt;= 0)  continue;  //剪枝            for(int j=0; j&lt;M; j++)            {               // if(b.m[k][j] &lt;= 0)    continue;  //剪枝                c.m[i][j]=(c.m[i][j]+a.m[i][k]*b.m[k][j]+MOD)%MOD;            }        }    return c;}Matrix operator ^ (Matrix a,LL b){    Matrix c;    for(int i=0; i&lt;n; i++) //初始化单位矩阵        for(int j=0; j&lt;n; j++)            c.m[i][j] = c.m[i+n][j+n] =  ( i == j );    while(b)    {        if(b&amp;1) c= c * a ;        b &gt;&gt;= 1;        a = a * a ;    }    return c;}Matrix operator + (Matrix a,Matrix b){    for(int i=0; i&lt;M; i++)        for(int j=0; j&lt;M; j++)            a.m[i][j]=(a.m[i][j]+b.m[i][j]+MOD)%MOD;    return a;}</code></pre><h2 id="博弈SG函数"><a href="#博弈SG函数" class="headerlink" title="博弈SG函数"></a>博弈SG函数</h2><h4 id="（一）-记忆化搜索dfs版"><a href="#（一）-记忆化搜索dfs版" class="headerlink" title="（一） 记忆化搜索dfs版"></a>（一） 记忆化搜索dfs版</h4><hr><pre><code>#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;algorithm&gt;using namespace std;//注意 S数组要按从小到大排序 SG函数要初始化为-1 对于每个集合只需初始化1边//不需要每求一个数的SG就初始化一边int SG[10100],n,m,s[102],k;//k是集合s的大小 S[i]是定义的特殊取法规则的数组int dfs(int x)//求SG[x]模板{    if(SG[x]!=-1) return SG[x];    bool vis[110];    memset(vis,0,sizeof(vis));    for(int i=0;i&lt;k;i++)    {        if(x&gt;=s[i])        {           dfs(x-s[i]);           vis[SG[x-s[i]]]=1;         }    }    int e;    for(int i=0;;i++)      if(!vis[i])      {        e=i;        break;      }    return SG[x]=e;}int main(){    int cas,i;    while(scanf(&quot;%d&quot;,&amp;k)!=EOF)    {        if(!k) break;        memset(SG,-1,sizeof(SG));        for(i=0;i&lt;k;i++) scanf(&quot;%d&quot;,&amp;s[i]);        sort(s,s+k);        scanf(&quot;%d&quot;,&amp;cas);        while(cas--)        {            int t,sum=0;            scanf(&quot;%d&quot;,&amp;t);            while(t--)            {                int num;                scanf(&quot;%d&quot;,&amp;num);                sum^=dfs(num);               // printf(&quot;SG[%d]=%d\n&quot;,num,SG[num]);            }            if(sum==0) printf(&quot;L&quot;);            else printf(&quot;W&quot;);        }        printf(&quot;\n&quot;);    }    return 0;}</code></pre><h4 id="（二）-预处理打表版"><a href="#（二）-预处理打表版" class="headerlink" title="（二） 预处理打表版"></a>（二） 预处理打表版</h4><pre><code>#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include &lt;string&gt;#include &lt;iostream&gt;using namespace std;const int N = 10008;int s[108],t;int sg[N];bool has[N];void sg_solve(int *s,int t,int N)   //N求解范围 S[]数组是可以每次取的值，t是s的长度。{    int i,j;    memset(sg,0,sizeof(sg));    for(i=1;i&lt;=N;i++)    {        memset(has,0,sizeof(has));        for(j=0;j&lt;t;j++)            if(i - s[j] &gt;= 0)                has[sg[i-s[j]]] = 1;        for(j=0;j&lt;=N;j++)            if(!has[j])                break;        sg[i] = j;    }    return ;}int main(){    int i,j,n,m,h;    while(scanf(&quot;%d&quot;,&amp;t),t)    {        string ans=&quot;&quot;;        for(i=0;i&lt;t;i++)            scanf(&quot;%d&quot;,&amp;s[i]);        sg_solve(s,t,N);        scanf(&quot;%d&quot;,&amp;n);        for(i=0;i&lt;n;i++)        {            scanf(&quot;%d&quot;,&amp;m);            int res = 0;            for(j=0;j&lt;m;j++)            {                scanf(&quot;%d&quot;,&amp;h);                res ^= sg[h];            }            ans+=res?&#39;W&#39;:&#39;L&#39;;        }        cout&lt;&lt;endl;    }    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c语言 </tag>
            
            <tag> 模板 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  POJ 3233 Matrix Power Series 【矩阵快速幂+等比矩阵】</title>
      <link href="/2016/07/17/51931853/"/>
      <url>/2016/07/17/51931853/</url>
      
        <content type="html"><![CDATA[<h1 id="POJ-3233-Matrix-Power-Series-【矩阵快速幂-等比矩阵】"><a href="#POJ-3233-Matrix-Power-Series-【矩阵快速幂-等比矩阵】" class="headerlink" title="POJ 3233 Matrix Power Series 【矩阵快速幂+等比矩阵】"></a>POJ 3233 Matrix Power Series 【矩阵快速幂+等比矩阵】</h1><p>2016年07月17日 12:56:31  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：265</p><hr><p> 博客爬取于<code>2019-04-18 17:20:24</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/51931853" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/51931853</a></p><p>题目连接 : <a href="http://poj.org/problem?id=3233" target="_blank" rel="noopener"> http://poj.org/problem?id=3233 </a></p><h2 id="——————————————————"><a href="#——————————————————" class="headerlink" title="——————————————————-"></a>——————————————————-</h2><p>Matrix Power Series<br>Time Limit: 3000MS Memory Limit: 131072K<br>Total Submissions: 20125 Accepted: 8449<br>Description</p><p>Given a n × n matrix A and a positive integer k, find the sum S = A + A2 + A3</p><ul><li>… + Ak.</li></ul><p>Input</p><p>The input contains exactly one test case. The first line of input contains<br>three positive integers n (n ≤ 30), k (k ≤ 109) and m (m &lt; 104). Then follow n<br>lines each containing n nonnegative integers below 32,768, giving A’s elements<br>in row-major order.</p><p>Output</p><p>Output the elements of S modulo m in the same way as A is given.</p><p>Sample Input</p><p>2 2 4<br>0 1<br>1 1<br>Sample Output</p><p>1 2<br>2 3</p><h2 id="————————————————————————————–"><a href="#————————————————————————————–" class="headerlink" title="————————————————————————————–"></a>————————————————————————————–</h2><p>题目大意 ： 就是求S %m；</p><p>题解 : 其实很容易知道A^k 之后只需加和就行了</p><p>但是直接加和还是不行 k的范围是在太大 会超时 所以就构造一个矩阵</p><p>因为S可以看成S=A(I+A(I+A(I+…A(I+A)))) (I是单位矩阵)</p><p>拿k=3举例S=A(I+A(I+A))</p><p>那么我们想，可不可以构造一个矩阵T使得T<em>T（因为是k次幂）这样乘下去每次可以得到A</em>(A+I)</p><p>那么肯定T有个两个元素就是A与I</p><p>那么假设：T={A I }<br>I I<br>那么T=T<em>T={A</em>A+I<em>I A</em>I+I<em>I}<br>A</em>I+I<em>I I</em>I+I<em>I<br>这样存在一个I</em>（A+I）的式子 ，当T再乘以T的时候会出现A（A+I）</p><p>这个时候我们可以简化将T={A I}</p><pre><code>                                        0   I</code></pre><p>这样可以简化很多计算T<em>T={A</em>A A<em>I+I</em>I}<br>0 I</p><p>那么容易得到T^(K+1)={A^(K+1) I+A+A^2+A^3+…+A^K}<br>0 I</p><p>这样我们只需要算T的k+1次幂就可以了</p><p>上文摘自 <a href="http://blog.csdn.net/yihuikang/article/details/7722765" target="_blank" rel="noopener"> http://blog.csdn.net/yihuikang/article/details/7722765</a></p><p>实在懒得写这些 其实就是简单的等比矩阵求和 学过线性代数 就应该能构造出来矩阵的</p><p>错将输入 n,k,m 当成的 n,m,k 错了一上午 。。汗2333333333</p><p>附本提代码</p><h2 id="———————————————————————————"><a href="#———————————————————————————" class="headerlink" title="———————————————————————————"></a>———————————————————————————</h2><pre><code>#include &lt;iostream&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;string&gt;#include &lt;algorithm&gt;#include &lt;math.h&gt;using namespace std;/******************************/#define LL long long int#define _LL __int64/*****************************//*const int M = 100;const int MOD = 1e4;*/#define M   n*2#define MOD mLL n,m,k;struct Matrix{   // int r,c;   //C行R列    LL m[66][66];};Matrix operator * (Matrix a,Matrix b){    Matrix c;    for(int i=0; i&lt;M; i++) //初始化矩阵        for(int j=0; j&lt;M; j++)            c.m[i][j]= 0;    for(int k=0; k&lt;M; k++)        for(int i=0; i&lt;M; i++) //实现矩阵乘法        {            if(a.m[i][k] &lt;= 0)  continue;  //剪枝            for(int j=0; j&lt;M; j++)            {               // if(b.m[k][j] &lt;= 0)    continue;  //剪枝                c.m[i][j]=(c.m[i][j]+a.m[i][k]*b.m[k][j]+MOD)%MOD;            }        }    return c;}Matrix operator ^ (Matrix a,LL b){    Matrix c;    for(int i=0; i&lt;M; i++) //初始化单位矩阵        for(int j=0; j&lt;M; j++)            c.m[i][j]= ( i == j );    while(b)    {        if(b&amp;1) c= c * a ;        b &gt;&gt;= 1;        a = a * a ;    }    return c;}Matrix operator + (Matrix a,Matrix b){    for(int i=0; i&lt;M; i++)        for(int j=0; j&lt;M; j++)            a.m[i][j]=(a.m[i][j]+b.m[i][j]+MOD)%MOD;    return a;}int main(){    ios::sync_with_stdio(false);    while( cin&gt;&gt;n&gt;&gt;k&gt;&gt;m )    {        Matrix a;        memset(a.m,0,sizeof(a.m));        for(int i=0; i&lt;n; i++)            for(int j=0; j&lt;n; j++)                cin &gt;&gt; a.m[i][j];        for(int i=0;i&lt;n;i++)            a.m[i+n][i+n]=a.m[i][i+n]=1;        Matrix c;        c = a ^ ( k + 1 );        for(int i=0;i&lt;n;i++)  //减掉单位矩阵。。            c.m[i][i+n] = (c.m[i][i+n]-1+MOD)%MOD;        for(int i=0; i&lt;n; i++)        {            for(int j=0; j&lt;n; j++)            {                if(j) cout&lt;&lt;&quot; &quot;;                cout&lt;&lt;c.m[i][j+n];            }            cout&lt;&lt;endl;        }    }    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  POJ 3070 Fibonacci 【矩阵快速幂】</title>
      <link href="/2016/07/17/51930813/"/>
      <url>/2016/07/17/51930813/</url>
      
        <content type="html"><![CDATA[<h1 id="POJ-3070-Fibonacci-【矩阵快速幂】"><a href="#POJ-3070-Fibonacci-【矩阵快速幂】" class="headerlink" title="POJ 3070 Fibonacci 【矩阵快速幂】"></a>POJ 3070 Fibonacci 【矩阵快速幂】</h1><p>2016年07月17日 09:37:27  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：232</p><hr><p> 博客爬取于<code>2019-04-18 17:20:25</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/51930813" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/51930813</a></p><p>题目连接 ： <a href="http://poj.org/problem?id=3070" target="_blank" rel="noopener"> http://poj.org/problem?id=3070 </a></p><h2 id="—————————————————————————"><a href="#—————————————————————————" class="headerlink" title="—————————————————————————"></a>—————————————————————————</h2><p>Fibonacci<br>Time Limit: 1000MS Memory Limit: 65536K<br>Total Submissions: 12738 Accepted: 9065<br>Description</p><p>In the Fibonacci integer sequence, F0 = 0, F1 = 1, and Fn = Fn − 1 + Fn − 2<br>for n ≥ 2. For example, the first ten terms of the Fibonacci sequence are:</p><p>0, 1, 1, 2, 3, 5, 8, 13, 21, 34, …</p><p>An alternative formula for the Fibonacci sequence is</p><p>. <img src="http://poj.org/images/3070_1.png" alt="这里写图片描述"></p><p>Given an integer n, your goal is to compute the last 4 digits of Fn.</p><p>Input</p><p>The input test file will contain multiple test cases. Each test case consists<br>of a single line containing n (where 0 ≤ n ≤ 1,000,000,000). The end-of-file<br>is denoted by a single line containing the number −1.</p><p>Output</p><p>For each test case, print the last four digits of Fn. If the last four digits<br>of Fn are all zeros, print ‘0’; otherwise, omit any leading zeros (i.e., print<br>Fn mod 10000).</p><p>Sample Input</p><p>0<br>9<br>999999999<br>1000000000<br>-1<br>Sample Output</p><p>0<br>34<br>626<br>6875<br>Hint</p><p>As a reminder, matrix multiplication is associative, and the product of two 2<br>× 2 matrices is given by<br><img src="http://poj.org/images/3070_2.png" alt="这里写图片描述"><br>.</p><p>Also, note that raising any 2 × 2 matrix to the 0th power gives the identity<br>matrix:</p><p>. <img src="http://poj.org/images/3070_3.gif" alt="这里写图片描述"></p><h2 id="——————————————"><a href="#——————————————" class="headerlink" title="——————————————"></a>——————————————</h2><p>题目大意 ： 这个的大意应该不用说了吧</p><p>题解 ： 这个题目大意里已经说得很清楚了吧 。。</p><p>就是裸的矩阵快速幂 没什么难度 主要是用来熟悉下 矩阵快速么的代码实现 并顺手撸了一发模板</p><pre><code>const int M = 2;const int MOD = 1e4;struct Matrix{    LL m[M][M];};Matrix operator * (Matrix a,Matrix b){    Matrix c;    for(int i=0; i&lt;M; i++) //初始化矩阵        for(int j=0; j&lt;M; j++)            c.m[i][j]= 0;    for(int k=0; k&lt;M; k++)        for(int i=0; i&lt;M; i++) //实现矩阵乘法        {            if(a.m[i][k] &lt;= 0)  continue;            for(int j=0; j&lt;M; j++)            {                if(b.m[k][j] &lt;= 0)    continue;                c.m[i][j]=(c.m[i][j]+a.m[i][k]*b.m[k][j]+MOD)%MOD;            }        }    return c;}Matrix operator ^ (Matrix a,LL b){    Matrix c;    for(int i=0; i&lt;M; i++) //初始化单位矩阵        for(int j=0; j&lt;M; j++)            c.m[i][j]= ( i == j );    while(b)    {        if(b&amp;1) c= c * a ;        b &gt;&gt;= 1;        a = a * a ;    }    return c;}</code></pre><p>直接附本题代码吧</p><h2 id="———————————————————————————"><a href="#———————————————————————————" class="headerlink" title="———————————————————————————"></a>———————————————————————————</h2><pre><code>#include &lt;iostream&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;string&gt;#include &lt;algorithm&gt;#include &lt;math.h&gt;using namespace std;#define LL long long int#define _LL __int64/******************************//*****************************/const int M = 2;const int MOD = 1e4;struct Matrix{    LL m[M][M];};Matrix operator * (Matrix a,Matrix b){    Matrix c;    for(int i=0; i&lt;M; i++) //初始化矩阵        for(int j=0; j&lt;M; j++)            c.m[i][j]= 0;    for(int k=0; k&lt;M; k++)        for(int i=0; i&lt;M; i++) //实现矩阵乘法        {            if(a.m[i][k] &lt;= 0)  continue;            for(int j=0; j&lt;M; j++)            {                if(b.m[k][j] &lt;= 0)    continue;                c.m[i][j]=(c.m[i][j]+a.m[i][k]*b.m[k][j]+MOD)%MOD;            }        }    return c;}Matrix operator ^ (Matrix a,LL b){    Matrix c;    for(int i=0; i&lt;M; i++) //初始化单位矩阵        for(int j=0; j&lt;M; j++)            c.m[i][j]= ( i == j );    while(b)    {        if(b&amp;1) c= c * a ;        b &gt;&gt;= 1;        a = a * a ;    }    return c;}void init(Matrix &amp;a){    a.m[0][0]=1;    a.m[0][1]=1;    a.m[1][0]=1;    a.m[1][1]=0;}int main(){    ios::sync_with_stdio(false);    Matrix f;    int n;    while(~scanf(&quot;%d&quot;,&amp;n)&amp;&amp;n!=-1)    {        init(f);        f=f^n;        printf(&quot;%lld/n&quot;,f.m[0][1]);    }    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  HDU 5317 RGCDQ 【筛法+前缀记录】</title>
      <link href="/2016/07/16/51925879/"/>
      <url>/2016/07/16/51925879/</url>
      
        <content type="html"><![CDATA[<h1 id="HDU-5317-RGCDQ-【筛法-前缀记录】"><a href="#HDU-5317-RGCDQ-【筛法-前缀记录】" class="headerlink" title="HDU 5317 RGCDQ 【筛法+前缀记录】"></a>HDU 5317 RGCDQ 【筛法+前缀记录】</h1><p>2016年07月16日 19:16:49  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：151</p><hr><p> 博客爬取于<code>2019-04-18 17:20:26</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/51925879" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/51925879</a></p><p>题目链接： <a href="http://acm.hdu.edu.cn/showproblem.php?pid=5317" target="_blank" rel="noopener"> http://acm.hdu.edu.cn/showproblem.php?pid=5317</a></p><h2 id="———————————————————————————————————————–"><a href="#———————————————————————————————————————–" class="headerlink" title="———————————————————————————————————————–"></a>———————————————————————————————————————–</h2><p>RGCDQ</p><p>Time Limit: 6000/3000 MS (Java/Others) Memory Limit: 65536/65536 K<br>(Java/Others)<br>Total Submission(s): 2667 Accepted Submission(s): 1060</p><p>Problem Description<br>Mr. Hdu is interested in Greatest Common Divisor (GCD). He wants to find more<br>and more interesting things about GCD. Today He comes up with Range Greatest<br>Common Divisor Query (RGCDQ). What’s RGCDQ? Please let me explain it to you<br>gradually. For a positive integer x, F(x) indicates the number of kind of<br>prime factor of x. For example F(2)=1. F(10)=2, because 10=2<em>5. F(12)=2,<br>because 12=2</em>2*3, there are two kinds of prime factor. For each query, we will<br>get an interval [L, R], Hdu wants to know maxGCD(F(i),F(j)) (L≤i&lt; j≤R)</p><p>Input<br>There are multiple queries. In the first line of the input file there is an<br>integer T indicates the number of queries.<br>In the next T lines, each line contains L, R which is mentioned above.</p><p>All input items are integers.<br>1&lt;= T &lt;= 1000000<br>2&lt;=L &lt; R&lt;=1000000</p><p>Output<br>For each query，output the answer in a single line.<br>See the sample for more details.</p><p>Sample Input<br>2<br>2 3<br>3 5</p><p>Sample Output<br>1<br>1</p><h2 id="——————————————————"><a href="#——————————————————" class="headerlink" title="——————————————————"></a>——————————————————</h2><p>题目大意 ： 就是在1~1e6 这个范围内 f[i]表示i的质因子的种类数 （8=2^3 f[8]=1 ( 仅有2 )） 让你求的是l~r区间内<br>GCD(F(i),F(j)) (L ≤ i &lt; j ≤ R) 的最大值</p><p>题解 ： 这道题目看起来很难 ，其实很好想。首先1~1e6 这个范围内f[i]的最大值也只有7 。举例2<em>3</em>5<em>7</em>11<em>13</em>17=510510<br>这已经是f[i]=7最小的数了 其次小的就是4849845已经大于1e6 很多了 所以至于f[i]=8的数就不用考虑了</p><p>知道了上述这些 就很好处理了 只要预先打表 先用筛法将f[1~1e6]计算出来 在用前缀和的形式 分别吧f[i]=1,=2,..=7的数记录出来<br>开的数组就是has[1e6][10] 并不会超内存</p><p>最后就能记录下来l~r范围内 f[i]=1,=2,..=7 的个数 这样的话再求MAXgcd就方便多了</p><p>总时间复杂度就是 O（7e6+7T）</p><p>7e6 = nlogn + n</p><p>附本题代码</p><p>Ps至于最后判断gcd是几的50+代码 是因为写短的 WA了5发 而且是在找不到别的错误 就枚举了一下maxgcd 还好AC了。。。</p><h2 id="——————————————————————"><a href="#——————————————————————" class="headerlink" title="——————————————————————-"></a>——————————————————————-</h2><pre><code>#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;limits.h&gt;#include &lt;malloc.h&gt;#include &lt;ctype.h&gt;#include &lt;math.h&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;map&gt;#include &lt;vector&gt;#include &lt;set&gt;#include &lt;queue&gt;#include &lt;time.h&gt;using namespace std;/*********************INPUT*************************/#define s2l(a,b)   scanf(&quot;%d%d&quot;,&amp;a,&amp;b)#define s2_l(a,b)  scanf(&quot;%I64d%I64d&quot;,&amp;a,&amp;b)#define s1l(a)     scanf(&quot;%d&quot;,&amp;a)/*********************OUTPUT*************************/#define pr1l(a)    printf(&quot;%d&quot;,a);#define pr1_l(a)   printf(&quot;%I64d&quot;,a);#define pr1ll(a)   printf(&quot;%lld&quot;,a);#define space      printf(&quot; &quot;);#define line       printf(&quot;\n&quot;);/*****************type-num***********************/#define LL long long int#define _LL __int64#define LLu unsigned long long int/****************************************/#define fr(a,b,c)  for(int a=b;a&lt;c;a++)#define del(a,b)   memset(b,a,sizeof(b));#define Rep(a,n)   for(int a=1;a&lt;n;a++)#define Rop(a,n)   for(int a=1;a&lt;n;a++)using namespace std;const int MOD = 1e9+7;const int Max = 1e6+7;bool Is_or[Max];int  f[Max];void Prime(){    memset(Is_or,true,sizeof(Is_or));    memset(f,0,sizeof(f));    int n=Max;    for(int i=2; i&lt;=n; i++)    {        if(Is_or[i])        {            f[i]++;            for(int j=i+i; j&lt;=n; j+=i)            {                Is_or[j] = false;                f[j]++;            }        }    }    return ;}int has[Max][8];void init(){    memset(has,0,sizeof(has));    for(int i=2; i&lt;Max; i++)    {        for(int j=1; j&lt;8; j++)            has[i][j] = has[i-1][j];        has[i][f[i]]++;    }    return ;}int main(){    Prime();    init();    /*        for(int i=2; i&lt;200; i++)            printf(&quot;%d %d\n&quot;,i,f[i]);    */    /*    for(int i=2; i&lt;220; i++)    {        for(int j=1; j&lt;8; j++)            printf(&quot;%d &quot;,has[i][j]);        printf(&quot;\n&quot;);    }    */    int t;    scanf(&quot;%d&quot;,&amp;t);    while(t--)    {        int l,r;        scanf(&quot;%d%d&quot;,&amp;l,&amp;r);        int h[10];        memset(h,0,sizeof(h));        for(int i=1; i&lt;8; i++)            h[i]=has[r][i]-has[l-1][i];        int flag=1;        if(h[7]&gt;=2)        {            printf(&quot;7\n&quot;);            flag=0;        }        if(h[6]&gt;=2&amp;&amp;flag)        {            printf(&quot;6\n&quot;);            flag=0;        }        if(h[5]&gt;=2&amp;&amp;flag)        {            printf(&quot;5\n&quot;);            flag=0;        }        if(h[4]&amp;&amp;flag)        {            if(h[4]&gt;=2&amp;&amp;flag)            {                printf(&quot;4\n&quot;);                flag=0;            }        }        if(h[3]&amp;&amp;flag)        {            if(h[3]&gt;=2||h[6])            {                printf(&quot;3\n&quot;);                flag=0;            }        }        if(h[2]&amp;&amp;flag)        {            if(h[2]||h[4]||h[6])            {                printf(&quot;2\n&quot;);                flag=0;            }            if(h[4]&amp;&amp;h[6]&amp;&amp;flag)            {                printf(&quot;2\n&quot;);                flag=0;            }        }        if(flag)            printf(&quot;1\n&quot;);    }    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  LightOJ 1090 Trailing Zeroes (II) [分解]【数论】</title>
      <link href="/2016/07/03/51815810/"/>
      <url>/2016/07/03/51815810/</url>
      
        <content type="html"><![CDATA[<h1 id="LightOJ-1090-Trailing-Zeroes-II-分解-【数论】"><a href="#LightOJ-1090-Trailing-Zeroes-II-分解-【数论】" class="headerlink" title="LightOJ 1090 Trailing Zeroes (II) [分解]【数论】"></a>LightOJ 1090 Trailing Zeroes (II) [分解]【数论】</h1><p>2016年07月03日 16:45:29  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：330</p><hr><p> 博客爬取于<code>2019-04-18 17:20:27</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/51815810" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/51815810</a></p><p>题目链接 ： <a href="http://acm.hust.edu.cn/vjudge/contest/view.action?cid=120197#problem/Y" target="_blank" rel="noopener"><br>http://acm.hust.edu.cn/vjudge/contest/view.action?cid=120197#problem/Y</a></p><h2 id="—————————————————–"><a href="#—————————————————–" class="headerlink" title="—————————————————–"></a>—————————————————–</h2><p>Trailing Zeroes (II)<br>Time Limit:2000MS Memory Limit:32768KB 64bit IO Format:%lld &amp; %llu<br>Submit Status Practice LightOJ 1090</p><p>Description</p><p>Find the number of trailing zeroes for the following function:</p><p><strong> _ C(n,r) x p^q _ </strong></p><p>where n, r, p, q are given. For example, if n = 10, r = 4, p = 1, q = 1, then<br>the number is 210 so, number of trailing zeroes is 1.</p><p>Input<br>Input starts with an integer T (≤ 10000), denoting the number of test cases.</p><p>Each case contains four integers: n, r, p, q (1 ≤ n, r, p, q ≤ 106, r ≤ n).</p><p>Output<br>For each test case, print the case number and the number of trailing zeroes.</p><p>Sample Input<br>2<br>10 4 1 1<br>100 5 40 5<br>Sample Output<br>Case 1: 1<br>Case 2: 6</p><hr><p>题目大意 ： 就是求 <strong> _ C(n,r) x p^q _ </strong> 末尾有几个 0</p><p>题解 : 求末尾有几个0 就将其展开成(2^n) <em> (5^m) </em> k 然后输出min（n，m） 即可。。</p><p>但是数据量特别大 所以需要先预处理</p><p>用 five[N],two[N]出 N！中n，m的值(值的含义如上所述) 然后 稍加操作即可求出C(n,m)中n,m的值 (这里并不难,看代码就明白了)</p><p>剩下的p^q 就更好办了 p=(2^n) <em> (5^m) </em> k<br>求出的n，m的值在乘上q</p><p>最后加上C(n,m)中n,m的值 就是方程里n,m的值</p><p>总复杂度 O（1e6<em>（log（2,1e6）+log（5,1e6））+T </em>（log（2,p）+log（5,p）））</p><p>附本题代码</p><h2 id="——————————————————————————————————————————"><a href="#——————————————————————————————————————————" class="headerlink" title="——————————————————————————————————————————"></a>——————————————————————————————————————————</h2><pre><code>#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;limits.h&gt;#include &lt;malloc.h&gt;#include &lt;ctype.h&gt;#include &lt;math.h&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;map&gt;#include &lt;vector&gt;#include &lt;set&gt;using namespace std;#define LL long long int#define uLL unsigned long long int#define _LL __int64struct Num{    int five,two;};Num Search( int n){    Num a;    a.five=a.two=0;    while(n%2==0)    {        n/=2;        a.two++;    }    while(n%5==0)    {        n/=5;        a.five++;    }    return a ;}Num num[1010101];Num add(Num a,Num b){    Num tem;    tem.five=a.five+b.five;    tem.two =a.two +b.two;    return tem;}Num jian(Num a,Num b){    Num tem;    tem.five=a.five-b.five;    tem.two =a.two -b.two;    return tem;}void init(){    memset(num,0,sizeof(num));    for(int i=2;i&lt;=1e6;i++)    {        num[i]=add(num[i-1],Search(i));    }    return ;}int solve(Num a){    return min(a.five,a.two);}int main(){    init();    LL t,pp=0;    scanf(&quot;%llu&quot;,&amp;t);    while(t--)    {        int n,p,q,r;        scanf(&quot;%d%d%d%d&quot;,&amp;n,&amp;r,&amp;p,&amp;q);        Num m;        m=Search(p);        m.five*=q,m.two*=q;        Num sum = add(jian(jian(num[n] ,num[n-r] ) ,num[r] ), m);        printf(&quot;Case %llu: %d\n&quot;,++pp,solve(sum));    }    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  UVA 10780 Again Prime? No Time. [质因子分解]【数论】</title>
      <link href="/2016/07/02/51811570/"/>
      <url>/2016/07/02/51811570/</url>
      
        <content type="html"><![CDATA[<h1 id="UVA-10780-Again-Prime-No-Time-质因子分解-【数论】"><a href="#UVA-10780-Again-Prime-No-Time-质因子分解-【数论】" class="headerlink" title="UVA 10780 Again Prime? No Time. [质因子分解]【数论】"></a>UVA 10780 Again Prime? No Time. [质因子分解]【数论】</h1><p>2016年07月02日 16:42:00  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：293<br>标签：  <a href="https://so.csdn.net/so/search/s.do?q=数论&amp;t=blog" target="_blank" rel="noopener"> 数论 </a> <a href="https://so.csdn.net/so/search/s.do?q=UVA-10780&amp;t=blog" target="_blank" rel="noopener"> UVA-10780</a> <a href="https://so.csdn.net/so/search/s.do?q=质因子分解&amp;t=blog" target="_blank" rel="noopener"> 质因子分解</a></p><p>个人分类：  <a href="https://blog.csdn.net/qq_33184171/article/category/6162724" target="_blank" rel="noopener"> 数学 </a></p><hr><p> 博客爬取于<code>2019-04-18 17:20:28</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/51811570" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/51811570</a></p><p>题目链接： <a href="http://acm.hust.edu.cn/vjudge/contest/view.action?cid=120197#problem/H" target="_blank" rel="noopener"> http://acm.hust.edu.cn/vjudge/contest/view.action?cid=120197#problem/H</a></p><hr><p>The problem statement is very easy. Given a number n you have to determine the<br>largest power of m,<br>not necessarily prime, that divides n!.<br>Input<br>The input file consists of several test cases. The first line in the file is<br>the number of cases to handle.<br>The following lines are the cases each of which contains two integers m (1 &lt; m<br>&lt; 5000) and n<br>(0 &lt; n &lt; 10000). The integers are separated by an space. There will be no<br>invalid cases given and<br>there are not more that 500 test cases.<br>Output<br>For each case in the input, print the case number and result in separate<br>lines. The result is either an<br>integer if m divides n! or a line ‘Impossible to divide’ (without the quotes).<br>Check the sample input<br>and output format.<br>Sample Input<br>2<br>2 10<br>2 100<br>Sample Output<br>Case 1:<br>8<br>Case 2:<br>97</p><h2 id="————————————————————————"><a href="#————————————————————————" class="headerlink" title="————————————————————————-"></a>————————————————————————-</h2><p>题目大意 ： 就是N!%m^k=0; 给你n和m 求最大的k；</p><p>题解 ： 其实很简单 就是把N!与M 质因子分解后<br>Pi表示第i个质数的贡献是多少<br>像这样<br>8 = 2^3 ，Pi=3；</p><p>N! ~~ Pn1..Pn2..Pn3..Pn4..Pn5..<br>M ~~ Pm1..Pm2..Pm3..Pm4..Pm5..</p><p>然后找出Pni/Pmi 的最小值 就是我们要求的答案了</p><p>附本题代码 170ms</p><h2 id="—————————————————–"><a href="#—————————————————–" class="headerlink" title="—————————————————–"></a>—————————————————–</h2><pre><code>#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;limits.h&gt;#include &lt;malloc.h&gt;#include &lt;ctype.h&gt;#include &lt;math.h&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;map&gt;#include &lt;vector&gt;#include &lt;set&gt;using namespace std;#define LL long long int#define _LL __int64LL prime[2000];LL Is_or[10101];void Prime(){    int  n = 10010 ,k = 0;    memset(prime,0,sizeof(prime));    memset(Is_or,1,sizeof(Is_or));    Is_or[0]=Is_or[1]=0;    for(int i=2; i&lt;n; i++)        if(Is_or[i])        {            prime[k++]=i;            for(int j=i+i; j&lt;n; j+=i)                Is_or[j]=0;        }    return ;}int  z[10010][1300];void init(){    memset(z,0,sizeof(z));    int  temp,k;    for(int i=1; i&lt;10000; i++)    {        temp=i;        k=0;        while(prime[k]&lt;=temp&amp;&amp;prime[k]!=0)        {            while(temp%prime[k]==0)            {                temp/=prime[k];                z[i][k]++;            }            k++;        }    }    for(int j=0; j&lt;1300; j++)    {        for(int i=2; i&lt;10010; i++)        {            z[i][j]+=z[i-1][j];        }    }    return ;}int mm[1300];int solve(int temp){    memset(mm,0,sizeof(mm));    int k=0;    while(prime[k]&lt;=temp&amp;&amp;prime[k]!=0)    {        while(temp%prime[k]==0)        {            temp/=prime[k];            mm[k]++;        }        k++;    }    return k;}int main(){    Prime();    init();    int t,p=0;    scanf(&quot;%d&quot;,&amp;t);    while(t--)    {        int n,m;        int sum=10000;        scanf(&quot;%d%d&quot;,&amp;m,&amp;n);        int num=solve(m);        for(int i=0; i&lt;num; i++)            if(mm[i])                sum=min(sum,z[n][i]/mm[i]);        printf(&quot;Case %d:\n&quot;,++p);        if(sum)            printf(&quot;%d\n&quot;,sum);        else            printf(&quot;Impossible to divide\n&quot;);    }    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
            <tag> 数论 </tag>
            
            <tag> UVA-10780 </tag>
            
            <tag> 质因子分解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  Light 1045 Digits of Factorial 【数论】</title>
      <link href="/2016/06/30/51791054/"/>
      <url>/2016/06/30/51791054/</url>
      
        <content type="html"><![CDATA[<h1 id="Light-1045-Digits-of-Factorial-【数论】"><a href="#Light-1045-Digits-of-Factorial-【数论】" class="headerlink" title="Light 1045 Digits of Factorial 【数论】"></a>Light 1045 Digits of Factorial 【数论】</h1><p>2016年06月30日 15:54:37  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：222<br>标签：  <a href="https://so.csdn.net/so/search/s.do?q=数论&amp;t=blog" target="_blank" rel="noopener"> 数论 </a> <a href="https://so.csdn.net/so/search/s.do?q=lightoj&amp;t=blog" target="_blank" rel="noopener"> lightoj</a></p><p>个人分类：  <a href="https://blog.csdn.net/qq_33184171/article/category/6162724" target="_blank" rel="noopener"> 数学 </a></p><hr><p> 博客爬取于<code>2019-04-18 17:20:29</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/51791054" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/51791054</a></p><p>题目链接： <a href="http://acm.hust.edu.cn/vjudge/contest/view.action?cid=120197#problem/U" target="_blank" rel="noopener"> http://acm.hust.edu.cn/vjudge/contest/view.action?cid=120197#problem/U</a></p><hr><p>Digits of Factorial<br>Time Limit:2000MS Memory Limit:32768KB 64bit IO Format:%lld &amp; %llu<br>Submit</p><p>Status<br>Description<br>Factorial of an integer is defined by the following function</p><p>f(0) = 1<br>f(n) = f(n - 1) * n, if(n &gt; 0)</p><p>So, factorial of 5 is 120. But in different bases, the factorial may be<br>different. For example, factorial of 5 in base 8 is 170.</p><p>In this problem, you have to find the number of digit(s) of the factorial of<br>an integer in a certain base.</p><p>Input<br>Input starts with an integer T (≤ 50000), denoting the number of test cases.</p><p>Each case begins with two integers n (0 ≤ n ≤ 106) and base (2 ≤ base ≤ 1000).<br>Both of these integers will be given in decimal.</p><p>Output<br>For each case of input you have to print the case number and the digit(s) of<br>factorial n in the given base.</p><p>Sample Input<br>5<br>5 10<br>8 10<br>22 3<br>1000000 2<br>0 100<br>Sample Output<br>Case 1: 3<br>Case 2: 5<br>Case 3: 45<br>Case 4: 18488885<br>Case 5: 1</p><h2 id="————————————————————"><a href="#————————————————————" class="headerlink" title="————————————————————"></a>————————————————————</h2><p>题目大意　　：　　就是求n!在base进制下表示 不算前导0的话 有多少位</p><p>多少位的话 直接取log即可<br>但是n大了 long long 会爆 所以<br>拆成<br>log(n!)=log(n)+log(n-1)+ …. （以上底数为base）.</p><p>因为计算机中只有底数为十的对数函数 所以 表示成lg(n!)/lg(base) 就行</p><p>最后n==0 的时候要特判一下.</p><h2 id="———————"><a href="#———————" class="headerlink" title="———————-"></a>———————-</h2><p>上面就是题解了<br>但是 我做的时候出现了 迷之RE+迷之WA</p><p>RE ： printf(“Case %d: %.0llf\n”,++p,f[n]/log(base)+0.5);<br>这么输出居然是RE</p><p>于是又换了一种</p><p>WA：printf(“Case %d: %d\n”,++p,(int)(f[n]/log(1.0*base)+0.5));</p><p>这样居然是WA ？我就不明白了</p><p>最后还是看别人代码 用的ceil() 才过的 但这到底是为什么啊啊啊啊啊啊啊啊啊<br>最终过得姿势 ::: printf(“Case %d: %d\n”,++p,(int)ceil(f[n]/log(1.0*base)))</p><hr><p>附本题代码</p><h2 id="——————————————"><a href="#——————————————" class="headerlink" title="——————————————"></a>——————————————</h2><pre><code>#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;limits.h&gt;#include &lt;malloc.h&gt;#include &lt;ctype.h&gt;#include &lt;math.h&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;map&gt;#include &lt;vector&gt;#include &lt;set&gt;using namespace std;#define LL long long intdouble f[1001110];int main(){    f[0]=0;    for(int i=1;i&lt;=1000010;i++)    {        f[i]=f[i-1]+log(1.0*i);    }    int t,p=0,n,base;    scanf(&quot;%d&quot;,&amp;t);    while(t--)    {        scanf(&quot;%d%d&quot;,&amp;n,&amp;base);        if(n==0)        {            printf(&quot;Case %d: 1\n&quot;,++p);            continue;        }        printf(&quot;Case %d: %d\n&quot;,++p,(int)ceil(f[n]/log(1.0*base)));    }    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
            <tag> 数论 </tag>
            
            <tag> lightoj </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  LightOJ 1035 Intelligent Factorial Factorization [预处理+一半的 质因子分解]【数论】</title>
      <link href="/2016/06/29/51783994/"/>
      <url>/2016/06/29/51783994/</url>
      
        <content type="html"><![CDATA[<h1 id="LightOJ-1035-Intelligent-Factorial-Factorization-预处理-一半的-质因子分解-【数论】"><a href="#LightOJ-1035-Intelligent-Factorial-Factorization-预处理-一半的-质因子分解-【数论】" class="headerlink" title="LightOJ 1035 Intelligent Factorial Factorization [预处理+一半的 质因子分解]【数论】"></a>LightOJ 1035 Intelligent Factorial Factorization [预处理+一半的 质因子分解]【数论】</h1><p>2016年06月29日 16:32:35  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：258</p><hr><p> 博客爬取于<code>2019-04-18 17:20:35</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/51783994" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/51783994</a></p><p>题目链接： <a href="http://acm.hust.edu.cn/vjudge/contest/view.action?cid=120197#problem/T" target="_blank" rel="noopener"> LightOJ 1035 Intelligent Factorial Factorization</a></p><hr><p>Intelligent Factorial Factorization<br>Time Limit:500MS Memory Limit:32768KB 64bit IO Format:%lld &amp; %llu<br>Submit</p><p>Status<br>Description<br>Given an integer N, you have to prime factorize N! (factorial N).</p><p>Input<br>Input starts with an integer T (≤ 125), denoting the number of test cases.</p><p>Each case contains an integer N (2 ≤ N ≤ 100).</p><p>Output<br>For each case, print the case number and the factorization of the factorial in<br>the following format as given in samples.</p><p>Case x: N = p1 (power of p1) <em> p2 (power of p2) </em> …</p><p>Here x is the case number, p1, p2 … are primes in ascending order.</p><p>Sample Input<br>3<br>2<br>3<br>6<br>Sample Output<br>Case 1: 2 = 2 (1)<br>Case 2: 3 = 2 (1) <em> 3 (1)<br>Case 3: 6 = 2 (4) </em> 3 (2) * 5 (1)</p><hr><p>题目大意 就是把N！ 质因子分解一下</p><p>题解： 因为数据量很小 所以预处理一下所有N！ 的质因子个数即可</p><p>这种办法 应该可以做到n&lt;=1000<br>n&lt;10000的时候用容器存一下 而且时间在大一丢丢 应该还是能做的</p><p>因为数据量太小 所有算法都是最最最最最暴力的</p><p>附本题代码</p><h2 id="—————————"><a href="#—————————" class="headerlink" title="—————————-"></a>—————————-</h2><pre><code>#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;limits.h&gt;#include &lt;malloc.h&gt;#include &lt;ctype.h&gt;#include &lt;math.h&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;map&gt;#include &lt;vector&gt;#include &lt;set&gt;using namespace std;#define LL unsigned long long intint Is_or[500];void Prime(){    int n=200;    int k=0;    memset(Is_or,1,sizeof(Is_or));    Is_or[0]=Is_or[1]=0;    for(int i=2; i&lt;n; i++)    {        if(Is_or[i])        {            for(int j=i+i; j&lt;n; j+=i)            {                Is_or[j]=0;            }        }    }    return ;}int has[105][105];void init(){    int num;    memset(has,0,sizeof(has));    for(int i=2;i&lt;=100;i++)    {        for(int j=2;j&lt;=i;j++)        {            num=i;            if(num%j==0&amp;&amp;Is_or[j])                while(num%j==0)                    has[i][j]++,num/=j;        }    }    for(int i=1;i&lt;=100;i++)    {        for(int j=1;j&lt;=100;j++)        {            has[i][j]+=has[i-1][j];        }    }    return ;}int main(){    Prime();    init();    int t,tt=0,num;    LL p,l;    scanf(&quot;%d&quot;,&amp;t);    while(t--)    {        int n,m;        scanf(&quot;%d&quot;,&amp;n);        printf(&quot;Case %d: %d = &quot;,++tt,n);        printf(&quot;%d (%d)&quot;,2,has[n][2]);        for(int i=3;i&lt;=n;i++)        {            if(has[n][i])            printf(&quot; * %d (%d)&quot;,i,has[n][i]);        }        printf(&quot;\n&quot;);    }    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  Light OJ 1014 Ifter Party [因子分解]【数论】</title>
      <link href="/2016/06/29/51783218/"/>
      <url>/2016/06/29/51783218/</url>
      
        <content type="html"><![CDATA[<h1 id="Light-OJ-1014-Ifter-Party-因子分解-【数论】"><a href="#Light-OJ-1014-Ifter-Party-因子分解-【数论】" class="headerlink" title="Light OJ 1014 Ifter Party [因子分解]【数论】"></a>Light OJ 1014 Ifter Party [因子分解]【数论】</h1><p>2016年06月29日 15:13:15  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：384<br>标签：  <a href="https://so.csdn.net/so/search/s.do?q=数论&amp;t=blog" target="_blank" rel="noopener"> 数论 </a> <a href="https://so.csdn.net/so/search/s.do?q=Light-OJ&amp;t=blog" target="_blank" rel="noopener"> Light-OJ</a> <a href="https://so.csdn.net/so/search/s.do?q=分解因子&amp;t=blog" target="_blank" rel="noopener"> 分解因子</a></p><p>个人分类：  <a href="https://blog.csdn.net/qq_33184171/article/category/6162724" target="_blank" rel="noopener"> 数学 </a></p><hr><p> 博客爬取于<code>2019-04-18 17:20:36</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/51783218" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/51783218</a></p><p>题目链接 ： <a href="http://acm.hust.edu.cn/vjudge/contest/view.action?cid=120197#problem/Q" target="_blank" rel="noopener"><br>http://acm.hust.edu.cn/vjudge/contest/view.action?cid=120197#problem/Q</a></p><h2 id="——————————"><a href="#——————————" class="headerlink" title="——————————"></a>——————————</h2><p>Ifter Party<br>Time Limit:2000MS Memory Limit:32768KB 64bit IO Format:%lld &amp; %llu<br>Submit</p><p>Status<br>Description<br>I have an Ifter party at the 5th day of Ramadan for the contestants. For this<br>reason I have invited C contestants and arranged P piaju’s (some kind of food,<br>specially made for Ifter). Each contestant ate Q piaju’s and L piaju’s were<br>left (L &lt; Q).</p><p>Now you have to find the number of piaju’s each contestant ate.</p><p>Input<br>Input starts with an integer T (≤ 325), denoting the number of test cases.</p><p>Each case contains two non-negative integers P and L (0 ≤ L &lt; P &lt; 231).</p><p>Output<br>For each case, print the case number and the number of possible integers in<br>ascending order. If no such integer is found print ‘impossible’.</p><p>Sample Input<br>4<br>10 0<br>13 2<br>300 98<br>1000 997<br>Sample Output<br>Case 1: 1 2 5 10<br>Case 2: 11<br>Case 3: 101 202<br>Case 4: impossible</p><h2 id="——————————————————"><a href="#——————————————————" class="headerlink" title="——————————————————-"></a>——————————————————-</h2><p>题目大意 ： 就是有P个单位的食物 有未知人数的人来吃 剩下L个单位的食物 其中没人吃的是一样多的 问每个人吃了多少食物<br>把每种可能都列举出来(任何一种可能均大于L)<br>如果没有任何一种可能就输出 impassbale</p><p>题解 ： 设 n=P-L 其实就是吧n的所有因子中大于L 的数输出</p><p>T只有325个 所以暴力求解即可</p><p>for(LL i=1;i*i&lt;=n;i++)<br>{<br>if(p%i==0)<br>{<br>if(i&gt;l)<br>a[num++]=i;<br>if(p/i&gt;l&amp;&amp;p/i!=i) //注意这里 能被开平方的话数就重了 在这wrong 5发 汗！<br>a[num++]=p/i;<br>}<br>}</p><p>附本题代码</p><h2 id="—————————————–"><a href="#—————————————–" class="headerlink" title="—————————————–"></a>—————————————–</h2><pre><code>#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;limits.h&gt;#include &lt;malloc.h&gt;#include &lt;ctype.h&gt;#include &lt;math.h&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;map&gt;#include &lt;vector&gt;#include &lt;set&gt;using namespace std;#define LL long long int// 分解因子啊    输出所有大于L的因子int a[2000000];int main(){    int  t,tt=0,num;    LL p,l;    scanf(&quot;%d&quot;,&amp;t);    while(t--)    {        num=0;        scanf(&quot;%lld%lld&quot;,&amp;p,&amp;l);        printf(&quot;Case %d:&quot;,++tt);        p-=l;        //11        for(LL i=1;i*i&lt;=p;i++)        {            if(p%i==0)            {                if(i&gt;l)                    a[num++]=i;                if(p/i&gt;l&amp;&amp;p/i!=i)                    a[num++]=p/i;            }        }        if(!num) printf(&quot; impossible&quot;);        else        {            sort(a,a+num);            for(int i=0;i&lt;num;i++)                printf(&quot; %d&quot;,a[i]);        }        printf(&quot;\n&quot;);    }    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
            <tag> 数论 </tag>
            
            <tag> Light-OJ </tag>
            
            <tag> 分解因子 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  UVA 11029 Leading and Trailing [数学]</title>
      <link href="/2016/06/28/51779048/"/>
      <url>/2016/06/28/51779048/</url>
      
        <content type="html"><![CDATA[<h1 id="UVA-11029-Leading-and-Trailing-数学"><a href="#UVA-11029-Leading-and-Trailing-数学" class="headerlink" title="UVA 11029 Leading and Trailing [数学]"></a>UVA 11029 Leading and Trailing [数学]</h1><p>2016年06月28日 21:47:05  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：220<br>标签：  <a href="https://so.csdn.net/so/search/s.do?q=数学&amp;t=blog" target="_blank" rel="noopener"> 数学 </a> <a href="https://so.csdn.net/so/search/s.do?q=uva&amp;t=blog" target="_blank" rel="noopener"> uva</a></p><p>个人分类：  <a href="https://blog.csdn.net/qq_33184171/article/category/6162724" target="_blank" rel="noopener"> 数学 </a></p><hr><p> 博客爬取于<code>2019-04-18 17:20:37</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/51779048" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/51779048</a></p><p>Apart from the novice programmers, all others know that you can’t exactly<br>represent numbers raised<br>to some high power. For example, the C function pow(125456, 455) can be<br>represented in double data<br>type format, but you won’t get all the digits of the result. However we can<br>get at least some satisfaction<br>if we could know few of the leading and trailing digits. This is the<br>requirement of this problem.<br>Input<br>The first line of input will be an integer T &lt; 1001, where T represents the<br>number of test cases. Each<br>of the next T lines contains two positive integers, n and k. n will fit in 32<br>bit integer and k will be less<br>than 10000001.<br>Output<br>For each line of input there will be one line of output. It will be of the<br>format LLL … T T T, where<br>LLL represents the first three digits of n<br>k and T T T represents the last three digits of n<br>k<br>. You are<br>assured that n<br>k will contain at least 6 digits.<br>Sample Input<br>2<br>123456 1<br>123456 2<br>Sample Output<br>123…456<br>152…936</p><h2 id="——————————"><a href="#——————————" class="headerlink" title="——————————-"></a>——————————-</h2><p>题目大意 就是求 n^k 的前三位和后三位</p><p>题解 :<br>后三位很好处理了 直接快速幂取模就好了</p><p>前三位就比较复杂了</p><p>n^k=A 同时取log<br>k<em>log(n)=log(A) =&gt; A=10^(k</em>log(n))</p><p>在这里我们知道k*log(10) =a.b (a是整数部分，b是小数部分)</p><p>在这里 a对A 的贡献就是一堆0 所以并没有什么用</p><p>所以A=10^(b)<br>因为要取 A 的前三位 所以A= 10^(2+b) 即可</p><p>还有一个坑点 就是后三位数如果是 12 的话 要输出012 就是前导0要有 wrong 了无数发</p><p>附本题代码</p><h2 id="————————–"><a href="#————————–" class="headerlink" title="————————–"></a>————————–</h2><pre><code>#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;limits.h&gt;#include &lt;malloc.h&gt;#include &lt;ctype.h&gt;#include &lt;math.h&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;map&gt;#include &lt;vector&gt;#include &lt;set&gt;using namespace std;#define LL unsigned long long intLL qmod (LL a,LL b,LL mod){    LL res=1;    while(b)    {        if(b&amp;1) res=(res*a)%mod;        b &gt;&gt;= 1;        a=(a*a)%mod;    }    return res;}LL  solve(int n, LL m,int weishu){    weishu-=1;    LL p, q, ans;    double f = m*log10(n);    //接下来三行就是求f的小数部分的    q = (LL)f;    p = (LL)(f*10000000)-q*10000000;    double x = 1.0*p/10000000;    ans = (LL)(pow(10, x+weishu));    return ans;}int main(){    int t,n,k;    scanf(&quot;%d&quot;,&amp;t);    while(t--)    {        scanf(&quot;%d%d&quot;,&amp;n,&amp;k);        LL a= qmod(n,k,1000) ;        LL b= solve(n,k,3) ;        printf(&quot;%lld...%03lld\n&quot;,b,a);    }    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
            <tag> uva </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  Light OJ 1007 Mathematically Hard [欧拉函数+前缀和]【数论】</title>
      <link href="/2016/06/28/51778975/"/>
      <url>/2016/06/28/51778975/</url>
      
        <content type="html"><![CDATA[<h1 id="Light-OJ-1007-Mathematically-Hard-欧拉函数-前缀和-【数论】"><a href="#Light-OJ-1007-Mathematically-Hard-欧拉函数-前缀和-【数论】" class="headerlink" title="Light OJ 1007 Mathematically Hard [欧拉函数+前缀和]【数论】"></a>Light OJ 1007 Mathematically Hard [欧拉函数+前缀和]【数论】</h1><p>2016年06月28日 21:36:41  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：596</p><hr><p> 博客爬取于<code>2019-04-18 17:20:38</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/51778975" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/51778975</a></p><p><strong> Mathematically Hard </strong></p><p>Time Limit:2000MS Memory Limit:65536KB 64bit IO Format:%lld &amp; %llu<br>Submit</p><p>Status<br>Description<br>Mathematically some problems look hard. But with the help of the computer,<br>some problems can be easily solvable.</p><p>In this problem, you will be given two integers a and b. You have to find the<br>summation of the scores of the numbers from a to b (inclusive). The score of a<br>number is defined as the following function.</p><p>score (x) = n2, where n is the number of relatively prime numbers with x,<br>which are smaller than x</p><p>For example,</p><p>For 6, the relatively prime numbers with 6 are 1 and 5. So, score (6) = 22 =<br>4.</p><p>For 8, the relatively prime numbers with 8 are 1, 3, 5 and 7. So, score (8) =<br>42 = 16.</p><p>Now you have to solve this task.</p><p>Input<br>Input starts with an integer T (≤ 105), denoting the number of test cases.</p><p>Each case will contain two integers a and b(2 ≤ a ≤ b ≤ 5 * 106).</p><p>Output<br>For each case, print the case number and the summation of all the scores from<br>a to b.</p><p>Sample Input<br>3<br>6 6<br>8 8<br>2 20<br>Sample Output<br>Case 1: 4<br>Case 2: 16<br>Case 3: 1237</p><hr><p>题目大意 就是求a~b的所有数的欧拉函数的和</p><p>题解：数据量5e6 预处理一下 将所有欧拉函数的平方求出 在处理一下前缀和 即可 因为后面的大数会爆long long 所以要用unsign long<br>long</p><p>附本题代码</p><h2 id="——————————————————"><a href="#——————————————————" class="headerlink" title="——————————————————"></a>——————————————————</h2><pre><code>#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;limits.h&gt;#include &lt;malloc.h&gt;#include &lt;ctype.h&gt;#include &lt;math.h&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;map&gt;#include &lt;vector&gt;#include &lt;set&gt;using namespace std;#define LL unsigned long long int/*const double eps = 1e-7;const double Pi = acos(-1.0);*/LL phi[5000500];void phi_table()  //欧拉函数。。。{    int i,j;    for(i=2; i&lt;=5e6; i++)        phi[i]=0;    phi[1]=1;    for(i=2; i&lt;=5e6; i++)        if(!phi[i])            for(j=i; j&lt;=5e6; j+=i)            {                if(!phi[j])                    phi[j]=j;                phi[j]=phi[j]/i*(i-1);            }    phi[0]=0;}void init(){    for(int i=2; i&lt;5000001; i++)    {        phi[i]=phi[i-1]+phi[i]*phi[i] ;    }    return ;}int main(){    phi_table();    init();    int t,aa,bb,p=0;    scanf(&quot;%d&quot;,&amp;t);    while(t--)    {        scanf(&quot;%d%d&quot;,&amp;aa,&amp;bb);        printf(&quot;Case %d: %llu\n&quot;,++p,phi[bb]-phi[aa-1]);    }    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  UVAlive 7308 Tom and Jerry 【几何数学】</title>
      <link href="/2016/06/26/51763961/"/>
      <url>/2016/06/26/51763961/</url>
      
        <content type="html"><![CDATA[<h1 id="UVAlive-7308-Tom-and-Jerry-【几何数学】"><a href="#UVAlive-7308-Tom-and-Jerry-【几何数学】" class="headerlink" title="UVAlive 7308 Tom and Jerry 【几何数学】"></a>UVAlive 7308 Tom and Jerry 【几何数学】</h1><p>2016年06月26日 19:17:17  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：444<br>标签：  <a href="https://so.csdn.net/so/search/s.do?q=数学&amp;t=blog" target="_blank" rel="noopener"> 数学 </a> <a href="https://so.csdn.net/so/search/s.do?q=几何&amp;t=blog" target="_blank" rel="noopener"> 几何</a> <a href="https://so.csdn.net/so/search/s.do?q=UVA-7308&amp;t=blog" target="_blank" rel="noopener"> UVA-7308</a></p><p>个人分类：  <a href="https://blog.csdn.net/qq_33184171/article/category/6162724" target="_blank" rel="noopener"> 数学 </a> <a href="https://blog.csdn.net/qq_33184171/article/category/6162722" target="_blank" rel="noopener"><br>==== 计算几何 ==== </a></p><hr><p> 博客爬取于<code>2019-04-18 17:20:39</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/51763961" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/51763961</a></p><p>题目链接： <a href="https://icpcarchive.ecs.baylor.edu/index.php?option=com_onlinejudge&amp;Itemid=8&amp;page=show_problem&amp;problem=5320" target="_blank" rel="noopener"> 这里是传送阵。。 </a></p><p>Tom and Jerry are very fond of cat and mice games, which might be rather<br>obvious to you. Today they<br>are playing a very complicated game. The goals are simple as usual though,<br>Jerry would be running<br>and Tom would have to catch Jerry.<br>However, today Jerry is running on a perfect circular<br>path with radius R meters, at a constant speed of<br>V m/s. Initially Tom is sitting at the very center of<br>the circle. He wants to catch Jerry as soon as possible,<br>but we all know, Tom is not very intelligent. Instead<br>of calculating an optimal direction to catch Jerry, he is<br>just running towards Jerry. <img src="https://img-blog.csdn.net/20160626191111871" alt="这里写图片描述"><br>As Jerry is also moving, the path Tom has taken<br>start to look like a curve (see picture above). At any<br>given moment, Tom’s position is between Jerry’s current<br>position and the center of the circle. Tom is also<br>moving at a constant speed of V m/s, same speed as<br>Jerry. Find the time (in seconds) Tom would need to<br>catch Jerry.<br>Input<br>Input file has T (T ≤ 10000) test cases, each case consists of two integer R<br>and V . Here, 0 &lt; R, V ≤<br>10000.<br>Output<br>For each test case, print the case number and the time Tom will need to catch<br>Jerry. Floating point<br>rounding error lower than 10−5 will be ignored by the judge.<br>Sample Input<br>4<br>45 100<br>5 1547<br>1000 10000<br>5668 5467<br>Sample Output<br>Case 1: 0.70685835<br>Case 2: 0.00507691<br>Case 3: 0.15707963<br>Case 4: 1.62854830</p><p>题目大意 ： 就是 Jerry在半径为R的圆上 Tom在圆心 Tom面向Jerry追 Jerry和Tom的速度都是V 问多长时间Tom能追上Jerry</p><p>既然Tom 总是面向Jerry 追的 所以Tom的路径就是一个半径为R/2 的半圆 Jerry的路径就是一个半径为R的四分之一圆 时间就可求了</p><p>t=2 <em> PI </em> r/4 / v;</p><p>附本题代码</p><h2 id="————————————–"><a href="#————————————–" class="headerlink" title="————————————–"></a>————————————–</h2><pre><code>#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;limits.h&gt;#include &lt;malloc.h&gt;#include &lt;ctype.h&gt;#include &lt;math.h&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;map&gt;#include &lt;vector&gt;#include &lt;set&gt;using namespace std;const double eps = 1e-7;const double Pi = acos(-1);int main(){    int t,p=0;    scanf(&quot;%d&quot;, &amp;t);    while(t--)    {        int r,v;        scanf(&quot;%d%d&quot;,&amp;r,&amp;v);        long double t;        t=Pi*r/v/2;        printf(&quot;Case %d: %llf\n&quot;,++p,t);    }    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
            <tag> 几何 </tag>
            
            <tag> UVA-7308 </tag>
            
            <tag> 计算几何 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  hdu 1717 &amp;&amp; 计蒜课 52 【分数小数的互相转化】【数论？】</title>
      <link href="/2016/06/07/51596858/"/>
      <url>/2016/06/07/51596858/</url>
      
        <content type="html"><![CDATA[<h1 id="hdu-1717-amp-amp-计蒜课-52-【分数小数的互相转化】【数论？】"><a href="#hdu-1717-amp-amp-计蒜课-52-【分数小数的互相转化】【数论？】" class="headerlink" title="hdu 1717 &amp;&amp; 计蒜课 52 【分数小数的互相转化】【数论？】"></a>hdu 1717 &amp;&amp; 计蒜课 52 【分数小数的互相转化】【数论？】</h1><p>2016年06月07日 10:37:00  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：439</p><hr><p> 博客爬取于<code>2019-04-18 17:20:40</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/51596858" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/51596858</a></p><p>本帖研究的是 <strong> 小数化分数 </strong> 与 <strong> 分数化小数 </strong></p><p>小数化分数 ： <a href="http://acm.hdu.edu.cn/showproblem.php?pid=1717" target="_blank" rel="noopener"> http://acm.hdu.edu.cn/showproblem.php?pid=1717</a><br>分数化小数 : <a href="http://nanti.jisuanke.com/t/42" target="_blank" rel="noopener"> http://nanti.jisuanke.com/t/42 </a></p><p>这里的小数包括循环小数 循环部分用”()” 括起来 For Example 1/3 = 0.(3) 。。。</p><p>小数化分数的性质如下 ：</p><p>1、有限小数的话把小数点后面的数除以10（一位数）.100（两位数）.1000（三位数）等，<br>2、如果是无限循环小数那就把循环的数除以9、99、999（同上）<br>3、如果是混循环小数，循环数字为两位情况下不循环的数字一位则除以990，两位则9900，并加上不循环小数数值乘以990或者9900。<br>即：分子=不循环部分和循环部分连起来-不循环部分。分母=99..（循环位数）0..（不循环位数）</p><h2 id="小数化分数"><a href="#小数化分数" class="headerlink" title="小数化分数"></a>小数化分数</h2><p>小数化分数就是<br>0.abcd(efghij)</p><p>(abcdefghij-abcd)/9999990000 <strong> (没有约分) </strong></p><p>在代码处理中 应该用字符串输入 ；<br>还有即使pow函数要慎用。。。</p><p>附代码。</p><h2 id="—————————————————–"><a href="#—————————————————–" class="headerlink" title="—————————————————–"></a>—————————————————–</h2><pre><code>#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;math.h&gt;using namespace std;/*分子=不循环部分和循环部分连起来-不循环部分。分母=99..（循环位数）0..（不循环位数）*/int gcd(int a,int b){    if(b==0) return a;    else return gcd(b,a%b);}int main(){    //freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin);    //freopen(&quot;out.txt&quot;, &quot;w&quot;, stdout);    char s[100];    int t;    scanf(&quot;%d\n&quot;,&amp;t);    while( t-- )    {        scanf(&quot;%s&quot;,s);        int l=strlen(s);        int kuo=0;        int n1=0,n2=1;        for(int i=2; i&lt;l; i++)        {            n1=n1*10+s[i]-&#39;0&#39;;            n2*=10;            if(s[i]==&#39;(&#39;)            {                kuo=1;                break;            }        }        if(kuo)        {            int t1=0,t2=0;            int l1=0,l2=0;            int nnnn=1;            int num=0,nu = 0;            int flag=0;            for(int i=2; i&lt;l; i++)            {                if(s[i]&gt;=&#39;0&#39;&amp;&amp;s[i]&lt;=&#39;9&#39;)                {                    if(!flag)                    {                        l1++;                        nnnn*=10;                        t1=t1*10+s[i]-&#39;0&#39;;                    }                    else                    {                        num*=10;                        nu=nu*10+9;                        l2++;                        t2=t2*10+s[i]-&#39;0&#39;;                    }                }                else                {                    if(!flag)                        num=t1;                    num+=t2;                    flag=1;                }            }            num-=t1;            nu=nu*nnnn;            int gcdd=gcd(num,nu);            printf(&quot;%d/%d\n&quot;, num/gcdd, nu/gcdd);        }        else        {            int gc=gcd(n1,n2);            printf(&quot;%d/%d\n&quot;, n1/gc, n2/gc );        }    }    return 0;}</code></pre><h2 id="分数化小数"><a href="#分数化小数" class="headerlink" title="分数化小数"></a>分数化小数</h2><p>这个暂时还没弄明白 ，，莫着急、、、</p><p>分数化小数代码</p><h2 id="———————————————–"><a href="#———————————————–" class="headerlink" title="———————————————–"></a>———————————————–</h2>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  codeforces</title>
      <link href="/2016/05/31/51544872/"/>
      <url>/2016/05/31/51544872/</url>
      
        <content type="html"><![CDATA[<h1 id="codeforces-354-div-2-C-amp-amp-676C-Vasya-and-String"><a href="#codeforces-354-div-2-C-amp-amp-676C-Vasya-and-String" class="headerlink" title="codeforces #354 div.2 C &amp;&amp;676C Vasya and String"></a>codeforces #354 div.2 C &amp;&amp;676C Vasya and String</h1><p>2016年05月31日 13:10:56  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：514</p><hr><p> 博客爬取于<code>2019-04-18 17:20:41</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/51544872" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/51544872</a></p><p>题目链接： <a href="http://codeforces.com/problemset/problem/676/C" target="_blank" rel="noopener"> http://codeforces.com/problemset/problem/676/C</a></p><h2 id="——————————"><a href="#——————————" class="headerlink" title="——————————"></a>——————————</h2><p>C. Vasya and String<br>time limit per test1 second<br>memory limit per test256 megabytes<br>inputstandard input<br>outputstandard output<br>High school student Vasya got a string of length n as a birthday present. This<br>string consists of letters ‘a’ and ‘b’ only. Vasya denotes beauty of the<br>string as the maximum length of a substring (consecutive subsequence)<br>consisting of equal letters.</p><p>Vasya can change no more than k characters of the original string. What is the<br>maximum beauty of the string he can achieve?</p><p>Input<br>The first line of the input contains two integers n and k (1 ≤ n ≤ 100 000, 0<br>≤ k ≤ n) — the length of the string and the maximum number of characters to<br>change.</p><p>The second line contains the string, consisting of letters ‘a’ and ‘b’ only.</p><p>Output<br>Print the only integer — the maximum beauty of the string Vasya can achieve by<br>changing no more than k characters.</p><p>Examples<br>input<br>4 2<br>abba<br>output<br>4<br>input<br>8 1<br>aabaabaa<br>output<br>5<br>Note<br>In the first sample, Vasya can obtain both strings “aaaa” and “bbbb”.</p><p>In the second sample, the optimal answer is obtained with the string<br>“aaaaabaa” or with the string “aabaaaaa”.</p><h2 id="——————————————–"><a href="#——————————————–" class="headerlink" title="——————————————–"></a>——————————————–</h2><p>题目大意 ：<br>给你一个长度为n且只有a和b构成的字符串，你可以改变k个字母 ，即a变b b变a。。<br>问在你操作后 的最长子串的长度是多少。。<br>子串要求只有一种字母构成 ；</p><p>解题思路 ：<br>分别计算一下 全是a的子串与全是b的自创最长能多长 ，取两个最大值即可；</p><p>我就是给字符串标一下号 ，并记录他们的位置 然后找到中间存在</p><p>举个栗子：(对的不是很齐 , 表格的话有太影响观看,,,最后就只能这样了)<br>aabaabaa<br>求a的子串的时候记录b的位置<br>-aabaabaa-<br>1–2–3–4 &lt;–这是序号<br>-1 2 5 8 &lt;–这是位置 </p><p>求b的子串的时候记录a的位置<br>-aabaabaa-<br>123-45-678 &lt;–这是序号<br>-1 0 1 3 4 6 7 8 &lt;–这是位置 </p><p>然后找中间有m个的区间 求一下开区间内的长度即可</p><p>附本题代码</p><h2 id="———————————"><a href="#———————————" class="headerlink" title="———————————"></a>———————————</h2><pre><code>#include&lt;iostream&gt;#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;algorithm&gt;#include&lt;stdlib.h&gt;using namespace std;char s[100050];int posa[100050],posb[100050];int main(){    int n,m;    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);    scanf(&quot;%s&quot;,s);    int na=1,nb=1;    posa[0]=posb[0]=-1;    for(int i=0;i&lt;n;i++)    {        if(s[i]==&#39;a&#39;)            posa[na++]=i;        if(s[i]==&#39;b&#39;)            posb[nb++]=i;    }    posa[na]=posb[nb]=n;    int mida=-1,midb=-1;    for(int i=m;i&lt;na;i++)    {        mida=max(mida,posa[i+1]-posa[i-m]-1);    }    for(int i=m;i&lt;nb;i++)    {        midb=max(midb,posb[i+1]-posb[i-m]-1);    }    if(na&lt;=m||nb&lt;=m)  //这个部分主要是看代码如何处理 处理好的话就不需要这里了        mida=n;    printf(&quot;%d\n&quot;,max(mida,midb));    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  数论各种小定理</title>
      <link href="/2016/05/24/51488462/"/>
      <url>/2016/05/24/51488462/</url>
      
        <content type="html"><![CDATA[<h1 id="数论各种小定理"><a href="#数论各种小定理" class="headerlink" title="数论各种小定理"></a>数论各种小定理</h1><p>置顶  2016年05月24日 10:54:37  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a><br>阅读数：1603</p><hr><p> 博客爬取于<code>2019-04-18 17:15:15</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/51488462" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/51488462</a></p><h1 id="这里是数论入门题目了-很全面"><a href="#这里是数论入门题目了-很全面" class="headerlink" title="[ 这里是数论入门题目了 很全面"></a>[ 这里是数论入门题目了 很全面</h1><p>](<a href="http://acm.hust.edu.cn/vjudge/contest/view.action?cid=120197#problem/D" target="_blank" rel="noopener">http://acm.hust.edu.cn/vjudge/contest/view.action?cid=120197#problem/D</a>) &lt;&lt;–<br>戳这里</p><p><strong> 欧拉降幂 </strong><br><img src="https://img-blog.csdn.net/20160507152606333?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt></p><p>A  x  %  C  =  A  x  %  ϕ  (  C  )  +  ϕ  (  C  )  %  C  ,  (  x  ≥  ϕ  (  C<br>)  )</p><p>O(1)解决快速乘取膜</p><pre><code>LLu qmodx(LLu a,LLu b,LLu c){    a%=c,b%=c;    if(c&lt;=1000000000) return a*b%c;    return (a*b-(LLu)(a/(long double)c*b+1e-8)*c+c)%c;}</code></pre><p>n = p1^a1<em>p2^a2</em>p3^a3<em>…</em>pk^ak 约束和s =<br>(p1^0+p1^1+p1^2+…p1^a1)(p2^0+p2^1+p2^2+…p2^a2)…(pk^0+pk^1+pk^2+…pk^ak）</p><p>lucas 定理 快速求大组合数 (省内存&amp;省时间)<br><a href="http://blog.csdn.net/skywalkert/article/details/52553048" target="_blank" rel="noopener"> 组合数求模 </a><br><a href="http://picks.logdown.com/posts/245545-binomial-coefficient-modulo-prime" target="_blank" rel="noopener"> 组合数求模 </a></p><pre><code>#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;cstring&gt;using namespace std;#define lld  __int64lld  n, m, p;lld Ext_gcd(lld a,lld b,lld &amp;x,lld &amp;y){   if(b==0) { x=1, y=0; return a; }   lld ret= Ext_gcd(b,a%b,y,x);   y-= a/b*x;   return ret;}lld Inv(lld a,int m)   ///求逆元{   lld d,x,y,t= (lld)m;   d= Ext_gcd(a,t,x,y);   if(d==1) return (x%t+t)%t;   return -1;}lld Cm(lld n, lld m, lld p)  ///组合数学{    lld a=1, b=1;    if(m&gt;n) return 0;    while(m)    {        a=(a*n)%p;        b=(b*m)%p;        m--;        n--;    }    return (lld)a*Inv(b,p)%p;  ///（a/b）%p 等价于 a*（b，p）的逆元}int Lucas(lld n, lld m, lld p)  ///把n分段递归求解相乘{    if(m==0) return 1;    return (lld)Cm(n%p,m%p,p)*(lld)Lucas(n/p,m/p,p)%p;}int main(){    int  T;    while(~scanf(&quot;%I64d%I64d&quot;,&amp;n,&amp;m))    {        n--,m--;        m--;        __int64 p=1000000007;        printf(&quot;%d\n&quot;,Lucas(n+m-1,m,p));    }    return 0;}/****************************************/LL qmul(LL a,LL b,LL c){    LL res=0;    while(b)    {        if(b&amp;1) res=(res+a)%c;        a=(a+a)%c;        b&gt;&gt;=1;    }    return res;}LL qmod(LL a,LL b,LL c){    LL res=1;    while(b)    {        if(b&amp;1) res=qmul(res,a,c)%c;        b&gt;&gt;=1;        a=qmul(a,a,c)%c;    }    return res;}LL exgcd(LL a,LL b,LL &amp;x,LL &amp;y) //ax+by=d{    if(!b)    {        x=1;        y=0;        return a;    }    else    {        LL r=exgcd(b,a%b,x,y);        LL t = x;        x = y;        y=t-a/b*x;        return r;    }}LL CRT(LL a[],LL m[],LL len) //x%m[i]=a[i]{    LL i,x,y,M,n=1,ret=0;    for(i=0; i&lt;len; ++i) n*=m[i];    for(i=0; i&lt;len; ++i)    {        M=n/m[i];        exgcd(M,m[i],x,y);        ret=(ret+qmul(qmul(x,M,n),a[i],n))%n;    }    return (ret+n)%n;}LL C(LL n,LL m,LL p)//组合数模素数P{    if(m&gt;n||m&lt;0) return 0;    if(n-m&lt;m) m=n-m;    LL a=1,b=1;    for(int i=0; i&lt;m; ++i)    {        a=a*(n-i)%p;        b=b*(m-i)%p;    }    return a*qmod(b,p-2,p)%p;}LL Lucas(LL n,LL m,LL p){    LL ans=1;    while(n&amp;&amp;m&amp;&amp;ans)    {        ans=ans*C(n%p,m%p,p)%p;        n/=p,m/=p;    }    return ans;}</code></pre><h1 id="余数问题"><a href="#余数问题" class="headerlink" title="余数问题"></a>余数问题</h1><p><a href="http://vjudge.net/contest/132006#overview" target="_blank" rel="noopener"> 这里是余数问题的练习题目 </a></p><h3 id="余数定理"><a href="#余数定理" class="headerlink" title="余数定理"></a>余数定理</h3><blockquote><p>计算  (  a  b  )  mod  c  其中b能整除a<br>如果b与c互素，则  (  a  /  b  )  %  c  =  a  ∗  b  p  h  i  (  c  )  −  1<br>如果b与c不互素，则  (  a  /  b  )  %  c  =  (  a  %  b  c  )  /  b<br>对于b与c互素和不互素都有  (  a  /  b  )  %  c  =  (  a  %  b  c  )  /  b  成立</p></blockquote><h3 id="扩展欧几里得"><a href="#扩展欧几里得" class="headerlink" title="扩展欧几里得"></a>扩展欧几里得</h3><p>这里是扩展欧几里德入门的题目了 做完这些我觉得才明白了扩展欧几里德的应用 <a href="http://acm.hust.edu.cn/vjudge/contest/117544#overview" target="_blank" rel="noopener"> 传送阵&lt;&lt;—</a></p><pre><code>#include &lt;iostream&gt;#include &lt;stdio.h&gt;#include &lt;algorithm&gt;#include &lt;string.h&gt;using namespace std;#define LL long long int#define _LL __int64LL exgcd_euclid(LL a,LL b,LL &amp;x,LL &amp;y){    if(b==0)    {        x=1;        y=0;        return a;    }    LL r=exgcd_euclid(b,a%b,x,y);    LL t=x;    x=y;    y=t-a/b*y;    return r;}LL exgcd(LL m,LL &amp;x,LL n,LL &amp;y){    LL x1,x0,y1,y0;    x0=1,y0=0;    x1=0,y1=1;    LL r=(m%n+n)%n;    LL q=(m-r)/n;    x=0,y=1;    while(r)    {        x=x0-q*x1,y=y0-q*y1,x0=x1,y0=y1;        x1=x,y1=y;        m=n,n=r,r=m%n;        q=(m-r)/n;    }    return n;}int main(){    LL ar,br,cr;    LL x,y,m,n,l;    while(~scanf(&quot;%lld%lld%lld%lld%lld&quot;,&amp;x,&amp;y,&amp;m,&amp;n,&amp;l))    {        LL M=exgcd(n-m,ar,l,br);        if((x-y)%M||m==n)            printf(&quot;Impossible\n&quot;);        else        {            LL s=l/M;            ar=ar*((x-y)/M);            ar=(ar%s+s)%s;            printf(&quot;%lld\n&quot;,ar);        }    }    return 0;}</code></pre><h3 id="逆元"><a href="#逆元" class="headerlink" title="逆元"></a>逆元</h3><p>定义:  a  ×  x  ≡  1  (  mod  m  )  ,称x为a关于m的逆元<br>对于方程  (  a  x  )  mod  c  我们可以转化为求  (  a  ×  x  −  1  )  mod  c<br>由于  x  ×  x  −  1  ≡  1  (  mod  m  )  恒成立,所以除法取模就可以将被除数转化为乘上被除数的逆元即可.</p><h5 id="求逆元的两种方法"><a href="#求逆元的两种方法" class="headerlink" title="求逆元的两种方法"></a>求逆元的两种方法</h5><ol><li>扩展欧几里德<br>(  a  x  )  ≡  ?  (  mod  c  )  =  &gt; a  ≡  ?  ×  x  (  mod  c  )  =  &gt; a  =  ?<br>×  x  +  k  ×  c<br>通过公式的推到，最后得到一个明显的同余式<br>而?的最小正整数解就是x的逆元</li></ol><pre><code>void exgcd(int a,int b,int &amp;d,int &amp;x,int &amp;y){    if(b==0) {        x = 1,y = 0,d=a;        return ;    }    exgcd(b,a%b,d,x,y);    int t = x;    x = y;    y = t - ( a / b ) * y;    return ;}int inv(int a){    int x,y,d;    exgcd(a,MOD,d,x,y);    if(d==1)  return (x%MOD+MOD)%MOD;   //返回最小正整数解    return -1;  //不存在逆元}/**注意只有当a与mod互质即 gcd(a,mod) 时才有逆元,否则不存在逆元*/</code></pre><ol><li>费马小定理   </li></ol><blockquote><p>费马小定理 :  a  p  −  1  ≡  1  (  mod  p  )  .<br>可以转化为  a  ×  a  p  −  2  ≡  1  (  mod  p  )  .所以  a  p  −  2<br>就是a关于p的逆元(!!!!!p必须为素数)</p></blockquote><pre><code>int qmod(int a,int b){    int res = 1;    while(b){        if(b&amp;1) res=res*a%MOD;        b&gt;&gt;=1;        a=a*a%MOD;    }    return res;}int inv(int a){    return qmod(a,MOD-2);}</code></pre><h3 id="求解高次同余方程"><a href="#求解高次同余方程" class="headerlink" title="求解高次同余方程"></a>求解高次同余方程</h3><p>还是用 babystep_gaintstep算法求解。但是这题并不能用POJ_2417的算法，直接套该<br>算法，下面简要说明一下不能用的原因。首先我们有必要归纳一下用babystep算法解题<br>的步骤：<br>(1) 求M = ceil( sqrt(C) ) ；<br>(2) for(i=0;i&lt; M;i++) hash( i , A^i ) ；<br>(3) 求D = A^M%C；<br>(4) r = 1 ; for( i = 0 ; i &lt; M ; i++ ) ex_gcd(r , C , x , y ) ; res = x <em> B %<br>C ; jj = find( res)<br>如果找到了这时候的jj，则答案就是i</em>M+jj，如果没有找到，则res = res <em> D % C，继续循<br>环查找，如果最终都没有找到，则输出无解。 在上述的步骤中，如果题目中没有告诉我们<br>gcd(A , C) = 1，则我们上述的方法是错误的，原因就在于第4步，求res的时候。因为如果<br>我们无法保证gcd(A , C) = 1 ，也就不能保证gcd(r ,C) = 1（因为D=A^M, r = D^i），所有在<br>用 扩展欧几里得求出r</em>x + C<em>y = gcd(r,C ) 的一个解x0之后，原方程:r</em>x+C<em>y = B的解<br>x = x0 </em> B / gcd(r,C) + i<em>C / gcd(r,C) ，但是我们这个时候并不能计算出gcd(r,C)，因为此时<br>的r本来就是经过取余之后得出的，并不能直接用来求gcd，因此我们上述的普通babystep<br>算法就会出错了。<br>这样我们就要换一种处理的方法了，这里介绍一种AC大牛博客上的一种“消因子”的方法，<br>具体内容请看这里：AC大牛。经过上面的分析我们很清楚接下去的处理应该从哪方面着<br>手，就是应该从不能求出gcd(r , C)入手。一种思想就是既然无法求， 那我每次只要保证<br>gcd(r, C) = 1那样就可以想普通babystep一样求解了，既然要保证gcd(r,C) =1 ，而<br>r = (A^M)^i,因此归根到底还是要求gcd( A , C ) = 1。下面就是从AC大牛博客上参考的“消因子”<br>法了，每次我们 都消去A,C的一个因子，然后对B,C, D进行如下的处理：B/=tmp;C/=tmp ;<br>D = D</em> A/tmp%C ，这样经过b轮的消因子之后，gcd(A,C) = 1， 接下去我们就可以用普通<br>的babystep求解出方程：A^x = B’( mod C’ ) 的解 res1， 原方程的解就是 res = res1 + b。<br>下面给出这种方法正确的简要证明；一开始我们要求的方程是：A^x = B( mod C )，也就是<br>求一个最小的x，使得A^x + C<em>y = B，通过消因子， 我们不断在方程两遍消去gcd(A,C)，这<br>样方程就可以变成 D</em>A^x1 + C’<em>y1 = B’，很简单就可以证明上式中 x = x1 + b ; y = y1 的（只要<br>在方程的两边分别将消去的因子乘回去等式还是保持不变的）。这样我们的问题就转化为了<br>求x1和y1，即D</em>A^x1 = B’( mod C’ )，此时gcd( A , C’) = 1，这样我们就可以用普通的babystep<br>求出上述式子的解x1，同时也就求出了x，这样本题就解决了。<br>但是上述的方法还是有一个bug的，也就是说，我们用babystep求出的x1&gt;=0，所以上述的<br>方法只能求出x &gt;= b的解，这样我们自然就会想到如果有一个解x &lt; b怎么办，上述方法就会出<br>先错误了，因此我们这里还需要改进。考虑b的最大值是多少，考虑每次我们消去的因子数都<br>最小也就是2，这样我们就可以得到b的最大值就是log(C)，这样我们只要保证每次log(C)之内的<br>解都特判一下， 就不会出现我们刚才的问题了， 所以我们要在进行上述处理之前进行一次for<br>循环 ，特判0 - log(C)直接的x是否能成为解，接下去再用上述的“消因子”算法。<br>最后不得不佩服发明这种算法的人的神奇，将O(C)复杂度的判断，分两级判断将复杂度降低<br>到O( sqrt(C) )，所以就是为什么叫” babystep_gaintstep “了， 哈哈。</p><h4 id="babystep算法模板"><a href="#babystep算法模板" class="headerlink" title="babystep算法模板"></a>babystep算法模板</h4><pre><code>#define CC(m ,what) memset(m , what , sizeof(m))LL A, B ,C ;const int NN = 99991 ;bool has[NN] ;int idx[NN] , val[NN] ;void insert_(int id , LL vv){    LL v = vv % NN ;    while( has[v] &amp;&amp; val[v]!=vv)    {        v++ ;        if(v == NN) v-=NN ;    }    if( !has[v] )    {        has[v] = 1;        val[v] = vv ;        idx[v] = id ;    }}int findi(LL vv){    LL v = vv % NN ;    while( has[v] &amp;&amp; val[v]!=vv)    {        v++ ;        if(v == NN) v-=NN ;    }    if( !has[v] )  return -1;    return idx[v] ;}void ex_gcd(LL a , LL b , LL&amp; x , LL&amp; y){    if(b == 0)    {        x = 1 ;        y = 0 ;        return ;    }    ex_gcd(b , a%b , x, y) ;    LL t = x ;    x = y;    y = t - a/b*y ;}LL gcd(LL a,LL b){    while( a%b != 0)    {        LL c = a ;        a = b ;        b = c % b ;    }    return b ;}LL baby_step(LL A, LL B , LL C){    LL ans = 1 ;    for(LL i=0; i&lt;=50; i++)    {        if(ans == B)    return i ;        ans = ans * A % C ;    }    LL tmp , d = 0 ;    LL D = 1 % C ;    while( (tmp=gcd(A,C)) != 1 )    {        if(B % tmp) return -1 ;        d++ ;        B/=tmp ;        C/=tmp ;        D = D*A/tmp%C ;    }    CC( has , 0) ;    CC( idx, -1) ;    CC(val , -1) ;    LL M = ceil( sqrt(C*1.0) ) ;    LL rr = 1 ;    for(int i=0; i&lt;M; i++)    {        insert_(i, rr) ;        rr = rr * A % C ;    }    LL x, y ;    for(int i=0; i&lt;M; i++)    {        ex_gcd(D, C , x, y) ;        LL r = x * B % C;        r = (r % C + C) % C ;        int jj = findi( r ) ;        if(jj != -1)        {            return  LL(i)*M + LL(jj) + d ;        }        D = D * rr % C ;    }    return -1 ;}</code></pre><h1 id="素数测试"><a href="#素数测试" class="headerlink" title="素数测试"></a>素数测试</h1><h3 id="线性筛法打素数表"><a href="#线性筛法打素数表" class="headerlink" title="线性筛法打素数表"></a>线性筛法打素数表</h3><pre><code>int prime[20000],kp=0;int Is_or[65536];void Prime(){    int n =65536; //2~n之间的素数    kp=0;    memset(Is_or,1,sizeof(Is_or));    Is_or[0]=Is_or[1]=0;    for(int i=2;i&lt;n;i++)    {        if(Is_or[i])    prime[kp++]=i;        for(int j=0;j&lt;kp&amp;&amp;i*prime[j]&lt;n;j++)        {            Is_or[i*prime[j]]=0;            if(i%prime[j]==0) break;        }    }    return ;}</code></pre><h3 id="随机性素数测试-miller-rabbin"><a href="#随机性素数测试-miller-rabbin" class="headerlink" title="随机性素数测试 miller-rabbin"></a>随机性素数测试 miller-rabbin</h3><p>普通的素数测试我们有O(√ n)的试除算法。事实上，我们有O(slog³n)的算法。</p><p>定理一：假如p是质数，且(a,p)=1，那么a^(p-1)≡1(mod<br>p)。即假如p是质数，且a,p互质，那么a的(p-1)次方除以p的余数恒等于1。（费马小定理）</p><p>该定理的逆命题是不一定成立的，但是令人可喜的是大多数情况是成立的。</p><p>于是我们就得到了一个定理的直接应用，对于待验证的数p，我们不断取a∈［1，p-1]且a∈Z，验证a^(p-1) mod<br>p是否等于1，不是则p果断不是素数，共取s次。其中a^(p-1) mod p可以通过把p-1写成二进制，由(a<em>b)mod c=(a mod c)</em>b<br>mod c，可以在t=log(p-1)的时间内计算出解，如考虑整数相乘的复杂度，则一次计算的总复杂度为log³(p-1)。这个方法叫快速幂取模。</p><p>为了提高算法的准确性，我们又有一个可以利用的定理。<br>定理二：对于0 &lt; x &lt; p，x^2 mod p =1 =&gt; x=1或p-1。</p><p>我们令p-1=(2^t)*u，即p-1为u二进制表示后面跟t个0。我们先计算出x[0]=a^u mod p<br>，再平方t次并在每一次模p，每一次的结果记为x[i]，最后也可以计算出a^(p-1) mod<br>p。若发现x[i]=1而x[i-1]不等于1也不等于p-1，则发现p果断不是素数。</p><p>可以证明，使用以上两个定理以后，检验s次出错的概率至多为2^(-s)，所以这个算法是很可靠的。</p><p>需要注意的是，为了防止溢出（特别大的数据），a*b mod c 也应用类似快速幂取模的方法计算。当然，数据不是很大就可以免了。</p><p>下面是我的程序。</p><pre><code>//****************************************************************// Miller_Rabin 算法进行素数测试//速度快，而且可以判断 &lt;2^63的数//****************************************************************const int S=20;//随机算法判定次数，S越大，判错概率越小//计算 (a*b)%c.   a,b都是long long的数，直接相乘可能溢出的//  a,b,c &lt;2^63long long mult_mod(long long a,long long b,long long c){    a%=c;    b%=c;    long long ret=0;    while(b)    {        if(b&amp;1){ret+=a;ret%=c;}        a&lt;&lt;=1;        if(a&gt;=c)a%=c;        b&gt;&gt;=1;    }    return ret;}//计算  x^n %clong long pow_mod(long long x,long long n,long long mod)//x^n%c{    if(n==1)return x%mod;    x%=mod;    long long tmp=x;    long long ret=1;    while(n)    {        if(n&amp;1) ret=mult_mod(ret,tmp,mod);        tmp=mult_mod(tmp,tmp,mod);        n&gt;&gt;=1;    }    return ret;}//以a为基,n-1=x*2^t      a^(n-1)=1(mod n)  验证n是不是合数//一定是合数返回true,不一定返回falsebool check(long long a,long long n,long long x,long long t){    long long ret=pow_mod(a,x,n);    long long last=ret;    for(int i=1;i&lt;=t;i++)    {        ret=mult_mod(ret,ret,n);        if(ret==1&amp;&amp;last!=1&amp;&amp;last!=n-1) return true;//合数        last=ret;    }    if(ret!=1) return true;    return false;}// Miller_Rabin()算法素数判定//是素数返回true.(可能是伪素数，但概率极小)//合数返回false;bool Miller_Rabin(long long n){    if(n&lt;2)return false;    if(n==2)return true;    if((n&amp;1)==0) return false;//偶数    long long x=n-1;    long long t=0;    while((x&amp;1)==0){x&gt;&gt;=1;t++;}    for(int i=0;i&lt;S;i++)    {        long long a=rand()%(n-1)+1;//rand()需要stdlib.h头文件        if(check(a,n,x,t))            return false;//合数    }    return true;}</code></pre><h3 id="pollard-rho-longlong质因子分解"><a href="#pollard-rho-longlong质因子分解" class="headerlink" title="pollard_rho(longlong质因子分解)"></a>pollard_rho(longlong质因子分解)</h3><pre><code>//************************************************//pollard_rho 算法进行质因数分解//************************************************long long factor[100];//质因数分解结果（刚返回时是无序的）int tol;//质因数的个数。数组小标从0开始long long gcd(long long a,long long b){    if(a==0)return 1;//???????    if(a&lt;0) return gcd(-a,b);    while(b)    {        long long t=a%b;        a=b;        b=t;    }    return a;}long long Pollard_rho(long long x,long long c){    long long i=1,k=2;    long long x0=rand()%x;    long long y=x0;    while(1)    {        i++;        x0=(mult_mod(x0,x0,x)+c)%x;        long long d=gcd(y-x0,x);        if(d!=1&amp;&amp;d!=x) return d;        if(y==x0) return x;        if(i==k){y=x0;k+=k;}    }}//对n进行素因子分解void findfac(long long n){    if(Miller_Rabin(n))//素数    {        factor[tol++]=n; //值得注意的是 这里的factor并不是有序的!!!!!        return;    }    long long p=n;    while(p&gt;=n)p=Pollard_rho(p,rand()%(n-1)+1);    findfac(p);    findfac(n/p);}</code></pre><h3 id="算数基本定理展开"><a href="#算数基本定理展开" class="headerlink" title="算数基本定理展开"></a>算数基本定理展开</h3><p>对于任意一个  N  我们可以写成  N  =  P  a  1  1  ∗  P  a  2  2  ∗  P  a  3  3  ∗  .  .  .<br>∗  P  a  n  n<br>我们求解的时候只要先讲素数筛出来,然后直接一个个的除就行了,这样的理想复杂度是  O  (  m  i  n  {  (  小  于  l  o  g  n<br>2  )  ,  k  p  }  )  ,  k  p  为  筛  出  的  素  数  个  数<br>但是注意一种情况,可能展开的数N就是一个很大的素数,比如  99997  ,这样的数如果有  1  e  6<br>个的话就不能简单快速的展开了.于是我们可以在判定数是否为素数的数组中在开一维记录其为第几个素数.这样一来复杂度就会降低很多  小  于  O  (  l<br>o  g  n  2  )</p><pre><code>int prime[N],kp;int Is_or[N][2];void Prime(){    kp = 0;    memset(Is_or,true,sizeof(Is_or));    Is_or[0][0]=Is_or[1][0]=0;    for(int i=2;i&lt;=100000;i++){        if(Is_or[i][0]) Is_or[i][1]=kp,prime[kp++]=i;//记录其为第几个素数        for(int j=0;j&lt;kp&amp;&amp;prime[j]*i&lt;=100000;j++){            Is_or[prime[j]*i][0]=0;            if(0==i%prime[j]) break;        }    }    return ;}int main(){    int tem;    cin&gt;&gt;tem;    for(int j=0;j&lt;kp&amp;&amp;tem&gt;=prime[j];j++){        if(Is_or[tem][0]) {a[Is_or[tem][1]]++;break;}        //if(0==tem%prime[j]) ;          while(0==tem%prime[j]) a[j]++,tem/=prime[j];    }}</code></pre><h1 id="乘性函数"><a href="#乘性函数" class="headerlink" title="乘性函数"></a>乘性函数</h1><h3 id="欧拉函数表"><a href="#欧拉函数表" class="headerlink" title="欧拉函数表"></a>欧拉函数表</h3><p>————————–.</p><pre><code>void phi_table()  //欧拉函数。。。{    int i,j;    for(i=2; i&lt;=5e6; i++)        phi[i]=0;    phi[1]=1;    for(i=2; i&lt;=5e6; i++)        if(!phi[i])            for(j=i; j&lt;=5e6; j+=i)            {                if(!phi[j])phi[j]=j;                phi[j]=phi[j]/i*(i-1);            }    phi[0]=0;    return 0;}void phi_table(int maxn){    for(int i=1;i&lt;=maxn;i++)    phi[i]=i;    for(int i=2;i&lt;=maxn;i+=2)    phi[i]/=2;    for(int i=3;i&lt;=maxn;i+=2)    if(phi[i]==i)        for(int j=i;j&lt;=maxn;j+=i)            phi[j]=phi[j]/i*(i-1);    return ;}//  以上是打表的形式  这是求单个的 void Prime(){    int n=200;    int k=0;    memset(Is_or,1,sizeof(Is_or));    Is_or[0]=Is_or[1]=0;    for(int i=2; i&lt;n; i++)    {        if(Is_or[i])        {        prime[k++]=i;            for(int j=i+i; j&lt;n; j+=i)            {                Is_or[j]=0;            }        }    }    return ;}LL Phi(LL n){    LL rea=n;    for(int i=0; prime[i]*prime[i]&lt;=n&amp;&amp;i&lt;kp; i++)    {        if(n%prime[i]==0)        {            rea=rea-rea/prime[i];            while(n%prime[i]==0)                n/=prime[i];        }    }    if(n&gt;1)    rea=rea-rea/n;    return rea;}/************************/O(n)求素数+欧拉函数用最小的素因子筛掉每个数int prime[N],phi[N],cnt;// prime:记录质数，phi记录欧拉函数int Min_factor[N];// i的最小素因子bool vis[N];void Init(){    cnt=0;    phi[1]=1;    int x;    for(int i=2;i&lt;N;i++)    {        if(!vis[i])        {            prime[++cnt]=i;            phi[i]=i-1;            Min_factor[i]=i;        }        for(int k=1;k&lt;=cnt&amp;&amp;prime[k]*i&lt;N;k++)        {            x=prime[k]*i;            vis[x]=true;            Min_factor[x]=prime[k];            if(i%prime[k]==0)            {                phi[x]=phi[i]*prime[k];                break;            }            else phi[x]=phi[i]*(prime[k]-1);        }    }}</code></pre><h1 id="计算方法"><a href="#计算方法" class="headerlink" title="计算方法"></a>计算方法</h1><h3 id="矩阵快速幂"><a href="#矩阵快速幂" class="headerlink" title="矩阵快速幂"></a>矩阵快速幂</h3><pre><code>struct Matrix{    LL m[M][M];    void clearO()    {        for(int i=0; i&lt;M; i++) //初始化矩阵            for(int j=0; j&lt;M; j++)                m[i][j]= 0;    }    void clearE()    {        for(int i=0; i&lt;M; i++) //初始化矩阵            for(int j=0; j&lt;M; j++)                m[i][j]= (i==j);    }    void display()    {        for(int i=0; i&lt;M; i++)            {                for(int j=0; j&lt;M; j++)                printf(&quot;%d &quot;,m[i][j]);                puts(&quot;&quot;);            }    }};Matrix operator * (Matrix a,Matrix b){    Matrix c;    c.clearO();    for(int k=0; k&lt;M; k++)        for(int i=0; i&lt;M; i++) //实现矩阵乘法        {            if(a.m[i][k] &lt;= 0)  continue;            for(int j=0; j&lt;M; j++)            {                if(b.m[k][j] &lt;= 0)    continue;                c.m[i][j]=(c.m[i][j]+a.m[i][k]*b.m[k][j]+MOD)%MOD;            }        }    return c;}Matrix operator ^ (Matrix a,LL b){    Matrix c;    c.clearE();    while(b)    {        if(b&amp;1) c= c * a ;        b &gt;&gt;= 1;        a = a * a ;    }    return c;}//#include &lt;bits/stdc++.h&gt;#include &lt;stdio.h&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;string.h&gt;using namespace std;#define INF 0x3f3f3f3f#define pb push_back#define abs(a) (a)&gt;0?(a):-(a)#define min(a,b) (a)&gt;(b)?(a):(b)#define lalal puts(&quot;*******&quot;);typedef long long int LL ;/*******************************/const int N = 100+5;int MOD ;struct Matrix{    LL m[N][N];    int row,culumn;    void clearE()    {        for(int i=0; i&lt;row; i++)            for(int j=0; j&lt;culumn; j++)                m[i][j]=(i==j);    }    void clearO()    {        for(int i=0; i&lt;row; i++)            for(int j=0; j&lt;culumn; j++)                m[i][j]=0;    }    void display()    {        for(int i=0; i&lt;row; i++)        {            for(int j=0; j&lt;culumn; j++)                printf(&quot;%d &quot;,m[i][j]);            puts(&quot;&quot;);        }    }};//循环矩阵 * 的写法。。对于循环矩阵来说 行和列是一样都循环的 并不用特意区分  Matrix operator *(Matrix &amp;a,Matrix &amp;b){    Matrix c;    c.row=a.row,c.culumn=b.culumn,c.clearO();    for (int k = 0; k &lt; a.culumn; k++)        if (a.m[0][k])        {            for (int j = 0; j &lt; b.culumn; j++)                if (b.m[k][j])                    c.m[0][j] = (c.m[0][j] + a.m[0][k] * b.m[k][j]) % MOD;        }    for (int i = 1; i &lt; c.culumn; i++)    {        c.m[i][0] = c.m[i - 1][c.culumn - 1];        for (int j = 1; j &lt; c.culumn; j++)            c.m[i][j] = c.m[i - 1][j - 1];    }    return c;}Matrix operator ^(Matrix &amp;a,int b){    Matrix c;    c.row=a.row,c.culumn=a.culumn,c.clearE();    while(b)    {        if(b&amp;1) c=c*a;        b&gt;&gt;=1;        a=a*a;    }    return c;}int main(){    int t;    scanf(&quot;%d&quot;,&amp;t);    while(t--)    {        LL n,m,L,R,M;        scanf(&quot;%I64d%I64d%I64d%I64d%I64d&quot;,&amp;n,&amp;m,&amp;L,&amp;R,&amp;M);        MOD=M;        Matrix a,b;        a.row=1,b.row=a.culumn=b.culumn=n,a.clearO(),b.clearO();        for(int i=0; i&lt;n; i++)        {            scanf(&quot;%I64d&quot;,&amp;a.m[0][i]);            a.m[0][i]%=MOD;            b.m[(i-1+n)%n][i]=R%MOD;            b.m[(i+1)%n][i]=L%MOD;            b.m[i][i]=1;        }        b=b^(m);        a=a*b;        for(int i=0; i&lt;n; i++)        {            if(i)printf(&quot; &quot;);            printf(&quot;%I64d&quot;,a.m[0][i]);        }        puts(&quot;&quot;);    }    return 0;}</code></pre><h3 id="FFT-NTT"><a href="#FFT-NTT" class="headerlink" title="FFT/NTT"></a>FFT/NTT</h3><p>用于快速求卷积  c  =  a  ⊗  b<br>卷积可以类比两个多项式相乘<br>正常暴力求卷积的复杂度是  O  (  n  2  )  ,但是通过FFT加速 求卷积的复杂度能降到  O  (  n  l  o  g  2  n  )<br><a href="http://www.gatevin.moe/acm/fft%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" target="_blank" rel="noopener"> 算法学习笔记 </a><br>FFT模板</p><pre><code>struct Complex{    double real, image;    Complex(double _real, double _image){        real = _real;        image = _image;    }    Complex(){}    Complex operator + (const Complex &amp;tmp){        return Complex(real + tmp.real, image + tmp.image);    }    Complex operator - (const Complex &amp;tmp){        return Complex(real - tmp.real, image - tmp.image);    }    Complex operator * (const Complex &amp;tmp){        return Complex(real*tmp.real - image*tmp.image, real*tmp.image + image*tmp.real);    }};int rev(int id, int len){    int ret = 0;    for(int i = 0; (1 &lt;&lt; i) &lt; len; i++){        ret &lt;&lt;= 1;        if(id &amp; (1 &lt;&lt; i)) ret |= 1;    }    return ret;}Complex A[N];void FFT(Complex *a, int len, int DFT){    for(int i = 0; i &lt; len; i++)        A[rev(i, len)] = a[i];    for(int s = 1; (1 &lt;&lt; s) &lt;= len; s++){        int m = (1 &lt;&lt; s);        Complex wm = Complex(cos(DFT*2*PI/m), sin(DFT*2*PI/m));        for(int k = 0; k &lt; len; k += m){            Complex w = Complex(1, 0);            for(int j = 0; j &lt; (m &gt;&gt; 1); j++){                Complex t = w*A[k + j + (m &gt;&gt; 1)];                Complex u = A[k + j];                A[k + j] = u + t;                A[k + j + (m &gt;&gt; 1)] = u - t;                w = w*wm;            }        }    }    if(DFT == -1) for(int i = 0; i &lt; len; i++) A[i].real /= len, A[i].image /= len;    for(int i = 0; i &lt; len; i++) a[i] = A[i];    return;}int main(){    /**    求卷积c=a⊗b    la为a的长度    lb为b的长度    len为最后结果的长度.    **/    int sa,sb;    sa=sb=0;    while((1&lt;&lt;sa)&lt;la) sa++;    while((1&lt;&lt;sb)&lt;lb) sb++;    int len = (1&lt;&lt;(max(sa,sb)+1));    A = FFT(A,len,1);    B = FFT(B,len,1);    for(int i=0;i&lt;len;i++)  A[i]=A[i]*B[i],ans[i]=0;    A = FFT(A,len,-1);    /**    这是最后的卷积的结果.    **/}</code></pre><p>NTT</p><pre><code>const int Maxn=50000;LL A[Maxn&lt;&lt;2],B[Maxn&lt;&lt;2];int ans[Maxn&lt;&lt;2];inline LL qmod(LL a, LL b,LL P) {    LL ans=1;    for(; b; b&gt;&gt;=1, a=a*a%P)        if(b&amp;1) ans=ans*a%P;    return ans;}struct NTT {    int pos[Maxn&lt;&lt;2],k,G,Mod;    inline void init(int len) {        Mod = 998244353,G = 3;        for(k=1; k&lt;=len; k&lt;&lt;=1);        for(int i=1; i&lt;k; i++)            pos[i]=(i&amp;1)?((pos[i&gt;&gt;1]&gt;&gt;1)^(k&gt;&gt;1)):(pos[i&gt;&gt;1]&gt;&gt;1);    }    inline void dft(LL *a) {        for(int i=1; i&lt;k; i++)if(pos[i]&gt;i)swap(a[pos[i]],a[i]);        for(int m1=1; m1&lt;k; m1&lt;&lt;=1) {            int m2=m1&lt;&lt;1;            LL wn=qmod(G,(Mod-1)/m2,Mod)%Mod;            for(int i=0; i&lt;k; i+=m2) {                LL w=1;                for(int j=0; j&lt;m1; j++) {                    LL &amp;A=a[i+j],&amp;B=a[i+j+m1],t=B*w%Mod;                    B=(A-t+Mod)%Mod;                    A=(A+t)%Mod;                    w=w*wn%Mod;                }            }        }    }    inline void mui(LL *A,LL *B,int m) {        init(m);        dft(A);dft(B);        for(int i=0; i&lt;k; i++)A[i]=A[i]*B[i]%Mod;        dft(A);        reverse(A+1,A+k);        int inv=qmod(k,Mod-2,Mod)%Mod;        for(int i=0; i&lt;k; i++)A[i]=inv*A[i]%Mod;    }} ntt;</code></pre><h3 id="牛顿迭代法-线性开根"><a href="#牛顿迭代法-线性开根" class="headerlink" title="牛顿迭代法 线性开根"></a>牛顿迭代法 线性开根</h3><blockquote><p>下面这种方法可以很有效地求出根号a的近似值：首先随便猜一个近似值x，然后不断令x等于x和a/x的平均数，迭代个六七次后x的值就已经相当精确了。<br>( 4 + 2/ 4 ) / 2 = 2.25<br>( 2.25 + 2/ 2.25 ) / 2 = 1.56944..<br>( 1.56944..+ 2/1.56944..) / 2 = 1.42189..<br>( 1.42189..+ 2/1.42189..) / 2 = 1.41423..<br>这种算法的原理很简单，我们仅仅是不断用(x,f(x))的切线来逼近方程x^2-a=0的根。根号a实际上就是x^2-a=0的一个正实根，这个函数的导数是2x。<br>也就是说，函数上任一点(x,f(x))处的切线斜率是2x。那么，x-f(x)/(2x)就是一个比x更接近的近似值。代入f(x)=x^2-a得到x-(x^2-<br>a)/(2x)，也就是(x+a/x)/2。</p></blockquote><pre><code>const float EPS = 1e-5;   int sqrt(double x) {       if(x == 0) return 0;       double result = x; /*Use double to avoid possible overflow*/       double lastValue;       do{           lastValue = result;           result = result / 2.0f + x / 2.0f / result;       }while(abs(result - lastValue) &gt; EPS);   return (double)result;   }  </code></pre><h4 id="更牛逼的一种开跟方式-快的一笔"><a href="#更牛逼的一种开跟方式-快的一笔" class="headerlink" title="更牛逼的一种开跟方式 快的一笔"></a>更牛逼的一种开跟方式 快的一笔</h4><pre><code>/**来自雷神之锤III的源代码中q_math.c的文件中。*/float Q_rsqrt( float number ) {       long i; float x2, y; const float threehalfs = 1.5F;      x2 = number * 0.5F;       y = number;       i = * ( long * ) &amp;y; // evil floating point bit level hacking       i = 0x5f3759df - ( i &gt;&gt; 1 ); // what the fuck?       y = * ( float * ) &amp;i;       y = y * ( threehalfs - ( x2 * y * y ) ); // 1st iteration       // y = y * ( threehalfs - ( x2 * y * y ) ); // 2nd iteration, this can be removed      #ifndef Q3_VM #      ifdef __linux__ assert( !isnan(y) ); // bk010122 - FPE?      #endif      #endif return y;   }  //整理得到int sqrt(float x) {       if(x == 0) return 0;       float result = x;       float xhalf = 0.5f*result;       int i = *(int*)&amp;result;       i = 0x5f375a86- (i&gt;&gt;1); // what the fuck?       result = *(float*)&amp;i;       result = result*(1.5f-xhalf*result*result); // Newton step, repeating increases accuracy       result = result*(1.5f-xhalf*result*result);       return 1.0f/result;   }  </code></pre><p>O  (  n  )  预处理逆元</p><pre><code>方法一  i的逆元inv[1] = 1;   for (int i = 2; i&lt;MAXN; i++)      inv[i] = inv[MOD%i]*(MOD-MOD/i)%MOD;  方法二  inv{(n-i)!} = inv(n!)*n    //阶乘逆元Fac[0] = 1;for (int i = 1; i &lt; N; i++) Fac[i] = (Fac[i-1] * i) % MOD;Inv[N-1] = pow_mod(Fac[N-1], MOD-2);//Fac[N]^{MOD-2}for (int i = N - 2; i &gt;= 0; i--) Inv[i] = Inv[i+1] * (i + 1) % MOD;方法三  费马小定理fac[0]=1;for(int i=1;i&lt;N;i++)fac[i]=fac[i-1]*i%MOD;for(int i=1;i&lt;N;i++)inv[i]=qmod(fac[i],MOD-2);</code></pre><h1 id="数学概念"><a href="#数学概念" class="headerlink" title="数学概念"></a>数学概念</h1><h2 id="素数"><a href="#素数" class="headerlink" title="素数"></a>素数</h2><pre><code>不赘述</code></pre><h2 id="反素数"><a href="#反素数" class="headerlink" title="反素数"></a>反素数</h2><h2 id="原根"><a href="#原根" class="headerlink" title="原根"></a>原根</h2><p><strong> 定义 </strong> ：设  m  &gt; 1  ，  gcd  (  a  ,  m  )  =  1  ，使得  a  r  ≡  (  mod  m  )  成立的最小的  r  ，称为  a  对模  m  的阶，记为。  δ  m  (  a  ) </p><p><strong> 定理 </strong> ：如果模  m  有原根，那么它一共有个  φ  (  φ  (  m  )  )  原根。 </p><p><strong> 定理 </strong> ：若  m  &gt; 1  ，  gcd  (  a  ,  m  )  =  1  ，  a  n  ≡  (  mod  m  )  则  δ  m  (  a  )  |  n  。 </p><p><strong> 定理 </strong> ：如果  p  为素数，那么素数  p  一定存在原根，并且模  p  的原根的个数为  φ  (  p  −  1  )  。 </p><p><strong> 定理 </strong> ：设  m  是正整数，  a  是整数，若  a  模  m  的阶等于  φ  (  m  )  ，则称  a  为模  m  的一个原根。 </p><p>假设一个数  g  对于模  m  来说是原根，那么  g  i  mod  p  的结果两两不同,且有  1  &lt; g  &lt; p  ，  0  ≤  i<br>&lt; p  那么  g  可以称为是模  p  的一个原根，归根到底就是  g  p  −  1  ≡  (  mod  p  )  当且仅当指数为  p<br>−  1  的时候成立。（这里是素数）</p><p>模  m  有原根的充要条件：  m  =  2  ,  4  ,  p  a  ,  2  p  a  ，其中  p  是奇素数。</p><p>求模素数  P  原根的方法：对  p  −  1  素因子分解，即  p  −  1  =  p  a  1  1  p  a  2  2  .  .<br>.  p  a  k  k  是的标准分解式，若恒有<br>g  p  −  1  p  i  ≠  1  (  mod  p  )</p><p>成立，则  g  就是  p  的原根。（对于合数求原根，只需把  p  −  1  换成  φ  (  p  )  即可）</p><p><a href="http://blog.csdn.net/zhang20072844/article/details/11541133" target="_blank" rel="noopener"> 求解原根的优化方法 </a></p><p>求解原根的完整代码</p><pre><code>如果mod 为素数int get(int mod) {    for(int i = 2; ; i++) {        set&lt;int&gt; s;        for(int j = 1, x = 1; j &lt; mod; j++) {            x = (x*i)%mod;            s.insert(x);        }        if(s.size() == mod-1) return i;    }}----------------------------------------------------------------//注意爆int，所以用LLLL qmod(LL a,LL b,LL c){    LL res = 1;a%=c;    while(b){        if(b&amp;1) res=res*a%c;        b&gt;&gt;=1,a=a*a%c;    }    return res;}int prime[N];int Is_or[N][2];void Prime(){    int n = 100000;    prime[0]=0;    memset(Is_or,1,sizeof(Is_or));    for(int i=2;i&lt;=n;i++){        if(Is_or[i][0]) prime[++prime[0]]=i,Is_or[i][1]=prime[0];        for(int j=1;j&lt;=prime[0]&amp;&amp;i*prime[j]&lt;=n;j++){            Is_or[i*prime[j]][0]=0;            if(0==i%prime[j]) break;        }    }    return ;}int Phi(int x){    //因为本题中数据都是质数，所以欧拉函数值就都是x-1了。    return x-1;}int a[10000],cnt;void divide(int n){    cnt = 0;    for(int i=1;prime[i]*prime[i]&lt;=n;i++){        if(n&lt;=prime[prime[0]]&amp;&amp;Is_or[n][0]){a[++cnt]=n;n=1;break;}        if(n%prime[i]==0){a[++cnt]=prime[i];n/=prime[i];}        while(n%prime[i]==0){n/=prime[i];}    }    if(n&gt;1)a[++cnt]=n;    return;}void work(int n){    int phi = Phi(n);    bool flag ;    for(int i=2;i&lt;n;i++){ //一个数的原根是很小的 所以暴力枚举就行,但其实是有优化方法的,        flag = true;        for(int j=1;j&lt;=cnt;j++){            int tmp = phi/a[j];            if(qmod(i,tmp,n)==1){                flag = false;                break;            }        }        if(flag){            printf(&quot;%d\n&quot;,i);            return ;        }    }    puts(&quot;没有原根&quot;);}int main(){    Prime();    int n;    while(~scanf(&quot;%d&quot;,&amp;n)){        divide(Phi(n));        work(n);    }    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  组合数学各种小定理</title>
      <link href="/2016/05/22/51476199/"/>
      <url>/2016/05/22/51476199/</url>
      
        <content type="html"><![CDATA[<h1 id="组合数学各种小定理"><a href="#组合数学各种小定理" class="headerlink" title="组合数学各种小定理"></a>组合数学各种小定理</h1><p>置顶  2016年05月22日 18:11:12  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a><br>阅读数：1262</p><hr><p> 博客爬取于<code>2019-04-18 17:15:16</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/51476199" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/51476199</a></p><p>//转自: <a href="http://www.oschina.net/code/snippet_203297_11313" target="_blank" rel="noopener"> http://www.oschina.net/code/snippet_203297_11313</a></p><h1 id="组合数"><a href="#组合数" class="headerlink" title="组合数"></a>组合数</h1><p><a href="http://blog.csdn.net/skywalkert/article/details/52553048" target="_blank" rel="noopener"> 组合数求模 </a><br><a href="http://picks.logdown.com/posts/245545-binomial-coefficient-modulo-prime" target="_blank" rel="noopener"> 组合数求模 </a><br>问题：求解组合数C(n,m)，即从n个相同物品中取出m个的方案数，由于结果可能非常大，对结果模10007即可。</p><p>方案1: 暴力求解，C(n,m)=n<em>(n-1) _ … _ (n-m+1)/m!，n&lt;=15<br>方案2: 打表，C(n,m)=C(n-1,m-1)+C(n-1,m)，n&lt;=1,000<br>方案3: 质因数分解，C(n,m)=n!/(m!</em>(n-m)!)，C(n,m)=p1a1-b1-c1p2a2-b2-c2…pkak-bk-<br>ck,n&lt;=10,000,000<br>方案4: Lucas定理，将m,n化为p进制,有:C(n,m)=C(n0,m0)*C(n1,m1)…(mod<br>p)，算一个不是很大的C(n,m)%p,p为素数，化为线性同余方程,用扩展的欧几里德定理求解，n在int范围内，修改一下可以满足long long范围内。</p><h3 id="方案1"><a href="#方案1" class="headerlink" title="方案1"></a>方案1</h3><pre><code>int Combination(int n, int m){    const int M = 10007;    int ans = 1;    for(int i=n; i&gt;=(n-m+1); --i)        ans *= i;    while(m)        ans /= m--;    return ans % M;}</code></pre><h3 id="方案2"><a href="#方案2" class="headerlink" title="方案2"></a>方案2</h3><pre><code>const int M = 10007;const int MAXN = 1000;int C[MAXN+1][MAXN+1];void Initial(){    int i,j;    for(i=0; i&lt;=MAXN; ++i)    {        C[0][i] = 0;        C[i][0] = 1;    }    for(i=1; i&lt;=MAXN; ++i)    {        for(j=1; j&lt;=MAXN; ++j)        C[i][j] = (C[i-1][j] + C[i-1][j-1]) % M;    }}int Combination(int n, int m){    return C[n][m];}</code></pre><h3 id="方案3"><a href="#方案3" class="headerlink" title="方案3"></a>方案3</h3><pre><code>//用筛法生成素数const int MAXN = 1000000;bool arr[MAXN+1] = {false};vector&lt;int&gt; produce_prim_number(){    vector&lt;int&gt; prim;    prim.push_back(2);    int i,j;    for(i=3; i*i&lt;=MAXN; i+=2)    {        if(!arr[i])        {            prim.push_back(i);            for(j=i*i; j&lt;=MAXN; j+=i)            arr[j] = true;        }    }    while(i&lt;=MAXN)    {        if(!arr[i])        prim.push_back(i);        i+=2;    }    return prim;}//计算n!中素因子p的指数int Cal(int x, int p){    int ans = 0;    long long rec = p;    while(x&gt;=rec)    {        ans += x/rec;        rec *= p;    }    return ans;}//计算n的k次方对M取模，二分法int Pow(long long n, int k, int M){    long long ans = 1;    while(k)    {        if(k&amp;1)        {            ans = (ans * n) % M;        }        n = (n * n) % M;        k &gt;&gt;= 1;    }    return ans;}//计算C(n,m)int Combination(int n, int m){    const int M = 10007;    vector&lt;int&gt; prim = produce_prim_number();    long long ans = 1;    int num;    for(int i=0; i&lt;prim.size() &amp;&amp; prim[i]&lt;=n; ++i)    {        num = Cal(n, prim[i]) - Cal(m, prim[i]) - Cal(n-m, prim[i]);        ans = (ans * Pow(prim[i], num, M)) % M;    }    return ans;}</code></pre><h3 id="方案4"><a href="#方案4" class="headerlink" title="方案4"></a>方案4</h3><pre><code>#include &lt;stdio.h&gt;const int M = 10007;int ff[M+5];  //打表，记录n!，避免重复计算//求最大公因数int gcd(int a,int b){    if(b==0)        return a;    else        return gcd(b,a%b);}//解线性同余方程，扩展欧几里德定理int x,y;void Extended_gcd(int a,int b){    if(b==0)    {       x=1;       y=0;    }    else    {       Extended_gcd(b,a%b);       long t=x;       x=y;       y=t-(a/b)*y;    }}//计算不大的C(n,m)int C(int a,int b){    if(b&gt;a)    return 0;    b=(ff[a-b]*ff[b])%M;    a=ff[a];    int c=gcd(a,b);    a/=c;    b/=c;    Extended_gcd(b,M);    x=(x+M)%M;    x=(x*a)%M;    return x;}//Lucas定理int Combination(int n, int m){    int ans=1;    int a,b;    while(m||n)    {             a=n%M;        b=m%M;        n/=M;        m/=M;        ans=(ans*C(a,b))%M;    }    return ans;}int main(void){    int i,m,n;    ff[0]=1;    for(i=1;i&lt;=M;i++)  //预计算n!    ff[i]=(ff[i-1]*i)%M;    scanf(&quot;%d%d&quot;,&amp;n, &amp;m);    printf(&quot;%d\n&quot;,func(n,m));    return 0;}</code></pre><h1 id="容斥原理"><a href="#容斥原理" class="headerlink" title="容斥原理"></a>容斥原理</h1><p><a href="http://www.cppblog.com/vici/archive/2011/09/05/155103.html" target="_blank" rel="noopener"> 容斥原理 </a></p><p><a href="https://vjudge.net/contest/84342#overview" target="_blank" rel="noopener"> 容斥原理+莫比乌斯反演 练习题目 </a></p><pre><code>LL solve (LL n, LL r){    vector&lt;int&gt; p;    for (int  i=2; i*i&lt;=n; ++i)        if (n % i == 0)        {            p.push_back (i);            while (n % i == 0)                n /= i;        }    if (n &gt; 1)  p.push_back (n);    LL sum = 0;    for (int msk=1; msk&lt;(1&lt;&lt;p.size()); ++msk)    {        LL mult = 1,            bits = 0;        for (int i=0; i&lt;(LL)p.size(); ++i)            if (msk &amp; (1&lt;&lt;i))            {                ++bits;                mult *= p[i];            }        LL cur = r / mult;        if (bits % 2 == 1)            sum += cur;        else            sum -= cur;    }    return r - sum;}/*****************************************//**容斥原理过程**/LL per;void dfs(LL a,LL b,LL c)//a在数组中的起始位置，b含的个数，c公共质因子的个数{    if(b==c)    {        LL t=m;        for(int i=0;i&lt;c;i++) t/=s[i];        per+=qmod(t,n,1);        //per+=balabala; 这里就是求选取这么多个元素的情况数有多少种    }    else    {        for(int i=a;i&lt;total;i++)        {            s[b]=num[i];            dfs(i+1,b+1,c);        }    }}LL DeMorgan(){    LL ans = 0;//看具体情况    for(int i=1;i&lt;=total;i++)    {        per=0;        dfs(0,0,i);        if(i&amp;1) ans-=per;        else    ans+=per;    }    return ans;}</code></pre><h1 id="莫比乌斯反演"><a href="#莫比乌斯反演" class="headerlink" title="莫比乌斯反演"></a>莫比乌斯反演</h1><p><a href="http://blog.csdn.net/acdreamers/article/details/8542292" target="_blank" rel="noopener"> 讲义 </a><br><a href="http://www.docin.com/p-687551303.html" target="_blank" rel="noopener"> 贾教的线性筛&lt;-很有帮助 </a><br><a href="http://www.cnblogs.com/femsub/p/5723780.html" target="_blank" rel="noopener"> 非常实用的莫比乌斯反演小节 </a></p><blockquote><p>设  f  为  算  术  函  数  ,  f  的  和  函  数  F  为  F  (  n  )  =  ∑  d  |  n  f  (<br>d  )  ,  它  是  依  据  f  的  值  决  定  的  .  是  否  存  在  一  种  用  F  求  f  的  简<br>单  方  法  ?  这  就  是  <strong> 莫比乌斯反演公式 </strong></p></blockquote><p>莫比乌斯函数</p><p>μ  (  n  )  =  ⎧  ⎩  ⎨  ⎪  ⎪  1  (  −  1  )  r  0  ,  n  =  1  ,  n  =  p  1<br>∗  p  2  ∗  .  .  .  ∗  p  r  ,  o  t  h  e  r</p><p>莫比乌斯函数是一个 <strong> 乘性函数 </strong></p><p>莫比乌斯函数的和函数  F  (  n  )  =  ∑  d  |  n  μ  (  d  )  满足<br>F  (  n  )  =  ∑  d  |  n  μ  (  d  )  =  {  1  0  ,  n  =  1  ,  n  &gt; 1</p><p><strong> 莫比乌斯反演公式 </strong><br>对于  f  与  其  和  函  数  F  (  F  (  n  )  =  ∑  d  |  n  f  (  d  )  )<br>形式一：  f  (  n  )  =  ∑  d  |  n  μ  (  d  )  F  (  n  /  d  )<br>形式二：  f  (  n  )  =  ∑  n  |  d  μ  (  d  /  n  )  F  (  d  )</p><p>注意有这样的两种形式,</p><hr><pre><code>int mobius(int n){    int m = 1;    for(int i=2;i*i&lt;=n;i++){        if(n%i==0){            m*=-1;            int k = 0;            n/=i;            if(n%i==0) {m=0;break;}//某个素因子的幂大于1        }    }    if(n&gt;1) m *= -1;    return m;}/*******************************************/线性筛法预处理mobius函数int prime[N],kp;int Is_or[N],mu[N];void Prime(){    int x;    mu[1]=1;    memset(Is_or,true,sizeof(Is_or));    for(int i=2;i&lt;=n;i++){        if(Is_or[i]) prime[kp++]=i,mu[i]=-1;        for(int j=0;j&lt;kp&amp;&amp;i*prime[j]&lt;=n;j++){            x = i*prime[j];            Is_or[x]=false;            if(0==i%prime[j]) break;            mu[x] = -mu[i];        }    }    return ;}</code></pre><h1 id="一些特殊的数"><a href="#一些特殊的数" class="headerlink" title="一些特殊的数"></a>一些特殊的数</h1><h2 id="卡特兰数"><a href="#卡特兰数" class="headerlink" title="卡特兰数"></a>卡特兰数</h2><h2 id="stirling数"><a href="#stirling数" class="headerlink" title="stirling数"></a>stirling数</h2><h2 id="默慈金数"><a href="#默慈金数" class="headerlink" title="默慈金数"></a>默慈金数</h2><p><a href="http://blog.csdn.net/acdreamers/article/details/41213667" target="_blank" rel="noopener"> Acdream的介绍贴 </a></p><blockquote><p>就是从(0,0)到(n,0)中 只能向左/左上/左下走的方案数<br>(x,y)其中y&gt;0</p></blockquote><p>两种公式<br><img src="https://img-blog.csdn.net/20141117193030984" alt></p><p><img src="https://img-blog.csdn.net/20141118104730235" alt></p><h2 id="那罗延数"><a href="#那罗延数" class="headerlink" title="那罗延数"></a>那罗延数</h2>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  百度之星 初赛2 瞬间转移 [杨辉三角]</title>
      <link href="/2016/05/22/51476184/"/>
      <url>/2016/05/22/51476184/</url>
      
        <content type="html"><![CDATA[<h1 id="百度之星-初赛2-瞬间转移-杨辉三角"><a href="#百度之星-初赛2-瞬间转移-杨辉三角" class="headerlink" title="百度之星 初赛2 瞬间转移 [杨辉三角]"></a>百度之星 初赛2 瞬间转移 [杨辉三角]</h1><p>2016年05月22日 18:08:16  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：514<br>标签：  <a href="https://so.csdn.net/so/search/s.do?q=百度之星&amp;t=blog" target="_blank" rel="noopener"> 百度之星 </a> <a href="https://so.csdn.net/so/search/s.do?q=思维&amp;t=blog" target="_blank" rel="noopener"> 思维</a> <a href="https://so.csdn.net/so/search/s.do?q=HDU-5698&amp;t=blog" target="_blank" rel="noopener"> HDU-5698</a></p><p>个人分类：  <a href="https://blog.csdn.net/qq_33184171/article/category/6117382" target="_blank" rel="noopener"> hdu </a> <a href="https://blog.csdn.net/qq_33184171/article/category/6132246" target="_blank" rel="noopener"><br>bestcoder </a></p><hr><p> 博客爬取于<code>2019-04-18 17:20:42</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/51476184" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/51476184</a></p><p>传送阵： <a href="http://acm.hdu.edu.cn/showproblem.php?pid=5698" target="_blank" rel="noopener"> http://acm.hdu.edu.cn/showproblem.php?pid=5698</a></p><p>瞬间移动</p><p>Time Limit: 4000/2000 MS (Java/Others) Memory Limit: 65536/65536 K<br>(Java/Others)<br>Total Submission(s): 128 Accepted Submission(s): 61</p><p>Problem Description<br>有一个无限大的矩形，初始时你在左上角（即第一行第一列），每次你都可以选择一个右下方格子，并瞬移过去（如从下图中的红色格子能直接瞬移到蓝色格子），求到第n行第<br>m列的格子有几种方案，答案对1000000007取模。</p><p><img src="http://acm.hdu.edu.cn/data/images/C702-1003-1.jpg" alt="http://acm.hdu.edu.cn/data/images/C702-1003-1.jpg"></p><p>Input<br>多组测试数据。</p><p>两个整数n,m(2≤n,m≤100000)</p><p>Output<br>一个整数表示答案</p><p>Sample Input<br>4 5</p><p>Sample Output<br>10</p><p>Source<br>2016”百度之星” - 初赛（Astar Round2B）</p><h2 id="————————————————————————–"><a href="#————————————————————————–" class="headerlink" title="————————————————————————–"></a>————————————————————————–</h2><p>其实写了写就是一个杨辉三角，只不过行变换了一下</p><p>杨辉三角是一个由数字排列成的三角形数表,一般形式如下：<br>1 n=0<br>1 1 n=1<br>1 2 1 n=2<br>1 3 3 1 n=3<br>1 4 6 4 1 n=4<br>1 5 10 10 5 1 n=5<br>1 6 15 20 15 6 1 n=6<br>……<br>特征<br>与二项式定理的关系：杨辉三角的第n行就是二项式 展开式的系数列.<br>对称性：杨辉三角中的数字左、右对称,对称轴是杨辉三角形底边上的“高”.<br>结构特征：杨辉三角除斜边上1以外的各数,都等于它“肩上”的两数之和.<br>这些数排列的形状像等腰三角形,两腰上的数都是1.<br>从右往左斜着看,从左往右斜着看,和前面的看法一样,这个数列是左右对称的.<br>上面两个数之和就是下面的一行的数.<br>这行数是第几行,就是第二个数加一.</p><p>而在本题中 是这样的、<br>1 1 1 1 1 1 1<br>1 2 3 4 5 6<br>1 3 6 10 15<br>1 4 10 20<br>1 5 15<br>1 6<br>1</p><p>看了看其实就是行变了 列并没有变<br>把它改一下 行变成行加列-1 即可；</p><p>最后的最后直接贴上求组合数的模板AC…..</p><p>附本题AC 代码</p><p>方案1 <strong> 187ms </strong></p><h2 id="————————————————————"><a href="#————————————————————" class="headerlink" title="————————————————————-"></a>————————————————————-</h2><pre><code>#include &lt;iostream&gt;#include &lt;string.h&gt;#include &lt;algorithm&gt;#include &lt;math.h&gt;#include &lt;vector&gt;#include &lt;stdio.h&gt;using namespace std;const int MOD = 1e9+7;const int MAXN = 1000000;bool arr[MAXN+100] = {false};vector&lt;int&gt; produce_prim_number(){    vector&lt;int&gt; prim;    prim.push_back(2);    int i,j;    for(i=3; i*i&lt;=MAXN; i+=2)    {        if(!arr[i])        {            prim.push_back(i);            for(j=i*i; j&lt;=MAXN; j+=i)            arr[j] = true;        }    }    while(i&lt;=MAXN)    {        if(!arr[i])        prim.push_back(i);        i+=2;    }    return prim;}//计算n!中素因子p的指数int Cal(int x, int p){    int ans = 0;    long long rec = p;    while(x&gt;=rec)    {        ans += x/rec;        rec *= p;    }    return ans;}//计算n的k次方对M取模，二分法int Pow(long long n, int k, int MOD){    long long ans = 1;    while(k)    {        if(k&amp;1)        {            ans = (ans * n) % MOD;        }        n = (n * n) % MOD;        k &gt;&gt;= 1;    }    return ans;}//计算C(n,m)int Combination(int n, int m){    vector&lt;int&gt; prim = produce_prim_number();    long long ans = 1;    int num;    for(int i=0; i&lt;prim.size() &amp;&amp; prim[i]&lt;=n; ++i)    {        num = Cal(n, prim[i]) - Cal(m, prim[i]) - Cal(n-m, prim[i]);        ans = (ans * Pow(prim[i], num, MOD)) % MOD;    }    return ans;}int main(){    int n,m;    while(~scanf(&quot;%d%d&quot;,&amp;n,&amp;m))    {        n=m+n-2;        printf(&quot;%d\n&quot;,Combination(n-2,m-2));    }    return 0;}</code></pre><p>方案 2 31ms</p><pre><code>#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;cstring&gt;using namespace std;#define lld  __int64lld  n, m, p;lld Ext_gcd(lld a,lld b,lld &amp;x,lld &amp;y){   if(b==0) { x=1, y=0; return a; }   lld ret= Ext_gcd(b,a%b,y,x);   y-= a/b*x;   return ret;}lld Inv(lld a,int m)   ///求逆元{   lld d,x,y,t= (lld)m;   d= Ext_gcd(a,t,x,y);   if(d==1) return (x%t+t)%t;   return -1;}lld Cm(lld n, lld m, lld p)  ///组合数学{    lld a=1, b=1;    if(m&gt;n) return 0;    while(m)    {        a=(a*n)%p;        b=(b*m)%p;        m--;        n--;    }    return (lld)a*Inv(b,p)%p;  ///（a/b）%p 等价于 a*（b，p）的逆元}int Lucas(lld n, lld m, lld p)  ///把n分段递归求解相乘{    if(m==0) return 1;    return (lld)Cm(n%p,m%p,p)*(lld)Lucas(n/p,m/p,p)%p;}int main(){    int  T;    while(~scanf(&quot;%I64d%I64d&quot;,&amp;n,&amp;m))    {        n--,m--;        m--;        __int64 p=1000000007;        printf(&quot;%d\n&quot;,Lucas(n+m-1,m,p));    }    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hdu </tag>
            
            <tag> bestcoder </tag>
            
            <tag> 思维 </tag>
            
            <tag> 百度之星 </tag>
            
            <tag> HDU-5698 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  Codeforces</title>
      <link href="/2016/05/18/51447994/"/>
      <url>/2016/05/18/51447994/</url>
      
        <content type="html"><![CDATA[<h1 id="Codeforces-353-div-2-Infinite-Sequence-amp-Restoring-Painting-amp-Money"><a href="#Codeforces-353-div-2-Infinite-Sequence-amp-Restoring-Painting-amp-Money" class="headerlink" title="Codeforces #353 div.2 Infinite Sequence&amp;Restoring Painting&amp;Money"></a>Codeforces #353 div.2 Infinite Sequence&amp;Restoring Painting&amp;Money</h1><p>Transfers前三题题解</p><p>2016年05月18日 21:59:54  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：509<br>标签：  <a href="https://so.csdn.net/so/search/s.do?q=codeforces&amp;t=blog" target="_blank" rel="noopener"> codeforces </a></p><p>个人分类：  <a href="https://blog.csdn.net/qq_33184171/article/category/6235560" target="_blank" rel="noopener"> codeforces</a></p><hr><p> 博客爬取于<code>2019-04-18 17:20:43</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/51447994" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/51447994</a></p><p>题目链接：<br>A : <a href="http://codeforces.com/problemset/problem/675/A" target="_blank" rel="noopener"> http://codeforces.com/problemset/problem/675/A</a><br>B : <a href="http://codeforces.com/problemset/problem/675/B" target="_blank" rel="noopener"> http://codeforces.com/problemset/problem/675/B</a><br>C : <a href="http://codeforces.com/problemset/problem/675/C" target="_blank" rel="noopener"> http://codeforces.com/problemset/problem/675/C</a></p><h2 id="A"><a href="#A" class="headerlink" title="A"></a>A</h2><h2 id="———————————————–"><a href="#———————————————–" class="headerlink" title="———————————————–"></a>———————————————–</h2><p>A. Infinite Sequence<br>time limit per test1 second<br>memory limit per test256 megabytes<br>inputstandard input<br>outputstandard output<br>Vasya likes everything infinite. Now he is studying the properties of a<br>sequence s, such that its first element is equal to a (s1 = a), and the<br>difference between any two neighbouring elements is equal to c (si - si - 1 =<br>c). In particular, Vasya wonders if his favourite integer b appears in this<br>sequence, that is, there exists a positive integer i, such that si = b. Of<br>course, you are the person he asks for a help.</p><p>Input<br>The first line of the input contain three integers a, b and c ( - 109 ≤ a, b,<br>c ≤ 109) — the first element of the sequence, Vasya’s favorite number and the<br>difference between any two neighbouring elements of the sequence,<br>respectively.</p><p>Output<br>If b appears in the sequence s print “YES” (without quotes), otherwise print<br>“NO” (without quotes).</p><p>Examples</p><p>input<br>1 7 3<br>output<br>YES</p><p>input<br>10 10 0<br>output<br>YES</p><p>input<br>1 -4 5<br>output<br>NO</p><p>input<br>0 60 50<br>output<br>NO</p><p>Note<br>In the first sample, the sequence starts from integers 1, 4, 7, so 7 is its<br>element.</p><p>In the second sample, the favorite integer of Vasya is equal to the first<br>element of the sequence.</p><p>In the third sample all elements of the sequence are greater than Vasya’s<br>favorite integer.</p><p>In the fourth sample, the sequence starts from 0, 50, 100, and all the<br>following elements are greater than Vasya’s favorite integer.</p><p>题目大意 ： 就是有一个等差数列 给你首元素与公差 再给你一个数 判断其在不在等差数列上</p><p>题目很简单</p><p>判断（b-a）mod C == 0 ？</p><p>注意的是C&lt;0 与C = 0 的情况稍加判断即可</p><p>直接上代码</p><h2 id="————–"><a href="#————–" class="headerlink" title="————–"></a>————–</h2><p>​    </p><pre><code>#include &lt;stdio.h&gt;#define _LL __int64int main(){    _LL a,b,c;    scanf(&quot;%I64d%I64d%I64d&quot;,&amp;a,&amp;b,&amp;c);    int flag=0;    if(c&lt;0)    {        a=-a,b=-b,c=-c;    }    if(a==b)  flag=1;    if(c!=0&amp;&amp;a&lt;b&amp;&amp;(b-a)%c==0)        flag=1;    if(flag)    printf(&quot;YES\n&quot;);    else        printf(&quot;NO\n&quot;);    return 0;}</code></pre><h2 id="B"><a href="#B" class="headerlink" title="B"></a>B</h2><h2 id="———————————————————————"><a href="#———————————————————————" class="headerlink" title="———————————————————————-"></a>———————————————————————-</h2><p>B. Restoring Painting<br>time limit per test1 second<br>memory limit per test256 megabytes<br>inputstandard input<br>outputstandard output<br>Vasya works as a watchman in the gallery. Unfortunately, one of the most<br>expensive paintings was stolen while he was on duty. He doesn’t want to be<br>fired, so he has to quickly restore the painting. He remembers some facts<br>about it.</p><p>The painting is a square 3 × 3, each cell contains a single integer from 1 to<br>n, and different cells may contain either different or equal integers.<br>The sum of integers in each of four squares 2 × 2 is equal to the sum of<br>integers in the top left square 2 × 2.<br>Four elements a, b, c and d are known and are located as shown on the picture<br>below.<br><img src="http://codeforces.com/predownloaded/46/58/46581d6f30e08c273666bf75dee6c4c9d79f0c8b.png" alt="这里写图片描述"><br>Help Vasya find out the number of distinct squares the satisfy all the<br>conditions above. Note, that this number may be equal to 0, meaning Vasya<br>remembers something wrong.</p><p>Two squares are considered to be different, if there exists a cell that<br>contains two different integers in different squares.</p><p>Input<br>The first line of the input contains five integers n, a, b, c and d (1 ≤ n ≤<br>100 000, 1 ≤ a, b, c, d ≤ n) — maximum possible value of an integer in the<br>cell and four integers that Vasya remembers.</p><p>Output<br>Print one integer — the number of distinct valid squares.</p><p>Examples<br>input<br>2 1 1 1 2<br>output<br>2<br>input<br>3 3 1 2 3<br>output<br>6<br>Note<br>Below are all the possible paintings for the first sample.<br><img src="http://codeforces.com/predownloaded/1d/40/1d40107f8ec7111e3e92ccf3727bdd75b472f9ea.png" alt="这里写图片描述"><br><img src="http://codeforces.com/predownloaded/3b/8b/3b8b94fa091fd035fe8d1e17d7ecdec5f7056d77.png" alt="这里写图片描述"><br>In the second sample, only paintings displayed below satisfy all the rules.<br><img src="http://codeforces.com/predownloaded/8a/e5/8ae5e327fcc31a4e42b1b6a0a63364f79677ff63.png" alt="这里写图片描述"><br><img src="http://codeforces.com/predownloaded/57/bc/57bc7758744dceb9ce05834202d4caab3a48c5c4.png" alt="这里写图片描述"><br><img src="http://codeforces.com/predownloaded/5d/e5/5de5691ec1ffe257089086c2eb27df372817a588.png" alt="这里写图片描述"><br><img src="http://codeforces.com/predownloaded/09/67/0967e8cdcf119b021ada92081611437f27ec70d2.png" alt="这里写图片描述"><br><img src="http://codeforces.com/predownloaded/87/cc/87cc8e5acf56acd63b6bbfb621369e1f3c188eb1.png" alt="这里写图片描述"><br><img src="http://codeforces.com/predownloaded/09/f7/09f713688090db1e4d08070e42e14ff4c5acdb96.png" alt="这里写图片描述"></p><p>题目大意 : 给你一个九宫格 其中四个角和中间的数是未知的<br>给定你一个数 n 和其他四个数a,b,c,d<br>问在四个角和中间的格子上填上1~n中的数 (可以重复填入)<br>使得四个2x2的格子数的和相等的填法有多少种</p><p>解题思路 ：</p><p>Tables  Are  Cool</p><p>x1</p><p>a</p><p>x2</p><p>b</p><p>??</p><p>c</p><p>x3</p><p>d</p><p>x4</p><p>2x2的情况为<br>1: x1+a+b+??<br>2: x2+a+c+??<br>3: x3+d+b+??<br>4: x4+c+d+??<br>显然中间的？？ 填什么多可以 即有n中填法</p><p>同时也能得到<br>当任意x值确定的时候 其他值也就确定了</p><p>假定当 x1,x2,x3,x4满足题意的时候<br>x1+1,x2+1,x3+1,x4+1 也满足题意 （当中最大值&lt;=n）</p><p>这个时候我们只要枚举一下<br>a+b, b+d,d+c,a+c的最大值 这时候其对应的x值为1</p><p>结果即为<br>count（maxX~n) * n;</p><p>附本题代码</p><h2 id="——————————————————————————"><a href="#——————————————————————————" class="headerlink" title="——————————————————————————-"></a>——————————————————————————-</h2><p>​    </p><pre><code>#include &lt;stdio.h&gt;#define _LL __int64int main(){    int n,a,c,b,d;    scanf(&quot;%d%d%d%d%d&quot;,&amp;n,&amp;a,&amp;b,&amp;c,&amp;d);    _LL sum=1;    int maxi=-11,m;    int x1=-1,x2=-1,x3=-1,x4=-1;    if(a+b&gt;=max(max(a+c,c+d),d+b))    {        x1=1;        m=a+b+1;        x2=m-a-c;        x3=m-b-d;        x4=m-c-d;    }    if(a+c&gt;=max(max(a+b,c+d),d+b))    {        x2=1;        m=a+c+1;        x1=m-a-b;        x3=m-b-d;        x4=m-c-d;    }    if(d+b&gt;=max(max(a+c,c+d),a+b))    {        x3=1;        m=d+b+1;        x1=m-a-b;        x2=m-a-c;        x4=m-c-d;    }    if(c+d&gt;=max(max(a+c,a+b),d+b))    {        x4=1;        m=c+d+1;        x1=m-a-b;        x2=m-a-c;        x3=m-b-d;    }  //  printf(&quot;%d %d %d %d\n&quot;,x1,x2,x3,x4);    if(a+b+x1==a+c+x2&amp;&amp;a+b+x1==b+d+x3&amp;&amp;a+b+x1==d+c+x4)    {        maxi=max(max(x1,x2),max(x3,x4));        if(maxi&lt;=n)            printf(&quot;%I64d\n&quot;,sum*(n-maxi+1)*n);        else            printf(&quot;0\n&quot;);    }    else        printf(&quot;0\n&quot;);    return 0;}</code></pre><h2 id="C"><a href="#C" class="headerlink" title="C"></a>C</h2><h2 id="—————————————————————————————————————————–"><a href="#—————————————————————————————————————————–" class="headerlink" title="—————————————————————————————————————————–"></a>—————————————————————————————————————————–</h2><p>C. Money Transfers<br>time limit per test1 second<br>memory limit per test256 megabytes<br>inputstandard input<br>outputstandard output<br>There are n banks in the city where Vasya lives, they are located in a circle,<br>such that any two banks are neighbouring if their indices differ by no more<br>than 1. Also, bank 1 and bank n are neighbours if n &gt; 1. No bank is a<br>neighbour of itself.</p><p>Vasya has an account in each bank. Its balance may be negative, meaning Vasya<br>owes some money to this bank.</p><p>There is only one type of operations available: transfer some amount of money<br>from any bank to account in any neighbouring bank. There are no restrictions<br>on the size of the sum being transferred or balance requirements to perform<br>this operation.</p><p>Vasya doesn’t like to deal with large numbers, so he asks you to determine the<br>minimum number of operations required to change the balance of each bank<br>account to zero. It’s guaranteed, that this is possible to achieve, that is,<br>the total balance of Vasya in all banks is equal to zero.</p><p>Input<br>The first line of the input contains a single integer n (1 ≤ n ≤ 100 000) —<br>the number of banks.</p><p>The second line contains n integers ai ( - 109 ≤ ai ≤ 109), the i-th of them<br>is equal to the initial balance of the account in the i-th bank. It’s<br>guaranteed that the sum of all ai is equal to 0.</p><p>Output<br>Print the minimum number of operations required to change balance in each bank<br>to zero.</p><p>Examples</p><p>input<br>3<br>5 0 -5<br>output<br>1</p><p>input<br>4<br>-1 0 1 0<br>output<br>2</p><p>input<br>4<br>1 2 3 -6<br>output<br>3</p><p>Note<br>In the first sample, Vasya may transfer 5 from the first bank to the third.</p><p>In the second sample, Vasya may first transfer 1 from the third bank to the<br>second, and then 1 from the second to the first.</p><p>In the third sample, the following sequence provides the optimal answer:</p><p>transfer 1 from the first bank to the second bank;<br>transfer 3 from the second bank to the third;<br>transfer 6 from the third bank to the fourth.</p><p>题目大意 : 就是一圈银行 有的银行缺钱 有的银行的钱有富余 你要把富余出来的前取走 存到缺钱的银行里 银行是围城一个圈的<br>问你身上揣钱的走过的路有多少<br>两个邻近的银行中有一条道<br>（略带意淫的翻译）</p><p>解题思路：<br>借鉴: <a href="http://blog.csdn.net/yukizzz/article/details/51437984" target="_blank" rel="noopener"> http://blog.csdn.net/yukizzz/article/details/51437984</a><br>把这些分成尽可能多的和为0的区间<br>每个区间走过的路即为区间元素个数-1;<br>这里用了map 否则数组开不了那么大<br>（区间和为0的充要条件是区间两端点的前缀和相等即mp[si] == mp[sj]）那么这道题就做出来了<br>附本题代码</p><h2 id="—————————"><a href="#—————————" class="headerlink" title="—————————"></a>—————————</h2><p>​    </p><pre><code>#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;string&gt;#include &lt;math.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;using namespace std;/*********************INPUT*************************/#define s2l(a,b)   scanf(&quot;%d%d&quot;,&amp;a,&amp;b)#define s2_l(a,b)  scanf(&quot;%I64d%I64d&quot;,&amp;a,&amp;b)#define s1l(a)     scanf(&quot;%d&quot;,&amp;a)/*********************OUTPUT*************************/#define pr1l(a)    printf(&quot;%d&quot;,a);#define pr1_l(a)   printf(&quot;%I64d&quot;,a);#define pr1ll(a)   printf(&quot;%lld&quot;,a);#define space      printf(&quot; &quot;);#define line       printf(&quot;\n&quot;);/*****************type-num***********************/#define LL long long int#define _LL __int64/****************************************/#define fr(a,b,c)  for(int a=b;a&lt;c;a++)#define del(a,b)   memset(b,a,sizeof(b));#define Rep(a,n)   for(int a=1;a&lt;n;a++)#define Rop(a,n)   for(int a=1;a&lt;n;a++)const int mod = 7;const _LL MOD = 1e9 + mod;const int MAX = 1e5+50;const int MIN = 1e2+50;map&lt;LL, int&gt;m;int main(void){    int n;    s1l(n);    int ans = 0;    LL tot = 0;    int qwer;    for(int i = 0; i &lt; n; i++)    {        s1l(qwer);        tot += qwer;        m[tot]++;        ans = max(ans, m[tot]);    }    printf(&quot;%d&quot;, n - ans);   return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> codeforces </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  HDU 5596 GTW likes gt 倒推</title>
      <link href="/2016/05/16/51426587/"/>
      <url>/2016/05/16/51426587/</url>
      
        <content type="html"><![CDATA[<h1 id="HDU-5596-GTW-likes-gt-倒推"><a href="#HDU-5596-GTW-likes-gt-倒推" class="headerlink" title="HDU 5596 GTW likes gt 倒推"></a>HDU 5596 GTW likes gt 倒推</h1><p>2016年05月16日 17:15:07  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：229<br>标签：  <a href="https://so.csdn.net/so/search/s.do?q=HDU&amp;t=blog" target="_blank" rel="noopener"> HDU </a> <a href="https://so.csdn.net/so/search/s.do?q=思维&amp;t=blog" target="_blank" rel="noopener"> 思维</a> <a href="https://so.csdn.net/so/search/s.do?q=bestcoder&amp;t=blog" target="_blank" rel="noopener"> bestcoder</a></p><p>个人分类：  <a href="https://blog.csdn.net/qq_33184171/article/category/6132246" target="_blank" rel="noopener"> bestcoder</a> <a href="https://blog.csdn.net/qq_33184171/article/category/6117382" target="_blank" rel="noopener"> hdu</a></p><hr><p> 博客爬取于<code>2019-04-18 17:20:45</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/51426587" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/51426587</a></p><p>题目链接：</p><h2 id="————————————————"><a href="#————————————————" class="headerlink" title="————————————————"></a>————————————————</h2><p>GTW likes gt Accepts: 54 Submissions: 782<br>Time Limit: 2000/1000 MS (Java/Others) Memory Limit: 131072/131072 K<br>(Java/Others)<br>问题描述<br>从前，有  n  只萌萌的GT，他们分成了两组在一起玩游戏。他们会排列成一排，第  i  只GT会随机得到一个能力值  b  i  。在第  i<br>秒的时候，第  i  只GT可以消灭掉所有排在他前面的和他不是同一组的且能力值小于他的GT。<br>为了使游戏更加有趣，GT的首领GTW会发功  m  次，第  i  次发功的时间为  c  i  ，则在第  c  i  ​  ​  秒结束后，  b  1<br>,  b  2  ,  .  .  .  ,  b  c  i  ​​ 都会增加1。<br>现在，GTW想知道在第  n  秒之后，会有几只GT存活下来。<br>输入描述<br>第一行只有一个整数  T  (  T  ≤  5  )  ，表示测试数据组数。<br>第二行有两个整数  n  ,  m  。表示GT的个数和GTW发功的次数。  (  1  ≤  n  ≤  50000  ,  1  ≤  m  ≤<br>50000  )<br>第三到  n  +  2  行，每行有两个整数  a  i  ,  b  i  ，表示第ii只GT在哪个组和他的能力值  (  0  ≤  a  [  i<br>]  ≤  1  ,  1  ≤  b  [  i  ]  ≤  10  6  )  第  n  +  3  行到第  n  +  m  +  2<br>行，每行有一个整数  c  i  ​​ ,表示GTW第ii次发功的时间。  1  ≤  c  [  i  ]  ≤  n<br>输出描述<br>总共  T  行，第  i  行表示第  i  组数据中，GT存活的个数。</p><p>输入样例</p><p>1<br>4 3<br>0 3<br>1 2<br>0 3<br>1 1<br>1<br>3<br>4<br>输出样例<br>3</p><p>HINT<br>第1秒后 能力值为4 2 3 1<br>第2秒后 能力值为4 2 3 1<br>第3秒后 能力值为5 3 4 1，第2只GT被第3只GT消灭掉了<br>第4秒后 能力值为6 4 5 2<br>c[i] 并不是有序的</p><h2 id="———————————————–"><a href="#———————————————–" class="headerlink" title="———————————————–"></a>———————————————–</h2><p>题目大意 : 详见中闻题面</p><p>题解：</p><p>本题求解的是最后还剩下多少 , 也就是求有多少被灭了;</p><p>在第i秒的时候i能把编号0~i-1的小于他的全灭了<br>如果每次到第i秒的时候在从前向后遍历一遍的话 必定会超时<br>所以换个角度<br>如果编号i被灭了 也就是说后面有比他大且是另外一组的<br>所以从后面遍历即可</p><p>根据c[i]的遍历就能计算出b[i]在i秒时的值 这时候看后面有没有比他大的且是另外一组的<br>所以<br>倒序遍历 维护两个最大值即可</p><p>附本题代码</p><h2 id="————————"><a href="#————————" class="headerlink" title="————————"></a>————————</h2><pre><code>#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;string&gt;#include &lt;math.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;using namespace std;int a[50050];int b[50050];int c[50050];int cmp(int a,int b){    return a&gt;b;}int main(){    int t;    scanf(&quot;%d&quot;,&amp;t);    while(t--)    {        memset(a,0,sizeof(a));        memset(b,0,sizeof(b));        memset(c,0,sizeof(c));        int n,m;        scanf(&quot;%d%d&quot;,&amp;n,&amp;m);        for(int i=1; i&lt;=n; i++)        {            scanf(&quot;%d %d&quot;,&amp;a[i],&amp;b[i]);        }        int x;        for(int i=1;i&lt;=m;i++)        {            scanf(&quot;%d&quot;,&amp;x);            c[x]++;        }        int sum=n,num=0,jia=0,maxi[2]={-1};        for(int i=n;i&gt;=1;i--)        {            jia+=c[i];            b[i]+=jia;            maxi[a[i]]=max(maxi[a[i]],b[i]);            if(b[i]&lt;maxi[a[i]^1])                sum--;        }        printf(&quot;%d\n&quot;,sum);    }    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hdu </tag>
            
            <tag> HDU </tag>
            
            <tag> bestcoder </tag>
            
            <tag> 思维 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  HDU 5606 tree BestCoder Round</title>
      <link href="/2016/04/29/51284402/"/>
      <url>/2016/04/29/51284402/</url>
      
        <content type="html"><![CDATA[<h1 id="HDU-5606-tree-BestCoder-Round-68-div-2-思维-【数学】"><a href="#HDU-5606-tree-BestCoder-Round-68-div-2-思维-【数学】" class="headerlink" title="HDU 5606 tree BestCoder Round #68 (div.2) [思维]【数学】"></a>HDU 5606 tree BestCoder Round #68 (div.2) [思维]【数学】</h1><p>2016年04月29日 21:34:59  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：271<br>标签：  <a href="https://so.csdn.net/so/search/s.do?q=数学&amp;t=blog" target="_blank" rel="noopener"> 数学 </a> <a href="https://so.csdn.net/so/search/s.do?q=HDU&amp;t=blog" target="_blank" rel="noopener"> HDU</a> <a href="https://so.csdn.net/so/search/s.do?q=思维&amp;t=blog" target="_blank" rel="noopener"> 思维</a> <a href="https://so.csdn.net/so/search/s.do?q=bestcoder&amp;t=blog" target="_blank" rel="noopener"> bestcoder</a> <a href="https://so.csdn.net/so/search/s.do?q=hdu-5606&amp;t=blog" target="_blank" rel="noopener"> hdu-5606</a></p><p>个人分类：  <a href="https://blog.csdn.net/qq_33184171/article/category/6117382" target="_blank" rel="noopener"> hdu </a> <a href="https://blog.csdn.net/qq_33184171/article/category/6162724" target="_blank" rel="noopener"><br>数学 </a> <a href="https://blog.csdn.net/qq_33184171/article/category/6132246" target="_blank" rel="noopener"> bestcoder</a></p><hr><p> 博客爬取于<code>2019-04-18 17:20:46</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/51284402" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/51284402</a></p><p>题目链接 ： <a href="http://acm.hdu.edu.cn/showproblem.php?pid=5606" target="_blank" rel="noopener"> http://acm.hdu.edu.cn/showproblem.php?pid=5606</a></p><h2 id="—————————————————————————————————————————"><a href="#—————————————————————————————————————————" class="headerlink" title="—————————————————————————————————————————-"></a>—————————————————————————————————————————-</h2><p>tree Accepts: 143 Submissions: 807<br>Time Limit: 2000/1000 MS (Java/Others) Memory Limit: 65536/65536 K<br>(Java/Others)<br>问题描述<br>有一个树(nn个点, n-1n−1条边的联通图),点标号从11~nn,树的边权是00或11.求离每个点最近的点个数(包括自己).<br>输入描述<br>第一行一个数字TT,表示TT组数据.<br>对于每组数据,第一行是一个nn,表示点个数,接下来n-1n−1,每行三个整数u,v,wu,v,w,表示一条边连接的两个点和边权.<br>T = 50,1 &lt;= n &lt;= 100000, 1 &lt;= u,v &lt;=n,0 &lt;= w &lt;=<br>1T=50,1≤n≤100000,1≤u,v≤n,0≤w≤1.<br>输出描述<br>对于每组数据,输出答案.<br>考虑到输出规模过大,设ans_ians<br>​i<br>​​ 表示第ii个点的答案.你只需输出ans_1 ^ ans_2 ^ ans_3^ans_nans</p><p>​1<br>​​ xor ans<br>​2<br>​​ xor ans<br>​3<br>​​ .. xor ans<br>​n<br>​​ 即可.<br>输入样例<br>1<br>3<br>1 2 0<br>2 3 1</p><p>输出样例<br>1</p><p>Hint<br>ans_1 = 2ans<br>​1<br>​​ =2<br>ans_2 = 2ans<br>​2<br>​​ =2<br>ans_3 = 1ans<br>​3<br>​​ =1<br>2 \ xor \ 2 \ xor \ 1=12 xor 2 xor 1=1, 因此输出11.</p><h2 id="——————————————————————————–"><a href="#——————————————————————————–" class="headerlink" title="——————————————————————————–"></a>——————————————————————————–</h2><p>题目大意 ： 如题 中文体面。。。。</p><p>解题思路 ： 题目说 找到每个点离自己最近的点的个数 而且 <strong> 还包括自己 </strong> 自己与自己的距离 就是0 没有疑议<br>所以就找到与自己距离为0的点的个数即可</p><p>但是数据达到了10^6 如果两层for的话必定会超时 所以不可以暴力解</p><p>这时思考 一个点与其距离为0的点的个数和 是对每一个点都成立的<br>比如说 点1 点2 点3 互相距离为0<br>所以ans1=3 ans2=3 ans3=3；<br>就是有几个点 他们有的ans值都相同<br>这样之求解出这些点的一个的ans值就行<br>然后在求解出ans个ans的自身异或 值<br>Ps： ans个ans的自身异或 值<br>很简单 只要判断ans的奇偶即可 ans为偶数 那么异或的结果为0 ans为奇数 异或值即为ans本身</p><p>在这里 我求解这些互相距离为0的点 采用的是并查集 把距离相同且为0 的点归为统一集合<br>之后在遍历一遍 记录每个集合的个数（即ans）即可 、</p><p>然后再把这些ans值互相异或即可</p><p>附本题代码</p><h2 id="————————————————————————"><a href="#————————————————————————" class="headerlink" title="————————————————————————"></a>————————————————————————</h2><pre><code>#include &lt;iostream&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;vector&gt;#include  &lt;math.h&gt;#define EPS 1e-8#define MAXN 30#define MAXM 31using namespace std;int pre[100005];int   b[100005];int fin(int x){    int r=x;    while(r!=pre[r])        r=pre[r];    int i=x,j;    while(i!=j)    {        j=pre[i];        pre[i]=r;        i=j;    }    return r;}int join(int x,int y){    int fx=fin(x),fy=fin(y);    if(fx!=fy)        pre[fy]=fx;}int solve(int x){    if(x%2==0)        return 0;    else        return x;}int main(){    int t ;    scanf(&quot;%d&quot;,&amp;t);    while(t--)    {        memset(b,0,sizeof(b));        int n;        scanf(&quot;%d&quot;,&amp;n);        for(int i=1; i&lt;=n; i++)            pre[i]=i;        int u,v,w;        for(int i=1; i&lt;n; i++)        {            scanf(&quot;%d%d%d&quot;,&amp;u,&amp;v,&amp;w);            if(!w)    join(u,v);        }        for(int i=1;i&lt;=n;i++)        {            b[pre[i]]++;        }        int flag=0,sum=0;        for(int i=1;i&lt;=n;i++)        {          //printf(&quot;%d--&gt;%d\n&quot;,i,b[i]);            if(b[i])                sum^=solve(b[i]);        }        printf(&quot;%d/n&quot;,sum);    }    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hdu </tag>
            
            <tag> HDU </tag>
            
            <tag> bestcoder </tag>
            
            <tag> 数学 </tag>
            
            <tag> 思维 </tag>
            
            <tag> hdu-5606 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>&lt;转&gt;#  POJ 2635 The Embarrassed Cryptographer [高精度求余+同余模定理]【数论】</title>
      <link href="/2016/04/29/51281788/"/>
      <url>/2016/04/29/51281788/</url>
      
        <content type="html"><![CDATA[<h1 id="POJ-2635-The-Embarrassed-Cryptographer-高精度求余-同余模定理-【数论】"><a href="#POJ-2635-The-Embarrassed-Cryptographer-高精度求余-同余模定理-【数论】" class="headerlink" title="POJ 2635 The Embarrassed Cryptographer [高精度求余+同余模定理]【数论】"></a>POJ 2635 The Embarrassed Cryptographer [高精度求余+同余模定理]【数论】</h1><p>2016年04月29日 14:45:29  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：353</p><hr><p> 博客爬取于<code>2019-04-18 17:20:46</code><br><strong><em>以下为正文</em></strong></p><p>ACMer与Coder的交流分享地</p><p>POJ2635-The Embarrassed Cryptographer</p><p>转载请注明出处：優YoU <a href="http://user.qzone.qq.com/289065406/blog/1309305108" target="_blank" rel="noopener"> http://user.qzone.qq.com/289065406/blog/1309305108</a></p><p>大致题意：</p><p>给定一个大数K，K是两个大素数的乘积的值。</p><p>再给定一个int内的数L</p><p>问这两个大素数中最小的一个是否小于L，如果小于则输出这个素数。</p><p>解题思路：</p><p>首先对题目的插图表示无语。。。</p><p>高精度求模+同余模定理</p><p>1、 Char格式读入K。把K转成千进制Kt，同时变为int型。</p><p>把数字往大进制转换能够加快运算效率。若用十进制则耗费很多时间，会TLE。</p><p>千进制的性质与十进制相似。</p><p>例如，把K=1234567890转成千进制，就变成了：Kt=[ 1][234][567][890]。</p><p>为了方便处理，我的程序是按“局部有序，全局倒序”模式存放Kt</p><p>即Kt=[890][567][234][1 ] (一个中括号代表一个数组元素)</p><p>2、 素数打表，把10^6内的素数全部预打表，在求模时则枚举到小于L为止。</p><p>注意打表不能只打到100W，要保证素数表中最大的素数必须大于10^6，否则当L=100W且K为GOOD时，会因为数组越界而RE，这是因为越界后prime都是<br>负无穷的数，枚举的while(prime[pMin]</p><pre><code>//Memory Time//624K  1235MS #include&lt;iostream&gt;#include&lt;string.h&gt;using namespace std;const int Range=1000100;  //打表不能只打到100W，素数表中最大的素数必须大于10^6int Kt[10000];  //千进制的Kint L;int prime[Range+1];/*素数组打表*/void PrimeTable(void){    int pNum=0;    prime[pNum++]=2;    for(int i=3;i&lt;=Range;i+=2)  //奇偶法    {        bool flag=true;        for(int j=0;prime[j]*prime[j]&lt;=i;j++)  //根号法+递归法            if(!(i%prime[j]))            {                flag=false;                break;            }        if(flag)            prime[pNum++]=i;    }    return;}/*高精度K对p求模，因数检查(整除)*/bool mod(const int* K,const int p,const int len){    int sq=0;    for(int i=len-1;i&gt;=0;i--)  //千进制K是逆序存放        sq=(sq*1000+K[i])%p;  //同余模定理    if(!sq)   //K被整除        return false;    return true;}int main(void){    PrimeTable();    char K[10000];    while(cin&gt;&gt;K&gt;&gt;L &amp;&amp; L)    {        memset(Kt,0,sizeof(Kt));        int lenK=strlen(K);        for(int i=0;i&lt;lenK;i++)  //把K转换为千进制Kt，其中Kt局部顺序，全局倒序        {                      //如K=1234567=[  1][234][567] ，则Kt=[567][234][1  ]            int pKt=(lenK+2-i)/3-1;            Kt[pKt]=Kt[pKt]*10+(K[i]-&#39;0&#39;);        }        int lenKt=(lenK+2)/3;        bool flag=true;        int pMin=0;  //能整除K且比L小的在prime中的最小素数下标        while(prime[pMin]&lt;L)  //枚举prime中比L小的素数        {            if(!mod(Kt,prime[pMin],lenKt))            {                flag=false;                cout&lt;&lt;&quot;BAD &quot;&lt;&lt;prime[pMin]&lt;&lt;endl;                break;            }            pMin++;        }        if(flag)            cout&lt;&lt;&quot;GOOD&quot;&lt;&lt;endl;    }    return 0;}</code></pre><p>按 Ctrl+C 复制代码</p><p>Sample Input</p><p>143 10<br>143 20<br>667 20<br>667 30<br>2573 30<br>2573 40<br>4 2<br>6 3<br>6 3<br>15 3<br>999999999999999999999999999999999999999999999999999999999999999999999999999999<br>9999999999999999536689 2<br>999999999999999999999999999999999999999999999999999999999999999999999999999999<br>9999999999999999536689 3<br>999999999999999999999999999999999999999999999999999999999999999999999999999999<br>9999999999999999536689 999981<br>999999999999999999999999999999999999999999999999999999999999999999999999999999<br>9999999999999999536689 999982<br>999999999999999999999999999999999999999999999999999999999999999999999999999999<br>9999999999999999536689 999983<br>999999999999999999999999999999999999999999999999999999999999999999999999999999<br>9999999999999999536689 999984<br>999999999999999999999999999999999999999999999999999999999999999999999999999999<br>9999999999999999536689 999985<br>993679883662170633590376636660502119975612757543890714468984337176411499837284<br>9970522970722679648297 1000000<br>999999999999999999999999999999999999999999999999999999999999999999999999999999<br>9999999999999924165887 1000000<br>999999999999999999770934147751292827073351575011149429680769321740159266001317<br>6273247584305454312971 1000000<br>999999999998888124508737926454038403035854452036077325262817469091559003407893<br>4845096473005364364269 1000000<br>999999999999999999999999999999999999999999999999999999999999999999999794771088<br>6296926452585995644787 1000000<br>999999999999999999999999999999999999999999999999999999999999999999999999999999<br>9999999999998743929569 1000000<br>999999999999999999999999999999999999999999999999999999999999999999999999640687<br>6316697599258447653751 1000000<br>999999999999999999999999999999999999999999999999999999999999999999999999999999<br>9999999999999995271511 1000000<br>999966451500620575794457242249569594263345267840539358121696678281609713250952<br>6872495414067984894021 1000000<br>0 0</p><p>Sample Output</p><p>GOOD<br>BAD 11<br>GOOD<br>BAD 23<br>GOOD<br>BAD 31<br>GOOD<br>BAD 2<br>BAD 2<br>GOOD<br>GOOD<br>GOOD<br>GOOD<br>GOOD<br>GOOD<br>BAD 999983<br>BAD 999983<br>BAD 587<br>BAD 100043<br>GOOD<br>GOOD<br>GOOD<br>GOOD<br>GOOD<br>BAD 16603<br>BAD 9103</p>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  ZOJ 3872 Beauty of Array 第12届浙江省省赛D题 [思维] 【数学】</title>
      <link href="/2016/04/19/51184895/"/>
      <url>/2016/04/19/51184895/</url>
      
        <content type="html"><![CDATA[<h1 id="ZOJ-3872-Beauty-of-Array-第12届浙江省省赛D题-思维-【数学】"><a href="#ZOJ-3872-Beauty-of-Array-第12届浙江省省赛D题-思维-【数学】" class="headerlink" title="ZOJ 3872 Beauty of Array 第12届浙江省省赛D题 [思维] 【数学】"></a>ZOJ 3872 Beauty of Array 第12届浙江省省赛D题 [思维] 【数学】</h1><p>2016年04月19日 00:23:29  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：506</p><hr><p> 博客爬取于<code>2019-04-18 17:20:48</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/51184895" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/51184895</a></p><p>题目链接 : <a href="http://acm.zju.edu.cn/onlinejudge/showProblem.do?problemCode=3872" target="_blank" rel="noopener"> http://acm.zju.edu.cn/onlinejudge/showProblem.do?problemCode=3872</a></p><p>Beauty of Array</p><hr><p>Time Limit: 2 Seconds Memory Limit: 65536 KB</p><hr><p>Edward has an array A with N integers. He defines the beauty of an array as<br>the summation of all distinct integers in the array. Now Edward wants to know<br>the summation of the beauty of all contiguous subarray of the array A.</p><p>Input<br>There are multiple test cases. The first line of input contains an integer T<br>indicating the number of test cases. For each test case:</p><p>The first line contains an integer N (1 &lt;= N &lt;= 100000), which indicates the<br>size of the array. The next line contains N positive integers separated by<br>spaces. Every integer is no larger than 1000000.</p><p>Output<br>For each case, print the answer in one line.</p><p>Sample Input<br>3<br>5<br>1 2 3 4 5<br>3<br>2 3 3<br>4<br>2 3 3 2</p><p>Sample Output<br>105<br>21<br>38</p><hr><p>题目大意 :<br>给出一个N大小的数组，寻找一些这个数组的子集的和，<br>举个例子吧</p><p>1 2 3 4 5</p><p>1<br>1 2<br>1 2 3<br>1 2 3 4<br>1 2 3 4 5<br>_ 2<br>_ 2 3<br>_ 2 3 4<br>_ 2 3 4 5<br>_ _ 3<br>_ _ 3 4<br>_ _ 3 4 5<br>_ _ _ 4<br>_ _ _ 4 5<br>_ _ _ _ 5</p><p>举例子的话 很形象了 就不再解释了</p><p>计算这些数组的和 （包括最开始输入的几个数）<br>如果 在每一个子集 中如果有重复出现的数则只加一遍；</p><p>数据非常大 10^6 暴力一定会超时</p><p>本题的主要思路就是 输入一个数 就把这个数包括之前的数新产生的符合题意的子集的和加入</p><p>如<br>输入1时 1<br>子集为<br>1</p><p>输入2时 1 2<br>新增子集为<br>1 2<br>_ 2<br>输入3时 1 2 3<br>新增子集为<br>1 2 3<br>_ 2 3<br>_ _ 3<br>输入4时 1 2 3 4<br>新增子集为<br>1 2 3 4<br>_ 2 3 4<br>_ _ 3 4<br>_ _ _ 4<br>输入5时 1 2 3 4 5<br>新增子集为<br>1 2 3 4 5<br>_ 2 3 4 5<br>_ _ 3 4 5<br>_ _ _ 4 5<br>_ _ _ _ 5</p><p>综合一下就是<br>1 2 3 4 5<br>1<br>1 2<br>1 2 3<br>1 2 3 4<br>1 2 3 4 5<br>_ 2<br>_ 2 3<br>_ 2 3 4<br>_ 2 3 4 5<br>_ _ 3<br>_ _ 3 4<br>_ _ 3 4 5<br>_ _ _ 4<br>_ _ _ 4 5<br>_ _ _ _ 5</p><p>以上是没有出现重复的情况<br>每次新增子集为前一种情况的每个新增子集加入这个元素<br>用一个数存上这些数的和即可</p><p>出现重复情况其实也很好理解</p><p>假定此时已经输入 1 2 3 4<br>在输入3时<br>新增子集为<br>1 2 3 4 3<br>_ 2 3 4 3<br>_ _ 3 4 3<br>_ _ _ 4 3<br>_ _ _ _ 3<br>因为之前已经出现过 3 所以新加入的子集中3就不需要再重复的加了;<br>而怎么判断子集中有没有与新输入元素重复的元素呢</p><p>观察<br>1 2 3 4 3<br>_ 2 3 4 3<br>_ _ 3 4 3<br>_ _ _ 4 3<br>_ _ _ _ 3</p><p>不难发现前三个新增子集已经有过3<br>但是后两个子集并没有3<br>其实想一想，如果输入顺序为1 3 2 4 3的话<br>新增子集为<br>1 3 2 4 3<br>_ 3 2 4 3<br>_ _ 2 4 3<br>_ _ _ 4 3<br>_ _ _ _ 3</p><p>这时前2个新增子集有过3<br>后3个子集并没有3<br>如果在换个顺序 又会发生变化 ；<br>而我们计算的时候把新增子集的和记录下来<br>之后再把多加的数值减去就行<br>不难发现只要与新加入元素相同的元素 在第几次输入 就会有几个子集存在元素重复<br>这是用一个数组吧这个数存在的位置记录一下就行</p><p>但是如果有多个重复的情况呢；<br>即输入为3 2 3 4 3<br>这时新增子集为<br>3 2 3 4 3<br>_ 2 3 4 3<br>_ _ 3 4 3<br>_ _ _ 4 3<br>_ _ _ _ 3</p><p>发现重复总是以除新输入元素之外最后输入的相同元素判断的；<br>所以每次更新一下元素出现位置即可；</p><p>用sum来存储总共的和<br>用ans来存储新增子集的和<br>这是如果出现相同时<br>ans- = 输入元素 * 未更新的位置；<br>就是新增元素的和</p><p>综上所述<br>本题的思路就完全出来了<br>看似本文叙述非常多，其实都是思维的过程，实际操作起来非常快的。</p><h2 id="附本题代码"><a href="#附本题代码" class="headerlink" title="附本题代码:"></a>附本题代码:</h2><p>-</p><pre><code>#include &lt;iostream&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;using namespace std;int bb[1000005];int main(){    int t,n,x;    scanf(&quot;%d&quot;,&amp;t);    while(t--)    {        memset(bb,0,sizeof(bb));        scanf(&quot;%d&quot;,&amp;n);        long long int sum=0,ans=0;        for(long long int i=1; i&lt;=n; i++)        {            scanf(&quot;%d&quot;,&amp;x);            ans+=(i*x);            sum+=ans;            sum-=bb[x]*x;            ans-=bb[x]*x;            bb[x]=i;        }        printf(&quot;%lld\n&quot;,sum);    }    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  ZOJ 3870 Team Formation 第12届浙江省省赛B题 [位运算+思维]【数学】</title>
      <link href="/2016/04/18/51183322/"/>
      <url>/2016/04/18/51183322/</url>
      
        <content type="html"><![CDATA[<h1 id="ZOJ-3870-Team-Formation-第12届浙江省省赛B题-位运算-思维-【数学】"><a href="#ZOJ-3870-Team-Formation-第12届浙江省省赛B题-位运算-思维-【数学】" class="headerlink" title="ZOJ 3870 Team Formation 第12届浙江省省赛B题 [位运算+思维]【数学】"></a>ZOJ 3870 Team Formation 第12届浙江省省赛B题 [位运算+思维]【数学】</h1><p>2016年04月18日 22:51:32  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：579</p><hr><p> 博客爬取于<code>2019-04-18 17:20:49</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/51183322" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/51183322</a></p><p>题目链接 ： <a href="http://acm.zju.edu.cn/onlinejudge/showProblem.do?problemCode=3870" target="_blank" rel="noopener"> http://acm.zju.edu.cn/onlinejudge/showProblem.do?problemCode=3870</a></p><p>Team Formation</p><hr><p>Time Limit: 3 Seconds Memory Limit: 131072 KB</p><hr><p>For an upcoming programming contest, Edward, the headmaster of Marjar<br>University, is forming a two-man team from N students of his university.</p><p>Edward knows the skill level of each student. He has found that if two<br>students with skill level A and B form a team, the skill level of the team<br>will be A ⊕ B, where ⊕ means bitwise exclusive or. A team will play well if<br>and only if the skill level of the team is greater than the skill level of<br>each team member (i.e. A ⊕ B &gt; max{A, B}).</p><p>Edward wants to form a team that will play well in the contest. Please tell<br>him the possible number of such teams. Two teams are considered different if<br>there is at least one different team member.</p><p>Input<br>There are multiple test cases. The first line of input contains an integer T<br>indicating the number of test cases. For each test case:</p><p>The first line contains an integer N (2 &lt;= N &lt;= 100000), which indicates the<br>number of student. The next line contains N positive integers separated by<br>spaces. The ith integer denotes the skill level of ith student. Every integer<br>will not exceed 109.</p><p>Output<br>For each case, print the answer in one line.</p><p>Sample Input<br>2<br>3<br>1 2 3<br>5<br>1 2 3 4 5</p><p>Sample Output<br>1<br>6</p><h2 id="——————————————————————————"><a href="#——————————————————————————" class="headerlink" title="——————————————————————————"></a>——————————————————————————</h2><p>题目大意 ： 就是给你N个数，找寻其中的两个数使得这两个数的异或值大于这两个数中的任意一个的情况数。</p><p>解题思路 :<br>正常的时候应该两两计算异或值判断，复杂度为O(n^2)，但是因为题目的数据量比较大为10^6，会超时所以不可行。<br>那怎么办呢，。<br>既然题目说的是异或，那么就是位运算，那么就在二进制上思考。<br>题目要的又是异或的值大于这两个值的每一个 也就是满足大于这两个数中大的一个即可 ， 那么就想一想仅在二进制下，两个数怎么比较大小。<br>我们知道二进制下的值 换算成10进制就是 2的整数次幂加和的形式<br>example：<br>x = 100001110（2） = 2^8+2^3+2^2+2^1；<br>y = 100011010（2） = 2^8+2^4+2^3+2^1；<br>看等式右边很容易就能得出 x &lt; y;<br>从最高位开始比较 如果相同就比较下一位,直到出现不同的情况 ,如果不同即一为0一为1 ,<br>则这位为1的大,这时候后面的位数怎样都不重要了,变化的这一位在数值上已经比后面的位数最大的情况还要大了,所以不需要考虑;</p><p>知道这些在异或<br>二进制下 同位运算 相异为1 (0^1/1^0) 相同为0 (1^1/0^0)</p><p>一个数在异或运算之后要比本身大,需要的是其与其异或运算的数在最高位(不计算前导0)的位上为0;<br>解释一下:<br>100001110<br>想要得到一个比它大的一个数只需要在它为0的任意1位上变为1即可(这时需要在这位的前面的任何一位都不改变,而后面的值则无所谓,前文已经解释)<br>所以另1个数的最高位在这个数为0的位上即可</p><p>明白了以上几点,本题就可以做了,<br>首先要把每个数的二进制上的为0的位数都记录下来(前导0不算)<br>在把每个数在二进制上的最高位的1（必为1）记录下来<br>比如说在二进制上的某一位 存在在这位上为0的数为n个，存在最高位在这位上的数为m个<br>则满足题目的结果就为n*m个；</p><p>而题目的数据为最大10^9 那么在二进制上就不超过int整型 既是32位;<br>所以只需要计算这32位的的情况的和即可</p><p>把每位的情况分别用两个数组来存就行</p><p>看下代码吧 很短 很好理解</p><h2 id="——————————————————"><a href="#——————————————————" class="headerlink" title="——————————————————"></a>——————————————————</h2><pre><code>#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;math.h&gt;#include&lt;string.h&gt;using namespace std;int a[40];int b[40];int main(){    int t,n,x,m,num;    scanf(&quot;%d&quot;,&amp;t);    while(t--)    {        memset(a,0,sizeof(a));        memset(b,0,sizeof(b));        scanf(&quot;%d&quot;,&amp;n);        for(int i=0;i&lt;n;i++)        {            scanf(&quot;%d&quot;,&amp;x);            num=0,m=0;            while(x)            {                if(x&amp;1)  m=num;                else     a[num]++;                num++;                x&gt;&gt;=1;            }            b[m]++;        }        long long int sum=0;        for(int i=0;i&lt;=32;i++)        {            sum+=a[i]*b[i];        }        printf(&quot;%lld\n&quot;,sum);    }    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  HDU 1233 又是畅通工程 [kruskal]+[prim]【最小生成树入门】</title>
      <link href="/2016/04/17/51174895/"/>
      <url>/2016/04/17/51174895/</url>
      
        <content type="html"><![CDATA[<h1 id="HDU-1233-又是畅通工程-kruskal-prim-【最小生成树入门】"><a href="#HDU-1233-又是畅通工程-kruskal-prim-【最小生成树入门】" class="headerlink" title="HDU 1233 又是畅通工程 [kruskal]+[prim]【最小生成树入门】"></a>HDU 1233 又是畅通工程 [kruskal]+[prim]【最小生成树入门】</h1><p>2016年04月17日 19:51:34  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：279<br>标签：  <a href="https://so.csdn.net/so/search/s.do?q=kruskal&amp;t=blog" target="_blank" rel="noopener"> kruskal </a> <a href="https://so.csdn.net/so/search/s.do?q=hdu&amp;t=blog" target="_blank" rel="noopener"> hdu</a> <a href="https://so.csdn.net/so/search/s.do?q=图论&amp;t=blog" target="_blank" rel="noopener"> 图论</a></p><p>个人分类：  <a href="https://blog.csdn.net/qq_33184171/article/category/6117382" target="_blank" rel="noopener"> hdu </a> <a href="https://blog.csdn.net/qq_33184171/article/category/6188704" target="_blank" rel="noopener"><br>===== 图论 ===== </a></p><hr><p> 博客爬取于<code>2019-04-18 17:20:50</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/51174895" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/51174895</a></p><p>题目链接 : <a href="http://acm.hdu.edu.cn/showproblem.php?pid=1233" target="_blank" rel="noopener"> http://acm.hdu.edu.cn/showproblem.php?pid=1233</a></p><p>还是畅通工程</p><p>Time Limit: 4000/2000 MS (Java/Others) Memory Limit: 65536/32768 K<br>(Java/Others)<br>Total Submission(s): 37241 Accepted Submission(s): 16762</p><p>Problem Description<br>某省调查乡村交通状况，得到的统计表中列出了任意两村庄间的距离。省政府“畅通工程”的目标是使全省任何两个村庄间都可以实现公路交通（但不一定有直接的公路相连，只<br>要能间接通过公路可达即可），并要求铺设的公路总长度为最小。请计算最小的公路总长度。</p><p>Input<br>测试输入包含若干测试用例。每个测试用例的第1行给出村庄数目N ( &lt; 100<br>)；随后的N(N-1)/2行对应村庄间的距离，每行给出一对正整数，分别是两个村庄的编号，以及此两村庄间的距离。为简单起见，村庄从1到N编号。<br>当N为0时，输入结束，该用例不被处理。</p><p>Output<br>对每个测试用例，在1行里输出最小的公路总长度。</p><p>Sample Input<br>3<br>1 2 1<br>1 3 2<br>2 3 4<br>4<br>1 2 1<br>1 3 4<br>1 4 1<br>2 3 3<br>2 4 2<br>3 4 5<br>0</p><p>Sample Output<br>3<br>5</p><p>Hint<br>Hint</p><p>Huge input, scanf is recommended.</p><h2 id="—————————————————————————————————"><a href="#—————————————————————————————————" class="headerlink" title="—————————————————————————————————-"></a>—————————————————————————————————-</h2><p>最简单的最小生成树 入门<br>就不赘述了<br>直接上代码</p><h2 id="——————————"><a href="#——————————" class="headerlink" title="——————————"></a>——————————</h2><p>kruskal</p><pre><code>#include &lt;iostream&gt;#include &lt;string.h&gt;#include &lt;stdio.h&gt;#include &lt;math.h&gt;#include &lt;algorithm&gt;using namespace std;int pre[1000];int n,m,mintree;struct node{    int a,b,l;} c[10200];void init(int n){    for(int i=1; i&lt;=n; i++)        pre[i]=i;    return ;}int findi(int x){    int r=x;    while(r!=pre[r])        r=pre[r];    int i=x,j;    while(i!=j)    {        j=pre[i];        pre[i]=r;        i=j;    }    return r;}int cmp(node a,node b){    return a.l&lt;b.l;}void kruskal(){    int fx,fy;    for(int i=0; i&lt;m; i++)    {        fx=findi(c[i].a),fy=findi(c[i].b);        if(fx!=fy)        {            mintree+=c[i].l;            pre[fy]=fx;        }    }    return ;}int main(){    while(~scanf(&quot;%d&quot;,&amp;n))    {        if(n==0) break;        init(n);        m=n*(n-1)/2;        mintree=0;        for(int i=0; i&lt;m; i++)        {            scanf(&quot;%d%d%d&quot;,&amp;c[i].a,&amp;c[i].b,&amp;c[i].l);        }        sort(c,c+m,cmp);        kruskal();        printf(&quot;%d\n&quot;,mintree);    }    return 0;}</code></pre><h2 id="——————–"><a href="#——————–" class="headerlink" title="——————–"></a>——————–</h2><p>prim</p><pre><code>#include &lt;iostream&gt;  #include&lt;stdio.h&gt;  #include&lt;string.h&gt;  #include&lt;math.h&gt;  const int N = 110;  const int INF = 0x7ffffff;  using namespace std;  int v[N],d[N],mp[N][N],n;  int prim()  {      for(int i=1;i&lt;=n;i++)    d[i]=INF,v[i]=0;      d[1]=0;      for(int i=0;i&lt;n;i++)      {          int mmin=INF,t;          for(int j=1;j&lt;=n;j++)              if(!v[j]&amp;&amp;mmin&gt;d[j])                  mmin=d[t=j];          v[t]=1;          for(int j=1;j&lt;=n;j++)              if(!v[j])                  d[j]=min(d[j],mp[t][j]);      }      int ans=0;      for(int i=1;i&lt;=n;i++)    ans+=d[i];      return ans;  }  int main()  {      while(~scanf(&quot;%d&quot;,&amp;n)&amp;&amp;n)      {          for(int i=1;i&lt;=n;i++)              for(int j=1;j&lt;=n;j++)                  mp[i][j]=INF;          int m=n*(n-1)/2;          for(int i=0;i&lt;m;i++)          {              int u,v,t;              scanf(&quot;%d%d%d&quot;,&amp;u,&amp;v,&amp;t);              if(mp[u][v]&gt;t)  mp[u][v]=mp[v][u]=t;          }          cout&lt;&lt;prim()&lt;&lt;endl;      }  } </code></pre>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hdu </tag>
            
            <tag> kruskal </tag>
            
            <tag> 图论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  POJ 2954 Triangle [PICK公式+GCD]【计算几何】</title>
      <link href="/2016/04/12/51132938/"/>
      <url>/2016/04/12/51132938/</url>
      
        <content type="html"><![CDATA[<h1 id="POJ-2954-Triangle-PICK公式-GCD-【计算几何】"><a href="#POJ-2954-Triangle-PICK公式-GCD-【计算几何】" class="headerlink" title="POJ 2954 Triangle [PICK公式+GCD]【计算几何】"></a>POJ 2954 Triangle [PICK公式+GCD]【计算几何】</h1><p>2016年04月12日 14:03:33  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：477</p><hr><p> 博客爬取于<code>2019-04-18 17:20:51</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/51132938" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/51132938</a></p><p>题目链接 ： <a href="http://poj.org/problem?id=2954" target="_blank" rel="noopener"> http://poj.org/problem?id=2954 </a></p><hr><p>Triangle<br>Time Limit: 1000MS Memory Limit: 65536K<br>Total Submissions: 5661 Accepted: 2439<br>Description</p><p>A lattice point is an ordered pair (x, y) where x and y are both integers.<br>Given the coordinates of the vertices of a triangle (which happen to be<br>lattice points), you are to count the number of lattice points which lie<br>completely inside of the triangle (points on the edges or vertices of the<br>triangle do not count).</p><p>Input</p><p>The input test file will contain multiple test cases. Each input test case<br>consists of six integers x1, y1, x2, y2, x3, and y3, where (x1, y1), (x2, y2),<br>and (x3, y3) are the coordinates of vertices of the triangle. All triangles in<br>the input will be non-degenerate (will have positive area), and −15000 ≤ x1,<br>y1, x2, y2, x3, y3 ≤ 15000. The end-of-file is marked by a test case with x1 =<br>y1 = x2 = y2 = x3 = y3 = 0 and should not be processed.</p><p>Output</p><p>For each input case, the program should print the number of internal lattice<br>points on a single line.</p><p>Sample Input</p><p>0 0 1 0 0 1<br>0 0 5 0 0 5<br>0 0 0 0 0 0<br>Sample Output</p><p>0<br>6</p><h2 id="——————————————————————————————————————–"><a href="#——————————————————————————————————————–" class="headerlink" title="——————————————————————————————————————–"></a>——————————————————————————————————————–</h2><p>题目大意 ：<br>在一个网格上有三个点，求这三个点围城的三角形内部有几个格点（恰好在三角形的边上的格点不算）。</p><p>题目思路：<br>涉及到格点了，很容易先到是PICK公式——S=a/2+b-1。<br>（Ps :不知道什么是PICK公式的点这里-&gt; <a href="http://blog.csdn.net/qq_33184171/article/details/51114511" target="_blank" rel="noopener"> 这里T_T这里</a> ）<br>这是一个PICK公式的逆运用来求b。<br>转换一下公式即可=&gt;b=(2S-a)/2+1。<br>本题中要先把每条边上的格点数求出来,其实很简单运用GCD(辗转相除法)即可。设每条边的向量为(x,y)-&gt;GCD(x,y)就是这条边上的格点个数-1,很好理<br>解,求得的结果是排除这条边的一个端点的. 而最大公约数实几就证明有几个格点在边上.也就是这个方向的向量中满足两端均在格点上的向量为(x,y)/GCD(x,y<br>),那么GCD(x,y)为几就说明有几个这样的 “单位” 向量.<br>明白了以上代码实心就好了,,,</p><h2 id="————————————————————————————————————————————————————————"><a href="#————————————————————————————————————————————————————————" class="headerlink" title="————————————————————————————————————————————————————————"></a>————————————————————————————————————————————————————————</h2><p>附本题代码</p><pre><code>#include&lt;iostream&gt;#include&lt;stdio.h&gt;#include&lt;math.h&gt;#include&lt;stdlib.h&gt;using namespace std;struct point{    int x, y;};int multi(point &amp;p1, point &amp;p2,point &amp;p3){    return (p2.x-p1.x)*(p3.y-p1.y)-(p3.x-p1.x)*(p2.y-p1.y);}int gcd(int x, int y){    if (x==0||y==0)  return max(x,y);    return gcd(y,x%y);}int pick(int area, int num){    return (area - num)/2 + 1;}int main(){    point one, two, three;    int x1, x2, x3, y1, y2, y3;    while (~scanf(&quot;%d%d%d%d%d%d&quot;,&amp;x1,&amp;y1,&amp;x2,&amp;y2,&amp;x3,&amp;y3))    {        if(x1==0&amp;&amp;x2==0&amp;&amp;x3==0&amp;&amp;y1==0&amp;&amp;y2==0&amp;&amp;y3==0)   break;        one.x = x1,one.y = y1,two.x = x2,two.y = y2,three.x = x3,three.y = y3;        int area=multi(one,two,three);        if (area&lt;0)  area=-area;        int num = gcd(abs(one.x - two.x),abs(one.y - two.y));        num += gcd(abs(two.x - three.x),abs(two.y - three.y));        num += gcd(abs(three.x - one.x),abs(three.y - one.y));        cout&lt;&lt;pick(area,num)&lt;&lt;endl;    }    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  【计算几何各种小模板总结贴】[不定期更新]</title>
      <link href="/2016/04/11/51124611/"/>
      <url>/2016/04/11/51124611/</url>
      
        <content type="html"><![CDATA[<h1 id="【计算几何各种小模板总结贴】-不定期更新"><a href="#【计算几何各种小模板总结贴】-不定期更新" class="headerlink" title="【计算几何各种小模板总结贴】[不定期更新]"></a>【计算几何各种小模板总结贴】[不定期更新]</h1><p>置顶  2016年04月11日 19:32:06  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a><br>阅读数：1465</p><hr><p> 博客爬取于<code>2019-04-18 17:15:17</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/51124611" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/51124611</a></p><p>相当全的计算几何模板<br><a href="http://paste.ubuntu.com/24458430/" target="_blank" rel="noopener"> http://paste.ubuntu.com/24458430/ </a></p><h2 id="精度控制"><a href="#精度控制" class="headerlink" title="精度控制"></a>精度控制</h2><p>Ps：尽量不要用除法，三角函数，强制类型转换等操作，否则精度损失比较大<br>const double PI = acos(-1.0);<br>const double EPS = 1e-8;<br><strong> 任何double的比较运算都要用eps </strong></p><h2 id="向量运算"><a href="#向量运算" class="headerlink" title="向量运算"></a>向量运算</h2><h4 id="二维空间"><a href="#二维空间" class="headerlink" title="二维空间"></a>二维空间</h4><h5 id="向量旋转矩阵"><a href="#向量旋转矩阵" class="headerlink" title="向量旋转矩阵"></a>向量旋转矩阵</h5><p>我们想将向量  x  ,  y  −  →  −  以  x  为轴点逆时针旋转，且旋转角为  α  ，<br>[  x  ′  y  ′  ]  =  [  cos  (  α  )  sin  (  α  )  −  sin  (  α  )  cos  (  α<br>)  ]  ×  [  x  y  ]</p><h5 id="叉积"><a href="#叉积" class="headerlink" title="叉积"></a>叉积</h5><pre><code>double mul(Point p1,Point p2,Point p0){    return((p1.x-p0.x)*(p2.y-p0.y)-(p2.x-p0.x)*(p1.y-p0.y));}</code></pre><h5 id="两点求距离"><a href="#两点求距离" class="headerlink" title="两点求距离"></a>两点求距离</h5><pre><code>double dis(Point p1,Point p2){    return(sqrt((p1.x-p2.x)*(p1.x-p2.x)+(p1.y-p2.y)*(p1.y-p2.y)));}</code></pre><h4 id="三维空间"><a href="#三维空间" class="headerlink" title="三维空间"></a>三维空间</h4><h5 id="点-线-面"><a href="#点-线-面" class="headerlink" title="点,线,面"></a>点,线,面</h5><pre><code>struct point{    double x,y,z;};struct line{    point a,b;};struct plane{    point a,b,c;};</code></pre><h5 id="计算-cross-product-product-product-product-U-x-V"><a href="#计算-cross-product-product-product-product-U-x-V" class="headerlink" title="计算 cross product product product product U x V"></a>计算 cross product product product product U x V</h5><pre><code>point xmult(point u,point v){    point ret;    ret.x=u.y*v.z-v.y*u.z;    ret.y=u.z*v.x-u.x*v.z;    ret.z=u.x*v.y-u.y*v.x;    return ret;}</code></pre><h5 id="计算-dot-product-product-product-product-U-V"><a href="#计算-dot-product-product-product-product-U-V" class="headerlink" title="计算 dot product product product product U . V"></a>计算 dot product product product product U . V</h5><pre><code>double dmult(point u,point v){    return u.x*v.x+u.y*v.y+u.z*v.z;}</code></pre><h5 id="矢量差-U-V"><a href="#矢量差-U-V" class="headerlink" title="矢量差 U - V"></a>矢量差 U - V</h5><pre><code>point subt(point u,point v){    point ret;    ret.x=u.x-v.x;    ret.y=u.y-v.y;    ret.z=u.z-v.z;    return ret;}</code></pre><h5 id="取平面法向量"><a href="#取平面法向量" class="headerlink" title="取平面法向量"></a>取平面法向量</h5><pre><code>point pvec(plane s){    return xmult(subt(s.a,s.b),subt(s.b,s.c));}point pvec(point s1,point s2,point s3){    return xmult(subt(s1,s2),subt(s2,s3));}</code></pre><h5 id="两点距离-单参数取向量大小"><a href="#两点距离-单参数取向量大小" class="headerlink" title="两点距离,单参数取向量大小"></a>两点距离,单参数取向量大小</h5><pre><code>double dis(point p1,point p2){    return sqrt((p1.x-p2.x)*(p1.x-p2.x)+(p1.y-p2.y)*(p1.y-p2.y)+(p1.z-p2.z)*(p1.z-p2.z));}</code></pre><h5 id="向量大小"><a href="#向量大小" class="headerlink" title="向量大小"></a>向量大小</h5><pre><code>double vlen(point p){    return sqrt(p.x*p.x+p.y*p.y+p.z*p.z);}</code></pre><h5 id="判断四点是不是共面"><a href="#判断四点是不是共面" class="headerlink" title="判断四点是不是共面"></a>判断四点是不是共面</h5><pre><code>bool judge(point a,point b,point c,point d){    double tmp = dmult(prec(a,b,c),smult(d,a));    return  ( abs(tmp) &lt; eps );}</code></pre><h5 id="点到平面距离"><a href="#点到平面距离" class="headerlink" title="点到平面距离"></a>点到平面距离</h5><pre><code>double ptoplane(point p,point s1,point s2,point s3){    return fabs(dmult(pvec(s1,s2,s3),subt(p,s1)))/vlen(pvec(s1,s2,s3));}</code></pre><h5 id="三角形面积"><a href="#三角形面积" class="headerlink" title="三角形面积"></a>三角形面积</h5><pre><code>double Area_triangle(point a,point b,point c){    double ab=dis(a,b),bc=dis(b,c),ac=dis(a,c);    double p=(ab+bc+ac)/2;    return sqrt(p* (p-ab) * (p-bc)*(p-ac));}double Area_triangle(point b,point p1,point p2){    point a=xmult(smult(b,p1),smult(b,p2));    return sqrt(a.x*a.x+a.y*a.y+a.z*a.z)/2.0;}</code></pre><h2 id="极角排序"><a href="#极角排序" class="headerlink" title="极角排序"></a>极角排序</h2><h4 id="极角排序-1"><a href="#极角排序-1" class="headerlink" title="//极角排序"></a>//极角排序</h4><pre><code>bool dy(double x,double y)  {   return x &gt; y + eps;} // x &gt; ybool xy(double x,double y)  {   return x &lt; y - eps;} // x &lt; ybool dyd(double x,double y) {   return x &gt; y - eps;} // x &gt;= ybool xyd(double x,double y) {   return x &lt; y + eps;} // x &lt;= ybool dd(double x,double y)  {   return fabs( x - y ) &lt; eps;}  // x == ybool cmp(point a,point b)   // 第一次排序{    if( dd(a.y ,b.y ) )  return xy(a.x, b.x);    return xy(a.y,b.y);}</code></pre><h2 id="凸包"><a href="#凸包" class="headerlink" title="凸包"></a>凸包</h2><h4 id="grabam-扫描法"><a href="#grabam-扫描法" class="headerlink" title=" grabam 扫描法 "></a><strong> grabam 扫描法 </strong></h4><p>O  (  n  l  o  g  2  n  )  复杂度寻求凸包</p><h4 id="凸包运算（周长-面积-最小园覆盖）"><a href="#凸包运算（周长-面积-最小园覆盖）" class="headerlink" title="凸包运算（周长+面积+最小园覆盖）"></a>凸包运算（周长+面积+最小园覆盖）</h4><pre><code>const int maxN=50000;  Point p[maxN];Point ch[maxN];int n;int len;int main(){    int t,l;    //scanf(&quot;%d&quot;,&amp;t);    while(~scanf(&quot;%d&quot;,&amp;n))    {        double distence=0.0;        for(int i=0; i&lt;n; i++)        {            scanf(&quot;%lf%lf&quot;,&amp;p[i].x,&amp;p[i].y);        }        if(n==0) break;        //这是一些值得特判的情况        //if(n==0) if(n==1) if(n==2)        if(n&lt;=1)        {            printf(&quot;0.50\n&quot;);            continue;        }        if (n == 2)        {            printf(&quot;%.2lf\n&quot;,dis(p[0],p[1])*0.50+0.50);            continue;        }        Graham_scan(p,ch,n,len);        for(int i=0; i&lt;len; i++) //凸包 各个顶点的顺序            cout&lt;&lt;ch[i].x&lt;&lt;&quot; &quot;&lt;&lt;ch[i].y&lt;&lt;endl;        //求凸包的周长        double perimeters=0.0;        for(int i=1;i&lt;len;i++)        {            perimeters+=dis(ch[i],ch[i-1]);        }        perimeters+=dis(ch[0],ch[len-1]);        printf(&quot;%.0lf\n&quot;,perimeters);        //求凸包的面积        double area=0.0;        for(int i=2; i&lt;len; i++)        {            area+=mul(ch[i-1],ch[i],ch[0]);        }        printf(&quot;%d\n&quot;,(int )area/100);        //求图包最小圆覆盖        double maxr = -1;        double a, b, c, r, s;        for (int i=0; i&lt;len; i++)  //枚举凸包上的点        {            for (int j=i+1; j&lt;len; j++)            {                for (int k=j+1; k&lt;len; k++)                {                    a = dis(ch[i], ch[j]);                    b = dis(ch[i], ch[k]);                    c = dis(ch[j], ch[k]);                    if (a*a+b*b&lt;c*c || a*a+c*c&lt;b*b || b*b+c*c&lt;a*a)                        r = max(max(a, b), c) / 2.0;//钝角时  半径为最长边的一半                    else                    {                        s = fabs(mul(ch[i], ch[j], ch[k])) / 2.0;                        r = a * b * c / (s * 4.0);//三角形外接圆公式                    }                    if (maxr &lt; r) maxr = r;                }            }        }        printf (&quot;%.2lf\n&quot;, maxr+0.50);        //if(t) printf(&quot;\n&quot;);  //这是控制两组输出数据之间有一个空格的    }    return 0;}</code></pre><h2 id="线与线"><a href="#线与线" class="headerlink" title="线与线"></a>线与线</h2><h5 id="线段相交"><a href="#线段相交" class="headerlink" title="线段相交"></a>线段相交</h5><pre><code>bool IsIntersected(point s1,point e1,point s2,point e2)//两个线段相交{    return(max(s1.x,e1.x)&gt;=min(s2.x,e2.x))&amp;&amp;           (max(s2.x,e2.x)&gt;=min(s1.x,e1.x))&amp;&amp;           (max(s1.y,e1.y)&gt;=min(s2.y,e2.y))&amp;&amp;           (max(s2.y,e2.y)&gt;=min(s1.y,e1.y))&amp;&amp;           (multi(s1,s2,e1)*multi(s1,e1,e2)&gt;0)&amp;&amp;           (multi(s2,s1,e2)*multi(s2,e2,e1)&gt;0);}</code></pre><h5 id="求两线段交点"><a href="#求两线段交点" class="headerlink" title="求两线段交点"></a>求两线段交点</h5><pre><code>point intersection(point &amp;A,point &amp;B,point &amp;C,point &amp;D){    /* AB与CD交点*/    point p;    double a1=A.y-B.y;    double b1=B.x-A.x;    double c1=A.x*B.y-B.x*A.y;    double a2=C.y-D.y;    double b2=D.x-C.x;    double c2=C.x*D.y-D.x*C.y;    p.x=(b1*c2-b2*c1)/(a1*b2-a2*b1);    p.y=(a2*c1-a1*c2)/(a1*b2-a2*b1);    return p;}</code></pre><h2 id="两圆相交"><a href="#两圆相交" class="headerlink" title="两圆相交"></a>两圆相交</h2><h5 id="两圆相交面积"><a href="#两圆相交面积" class="headerlink" title="两圆相交面积"></a>两圆相交面积</h5><pre><code>struct Round {      double x, y;      double r;  };  double solve(Round a, Round b){    double d = dis(a, b);    if (d &gt;= a.r + b.r)        return 0;    if (d &lt;= fabs(a.r - b.r))    {        double r = a.r &lt; b.r ? a.r : b.r;        return PI * r * r;    }    double ang1 = acos((a.r * a.r + d * d - b.r * b.r) / 2. / a.r / d);    double ang2 = acos((b.r * b.r + d * d - a.r * a.r) / 2. / b.r / d);    double ret = ang1 * a.r * a.r + ang2 * b.r * b.r - d * a.r * sin(ang1);    return ret;}</code></pre><h2 id="四点共面"><a href="#四点共面" class="headerlink" title="四点共面"></a>四点共面</h2><p>可以由4个点构成3个向量，3个向量共面的充要条件是向量为a，b，c，存在实数x,y,z不全为零，使得xa+yb+zc=0。转化为线性代数的3个向量线性相关的<br>行列式为0。</p><pre><code>double is_coplanar(point a, point b, point c, point d){    point ab, ac, ad;    ab.x=a.x-b.x, ab.y=a.y-b.y, ab.z=a.z-b.z;    ac.x=a.x-c.x, ac.y=a.y-c.y, ac.z=a.z-c.z;    ad.x=a.x-d.x, ad.y=a.y-d.y, ad.z=a.z-d.z;    double gg=ab.x*ac.y*ad.z+ab.y*ac.z*ad.x+ac.x*ad.y*ab.z;    gg-=ab.z*ac.y*ad.x+ab.x*ac.z*ad.y+ab.y*ac.x*ad.z;    return gg;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  【计算几何各种知识点总结】[不定期补充]</title>
      <link href="/2016/04/10/51114511/"/>
      <url>/2016/04/10/51114511/</url>
      
        <content type="html"><![CDATA[<h1 id="【计算几何各种知识点总结】-不定期补充"><a href="#【计算几何各种知识点总结】-不定期补充" class="headerlink" title="【计算几何各种知识点总结】[不定期补充]"></a>【计算几何各种知识点总结】[不定期补充]</h1><p>置顶  2016年04月10日 19:26:51  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a><br>阅读数：3282</p><hr><p> 博客爬取于<code>2019-04-18 17:15:18</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/51114511" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/51114511</a></p><h1 id="计算几何模板总结-："><a href="#计算几何模板总结-：" class="headerlink" title="计算几何模板总结 ："></a>计算几何模板总结 ：</h1><h2 id="http-blog-csdn-net-qq-33184171-article-details-51124611"><a href="#http-blog-csdn-net-qq-33184171-article-details-51124611" class="headerlink" title="[ http://blog.csdn.net/qq_33184171/article/details/51124611"></a>[ <a href="http://blog.csdn.net/qq_33184171/article/details/51124611" target="_blank" rel="noopener">http://blog.csdn.net/qq_33184171/article/details/51124611</a></h2><p>](<a href="http://blog.csdn.net/qq_33184171/article/details/51124611" target="_blank" rel="noopener">http://blog.csdn.net/qq_33184171/article/details/51124611</a>)</p><h2 id="精度控制"><a href="#精度控制" class="headerlink" title=" 精度控制 "></a><strong> 精度控制 </strong></h2><p>尽量不要用除法，三角函数，强制类型转换（尤其是double转int）等操作，否则精度损失比较大 。<br>const double PI = acos(-1.0);<br>const double EPS = 1e-8;<br>对小数点后1位 取整 的方法为 ±1 （+1位进位 -1为退位）<br>eg：8(double)=7.9999999999….;<br>8(int)=8;<br>int(8(double))=7; !!!!!!<br>这样精度损失就大了~~~~</p><h2 id="杂点"><a href="#杂点" class="headerlink" title=" 杂点 "></a><strong> 杂点 </strong></h2><h3 id="精度问题"><a href="#精度问题" class="headerlink" title="精度问题"></a>精度问题</h3><p>1.在用1e-n判断相等的时候不是n越大越好 要选择合适的 ，一般为6/8/9/10<br>2.判断两条线段距离大小关系的时候有平方倍进行比较。<br>3.未完待续。。。</p><h2 id="点与其他图形的位置关系"><a href="#点与其他图形的位置关系" class="headerlink" title=" 点与其他图形的位置关系 "></a><strong> 点与其他图形的位置关系 </strong></h2><h3 id="点与直线的位置关系"><a href="#点与直线的位置关系" class="headerlink" title="点与直线的位置关系"></a>点与直线的位置关系</h3><p>首先明确点与直线的位置关系只有两种：<br>1.点在直线上<br><img src="https://img-blog.csdn.net/20160414155301693" alt="这里写图片描述"><br>2.点不在直线上<br><img src="https://img-blog.csdn.net/20160414155341162" alt="这里写图片描述"></p><p>在这里只要用叉积判断就可以了<br>以上图为例只需满足向量  a  ⋅  b  ×  a  ⋅  c  =  0  即可<br>如果叉积等于0 则说明两向量共线 所以点在直线上<br>如果叉积不为0 则说明点不在直线上</p><h3 id="点与线段的关系"><a href="#点与线段的关系" class="headerlink" title="点与线段的关系"></a>点与线段的关系</h3><p>知道了如何判断点与直线的位置关系在来判断点与线段的位置关系就容易多了<br>跟直线类似点与线段也只有两种位置关系：<br>1.点在线段上<br>2.点不在线段上</p><p>如果点在线段上则需满足以下两种情况：<br>1.点在线段所在的直线上。<br>2.点在以线段为对角线的矩形内。<br>前者很好理解，而后者则确保点不在线段的两端延长线上。<br>所以除了判断叉积还要判断坐标关系<br>以下图为例<br><img src="https://img-blog.csdn.net/20160414160454816" alt="这里写图片描述"><br>很容易得出<br>应满足以下结论</p><blockquote><p>c.x&gt; min(a.x,b.x);<br>c.x&lt; max(a.x,b.x);<br>c.y&gt; min(a.y,b.y);<br>c.y&lt; max(a.y,b.y);<br>这样就满足了点在矩形内<br>当然不能忘记用叉积判断；；；</p></blockquote><h3 id="点与三角形的内外"><a href="#点与三角形的内外" class="headerlink" title="点与三角形的内外"></a>点与三角形的内外</h3><p>先要说明，当点在三角形边上的时候视为点在三角形的内部<br>在这里我们运用面积关系来判断点在三角形的内外<br><img src="https://img-blog.csdn.net/20160414161308397" alt="这里写图片描述"> <img src="https://img-blog.csdn.net/20160414161220819" alt="这里写图片描述"></p><p>观察S△dab+S△dbc+S△dac与S△abc的大小关系<br>观察上两图不难发现当点在三角形内是S△dab+S△dbc+S△dac是相等于S△abc的<br>而点在三角线外的时候<br>S△dab+S△dbc+S△dac是大于S△abc的</p><p>所以只要计算出两式的大小关系即可<br>Ps：这里求面积运用的为叉乘,  a  b  →  ×  a  c  →  就是 延伸出去的平行四边形的面积<br>S  △  a  b  c  =  a  b  →  ×  a  c  →  2  ；</p><blockquote><p>判断大小关系的时候不用除以2 直接判断即可 且更加精确</p></blockquote><h2 id="线段相交"><a href="#线段相交" class="headerlink" title=" 线段相交 "></a><strong> 线段相交 </strong></h2><h3 id="判断两线段是否相交"><a href="#判断两线段是否相交" class="headerlink" title="判断两线段是否相交"></a>判断两线段是否相交</h3><p>判断两个线段是否相交，要先想一下两条线段之间都有什么样的位置关系。<br>1.相离<br><img src="https://img-blog.csdn.net/20160410184617699" alt="两线段相离"><br>2.相交<br><img src="https://img-blog.csdn.net/20160410184718919" alt="两线段相交"><br>3.重合<br><img src="https://img-blog.csdn.net/20160410184738888" alt="两线段重合"><br>4.平行<br><img src="https://img-blog.csdn.net/20160410184747842" alt="两线段平行"><br>观察了上面4个图片 可以明显的观察到 相交与其他3种的不同<br>一条线段的两个端点分别在另一条线段的两边<br>了解了这些加上叉乘就可以进行计算了<br>Ps：如果不了解叉乘的话必须先了解下叉乘，但我相信能做到求线段相交的人一定对叉乘有了全方位的了解<br>首先我们知道如果两个点在在一条线段两侧 那么对于线段两端与这两个点分别做叉乘计算取得的积一定是小于0的<br>可以得到以下结论<br><img src="https://img-blog.csdn.net/20160410190214032" alt="这里写图片描述"></p><p>(  C  D  −  →  −  ×  D  A  −  →  −  )  ⋅  (  C  D  −  →  −  ×  D  B  −  →  −<br>)  &lt; 0  ;<br>(  A  B  −  →  −  ×  B  D  −  →  −  )  ⋅  (  A  B  −  →  −  ×  B  C  −  →  −<br>)  &lt; 0  ;</p><p>其实想也很好想<br>如果两个线段不想交那么势必存在一条线段的两个端点在另一条线段同侧，上述式子就不能满足。<br>所以通过计算上述式子也就能知道两线段是不是相交了。<br>但是在实际计算中如果数据量非常大的话那么我们总是计算4遍叉乘的话会很麻烦<br>所以要考虑更简单的判断两条线不相交的办法来排除一些情况，当然也只能排除一些情况而已，但即使这样也能使整个程序运行的快一些。<br>我们可以通过判断这两条线段的四个点的关系来淘汰很多点:<br>(这部分证明并没有什么意义，大家想想即可明白，在此就不赘述了，支架以代码形式给出)</p><blockquote><p>max(s1.x,e1.x) &lt; min(s2.x,e2.x)<br>max(s2.x,e2.x) &lt; min(s1.x,e1.x)<br>max(s1.y,e1.y) &lt; min(s2.y,e2.y)<br>max(s2.y,e2.y) &lt; min(s1.y,e1.y)<br>这4中情况都是不相交的</p></blockquote><p>======<br>上述已经介绍了如何判断线段相交,该上代码了</p><pre><code>double multi(Point p1,Point p2,Point p0){    return ((p1.x-p0.x)*(p2.y-p0.y)-(p1.y-p0.y)*(p2.x-p0.x));}bool IsIntersected(Point s1,Point e1,Point s2,Point e2) { //两个线段相交    return(max(s1.x,e1.x)&gt;=min(s2.x,e2.x))&amp;&amp;          (max(s2.x,e2.x)&gt;=min(s1.x,e1.x))&amp;&amp;          (max(s1.y,e1.y)&gt;=min(s2.y,e2.y))&amp;&amp;          (max(s2.y,e2.y)&gt;=min(s1.y,e1.y))&amp;&amp;          (multi(s1,s2,e1)*multi(s1,e2,e1)&lt;=0)&amp;&amp;          (multi(s2,s1,e2)*multi(s2,e1,e2)&lt;=0);}</code></pre><h2 id="————————————————————————"><a href="#————————————————————————" class="headerlink" title="————————————————————————"></a>————————————————————————</h2><h2 id="求两圆相交面积"><a href="#求两圆相交面积" class="headerlink" title=" 求两圆相交面积 "></a><strong> 求两圆相交面积 </strong></h2><p>两个圆的位置一共有五种情况<br>1.内含 2.内切 3.相交 4.外切 5.外离<br>在计算几何中 内含与内切 可以当做同一种情况 外切与外离 可以当做同一种情况<br>Ps：如果有疑问可以自己画一画图 就会明白了</p><p>所以在计算几何中只要分成3种情况就行了<br>先定义 d为两圆圆心距离</p><p>1.外离<br><img src="https://img-blog.csdn.net/20160408213313210" alt="这里写图片描述"><br>外离<br>这种情况下d&gt;=r1+r2<br>两圆间没有相交的部分<br>所以相交面积是0</p><p>2.内含<br><img src="https://img-blog.csdn.net/20160408213509414" alt="这里写图片描述"><br>内含<br>这种情况下 大圆把小圆全部覆盖<br>相交的面积就是校园的面积 PI <em> r1 </em> r1<br>此情况下 d&lt;=r大-r小<br>写成代码就是d &lt;= fabs(r1 - r2)</p><p>3.相交<br><img src="https://img-blog.csdn.net/20160408213838460" alt="这里写图片描述"><br>相交<br>相交的部分可以分成 大小两个圆上弧ab与直线ab围成的图形<br>即可看作<br>S扇形abc1-S△abc1+S扇形abc2-S△abc2&lt;=&gt;<br>S扇形abc1+S扇形abc2-S□ac1bc2;<br>根据中学学的扇形的面积公式可以推到如下</p><p>a  n  g  1  =  a  c  o  s  (  r  1  ∗  r  1  +  d  ∗  d  −  r  2  ∗  r  2<br>2.0  ∗  r  1  ∗  d  )<br>a  n  g  2  =  a  c  o  s  (  r  2  ∗  r  2  +  d  ∗  d  −  r  1  ∗  r  1<br>2.0  ∗  r  2  ∗  d  )<br>S  扇  形  a  b  c  1  =  a  n  g  1  ∗  r  1  ∗  r  1<br>S  扇  形  a  b  c  2  =  a  n  g  2  ∗  r  2  ∗  r  2<br>S  □  a  c  1  b  c  2  =  d  ∗  r  1  ∗  s  i  n  (  a  n  g  1  )</p><p>S  =  a  n  g  1  ∗  r  1  ∗  r  1  +  a  n  g  2  ∗  r  2  ∗  r  2  −  d  ∗<br>r  1  ∗  s  i  n  (  a  n  g  1  )  ；</p><p>======<br>上述已经介绍了如何计算两圆相交面积,该上代码了</p><pre><code>double solve(Round a, Round b){    double d = dis(a, b);    if (d &gt;= a.r + b.r)        return 0;    if (d &lt;= fabs(a.r - b.r))    {        double r = a.r &lt; b.r ? a.r : b.r;        return PI * r * r;    }    double ang1 = acos((a.r * a.r + d * d - b.r * b.r) / 2. / a.r / d);    double ang2 = acos((b.r * b.r + d * d - a.r * a.r) / 2. / b.r / d);    double ret = ang1 * a.r * a.r + ang2 * b.r * b.r - d * a.r * sin(ang1);    return ret;}</code></pre><h2 id="————————————————————————-1"><a href="#————————————————————————-1" class="headerlink" title="————————————————————————-"></a>————————————————————————-</h2>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  POJ 1066 Treasure Hunt [线段相交]【计算几何】</title>
      <link href="/2016/04/10/51114254/"/>
      <url>/2016/04/10/51114254/</url>
      
        <content type="html"><![CDATA[<h1 id="POJ-1066-Treasure-Hunt-线段相交-【计算几何】"><a href="#POJ-1066-Treasure-Hunt-线段相交-【计算几何】" class="headerlink" title="POJ 1066 Treasure Hunt [线段相交]【计算几何】"></a>POJ 1066 Treasure Hunt [线段相交]【计算几何】</h1><p>2016年04月10日 18:36:31  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：443</p><hr><p> 博客爬取于<code>2019-04-18 17:20:52</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/51114254" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/51114254</a></p><p>题目链接 ： <a href="http://poj.org/problem?id=1066" target="_blank" rel="noopener"> http://poj.org/problem?id=1066 </a></p><hr><p>Treasure Hunt<br>Time Limit: 1000MS Memory Limit: 10000K<br>Total Submissions: 6260 Accepted: 2598<br>Description</p><p>Archeologists from the Antiquities and Curios Museum (ACM) have flown to Egypt<br>to examine the great pyramid of Key-Ops. Using state-of-the-art technology<br>they are able to determine that the lower floor of the pyramid is constructed<br>from a series of straightline walls, which intersect to form numerous enclosed<br>chambers. Currently, no doors exist to allow access to any chamber. This<br>state-of-the-art technology has also pinpointed the location of the treasure<br>room. What these dedicated (and greedy) archeologists want to do is blast<br>doors through the walls to get to the treasure room. However, to minimize the<br>damage to the artwork in the intervening chambers (and stay under their<br>government grant for dynamite) they want to blast through the minimum number<br>of doors. For structural integrity purposes, doors should only be blasted at<br>the midpoint of the wall of the room being entered. You are to write a program<br>which determines this minimum number of doors.<br>An example is shown below:<br><img src="http://poj.org/images/1066/t1.jpg" alt="这里写图片描述"><br>Input</p><p>The input will consist of one case. The first line will be an integer n (0 &lt;=<br>n &lt;= 30) specifying number of interior walls, followed by n lines containing<br>integer endpoints of each wall x1 y1 x2 y2 . The 4 enclosing walls of the<br>pyramid have fixed endpoints at (0,0); (0,100); (100,100) and (100,0) and are<br>not included in the list of walls. The interior walls always span from one<br>exterior wall to another exterior wall and are arranged such that no more than<br>two walls intersect at any point. You may assume that no two given walls<br>coincide. After the listing of the interior walls there will be one final line<br>containing the floating point coordinates of the treasure in the treasure room<br>(guaranteed not to lie on a wall).<br>Output</p><p>Print a single line listing the minimum number of doors which need to be<br>created, in the format shown below.<br>Sample Input</p><p>7<br>20 0 37 100<br>40 0 76 100<br>85 0 0 75<br>100 90 0 90<br>0 71 100 61<br>0 14 100 38<br>100 47 47 100<br>54.5 55.4<br>Sample Output</p><p>Number of doors = 2</p><hr><p>题目大意 :<br>有一个100*100大的封闭，有着一堆墙，墙的两端都在封闭空间的边上，在封闭空间内有一出宝藏，问你至少要打穿多少墙才能取得宝藏。</p><p>解题思路 ：<br>在外围进入里面打多少墙就是计算从这堆墙的两端与宝藏处所连成的线段总共穿过了几道墙（其实想一想也能明白，两点之间直线最短，所以在这样的条件下穿过的墙数最少，就<br>是最少的了），也就是判断一下线段相交，因为数据量并不是很大，所以暴力的枚举就好。<br>这里应用到了判断线段相交的方法<br>如果对此不是怎么了解的话可以看下这里：<br>华丽丽的传送阵： <a href="http://blog.csdn.net/qq_33184171/article/details/51114511" target="_blank" rel="noopener"> http://blog.csdn.net/qq_33184171/article/details/51114511</a></p><p>提示：<br>1.计算结果要加1，因为从封闭空间也是用墙封上的。<br>2.0的时候要特判下，这时结果为1。</p><hr><p>附本题代码</p><pre><code>#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cmath&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cstdlib&gt;#include &lt;iomanip&gt;using namespace std;const double PI = acos(-1.0);const double EPS = 1e-8;int n;struct point{    double x,y;} p;struct line{    point p1,p2;} line1[32],temp;double multi(point p0,point p1,point p2) //{    return (p1.x-p0.x)*(p2.y-p0.y)-(p2.x-p0.x)*(p1.y-p0.y);}bool IsIntersected(point s1,point e1,point s2,point e2)//两个线段相交{    return(max(s1.x,e1.x)&gt;=min(s2.x,e2.x))&amp;&amp;           (max(s2.x,e2.x)&gt;=min(s1.x,e1.x))&amp;&amp;           (max(s1.y,e1.y)&gt;=min(s2.y,e2.y))&amp;&amp;           (max(s2.y,e2.y)&gt;=min(s1.y,e1.y))&amp;&amp;           (multi(s1,s2,e1)*multi(s1,e1,e2)&gt;0)&amp;&amp;           (multi(s2,s1,e2)*multi(s2,e2,e1)&gt;0);}int  sumdoor(line l){    int sum=0;    for(int i=0; i&lt;n; i++)    {        if(IsIntersected(line1[i].p1,line1[i].p2,l.p1,l.p2))        sum++;    }    return  sum;}int main(){    while(~scanf(&quot;%d&quot;,&amp;n))    {        double x,y;        int sum=0x1f1f1f1f;        for(int i=0; i&lt;n; i++)            scanf(&quot;%lf%lf%lf%lf&quot;,&amp;line1[i].p1.x,&amp;line1[i].p1.y,&amp;line1[i].p2.x,&amp;line1[i].p2.y);        scanf(&quot;%lf%lf&quot;,&amp;p.x,&amp;p.y);        if(n==0) {cout&lt;&lt;&quot;Number of doors = &quot;&lt;&lt;1&lt;&lt;endl;continue;}        temp.p2=p;        for(int i=0; i&lt;n; i++)        {            temp.p1=line1[i].p1;            sum=min(sum,sumdoor(temp));            temp.p1=line1[i].p2;            sum=min(sum,sumdoor(temp));        }        printf(&quot;Number of doors = %d\n&quot;,sum+1);    }    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  HDU 3264 Open-air shopping malls [相交圆面积+二分查找]【计算几何】</title>
      <link href="/2016/04/08/51100211/"/>
      <url>/2016/04/08/51100211/</url>
      
        <content type="html"><![CDATA[<h1 id="HDU-3264-Open-air-shopping-malls-相交圆面积-二分查找-【计算几何】"><a href="#HDU-3264-Open-air-shopping-malls-相交圆面积-二分查找-【计算几何】" class="headerlink" title="HDU 3264 Open-air shopping malls [相交圆面积+二分查找]【计算几何】"></a>HDU 3264 Open-air shopping malls [相交圆面积+二分查找]【计算几何】</h1><p>2016年04月08日 22:01:36  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：530</p><hr><p> 博客爬取于<code>2019-04-18 17:20:53</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/51100211" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/51100211</a></p><p>题目链接 : <a href="http://acm.hdu.edu.cn/showproblem.php?pid=3264" target="_blank" rel="noopener"> http://acm.hdu.edu.cn/showproblem.php?pid=3264</a></p><p>Open-air shopping malls</p><p>Time Limit: 2000/1000 MS (Java/Others) Memory Limit: 32768/32768 K<br>(Java/Others)<br>Total Submission(s): 2314 Accepted Submission(s): 859</p><p>Problem Description<br>The city of M is a famous shopping city and its open-air shopping malls are<br>extremely attractive. During the tourist seasons, thousands of people crowded<br>into these shopping malls and enjoy the vary-different shopping.</p><p>Unfortunately, the climate has changed little by little and now rainy days<br>seriously affected the operation of open-air shopping malls—it’s obvious that<br>nobody will have a good mood when shopping in the rain. In order to change<br>this situation, the manager of these open-air shopping malls would like to<br>build a giant umbrella to solve this problem.</p><p>These shopping malls can be considered as different circles. It is guaranteed<br>that these circles will not intersect with each other and no circles will be<br>contained in another one. The giant umbrella is also a circle. Due to some<br>technical reasons, the center of the umbrella must coincide with the center of<br>a shopping mall. Furthermore, a fine survey shows that for any mall, covering<br>half of its area is enough for people to seek shelter from the rain, so the<br>task is to decide the minimum radius of the giant umbrella so that for every<br>shopping mall, the umbrella can cover at least half area of the mall.</p><p>Input<br>The input consists of multiple test cases.<br>The first line of the input contains one integer T (1&lt;=T&lt;=10), which is the<br>number of test cases.<br>For each test case, there is one integer N (1&lt;=N&lt;=20) in the first line,<br>representing the number of shopping malls.<br>The following N lines each contain three integers X,Y,R, representing that the<br>mall has a shape of a circle with radius R and its center is positioned at<br>(X,Y). X and Y are in the range of [-10000,10000] and R is a positive integer<br>less than 2000.</p><p>Output<br>For each test case, output one line contains a real number rounded to 4<br>decimal places, representing the minimum radius of the giant umbrella that<br>meets the demands.</p><p>Sample Input<br>1<br>2<br>0 0 1<br>2 0 1</p><p>Sample Output<br>2.0822</p><hr><p>题目大意 :<br>就是给你一堆圆 选一个圆的圆心给定一个半径 使得这个圆能够覆盖其他圆面积的一半以上 输出最小的这种圆的面积</p><p>解题思路 ：<br>枚举每个点，用二分的方法寻找半径<br>二分区间为[0,完整覆盖一个圆的半径长度]<br>然后二分就好<br>二分判定为 覆盖一个圆面积一半</p><p>其中涉及计算相交圆面积<br>可以先看一看这道题 POJ 2546<br>详细题解加相交圆面积的算法 可以看这里<br><a href="http://blog.csdn.net/qq_33184171/article/details/51100090" target="_blank" rel="noopener"> http://blog.csdn.net/qq_33184171/article/details/51100090</a></p><p>提示 :<br>本题数据较少 一个个的枚举即可 不用担心超时的问题<br>计算几何这种问题相对来说涉及的数学公式非常多<br>其中反映到编译语言上就会非常复杂<br>所以多整理模板<br>参加竞赛时会省很多事</p><hr><p>附本题代码</p><pre><code>#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cmath&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cstdlib&gt;#include &lt;iomanip&gt;using namespace std;const double PI = acos(-1.0);const double EPS = 1e-8;int n;struct circle{    double x,y,r;} c[10005],ori;double area[30];double dis(circle &amp;a,circle &amp;b){    return sqrt((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y));}double Area(circle &amp;a){    return PI*a.r*a.r;}double  getcrossarea(circle &amp;a ,circle &amp;b){    double d=dis(a,b);    if(d&gt;=a.r+b.r) return 0;    if(d&lt;=fabs(a.r-b.r))    {        double rr=min(a.r,b.r);        return PI*rr*rr;    }    double ang1 = acos((a.r * a.r + d * d - b.r * b.r) / 2. / a.r / d);    double ang2 = acos((b.r * b.r + d * d - a.r * a.r) / 2. / b.r / d);    double ret = ang1 * a.r * a.r + ang2 * b.r * b.r - d * a.r * sin(ang1);    return ret;}bool check(circle &amp; ori){    for(int i=0;i&lt;n;i++)    {        if (getcrossarea(ori, c[i]) * 2 &lt; PI * c[i].r * c[i].r)            return false;    }    return true;}double bin(double l, double r, circle&amp; ori){    double mid;    while (fabs(l - r) &gt;= EPS)    {        mid = (l + r) / 2;        ori.r = mid;        if (check(ori))        {            r = mid;        }        else        {            l = mid + EPS;        }    }    return mid;}int main(){    int t;    scanf(&quot;%d&quot;,&amp;t);    while(t--)    {        scanf(&quot;%d&quot;,&amp;n);        for(int i=0; i&lt;n; i++)        {            scanf(&quot;%lf%lf%lf&quot;,&amp;c[i].x,&amp;c[i].y,&amp;c[i].r);            area[i]=Area(c[i]);        }        double ans = 1e10;        for(int i=0; i&lt;n; i++)        {            ori.x = c[i].x;            ori.y = c[i].y;            double right = 0;            for(int j=0; j&lt;n; j++)            {                right = max(right, dis(ori, c[j]) + c[j].r);            }            ans = min(ans, bin(0, right, ori));        }        printf(&quot;%.4f\n&quot;, ans);    }    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  POJ 2546 Circular Area [相交园面积]【计算几何】</title>
      <link href="/2016/04/08/51100090/"/>
      <url>/2016/04/08/51100090/</url>
      
        <content type="html"><![CDATA[<h1 id="POJ-2546-Circular-Area-相交园面积-【计算几何】"><a href="#POJ-2546-Circular-Area-相交园面积-【计算几何】" class="headerlink" title="POJ 2546 Circular Area [相交园面积]【计算几何】"></a>POJ 2546 Circular Area [相交园面积]【计算几何】</h1><p>2016年04月08日 21:48:50  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：1152</p><hr><p> 博客爬取于<code>2019-04-18 17:20:54</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/51100090" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/51100090</a></p><p>题目链接： <a href="http://poj.org/problem?id=2546" target="_blank" rel="noopener"> http://poj.org/problem?id=2546 </a></p><p>Circular Area<br>Time Limit: 1000MS Memory Limit: 65536K<br>Total Submissions: 5662 Accepted: 2215<br>Description</p><p>Your task is to write a program, which, given two circles, calculates the area<br>of their intersection with the accuracy of three digits after decimal point.<br>Input</p><p>In the single line of input file there are space-separated real numbers x1 y1<br>r1 x2 y2 r2. They represent center coordinates and radii of two circles.<br>Output</p><p>The output file must contain single real number - the area.<br>Sample Input</p><p>20.0 30.0 15.0 40.0 30.0 30.0<br>Sample Output</p><p>608.366</p><hr><p>题目大意：<br>就是求两个圆的相交部分的面积</p><p>解题思路：<br>就是简单的几何题目。<br>两个圆的位置一共有五种情况<br>1.内含 2.内切 3.相交 4.外切 5.外离<br>在计算几何中 内含与内切 可以当做同一种情况 外切与外离 可以当做同一种情况<br>Ps：如果有疑问可以自己画一画图 就会明白了</p><p>所以在计算几何中只要分成3种情况就行了<br>先定义 d为两圆圆心距离</p><p>1.外离<br><img src="https://img-blog.csdn.net/20160408213313210" alt="外离"></p><p>这种情况下d&gt;=r1+r2<br>两圆间没有相交的部分<br>所以相交面积是0</p><p>2.内含</p><p><img src="https://img-blog.csdn.net/20160408213509414" alt="内含"><br>这种情况下 大圆把小圆全部覆盖<br>相交的面积就是校园的面积 PI <em> r1 </em> r1<br>此情况下 d&lt;=r大-r小<br>写成代码就是d &lt;= fabs(r1 - r2)</p><p>3.相交<br><img src="https://img-blog.csdn.net/20160408213838460" alt="相交"></p><p>相交的部分可以分成 大小两个圆上弧ab与直线ab围成的图形<br>即可看作<br>S扇形abc1-S△abc1+S扇形abc2-S△abc2&lt;=&gt;<br>S扇形abc1+S扇形abc2-S□ac1bc2;<br>根据中学学的扇形的面积公式可以推到如下</p><p>ang1 = acos((r1 <em> r1 + d </em> d - r2 <em> r2) / 2. / r1 / d)<br>ang2 = acos((r2 </em> r2 + d <em> d - r1 </em> r1) / 2. / r2 / d)<br>S扇形abc1=ang1 <em> r1 </em> r1<br>S扇形abc2=ang2 <em> r2 </em> r2<br>S□ac1bc2=d <em> r1 </em> sin(ang1)</p><p>S = ang1 <em> r1 </em> r1+ang2 <em> r2 </em> r2 - d <em> r1 </em> sin(ang1)</p><hr><p>附本题代码</p><pre><code>#include &lt;iostream&gt;  #include &lt;cstdio&gt;  #include &lt;cstring&gt;  #include &lt;cmath&gt;  #include &lt;algorithm&gt;  using namespace std;  #define repf(i,a,b) for(int i=(a);i&lt;=(b);i++)  typedef long long ll;  const double PI = 3.141592653;  struct Round {      double x, y;      double r;  } r[2];  double dis(Round a, Round b) {      return sqrt((a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y));  }  double solve(Round a, Round b) {      double d = dis(a, b);      if (d &gt;= a.r + b.r)          return 0;      if (d &lt;= fabs(a.r - b.r)) {          double r = a.r &lt; b.r ? a.r : b.r;          return PI * r * r;      }      double ang1 = acos((a.r * a.r + d * d - b.r * b.r) / 2. / a.r / d);      double ang2 = acos((b.r * b.r + d * d - a.r * a.r) / 2. / b.r / d);      double ret = ang1 * a.r * a.r + ang2 * b.r * b.r - d * a.r * sin(ang1);      return ret;  }  int main() {      while (~scanf(&quot;%lf%lf%lf%lf%lf%lf&quot;, &amp;r[0].x, &amp;r[0].y, &amp;r[0].r, &amp;r[1].x, &amp;r[1].y, &amp;r[1].r)) {          printf(&quot;%.3f\n&quot;, solve(r[0], r[1]));      }      return 0;  }  </code></pre>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  hdu 1007 Quoit Design [sort+分治] 寻找最小距离点对</title>
      <link href="/2016/04/05/51068008/"/>
      <url>/2016/04/05/51068008/</url>
      
        <content type="html"><![CDATA[<h1 id="hdu-1007-Quoit-Design-sort-分治-寻找最小距离点对"><a href="#hdu-1007-Quoit-Design-sort-分治-寻找最小距离点对" class="headerlink" title="hdu 1007 Quoit Design [sort+分治] 寻找最小距离点对"></a>hdu 1007 Quoit Design [sort+分治] 寻找最小距离点对</h1><p>2016年04月05日 20:44:34  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：350<br>标签：  <a href="https://so.csdn.net/so/search/s.do?q=hdu&amp;t=blog" target="_blank" rel="noopener"> hdu </a> <a href="https://so.csdn.net/so/search/s.do?q=分治&amp;t=blog" target="_blank" rel="noopener"> 分治</a></p><p>个人分类：  <a href="https://blog.csdn.net/qq_33184171/article/category/6117382" target="_blank" rel="noopener"> hdu </a> <a href="https://blog.csdn.net/qq_33184171/article/category/6168208" target="_blank" rel="noopener"><br>分治 </a></p><hr><p> 博客爬取于<code>2019-04-18 17:20:55</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/51068008" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/51068008</a></p><p>题目链接 <a href="http://acm.hdu.edu.cn/showproblem.php?pid=1007" target="_blank" rel="noopener"> http://acm.hdu.edu.cn/showproblem.php?pid=1007</a></p><hr><p>Quoit Design</p><p>Time Limit: 10000/5000 MS (Java/Others) Memory Limit: 65536/32768 K<br>(Java/Others)<br>Total Submission(s): 43752 Accepted Submission(s): 11379</p><p>Problem Description<br>Have you ever played quoit in a playground? Quoit is a game in which flat<br>rings are pitched at some toys, with all the toys encircled awarded.<br>In the field of Cyberground, the position of each toy is fixed, and the ring<br>is carefully designed so it can only encircle one toy at a time. On the other<br>hand, to make the game look more attractive, the ring is designed to have the<br>largest radius. Given a configuration of the field, you are supposed to find<br>the radius of such a ring.</p><p>Assume that all the toys are points on a plane. A point is encircled by the<br>ring if the distance between the point and the center of the ring is strictly<br>less than the radius of the ring. If two toys are placed at the same point,<br>the radius of the ring is considered to be 0.</p><p>Input<br>The input consists of several test cases. For each case, the first line<br>contains an integer N (2 &lt;= N &lt;= 100,000), the total number of toys in the<br>field. Then N lines follow, each contains a pair of (x, y) which are the<br>coordinates of a toy. The input is terminated by N = 0.</p><p>Output<br>For each test case, print in one line the radius of the ring required by the<br>Cyberground manager, accurate up to 2 decimal places.</p><p>Sample Input<br>2<br>0 0<br>1 1<br>2<br>1 1<br>1 1<br>3<br>-1.5 0<br>0 0<br>0 1.5<br>0</p><p>Sample Output<br>0.71<br>0.00<br>0.75</p><hr><p>题目大意 :<br>给你N个点 求最小距离点对</p><p>解决方案 :<br>因为数据过多 达到了100000 而且时间只给了1s 如果两两对比的话 一定会超时 所以想到用分治的思想解决 但第一次提交居然WA了一发 之后才想到<br>光分治还不行 还要对坐标排下序 我采取的是从大到小排x坐标与y坐标和 的方式 点的距离就能分布均匀</p><p>然后AC 但是跑了702ms 不开心 #_#~~</p><p>看到有人跑了0ms 差距啊 ..<br>但是并不想在优化了<br>所以开始贴代码了</p><hr><pre><code>#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;int n,m;struct point{    double  x,y;} p[100005];double dis (const point &amp;p1,const point &amp;p2){    return (p1.x-p2.x)*(p1.x-p2.x)+(p1.y-p2.y)*(p1.y-p2.y);}double  Minlenth(int l,int r){    if(r==l) return 1000000000.0;    if(r-l==1)       return   dis(p[l],p[r]);    return min(Minlenth(l,(l+r)/2),Minlenth((l+r)/2,r));}int cmp(point p1,point p2){    return p1.x+p1.y&lt;p2.x+p2.y;}int main(){    while(~scanf(&quot;%d&quot;,&amp;n))    {        if(n==0) break;        for(int i=0; i&lt;n; i++)            scanf(&quot;%lf%lf&quot;,&amp;p[i].x,&amp;p[i].y);        sort(p,p+n,cmp);        printf(&quot;%.2lf\n&quot;,sqrt(Minlenth(0,n-1))/2);    }    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hdu </tag>
            
            <tag> 分治 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  POJ 3304 Segments [枚举+叉乘判断线段相交]【计算几何】</title>
      <link href="/2016/04/05/51066516/"/>
      <url>/2016/04/05/51066516/</url>
      
        <content type="html"><![CDATA[<h1 id="POJ-3304-Segments-枚举-叉乘判断线段相交-【计算几何】"><a href="#POJ-3304-Segments-枚举-叉乘判断线段相交-【计算几何】" class="headerlink" title="POJ 3304 Segments [枚举+叉乘判断线段相交]【计算几何】"></a>POJ 3304 Segments [枚举+叉乘判断线段相交]【计算几何】</h1><p>2016年04月05日 17:31:08  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：1642</p><hr><p> 博客爬取于<code>2019-04-18 17:20:56</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/51066516" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/51066516</a></p><p>题目链接 <a href="http://poj.org/problem?id=3304" target="_blank" rel="noopener"> http://poj.org/problem?id=3304 </a></p><p>Segments<br>Time Limit: 1000MS Memory Limit: 65536K<br>Total Submissions: 11920 Accepted: 3757</p><p>Description</p><p>Given n segments in the two dimensional space, write a program, which<br>determines if there exists a line such that after projecting these segments on<br>it, all projected segments have at least one point in common.</p><p>Input</p><p>Input begins with a number T showing the number of test cases and then, T test<br>cases follow. Each test case begins with a line containing a positive integer<br>n ≤ 100 showing the number of segments. After that, n lines containing four<br>real numbers x1 y1 x2 y2 follow, in which (x1, y1) and (x2, y2) are the<br>coordinates of the two endpoints for one of the segments.</p><p>Output</p><p>For each test case, your program must output “Yes!”, if a line with desired<br>property exists and must output “No!” otherwise. You must assume that two<br>floating point numbers a and b are equal if |a - b| &lt; 10-8.</p><p>Sample Input</p><p>3<br>2<br>1.0 2.0 3.0 4.0<br>4.0 5.0 6.0 7.0<br>3<br>0.0 0.0 0.0 1.0<br>0.0 1.0 0.0 2.0<br>1.0 1.0 2.0 1.0<br>3<br>0.0 0.0 0.0 1.0<br>0.0 2.0 0.0 3.0<br>1.0 1.0 2.0 1.0<br>Sample Output</p><p>Yes!<br>Yes!<br>No!<br>Source</p><p>Amirkabir University of Technology Local Contest 2006</p><hr><p>题目大意 ：<br>就是给你一堆线段 问你是否存在这样一条直线 使得所有线段在直线上的投影均有公共部分 有输出Yes 没有输出No</p><p>解题方法 ：<br>投影直线上有公共点的话就是说这条直线存在一个垂线经过所有线段 就是与所有线段均相交</p><p>只要枚举这些线段端点所确定的直线 是否存在一条与所有线段均相交即可</p><p>判断线段相交用的是叉乘 首先用两点p1,p2确定了一条直线 在用p1,p2分别与计算线段两个端点计算叉乘即可<br>叉乘之积&gt;0就说明线段两端点在直线的同侧 也就是直线不经过此线段</p><p>注意 ：<br>本题是double类型<br>判断是否有重点 重点定义为坐标非常接近的两点 &lt;1e-8即可<br>判断叉乘之积时 只要&lt;1e-8 即可</p><p>附本题代码</p><hr><p>这是引用网上与我代码非常接近的大神的代码 能Ac 但我的不知为什么就是不行 ~&gt;_&lt;~ 但也在下面贴出来了 如果有人找到BUG 了 一定要回复我 不胜感激</p><pre><code>#include &lt;iostream&gt;#include &lt;math.h&gt;#include &lt;cstdio&gt;using namespace std;#define MAXM 110#define EPS 1e-8typedef struct{    double x1,y1,x2,y2;}Segment;Segment segment[MAXM];int n;double distance(double x1,double y1,double x2,double y2){    return sqrt((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2));}double corss(double x1,double y1,double x2,double y2,double x,double y){    return (x2-x1)*(y-y1)-(x-x1)*(y2-y1);}bool judge(double x1,double y1,double x2,double y2){    int i;    if(distance(x1,y1,x2,y2)&lt;EPS) return 0;    for(i=0;i&lt;n;i++){        if(corss(x1,y1,x2,y2,segment[i].x1,segment[i].y1)*            corss(x1,y1,x2,y2,segment[i].x2,segment[i].y2)&gt;EPS) return 0;    }    return 1;}int main(){    int t,i,j,ans;    scanf(&quot;%d&quot;,&amp;t);    while(t--){        scanf(&quot;%d&quot;,&amp;n);        for(i=0;i&lt;n;i++)            scanf(&quot;%lf%lf%lf%lf&quot;,&amp;segment[i].x1,&amp;segment[i].y1,&amp;segment[i].x2,&amp;segment[i].y2);        if(n==1) {printf(&quot;Yes!\n&quot;);continue;}        ans=0;        for(i=0;i&lt;n &amp;&amp; !ans;i++)            for(j=i+1;j&lt;n &amp;&amp; !ans;j++){                if(judge(segment[i].x1,segment[i].y1,segment[j].x1,segment[j].y1) ||                    judge(segment[i].x1,segment[i].y1,segment[j].x2,segment[j].y2) ||                    judge(segment[i].x2,segment[i].y2,segment[j].x1,segment[j].y1) ||                    judge(segment[i].x2,segment[i].y2,segment[j].x2,segment[j].y2))                    ans=1;            }        if(ans) printf(&quot;Yes!\n&quot;);        else printf(&quot;No!\n&quot;);    }    return 0;}</code></pre><p>我那错误的代码&gt;_&lt;</p><pre><code>#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;int n,m;//精度是个大问题啊  很重要  判断重点const double eps = 1E-8;struct point{    double  x,y;} pzuo[1005],pyou[1005];int dis (const point &amp;p1,const point &amp;p2){    return sqrt((p1.x-p2.x)*(p1.x-p2.x)+(p1.y-p2.y)*(p1.y-p2.y));}int mul(const point &amp;p1,const point &amp;p2,const point &amp;p3){    return (p2.x-p1.x)*(p3.y-p1.y)-(p3.x-p1.x)*(p2.y-p1.y);}int judge(const point &amp;p1,const point &amp;p2){    if(dis(p1,p2)&lt;eps)  return 0;    for(int i=0; i&lt;n; i++)        if(mul(p1,p2,pzuo[i])*mul(p1,p2,pyou[i])&gt;eps)            return 0;    return 1;}int solve(){    for(int i=0; i&lt;n; i++)        for(int j=i+1; j&lt;n; j++)            if(judge(pzuo[i],pzuo[j])||                    judge(pzuo[i],pyou[j])||                    judge(pyou[i],pzuo[j])||                    judge(pyou[i],pyou[j]))                return 1;    return 0;}int main(){    int t;    scanf(&quot;%d&quot;,&amp;t);    while(t--)    {        scanf(&quot;%d&quot;,&amp;n);        for(int i=0; i&lt;n; i++)            scanf(&quot;%lf%lf%lf%lf&quot;,&amp;pzuo[i].x,&amp;pzuo[i].y,&amp;pyou[i].x,&amp;pyou[i].y);        if(n==1)        {            printf(&quot;Yes!\n&quot;);            continue;        }        if(solve())     printf(&quot;Yes!\n&quot;);        else            printf(&quot;No!\n&quot;);    }    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  POJ 2398 Toy Storage [叉积判断+二分查找]【计算几何】</title>
      <link href="/2016/04/05/51064675/"/>
      <url>/2016/04/05/51064675/</url>
      
        <content type="html"><![CDATA[<h1 id="POJ-2398-Toy-Storage-叉积判断-二分查找-【计算几何】"><a href="#POJ-2398-Toy-Storage-叉积判断-二分查找-【计算几何】" class="headerlink" title="POJ 2398 Toy Storage [叉积判断+二分查找]【计算几何】"></a>POJ 2398 Toy Storage [叉积判断+二分查找]【计算几何】</h1><p>2016年04月05日 14:42:26  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：299</p><hr><p> 博客爬取于<code>2019-04-18 17:20:57</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/51064675" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/51064675</a></p><p>题目链接： <a href="http://poj.org/problem?id=2398" target="_blank" rel="noopener"> http://poj.org/problem?id=2398 </a></p><p>Toy Storage<br>Time Limit: 1000MS Memory Limit: 65536K<br>Total Submissions: 4962 Accepted: 2950</p><p>Description</p><p>Mom and dad have a problem: their child, Reza, never puts his toys away when<br>he is finished playing with them. They gave Reza a rectangular box to put his<br>toys in. Unfortunately, Reza is rebellious and obeys his parents by simply<br>throwing his toys into the box. All the toys get mixed up, and it is<br>impossible for Reza to find his favorite toys anymore.<br>Reza’s parents came up with the following idea. They put cardboard partitions<br>into the box. Even if Reza keeps throwing his toys into the box, at least toys<br>that get thrown into different partitions stay separate. The box looks like<br>this from the top:</p><p><img src="http://poj.org/images/2398_1.jpg" alt="这里写图片描述"></p><p>We want for each positive integer t, such that there exists a partition with t<br>toys, determine how many partitions have t, toys.<br>Input</p><p>The input consists of a number of cases. The first line consists of six<br>integers n, m, x1, y1, x2, y2. The number of cardboards to form the partitions<br>is n (0 &lt; n &lt;= 1000) and the number of toys is given in m (0 &lt; m &lt;= 1000). The<br>coordinates of the upper-left corner and the lower-right corner of the box are<br>(x1, y1) and (x2, y2), respectively. The following n lines each consists of<br>two integers Ui Li, indicating that the ends of the ith cardboard is at the<br>coordinates (Ui, y1) and (Li, y2). You may assume that the cardboards do not<br>intersect with each other. The next m lines each consists of two integers Xi<br>Yi specifying where the ith toy has landed in the box. You may assume that no<br>toy will land on a cardboard.</p><p>A line consisting of a single 0 terminates the input.<br>Output</p><p>For each box, first provide a header stating “Box” on a line of its own. After<br>that, there will be one line of output per count (t &gt; 0) of toys in a<br>partition. The value t will be followed by a colon and a space, followed the<br>number of partitions containing t toys. Output will be sorted in ascending<br>order of t for each box.<br>Sample Input</p><p>4 10 0 10 100 0<br>20 20<br>80 80<br>60 60<br>40 40<br>5 10<br>15 10<br>95 10<br>25 10<br>65 10<br>75 10<br>35 10<br>45 10<br>55 10<br>85 10<br>5 6 0 10 60 0<br>4 3<br>15 30<br>3 1<br>6 8<br>10 10<br>2 1<br>2 8<br>1 5<br>5 5<br>40 10<br>7 9<br>0</p><p>Sample Output</p><p>Box<br>2: 5<br>Box<br>1: 4<br>2: 1</p><hr><p>没做过poj 2318的建议先做一下 跟本题是差不多的 但稍微简单些 <a href="http://poj.org/problem?id=2398" target="_blank" rel="noopener"> http://poj.org/problem?id=2398</a></p><p>题目大意： 有一个方盒子 有N个板隔开 分成N+1个区域<br>又给了M个玩具的坐标 问你有N个玩具（忽略玩具体积）的区域（不能恰好在区域内）有几个</p><p>解题思路： 每相邻的两个板看成两个向量 分别求其与其中一点和玩具坐标的叉积 如果两叉积的乘积&lt;0 就说明这个玩具坐标点在一个板的右边 一个板的左边</p><p>因为数据量比较大 可以把板和方盒的两边记录下来 然后二分 道理是一样的</p><p>上述就能记录下来每个区域有几个玩具<br>所以有N个玩具的区域有几个 就不用赘述了…</p><hr><p>附本题代码</p><pre><code>#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;int num[5005],sum[5005];int n,m;struct point{    int x,y;} q;struct node{    point pu,pl;}ban[5005];int mul(point p1,point p2,point p3){    return (p2.x-p1.x)*(p3.y-p1.y)-(p3.x-p1.x)*(p2.y-p1.y);}int cmp(node A,node B){    /*    if(A.pu.x==B.pu.x)        return A.pl.y&lt;B.pl.y;    else    */    return A.pu.x&lt;B.pu.x;}void Besearch(point x){    int l=0,r=n+1,ans;    while(l&lt;=r)    {        int mid=(l+r)/2;        if(mul(x,ban[mid].pu,ban[mid].pl)&lt;0)        {            ans=mid;            r=mid-1;        }        else            l=mid+1;    }    num[ans-1]++;}int main(){    int x1,x2,y1,y2;    while(~scanf(&quot;%d&quot;,&amp;n))    {        if(n==0) break;        memset(num,0,sizeof(num));        memset(sum,0,sizeof(sum));        scanf(&quot;%d %d %d %d %d &quot;,&amp;m,&amp;x1,&amp;y1,&amp;x2,&amp;y2);        ban[0].pu.x = x1,ban[0].pu.y=y1;        ban[0].pl.x = x1,ban[0].pl.y=y2;        for(int i=1; i&lt;=n; i++)        {            scanf(&quot;%d %d&quot;,&amp;ban[i].pu.x,&amp;ban[i].pl.x);            ban[i].pu.y=y1,ban[i].pl.y=y2;        }        ban[n+1].pu.x = x2,ban[n+1].pu.y=y1;        ban[n+1].pl.x = x2,ban[n+1].pl.y=y2;        sort(ban,ban+n+1,cmp);        for(int i=0; i&lt;m; i++)        {            scanf(&quot;%d %d&quot;,&amp;q.x,&amp;q.y);            Besearch(q);        }        printf(&quot;Box\n&quot;);        int maxi=-100;        for(int i=0;i&lt;=n;i++)        {            sum[num[i]]++;            maxi=max(maxi,sum[num[i]]);        }        for(int i=1; i&lt;=maxi; i++)            if(sum[i])            printf(&quot;%d: %d\n&quot;,i,sum[i]);    }    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  POJ 2318 TOYS [叉积判断+二分查找]【计算几何】</title>
      <link href="/2016/04/05/51064266/"/>
      <url>/2016/04/05/51064266/</url>
      
        <content type="html"><![CDATA[<h1 id="POJ-2318-TOYS-叉积判断-二分查找-【计算几何】"><a href="#POJ-2318-TOYS-叉积判断-二分查找-【计算几何】" class="headerlink" title="POJ 2318 TOYS [叉积判断+二分查找]【计算几何】"></a>POJ 2318 TOYS [叉积判断+二分查找]【计算几何】</h1><p>2016年04月05日 13:59:34  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：415</p><hr><p> 博客爬取于<code>2019-04-18 17:20:58</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/51064266" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/51064266</a></p><p>题目链接： <a href="http://poj.org/problem?id=2318" target="_blank" rel="noopener"> http://poj.org/problem?id=2318 </a></p><p>TOYS<br>Time Limit: 2000MS Memory Limit: 65536K<br>Total Submissions: 13008 Accepted: 6269</p><p>Description</p><p>Calculate the number of toys that land in each bin of a partitioned toy box.<br>Mom and dad have a problem - their child John never puts his toys away when he<br>is finished playing with them. They gave John a rectangular box to put his<br>toys in, but John is rebellious and obeys his parents by simply throwing his<br>toys into the box. All the toys get mixed up, and it is impossible for John to<br>find his favorite toys.</p><p>John’s parents came up with the following idea. They put cardboard partitions<br>into the box. Even if John keeps throwing his toys into the box, at least toys<br>that get thrown into different bins stay separated. The following diagram<br>shows a top view of an example toy box.<br><img src="http://poj.org/images/2318_1.jpg" alt="这里写图片描述"><br>For this problem, you are asked to determine how many toys fall into each<br>partition as John throws them into the toy box.<br>Input</p><p>The input file contains one or more problems. The first line of a problem<br>consists of six integers, n m x1 y1 x2 y2. The number of cardboard partitions<br>is n (0 &lt; n &lt;= 5000) and the number of toys is m (0 &lt; m &lt;= 5000). The<br>coordinates of the upper-left corner and the lower-right corner of the box are<br>(x1,y1) and (x2,y2), respectively. The following n lines contain two integers<br>per line, Ui Li, indicating that the ends of the i-th cardboard partition is<br>at the coordinates (Ui,y1) and (Li,y2). You may assume that the cardboard<br>partitions do not intersect each other and that they are specified in sorted<br>order from left to right. The next m lines contain two integers per line, Xj<br>Yj specifying where the j-th toy has landed in the box. The order of the toy<br>locations is random. You may assume that no toy will land exactly on a<br>cardboard partition or outside the boundary of the box. The input is<br>terminated by a line consisting of a single 0.<br>Output</p><p>The output for each problem will be one line for each separate bin in the toy<br>box. For each bin, print its bin number, followed by a colon and one space,<br>followed by the number of toys thrown into that bin. Bins are numbered from 0<br>(the leftmost bin) to n (the rightmost bin). Separate the output of different<br>problems by a single blank line.<br>Sample Input</p><p>5 6 0 10 60 0<br>3 1<br>4 3<br>6 8<br>10 10<br>15 30<br>1 5<br>2 1<br>2 8<br>5 5<br>40 10<br>7 9<br>4 10 0 10 100 0<br>20 20<br>40 40<br>60 60<br>80 80<br>5 10<br>15 10<br>25 10<br>35 10<br>45 10<br>55 10<br>65 10<br>75 10<br>85 10<br>95 10<br>0</p><p>Sample Output</p><p>0: 2<br>1: 1<br>2: 1<br>3: 1<br>4: 0<br>5: 1</p><p>0: 2<br>1: 2<br>2: 2<br>3: 2<br>4: 2</p><p>Hint</p><p>As the example illustrates, toys that fall on the boundary of the box are “in”<br>the box.</p><hr><p>题目大意： 有一个方盒子 有N个板隔开 分成N+1个区域<br>又给了M个玩具的坐标 问你每个区域内（不能恰好在区域内）的玩具有几个（忽略玩具体积）</p><hr><p>解题思路： 每相邻的两个板看成两个向量 分别求其与其中一点和玩具坐标的叉积 如果两叉积的乘积&lt;0 就说明这个玩具坐标点在一个板的右边 一个板的左边</p><p>因为数据量比较大 可以把板和方盒的两边记录下来 然后二分 道理是一样的</p><hr><p>附本题代码</p><pre><code>#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;int num[5005],x[5005],y[5005];int n,m,f=0;struct point{    int x,y;} pu[5005],pl[5005],q;int mul(point p1,point p2,point p3){    return (p2.x-p1.x)*(p3.y-p1.y)-(p3.x-p1.x)*(p2.y-p1.y);}void Besearch(point x){    int l=0,r=n+1,ans;    while(l&lt;=r)    {        int mid=(l+r)/2;        if(mul(x,pu[mid],pl[mid])&lt;0)        {            ans=mid;            r=mid-1;        }        else            l=mid+1;    }    num[ans-1]++;}int main(){    int x1,x2,y1,y2;    while(~scanf(&quot;%d&quot;,&amp;n))    {        if(n==0) break;        memset(num,0,sizeof(num));        scanf(&quot;%d %d %d %d %d &quot;,&amp;m,&amp;x1,&amp;y1,&amp;x2,&amp;y2);        pu[0].x = x1;        pu[0].y=y1;        pl[0].x = x1;        pl[0].y=y2;        for(int i=1; i&lt;=n; i++)        {            scanf(&quot;%d %d&quot;,&amp;pu[i].x,&amp;pl[i].x);            pu[i].y=y1,pl[i].y=y2;        }        pu[n+1].x = x2;        pu[n+1].y=y1;        pl[n+1].x = x2;        pl[n+1].y=y2;        /*        for(int i=0; i&lt;=n+1; i++)        {            printf(&quot;---&gt;%d-%d %d-%d\n&quot;,pu[i].x,pu[i].y,pl[i].x,pl[i].y);        }        */        for(int i=0; i&lt;m; i++)        {            scanf(&quot;%d %d&quot;,&amp;q.x,&amp;q.y);            Besearch(q);            /*            for(int j=0;j&lt;n;j++)            {                if(mul(a[j].u,y1,a[j].l,y2,x[i],y[i])*mul(a[j+1].u,y1,a[j+1].l,y2,x[i],y[i])&lt;0)                {num[j]++;break; }            }            */        }        if(f==1) printf(&quot;\n&quot;);        f=1;        for(int i=0; i&lt;=n; i++)            printf(&quot;%d: %d\n&quot;,i,num[i]);    }    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  POJ 1654 Area 【叉乘+外积的几何意义】【计算几何】</title>
      <link href="/2016/04/01/51036352/"/>
      <url>/2016/04/01/51036352/</url>
      
        <content type="html"><![CDATA[<h1 id="POJ-1654-Area-【叉乘-外积的几何意义】【计算几何】"><a href="#POJ-1654-Area-【叉乘-外积的几何意义】【计算几何】" class="headerlink" title="POJ 1654 Area 【叉乘+外积的几何意义】【计算几何】"></a>POJ 1654 Area 【叉乘+外积的几何意义】【计算几何】</h1><p>2016年04月01日 13:54:06  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：730</p><hr><p> 博客爬取于<code>2019-04-18 17:20:59</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/51036352" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/51036352</a></p><p>题目链接—&gt; <a href="http://poj.org/problem?id=1654" target="_blank" rel="noopener"> 点此传送阵 </a></p><p>Area<br>Time Limit: 1000MS Memory Limit: 10000K<br>Total Submissions: 17766 Accepted: 4925<br>Description</p><p>You are going to compute the area of a special kind of polygon. One vertex of<br>the polygon is the origin of the orthogonal coordinate system. From this<br>vertex, you may go step by step to the following vertexes of the polygon until<br>back to the initial vertex. For each step you may go North, West, South or<br>East with step length of 1 unit, or go Northwest, Northeast, Southwest or<br>Southeast with step length of square root of 2.</p><p>For example, this is a legal polygon to be computed and its area is 2.5:<br><img src="http://poj.org/images/1654_1.jpg" alt="这里写图片描述"><br>Input</p><p>The first line of input is an integer t (1 &lt;= t &lt;= 20), the number of the test<br>polygons. Each of the following lines contains a string composed of digits 1-9<br>describing how the polygon is formed by walking from the origin. Here 8, 2, 6<br>and 4 represent North, South, East and West, while 9, 7, 3 and 1 denote<br>Northeast, Northwest, Southeast and Southwest respectively. Number 5 only<br>appears at the end of the sequence indicating the stop of walking. You may<br>assume that the input polygon is valid which means that the endpoint is always<br>the start point and the sides of the polygon are not cross to each other.Each<br>line may contain up to 1000000 digits.<br>Output</p><p>For each polygon, print its area on a single line.<br>Sample Input</p><p>4<br>5<br>825<br>6725<br>6244865<br>Sample Output</p><p>0<br>0<br>0.5<br>2</p><hr><p>题目大意: 有一个直角坐标系 初始位置在（0,0） 给你一个字符串，其中1,2,3,4,6,7,8,9分别对应向8个方向 最后走回来 确保<br>数据最后能走回原点 <strong> 问 </strong> 行走路线所圈成的多边形面积。。</p><hr><p>最开是就想到了要用外积的几何意义来做 但是题目不能确保所走过的路线能是一个凸包 所以不敢用 然后就一直没有别的思路 最后按照样例 画了画 发现<br>外积的几何意义成立 于是有画了个凹包 发现也成立 于是敲了敲代码 就Ac了。。</p><hr><p><strong> 外积的几何意义： </strong><br>外积也称叉积或向量积<br>几何意义就是两个向量所构成的平行四边形面积就是外积<br>三角形的话就是外积的一半</p><p><img src="https://img-blog.csdn.net/20160401134518312" alt="这里写图片描述"></p><p>如上图所示<br>Sabcd=αxβ；<br>SΔabc=αxβ；</p><hr><p>本题就是把除原点外的相邻两个点与原点组成的三角形的面积加和就行</p><p>用外积求面积是会遇到结果为负的情况 是正常的 ，这样最后得到的和就会把多加上去的消掉 ，<br>注意 最终结果为正<br>注意 double的精度不好控制 用long long int 比较好控制</p><hr><p>附本题代码</p><pre><code>#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cstdlib&gt;#include &lt;string&gt;using namespace std;struct point{    int x,y;} p[1000005],temp;long long int mul(point p1,point p2,point p0){    return ((p1.x-p0.x)*(p2.y-p0.y)-(p2.x-p0.x)*(p1.y-p0.y));}point pp(char a,point b){         if(a==&#39;1&#39;) b.x--,b.y--;    else if(a==&#39;2&#39;) b.y--;    else if(a==&#39;3&#39;) b.x++,b.y--;    else if(a==&#39;4&#39;) b.x--;    else if(a==&#39;5&#39;) ;    else if(a==&#39;6&#39;) b.x++;    else if(a==&#39;7&#39;) b.x--,b.y++;    else if(a==&#39;8&#39;) b.y++;    else if(a==&#39;9&#39;) b.x++,b.y++;    return b;}char a[1000005];int main(){    int  t;    scanf(&quot;%d&quot;,&amp;t);    getchar();    while(t--)    {        gets(a);        int l=strlen(a);        if(l &lt;= 3){            printf(&quot;0\n&quot;); continue;        }        p[0].x=0,p[0].y=0;        for(int i=1; i&lt;l; i++)        {            p[i]=pp(a[i-1],p[i-1]);        }        long long int area=0;        for(int i=2;i&lt;l;i++)        {           long long int  aa=mul(p[i-1],p[i],p[0]);            printf(&quot;--&gt;%I64d\n&quot;,aa);            area+=aa;        }        if(area&lt;0) area=-area;        if(area%2==0)  //这里只是用来控制精度        printf(&quot;%I64d\n&quot;,area/2);        else            printf(&quot;%I64d.5\n&quot;,area/2);    }    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  2016 蓝桥杯 C/C++ B组 省赛 个人题解</title>
      <link href="/2016/03/22/50955548/"/>
      <url>/2016/03/22/50955548/</url>
      
        <content type="html"><![CDATA[<h1 id="2016-蓝桥杯-C-C-B组-省赛-个人题解"><a href="#2016-蓝桥杯-C-C-B组-省赛-个人题解" class="headerlink" title="2016 蓝桥杯 C/C++ B组 省赛 个人题解"></a>2016 蓝桥杯 C/C++ B组 省赛 个人题解</h1><p>2016年03月22日 15:28:27  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：6927</p><hr><p> 博客爬取于<code>2019-04-18 17:21:00</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/50955548" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/50955548</a></p><p>暂时标准答案没有出来 个别题目 不好现在就写出来 先将就看 过后会补上</p><h1 id="2016-蓝桥杯-C-C-B组-省赛-个人题解-1"><a href="#2016-蓝桥杯-C-C-B组-省赛-个人题解-1" class="headerlink" title="2016 蓝桥杯 C/C++ B组 省赛 个人题解"></a>2016 蓝桥杯 C/C++ B组 省赛 个人题解</h1><hr><h3 id="第一题："><a href="#第一题：" class="headerlink" title="第一题："></a>第一题：</h3><p>煤球数目</p><p>有一堆煤球，堆成三角棱锥形。具体：<br>第一层放1个，<br>第二层3个（排列成三角形），<br>第三层6个（排列成三角形），<br>第四层10个（排列成三角形），<br>….<br>如果一共有100层，共有多少个煤球？</p><p>请填表示煤球总数目的数字。<br>注意：你提交的应该是一个整数，不要填写任何多余的内容或说明性文字。</p><p><strong> 本题 就是签到题 </strong><br>每层 为上面所有层之和<br>然后求100层 共有多少个煤球<br><strong> 答案是171700 </strong></p><hr><pre><code>#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;queue&gt;using namespace std;int main(){    int num=0,sum=0;    for(int i=1;i&lt;=100;i++)    {        num+=i;        sum+=num;    }    printf(&quot;%d\n&quot;,sum);    return 0;}</code></pre><hr><h3 id="第二题："><a href="#第二题：" class="headerlink" title="第二题："></a>第二题：</h3><p>生日蜡烛</p><p>某君从某年开始每年都举办一次生日party，并且每次都要吹熄与年龄相同根数的蜡烛。</p><p>现在算起来，他一共吹熄了236根蜡烛。</p><p>请问，他从多少岁开始过生日party的？</p><p>请填写他开始过生日party的年龄数。<br>注意：你提交的应该是一个整数，不要填写任何多余的内容或说明性文字。</p><p><strong> 本题就是暴力求解 </strong><br>把1到1000岁都试一遍 <strong> _ (其实到100岁就行 毕竟人活不到那岁数啊) _ </strong><br>答案是26与236 毕竟活不到236 所以 <strong> 答案是26 </strong></p><hr><pre><code>#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;queue&gt;using namespace std;int main(){    int num=0,sum=0;    for(int i=1;i&lt;=1000;i++)    {        sum=0;        for(int j=i;j&gt;0;j++)        {            sum+=j;            if(sum==236)                printf(&quot;%d\n&quot;,i);            if(sum&gt;236)                break;        }    }    return 0;}</code></pre><hr><h3 id="第三题："><a href="#第三题：" class="headerlink" title="第三题："></a>第三题：</h3><p>凑算式</p><p>B DEF<br>A + — + ——- = 10<br>C GHI</p><p>（如果显示有问题，可以参见【图1.jpg】）</p><p>这个算式中A~I代表1~9的数字，不同的字母代表不同的数字。</p><p>比如：<br>6+8/3+952/714 就是一种解法，<br>5+3/1+972/486 是另一种解法。</p><p>这个算式一共有多少种解法？</p><p>注意：你提交应该是个整数，不要填写任何多余的内容或说明性文字。</p><p>本题 也是暴力求解 挨个试 满足了 +1 之后输出总和就好了<br>我没有采用9层for 用的是全排列 代码能简洁一点<br><strong> 答案是29 </strong></p><hr><pre><code>#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;queue&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;int main(){    int a[10]= {0,1,2,3,4,5,6,7,8,9};    int num=1,sum=0;    for(int i=1; i&lt;=9; i++)    {        num*=i;    }    while(num--)    {        next_permutation(a+1,a+10);        double lala=(double)a[1]+(double)a[2]/a[3]+(double)(a[4]*100+a[5]*10+a[6])/(a[7]*100+a[8]*10+a[9]);        if(lala==10.0)            sum++;    }    printf(&quot;%d\n&quot;,sum);    return 0;}</code></pre><hr><h3 id="第四题："><a href="#第四题：" class="headerlink" title="第四题："></a>第四题：</h3><p>快速排序</p><p>排序在各种场合经常被用到。<br>快速排序是十分常用的高效率的算法。</p><p>其思想是：先选一个“标尺”，<br>用它把整个队列过一遍筛子，<br>以保证：其左边的元素都不大于它，其右边的元素都不小于它。</p><p>这样，排序问题就被分割为两个子区间。<br>再分别对子区间排序就可以了。</p><p>下面的代码是一种实现，请分析并填写划线部分缺少的代码。</p><pre><code>#include &lt;stdio.h&gt;void swap(int a[], int i, int j){    int t = a[i];    a[i] = a[j];    a[j] = t;}int partition(int a[], int p, int r){    int i = p;    int j = r + 1;    int x = a[p];    while(1)    {        while(i&lt;r &amp;&amp; a[++i]&lt;x);        while(a[--j]&gt;x);        if(i&gt;=j) break;        swap(a,i,j);    }    ______________________;    return j;}void quicksort(int a[], int p, int r){    if(p&lt;r)    {        int q = partition(a,p,r);        quicksort(a,p,q-1);        quicksort(a,q+1,r);    }}int main(){    int i;    int a[] = {5,13,6,24,2,8,19,27,6,12,1,17};    int N = 12;    quicksort(a, 0, N-1);    for(i=0; i&lt;N; i++) printf(&quot;%d &quot;, a[i]);    printf(&quot;\n&quot;);    return 0;}</code></pre><p>注意：只填写缺少的内容，不要书写任何题面已有代码或说明性文字。</p><p>本题就是一个基础的快速排序<br>仔细观察了一下 就是缺少将“标尺”这个数交换到分好的数中间的操作 所以加上 <strong> swap（a，p，j） </strong><br>这个代码填空吧 关于后面有没有分号这个问题 我认为 既然横线后面给你分号了 就不用写了 但是 这个分号加与不加 对整体代码都是一样的 即使加了 也不能算错</p><hr><h3 id="第五题"><a href="#第五题" class="headerlink" title="第五题"></a>第五题</h3><p>抽签</p><p>X星球要派出一个5人组成的观察团前往W星。<br>其中：<br>A国最多可以派出4人。<br>B国最多可以派出2人。<br>C国最多可以派出2人。<br>….</p><p>那么最终派往W星的观察团会有多少种国别的不同组合呢？</p><p>下面的程序解决了这个问题。<br>数组a[] 中既是每个国家可以派出的最多的名额。<br>程序执行结果为：<br>DEFFF<br>CEFFF<br>CDFFF<br>CDEFF<br>CCFFF<br>CCEFF<br>CCDFF<br>CCDEF<br>BEFFF<br>BDFFF<br>BDEFF<br>BCFFF<br>BCEFF<br>BCDFF<br>BCDEF<br>….<br>(以下省略，总共101行)</p><pre><code>#include &lt;stdio.h&gt;#define N 6#define M 5#define BUF 1024void f(int a[], int k, int m, char b[]){    int i,j;    if(k==N)    {        b[M] = 0;        if(m==0) printf(&quot;%s\n&quot;,b);        return;    }    for(i=0; i&lt;=a[k]; i++)    {        for(j=0; j&lt;i; j++) b[M-m+j] = k+&#39;A&#39;;        ______________________; //填空位置    }}int main(){    int a[N] = {4,2,2,1,1,3};    char b[BUF];    f(a,0,M,b);    return 0;}</code></pre><p>仔细阅读代码，填写划线部分缺少的内容。</p><p>注意：不要填写任何已有内容或说明性文字。</p><p>本题就是一个简单的深搜<br>观察到（k==N） 就能知道 每次k应该加1<br>在观察 b[M-m+j] = k+’A’; 就能判断出 应该是m-j<br>当然 在这个代码中 i==j 所以<br><strong> f（a，k+1，m-j，b） </strong><br><strong> f（a，k+1，m-i，b） </strong><br>是一样的 哪个都对 。</p><hr><h3 id="第六题："><a href="#第六题：" class="headerlink" title="第六题："></a>第六题：</h3><p>方格填数</p><p>如下的10个格子</p><p><img src="https://img-blog.csdn.net/20160320214206481?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="这里写图片描述"><br>（如果显示有问题，也可以参看【图1.jpg】）</p><p>填入0~9的数字。要求：连续的两个数字不能相邻。<br>（左右、上下、对角都算相邻）</p><p>一共有多少种可能的填数方案？</p><p>请填写表示方案数目的整数。<br>注意：你提交的应该是一个整数，不要填写任何多余的内容或说明性文字。</p><p>本题如果用二维数组做 其实就是和数独差不多 判断一圈就可以了</p><p>本题我用的也是全排列 毕竟方便 然后判断可不可行 可行就加1</p><p>最后 <strong> 答案为1580 </strong></p><pre><code>#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;queue&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;int a[11]= {11111,0,1,2,3,4,5,6,7,8,9};int judge(){    if(abs(a[1]-a[2])==1||abs(a[1]-a[4])==1||abs(a[1]-a[5])==1||abs(a[1]-a[6])==1)        return 0;    else if(abs(a[2]-a[5])==1||abs(a[2]-a[6])==1||abs(a[2]-a[7])==1||abs(a[2]-a[3])==1)        return 0;    else if(abs(a[3]-a[6])==1||abs(a[3]-a[7])==1)        return 0;    else if(abs(a[4]-a[5])==1||abs(a[4]-a[8])==1||abs(a[4]-a[9])==1)        return 0;    else if(abs(a[5]-a[6])==1||abs(a[5]-a[8])==1||abs(a[5]-a[9])==1||abs(a[5]-a[10])==1)        return 0;    else if(abs(a[6]-a[7])==1||abs(a[6]-a[9])==1||abs(a[6]-a[10])==1)        return 0;    else if(abs(a[7]-a[10])==1)        return 0;    else if(abs(a[8]-a[9])==1)        return 0;    else if(abs(a[9]-a[10])==1)        return 0;    return 1;}int main(){    int num=1,sum=0;    for(int i=2; i&lt;=10; i++)    {        num*=i;    }    while(num--)    {        next_permutation(a+1,a+11);        if(judge())            sum++;    }    printf(&quot;%d\n&quot;,sum);    return 0;}</code></pre><hr><h3 id="第七题："><a href="#第七题：" class="headerlink" title="第七题："></a>第七题：</h3><p>剪邮票</p><p>如【图1.jpg】, 有12张连在一起的12生肖的邮票。<br>现在你要从中剪下5张来，要求必须是连着的。<br>（仅仅连接一个角不算相连）<br>比如，【图2.jpg】，【图3.jpg】中，粉红色所示部分就是合格的剪取。<br><img src="https://img-blog.csdn.net/20160320220250806?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="这里写图片描述"><br><img src="https://img-blog.csdn.net/20160320220300618?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="这里写图片描述"><br><img src="https://img-blog.csdn.net/20160320220338206?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="这里写图片描述"></p><p>请你计算，一共有多少种不同的剪取方法。</p><p>请填写表示方案数目的整数。<br>注意：你提交的应该是一个整数，不要填写任何多余的内容或说明性文字。</p><p>个人用的深搜 得出的答案为124 与网上的其他题解有出入 先不放题解了</p><p>最后看来正解应该是116<br>———————update————————<br>我的方法是在int a[]={0,0,0,0,0,0,0,1,1,1,1,1};的全排列中找5个1联通的个数.</p><pre><code>int b[10][10];int ans = 0;int fx[]={0,0,1,-1};int fy[]={1,-1,0,0};int vis[10][10];void dfs(int x,int y,int num){    vis[x][y]=1;    if(num&gt;=5){        return;    }    int xx,yy;    for(int i=0;i&lt;4;i++){        xx=x+fx[i];        yy=y+fy[i];        if(xx&gt;0&amp;&amp;yy&gt;0&amp;&amp;xx&lt;=3&amp;&amp;yy&lt;=4&amp;&amp;!vis[xx][yy]&amp;&amp;b[xx][yy]){            dfs(xx,yy,num+1);        }    }}int h[1000000];int main(){    int a[]={0,0,0,0,0,0,0,1,1,1,1,1};    memset(h,0,sizeof(h));    while(true){        next_permutation(a,a+12);        int tem = 0;        memset(b,0,sizeof(b));        memset(vis,0,sizeof(vis));        for(int i=0;i&lt;12;i++)if(a[i])tem|=1&lt;&lt;i,b[i/4+1][((i+1)%4==0)?4:(i+1)%4]=1;        for(int i=0;i&lt;12;i++)if(a[i]){dfs(i/4+1,((i+1)%4==0)?4:(i+1)%4,1);break;}        int cnt = 0;        for(int i=1;i&lt;=3;i++)            for(int j=1;j&lt;=4;j++)                if(vis[i][j])                    cnt++;        if(h[tem]) break;    h[tem]=1;        if(cnt == 5){            ans++;            for(int i=1;i&lt;=3;i++){                for(int j=1;j&lt;=4;j++){                    printf(&quot;%*d&quot;,2,vis[i][j]);                }                puts(&quot;&quot;);            }            printf(&quot;%d  &quot;,tem);            display(tem);            puts(&quot;-----------------------&quot;);        }    }    printf(&quot;%d\n&quot;,ans);    return 0;}</code></pre><hr><h3 id="第八题："><a href="#第八题：" class="headerlink" title="第八题："></a>第八题：</h3><p>四平方和</p><p>四平方和定理，又称为拉格朗日定理：<br>每个正整数都可以表示为至多4个正整数的平方和。<br>如果把0包括进去，就正好可以表示为4个数的平方和。</p><p>比如：<br>5 = 0^2 + 0^2 + 1^2 + 2^2<br>7 = 1^2 + 1^2 + 1^2 + 2^2<br>（^符号表示乘方的意思）</p><p>对于一个给定的正整数，可能存在多种平方和的表示法。<br>要求你对4个数排序：<br>0 &lt;= a &lt;= b &lt;= c &lt;= d<br>并对所有的可能表示法按 a,b,c,d 为联合主键升序排列，最后输出第一个表示法</p><p>程序输入为一个正整数N (N&lt;5000000)<br>要求输出4个非负整数，按从小到大排序，中间用空格分开</p><p>例如，输入：<br>5<br>则程序应该输出：<br>0 0 1 2</p><p>再例如，输入：<br>12<br>则程序应该输出：<br>0 2 2 2</p><p>再例如，输入：<br>773535<br>则程序应该输出：<br>1 1 267 838</p><p>资源约定：<br>峰值内存消耗 &lt; 256M<br>CPU消耗 &lt; 3000ms</p><p>请严格按要求输出，不要画蛇添足地打印类似：“请您输入…” 的多余内容。</p><p>所有代码放在同一个源文件中，调试通过后，拷贝提交该源码。</p><p>注意: main函数需要返回0<br>注意: 只使用ANSI C/ANSI C++ 标准，不要调用依赖于编译环境或操作系统的特殊函数。<br>注意: 所有依赖的函数必须明确地在源文件中 #include ， 不能通过工程设置而省略常用头文件。</p><p>提交时，注意选择所期望的编译器类型。</p><p>这题比赛时没有优化只用了 4层for 加剪枝 运行了一下4888888 秒出 所以就没有优化 但是用三层for完全可以解决 哎 不知能不能超时 都怪蓝桥杯<br>前面各种小暴力 最后都忘记优化了</p><p>话不多说 直接上代码 上三层for的吧 毕竟 这个肯定更稳妥</p><pre><code>#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;queue&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;int main(){    int n;    scanf(&quot;%d&quot;,&amp;n);    int l=sqrt(n);    int ll,f=0;    for(int i=0; i&lt;=l; i++)    {        if(i*i&gt;=n) break;        for(int j=i; j&lt;=l; j++)        {            if(i*i+j*j&gt;=n) break;            for(int k=j; k&lt;=l; k++)            {                ll=i*i+j*j+k*k;                   if(ll&gt;=n) break;                double sum=sqrt(n-ll);                if(sum==(int)sum)                {                    printf(&quot;%d %d %d %d\n&quot;,i,j,k,(int)sum);                    f=1;                    break;                }            }            if(f)   break;        }        if(f)   break;    }    return 0;}</code></pre><hr><h3 id="第九题："><a href="#第九题：" class="headerlink" title="第九题："></a>第九题：</h3><p>交换瓶子</p><p>有N个瓶子，编号 1 ~ N，放在架子上。</p><p>比如有5个瓶子：<br>2 1 3 5 4</p><p>要求每次拿起2个瓶子，交换它们的位置。<br>经过若干次后，使得瓶子的序号为：<br>1 2 3 4 5</p><p>对于这么简单的情况，显然，至少需要交换2次就可以复位。</p><p>如果瓶子更多呢？你可以通过编程来解决。</p><p>输入格式为两行：<br>第一行: 一个正整数N（N&lt;10000）, 表示瓶子的数目<br>第二行：N个正整数，用空格分开，表示瓶子目前的排列情况。</p><p>输出数据为一行一个正整数，表示至少交换多少次，才能完成排序。</p><p>例如，输入：<br>5<br>3 1 2 5 4</p><p>程序应该输出：<br>3</p><p>再例如，输入：<br>5<br>5 4 3 2 1</p><p>程序应该输出：<br>2</p><p>资源约定：<br>峰值内存消耗 &lt; 256M<br>CPU消耗 &lt; 1000ms</p><p>请严格按要求输出，不要画蛇添足地打印类似：“请您输入…” 的多余内容。</p><p>所有代码放在同一个源文件中，调试通过后，拷贝提交该源码。</p><p>注意: main函数需要返回0<br>注意: 只使用ANSI C/ANSI C++ 标准，不要调用依赖于编译环境或操作系统的特殊函数。<br>注意: 所有依赖的函数必须明确地在源文件中 #include ， 不能通过工程设置而省略常用头文件。</p><p>提交时，注意选择所期望的编译器类型。</p><p>本题鄙人有两种解法<br>一、<br>比赛时用的是并查集解决的，主要是观察过后发现一个很神奇的现象，如果N个数在这N个数，本来的位置的集合中相互混乱，那么只需操作N-1步，就能换回来。<br>比如说 5-3 1 2 5 4<br>其中 3 1 2 本应在1 2 3 的位置 但是他们相互乱序 但只要先把1和3换过来 变成1 3 2 在换3和2 这样就变回了1 2 3 这样的顺序 ，5<br>4也一样 交换一步就可以了 。<br>但是这个方法并不知道对不对<br>但比赛是我用的就是这种<br>采用并查集的方法 把相互乱序的放在一个集合中 然后只要计算每个集合的元素数-1的和 这样就可以了<br>比赛时测试样例 并没有什么出入 但有了下一种解法就总感觉会有错 哎 等结果下来吧 看看成绩怎么样就知道了</p><pre><code>怕误人子弟 代码就暂时不贴了</code></pre><p>二、</p><p>这是比赛之后发现校oj里有的一道题 但比较复杂 稍加修改 就成了这道题 算是直接模拟两两交换就行了</p><pre><code>#include&lt;stdio.h&gt;#include&lt;algorithm&gt;#include&lt;math.h&gt;#include&lt;string.h&gt;using namespace std;int a[10010];int main(){    int tot=0;    int n;    scanf(&quot;%d&quot;,&amp;n);    int i;    for(i=1; i&lt;=n; i++)    {        scanf(&quot;%d&quot;,&amp;a[i]);    }    int j;    for(i=1; i&lt;=n; i++)    {        if(a[i]!=i)        {            for(j=i+1; j&lt;=n; j++)            {                if(a[j]==i)                {                    swap(a[j],a[i]);                    tot++;                }            }        }    }    printf(&quot;%d\n&quot;,tot);    return 0;}</code></pre><hr><h3 id="第十题："><a href="#第十题：" class="headerlink" title="第十题："></a>第十题：</h3><p>最大比例</p><p>X星球的某个大奖赛设了M级奖励。每个级别的奖金是一个正整数。<br>并且，相邻的两个级别间的比例是个固定值。<br>也就是说：所有级别的奖金数构成了一个等比数列。比如：<br>16,24,36,54<br>其等比值为：3/2</p><p>现在，我们随机调查了一些获奖者的奖金数。<br>请你据此推算可能的最大的等比值。</p><p>输入格式：<br>第一行为数字N，表示接下的一行包含N个正整数<br>第二行N个正整数Xi(Xi&lt;1 000 000 000 000)，用空格分开。每个整数表示调查到的某人的奖金数额</p><p>要求输出：<br>一个形如A/B的分数，要求A、B互质。表示可能的最大比例系数</p><p>测试数据保证了输入格式正确，并且最大比例是存在的。</p><p>例如，输入：<br>3<br>1250 200 32</p><p>程序应该输出：<br>25/4</p><p>再例如，输入：<br>4<br>3125 32 32 200</p><p>程序应该输出：<br>5/2</p><p>再例如，输入：<br>3<br>549755813888 524288 2</p><p>程序应该输出：<br>4/1</p><p>资源约定：<br>峰值内存消耗 &lt; 256M<br>CPU消耗 &lt; 3000ms</p><p>请严格按要求输出，不要画蛇添足地打印类似：“请您输入…” 的多余内容。</p><p>所有代码放在同一个源文件中，调试通过后，拷贝提交该源码。</p><p>注意: main函数需要返回0<br>注意: 只使用ANSI C/ANSI C++ 标准，不要调用依赖于编译环境或操作系统的特殊函数。<br>注意: 所有依赖的函数必须明确地在源文件中 #include ， 不能通过工程设置而省略常用头文件。</p><p>提交时，注意选择所期望的编译器类型。</p><p><strong> _ 这道题 本渣并不会 所以 嘿嘿 你懂得…… _ </strong></p><hr>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  蓝桥杯 2016/3/17 测试 前6题题解...</title>
      <link href="/2016/03/17/50912690/"/>
      <url>/2016/03/17/50912690/</url>
      
        <content type="html"><![CDATA[<h1 id="蓝桥杯-2016-3-17-测试-前6题题解…"><a href="#蓝桥杯-2016-3-17-测试-前6题题解…" class="headerlink" title="蓝桥杯 2016/3/17 测试 前6题题解…"></a>蓝桥杯 2016/3/17 测试 前6题题解…</h1><p>2016年03月17日 12:39:13  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：2479</p><hr><p> 博客爬取于<code>2019-04-18 17:21:02</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/50912690" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/50912690</a></p><p>只有答案。。。。。将就着看吧 最近没时间写解题报告。。。。<br>至于为什么没有第7题 。。因为我不会啊。。。。</p><h2 id="1"><a href="#1" class="headerlink" title="1"></a>1</h2><p>一个串的子串是指该串的一个连续的局部。如果不要求连续，则可称为它的子序列。<br>比如对串： “abcdefg” 而言，”ab”,”abd”,”bdef” 等都是它的子序列。<br>特别地，一个串本身，以及空串也是它的子序列。</p><p>对两个串而言，可以有许多的共同的子序列，我们关心的是：它们所共同拥有的长度最大的子序列是多长。以下代码实现了这个问题的求解。请填写划线部分缺失的代码。</p><p>注意：只填写划线部分缺少的内容，不要填写任何多余的符号或注释、说明等。例如，不要填写已经给出的小括号。</p><pre><code>//   tag==1  &amp;&amp;  *p!=&#39; &#39;   #include &lt;stdio.h&gt;#include &lt;math.h&gt;#include &lt;iostream&gt;using namespace std;int get_word_num(char* buf){    int n=0;    int tag=1;    char* p=buf;    for( ; *p!=0&amp;&amp;*p!=13&amp;&amp;*p!=10; p++)    {        if(*p==&#39; &#39; &amp;&amp; tag==0)            tag=1;        if(   tag==1  &amp;&amp;  *p!=&#39; &#39;   )        {            n++;            tag=0;        }    }    return n;}int main(){    char buf[1000];    fgets(buf,1000,stdin);    printf(&quot;%d\n&quot;, get_word_num(buf));    return 0;}</code></pre><h2 id="2"><a href="#2" class="headerlink" title="2"></a>2</h2><p>1/1 + 1/2 + 1/3 + 1/4 + … 在数学上称为调和级数。</p><p>它是发散的，也就是说，只要加上足够多的项，就可以得到任意大的数字。</p><p>但是，它发散的很慢：</p><p>前1项和达到 1.0<br>前4项和才超过 2.0<br>前83项的和才超过 5.0</p><p>那么，请你计算一下，要加多少项，才能使得和达到或超过 15.0 呢？</p><p>请填写这个整数。</p><p>注意：只需要填写一个整数，不要填写任何多余的内容。比如说明文字。</p><pre><code>#include &lt;stdio.h&gt;   #include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;math.h&gt;#include &lt;string.h&gt;#define  C  0.57721566490153286060651209using namespace std;int main(){    double sum=0;    int flag=0;    for(int n=1000000; n&lt;10000000; n++)    {        if(log(n)+C&gt;=15)            {                printf(&quot;%d\n&quot;,n);                break;            }    }    return 0;}//----------------- 正常解法#include&lt;stdio.h&gt;int main(){    int n,k;    double sum=0;    for(int i=1; i&lt;10000000000000; i++)    {        double m=double((1000000000000000000.0/i));        sum+=m;       // printf(&quot;i=%d  m=%d  sum=%d\n&quot;,i,m,sum);        if(sum&gt;=15000000000000000000)        {            printf(&quot;i=%d  sum=%d&quot;,i,sum);            break;        }    }    return 0;}</code></pre><h2 id="3"><a href="#3" class="headerlink" title="3"></a>3</h2><hr><p>如果x的x次幂结果为10（参见【图1.png】），你能计算出x的近似值吗？</p><p>显然，这个值是介于2和3之间的一个数字。</p><p>请把x的值计算到小数后6位（四舍五入），并填写这个小数值。</p><p>注意：只填写一个小数，不要写任何多余的符号或说明。</p><pre><code>//手动二分#include &lt;stdio.h&gt;#include &lt;math.h&gt;int main(){    double x=2.506184;    double x10=pow(x,x);    printf(&quot;%.10lf\n&quot;,x10);    return 0;}//暴力#include &lt;stdio.h&gt;#include &lt;math.h&gt;int main(){   // double x=2.506184;    double x10;double x;    for(x=2.000000;x&lt;3;x+=0.0000001)    {         x10=pow(x,x);         if(x10&gt;=10)            break;    }    printf(&quot;%.10lf\n&quot;,x);    return 0;}</code></pre><h2 id="4"><a href="#4" class="headerlink" title="4"></a>4</h2><p>今有7对数字：两个1，两个2，两个3，…两个7，把它们排成一行。<br>要求，两个1间有1个其它数字，两个2间有2个其它数字，以此类推，两个7之间有7个其它数字。如下就是一个符合要求的排列：</p><p>17126425374635</p><p>当然，如果把它倒过来，也是符合要求的。</p><p>请你找出另一种符合要求的排列法，并且这个排列法是以74开头的。</p><p>注意：只填写这个14位的整数，不能填写任何多余的内容，比如说明注释等。</p><pre><code>#include &lt;stdio.h&gt;int a[15];int b[8];void judge(){    for(int i=1; i&lt;15; i++)        printf(&quot;%d&quot;,a[i]);    printf(&quot;+++++\n&quot;);}void dfs(int n){    //еп╤о/*    for(int i=1; i&lt;15; i++)        printf(&quot;%d&quot;,a[i]);    printf(&quot;      &quot;);    for(int i=1; i&lt;8; i++)        printf(&quot;%d&quot;,b[i]);    printf(&quot;\n&quot;);*/    if(n&gt;14)    {         judge();         return ;    }    if(a[n])    {        dfs(n+1);        return;    }    int sum=0;    for(int i=1; i&lt;7; i++)    {        if(b[i])            sum+=i;    }    if(sum==21)    {         judge();         return ;    }    for(int i=1; i&lt;7; i++)    {        if(b[i]||a[n+1+i]||n+1+i&gt;14||i==4)            continue;        if(a[n])        {            i--;            continue;        }        a[n]=i;        a[n+i+1]=i;        b[i]=1;        dfs(n+1);        a[n]=0;        a[n+i+1]=0;        b[i]=0;    }}int main(){    a[1]=7,a[2]=4,a[7]=4,a[9]=7;    b[7]=1,b[4]=1;    dfs(3);  //  judge();    int s;    scanf(&quot;%d&quot;,&amp;s);    return 0;}</code></pre><h2 id="5"><a href="#5" class="headerlink" title="5"></a>5</h2><p>勾股定理，西方称为毕达哥拉斯定理，它所对应的三角形现在称为：直角三角形。</p><p>已知直角三角形的斜边是某个整数，并且要求另外两条边也必须是整数。</p><p>求满足这个条件的不同直角三角形的个数。</p><p>【数据格式】<br>输入一个整数 n (0 &lt; n &lt; 10000000) 表示直角三角形斜边的长度。<br>要求输出一个整数，表示满足条件的直角三角形个数。</p><p>例如，输入：<br>5<br>程序应该输出：<br>1</p><p>再例如，输入：<br>100<br>程序应该输出：<br>2</p><p>再例如，输入：<br>3<br>程序应该输出：<br>0</p><p>资源约定：<br>峰值内存消耗 &lt; 256M<br>CPU消耗 &lt; 1000ms</p><p>请严格按要求输出，不要画蛇添足地打印类似：“请您输入…” 的多余内容。</p><p>所有代码放在同一个源文件中，调试通过后，拷贝提交该源码。</p><p>注意: main函数需要返回0<br>注意: 只使用ANSI C/ANSI C++ 标准，不要调用依赖于编译环境或操作系统的特殊函数。<br>注意: 所有依赖的函数必须明确地在源文件中 #include ， 不能通过工程设置而省略常用头文件。</p><p>提交时，注意选择所期望的编译器类型。</p><pre><code>#include &lt;stdio.h&gt;#include &lt;math.h&gt;#include &lt;iostream&gt;using namespace std;int main(){    int n,sum;    cin&gt;&gt;n;    sum=0;    double other;    for(int i=1; i&lt;n; i++)    {        other=n*n-i*i;        if(sqrt(other)==(int)sqrt(other))            sum++;    }    cout&lt;&lt;sum/2&lt;&lt;endl;    return 0;}</code></pre><h2 id="6"><a href="#6" class="headerlink" title="6"></a>6</h2><p>你一定听说过“数独”游戏。<br>如【图1.png】，玩家需要根据9×9盘面上的已知数字，推理出所有剩余空格的数字，并满足每一行、每一列、每一个同色九宫内的数字均含1-9，不重复。</p><p>数独的答案都是唯一的，所以，多个解也称为无解。</p><p>本图的数字据说是芬兰数学家花了3个月的时间设计出来的较难的题目。但对会使用计算机编程的你来说，恐怕易如反掌了。</p><p>本题的要求就是输入数独题目，程序输出数独的唯一解。我们保证所有已知数据的格式都是合法的，并且题目有唯一的解。</p><p>格式要求：<br>输入9行，每行9个数字，0代表未知，其它数字为已知。<br>输出9行，每行9个数字表示数独的解。</p><p>例如：<br>输入（即图中题目）：<br>005300000<br>800000020<br>070010500<br>400005300<br>010070006<br>003200080<br>060500009<br>004000030<br>000009700</p><p>程序应该输出：<br>145327698<br>839654127<br>672918543<br>496185372<br>218473956<br>753296481<br>367542819<br>984761235<br>521839764</p><p>再例如，输入：<br>800000000<br>003600000<br>070090200<br>050007000<br>000045700<br>000100030<br>001000068<br>008500010<br>090000400</p><p>程序应该输出：<br>812753649<br>943682175<br>675491283<br>154237896<br>369845721<br>287169534<br>521974368<br>438526917<br>796318452</p><p>资源约定：<br>峰值内存消耗 &lt; 256M<br>CPU消耗 &lt; 2000ms</p><p>请严格按要求输出，不要画蛇添足地打印类似：“请您输入…” 的多余内容。</p><p>所有代码放在同一个源文件中，调试通过后，拷贝提交该源码。</p><p>注意: main函数需要返回0<br>注意: 只使用ANSI C/ANSI C++ 标准，不要调用依赖于编译环境或操作系统的特殊函数。<br>注意: 所有依赖的函数必须明确地在源文件中 #include ， 不能通过工程设置而省略常用头文件。</p><p>提交时，注意选择所期望的编译器类型。</p><pre><code>#include &lt;cstdio&gt;#include &lt;cmath&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;char a[20][20],f=0;int judge(int x,int y){    //判断横竖有没有重的    for(int i=1; i&lt;10; i++)    {        if(i!=y&amp;&amp;a[x][i]==a[x][y]||i!=x&amp;&amp;a[i][y]==a[x][y])            return 0;    }    //判断小九宫格里有没有重的    int xx,yy;    if(x&gt;=1&amp;&amp;x&lt;=3)        xx=1;    else if(x&gt;=4&amp;&amp;x&lt;=6)        xx=4;    else if(x&gt;=7&amp;&amp;x&lt;=9)        xx=7;    if(y&gt;=1&amp;&amp;y&lt;=3)        yy=1;    else if(y&gt;=4&amp;&amp;y&lt;=6)        yy=4;    else if(y&gt;=7&amp;&amp;y&lt;=9)        yy=7;    int xxx=xx+3,yyy=yy+3;    for(int i=xx; i&lt;xxx; i++)    {        for(int j=yy; j&lt;yyy; j++)        {            if(a[i][j]==a[x][y])                if(i!=x&amp;&amp;j!=y)                    return 0;        }    }    return 1;}void output(){    for(int i=1; i&lt;=9; i++)    {        puts(a[i]+1);    }    return ;}void dfs(int x,int y){    if(f==1)        return;    if(x==9&amp;&amp;y==9)//到头了 要跳回去    {        output();        f=1;        return ;    }    for(int i=x; i&lt;10; i++)    {        for(int j=1; j&lt;10; j++)        {            if(a[i][j]!=&#39;0&#39;)            {                if(i==9&amp;&amp;j==9)                {                    output();                    f=1;                    return ;                }                continue;            }            for(int k=1; k&lt;10; k++)            {                a[i][j]=k+&#39;0&#39;;                if(judge(i,j))                    dfs(i,j);                a[i][j]=&#39;0&#39;;                if(i==9&amp;&amp;j==9)//到头了 要跳回去                {                    output();                    f=1;                    return ;                }                if(k==9)                    return ;            }        }    }}int main(){    // freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin);    // freopen(&quot;outt.txt&quot;, &quot;w&quot;, stdout);    for(int j=1; j&lt;=9; j++)    {        gets(a[j]+1);    }    dfs(1,1);    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  蓝桥杯 2014 B组 C++ 第五题 分形问题</title>
      <link href="/2016/03/15/50899795/"/>
      <url>/2016/03/15/50899795/</url>
      
        <content type="html"><![CDATA[<h1 id="蓝桥杯-2014-B组-C-第五题-分形问题"><a href="#蓝桥杯-2014-B组-C-第五题-分形问题" class="headerlink" title="蓝桥杯 2014 B组 C++ 第五题 分形问题"></a>蓝桥杯 2014 B组 C++ 第五题 分形问题</h1><p>2016年03月15日 20:42:54  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：1495<br>标签：  <a href="https://so.csdn.net/so/search/s.do?q=c语言&amp;t=blog" target="_blank" rel="noopener"> c语言 </a> <a href="https://so.csdn.net/so/search/s.do?q=图形&amp;t=blog" target="_blank" rel="noopener"> 图形</a> <a href="https://so.csdn.net/so/search/s.do?q=分形&amp;t=blog" target="_blank" rel="noopener"> 分形</a> <a href="https://so.csdn.net/so/search/s.do?q=蓝桥杯&amp;t=blog" target="_blank" rel="noopener"> 蓝桥杯</a></p><p>个人分类：  <a href="https://blog.csdn.net/qq_33184171/article/category/6042595" target="_blank" rel="noopener"> 分形 </a> <a href="https://blog.csdn.net/qq_33184171/article/category/6136180" target="_blank" rel="noopener"><br>蓝桥杯 </a></p><hr><p> 博客爬取于<code>2019-04-18 17:21:03</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/50899795" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/50899795</a></p><p>蓝桥杯2014第五题<br>打印图形：<br>小明在X星球的城堡了发现了如下图形和文字：<br>Rank=3<br><img src="https://img-blog.csdn.net/20151228172916859?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="这里写图片描述"><br>Rank=4<br><img src="https://img-blog.csdn.net/20151228172935235?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="这里写图片描述"><br>Rank=5<br><img src="https://img-blog.csdn.net/20151228172948657?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="这里写图片描述"></p><hr><p>题目是填空题 但是代码是自己写的 博客最下面有原代码</p><p>分形问题最主要的是找到图形的最基本的点<br>如POJ 2083 的那个X 基本构成 就是在九个方格里 左上，左下，中间，右上，右下，这5个位置 都有X 而数字每加一个 就把每一个X替换成这个基本的构成<br>POJ ： <a href="http://poj.org/problem?id=2083" target="_blank" rel="noopener"> http://poj.org/problem?id=2083 </a></p><p>这道题个基本构成就不是这么简单 不是每个三角形上的每个点 而是三角形上的 <strong> 一个顶点 </strong> 其实了解过分形的 看到这句就能解决了<br>之后就一遍又一遍的递归就好了 但千万注意 你递归的只是三角形的 <strong> 一个顶点 </strong> (选择这个图形选择上顶点会方便一些） 在打印图形的时候 要把 <strong><br>基本三角形的8个点 </strong> 都打印上</p><p>具体如下 <strong> 数字表示递归操作的层级 </strong><br><img src="https://img-blog.csdn.net/20160315203000610" alt="这里写图片描述"></p><p>画圈的就是所说的基本点 递归应从这里开始<br>然后找下一级图形的基本点<br>其实每个上级的基本点都是被递归多次的 毕竟分形就是大的图形中套用小的图形 一直套 直到分形处理结束 这时候就开始赋值了（也就是打印图形的过程）</p><hr><p>详情请看代码注释 很详细的哦</p><pre><code>#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;algorithm&gt;#include&lt;math.h&gt;using namespace std;char a[3000][3000];void  dayin(int car,int x,int y)  //核心算法 递归打印{    if(car==1)  //因为递归的只是三角形的定点 所以得把剩下所有的点 都给附上图形    {        a[x][y]=&#39;*&#39;;        a[x+1][y+1]=&#39;*&#39;;        a[x+1][y-1]=&#39;*&#39;;        a[x+2][y+2]=&#39;*&#39;;        a[x+2][y-2]=&#39;*&#39;;        a[x+3][y+1]=&#39;*&#39;;        a[x+3][y-1]=&#39;*&#39;;        a[x+3][y+3]=&#39;*&#39;;        a[x+3][y-3]=&#39;*&#39;;        return ;    }    int s=pow(2,car-2);    //这也是高    int e=pow(2,car-2);    //这也是宽度    dayin(car-1,x,y);   // dayin(car-1,x+s,y+e);       //因为图形是根据三个定点进行分形的  所以 只打印三个定点就好了 剩下的都不需要递归   // dayin(car-1,x+s,y-e);   // dayin(car-1,x+s*2,y+e*2);   // dayin(car-1,x+s*2,y-e*2);    dayin(car-1,x+s*4,y+e*4);    dayin(car-1,x+s*4,y-e*4);   // dayin(car-1,x+s*3,y+e);   // dayin(car-1,x+s*3,y-e);}int main(){    int t;    scanf(&quot;%d&quot;,&amp;t);    while(t--)    {        memset(a,&#39; &#39;,sizeof(a));        int n;        scanf(&quot;%d&quot;,&amp;n);        int s=pow(2,n-1);  //这是高        int e=pow(2,n);    //这是宽度        dayin(n,1,e/2);   //打印        for(int i=1;i&lt;=s;i++)  //把图形之外的都去掉            a[i][e]=&#39;\0&#39;;        for(int i=1;i&lt;=s;i++)            printf(&quot;%s\n&quot;,a[i]+1);    }}</code></pre><hr><p>精简版代码</p><pre><code>#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;algorithm&gt;#include&lt;math.h&gt;using namespace std;char a[3000][3000];void  dayin(int car,int x,int y){    if(car==1)      {        a[x][y]=&#39;*&#39;;        a[x+1][y+1]=&#39;*&#39;;        a[x+1][y-1]=&#39;*&#39;;        a[x+2][y+2]=&#39;*&#39;;        a[x+2][y-2]=&#39;*&#39;;        a[x+3][y+1]=&#39;*&#39;;        a[x+3][y-1]=&#39;*&#39;;        a[x+3][y+3]=&#39;*&#39;;        a[x+3][y-3]=&#39;*&#39;;        return ;    }    int s=pow(2,car-2);       int e=pow(2,car-2);      dayin(car-1,x,y);    dayin(car-1,x+s*4,y+e*4);    dayin(car-1,x+s*4,y-e*4);}int main(){    int t;    scanf(&quot;%d&quot;,&amp;t);    while(t--)    {        memset(a,&#39; &#39;,sizeof(a));        int n;        scanf(&quot;%d&quot;,&amp;n);        int s=pow(2,n-1);        int e=pow(2,n);          dayin(n,1,e/2);          for(int i=1;i&lt;=s;i++)             a[i][e]=&#39;\0&#39;;        for(int i=1;i&lt;=s;i++)            printf(&quot;%s\n&quot;,a[i]+1);    }}</code></pre><hr><p>蓝桥杯的代码(为填空)<br>其答案为 <strong> f(a,rank-1,row,col+w/2) </strong><br>他的想法和我稍有偏差 但是道理都一样的 这里就不在过多阐述了<br>但是他的这个代码还是值得读一读的</p><hr><pre><code>#define N 70void f(char a[][N], int rank, int row, int col){    if(rank==1)    {        a[row][col] = &#39;*&#39;;        return;    }    int w = 1;    int i;    for(i=0; i&lt;rank-1; i++)         w *= 2;    ____________________________________________;    f(a, rank-1, row+w/2, col);    f(a, rank-1, row+w/2, col+w);}int main(){    char a[N][N];    int i,j;    for(i=0; i&lt;N; i++)        for(j=0; j&lt;N; j++)            a[i][j] = &#39; &#39;;    f(a,6,0,0);    for(i=0; i&lt;N; i++)    {        for(j=0; j&lt;N; j++)            printf(&quot;%c&quot;,a[i][j]);        printf(&quot;\n&quot;);    }    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c语言 </tag>
            
            <tag> 图形 </tag>
            
            <tag> 分形 </tag>
            
            <tag> 蓝桥杯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  hrbust 1430 神秘植物 [递推+矩阵快速幂]</title>
      <link href="/2016/03/14/50888426/"/>
      <url>/2016/03/14/50888426/</url>
      
        <content type="html"><![CDATA[<h1 id="hrbust-1430-神秘植物-递推-矩阵快速幂"><a href="#hrbust-1430-神秘植物-递推-矩阵快速幂" class="headerlink" title="hrbust 1430 神秘植物 [递推+矩阵快速幂]"></a>hrbust 1430 神秘植物 [递推+矩阵快速幂]</h1><p>2016年03月14日 17:44:24  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：399</p><hr><p> 博客爬取于<code>2019-04-18 17:21:04</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/50888426" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/50888426</a></p><p><a href="http://acm.hrbust.edu.cn/index.php?m=ProblemSet&amp;a=showProblem&amp;problem_id=1430" target="_blank" rel="noopener"> 题目链接 </a></p><h1 id="神秘植物"><a href="#神秘植物" class="headerlink" title="神秘植物"></a>神秘植物</h1><p>Time Limit: 1000 MS Memory Limit: 65536 K<br>Total Submit: 49(25 users) Total Accepted: 23(19 users) Rating: Special Judge:<br>No<br>Description<br>Leyni有一种神秘的植物，形状是一种“向上”三角形植物，每过一年，每个“向上”三角形植物会变成三个“向上”三角形植物和一个“向下”三角形植物，每个“向下”<br>三角形植物会变成三个“向下”三角形植物和一个“向上”三角形植物。如下图：</p><p><img src="http://acm.hrbust.edu.cn/Public/problems_attached/image/20120523/20120523004932_94188.png" alt="1 2 3"></p><p>Leyni想知道经过n年有多少个“向上”三角形植物。</p><p>Input<br>输入包含多组测试数据。</p><p>对于每组测试数据：</p><p>第1行，包含一个整数n (0 ≤ n ≤ 10^18)</p><p>处理到文件结束</p><p>Output<br>对于每组测试数据：</p><p>第1行，输出Leyni拥有多少个“向上”三角形植物。(MOD 1000000007)</p><p>Sample Input<br>1</p><p>2</p><p>Sample Output<br>3</p><p>10</p><p>Author<br>齐达拉图@HRBUST</p><hr><p>这里先简单递推一下</p><p>序号  向上的三角形个数  向下的三角形个数</p><p>0</p><p>1</p><p>0</p><p>1</p><p>3</p><p>1</p><p>2</p><p>10</p><p>6</p><p>3</p><p>36</p><p>28</p><p>不难观察出规律 ，规律如下</p><p>.  递推公式</p><p>向上的三角</p><p>shang[i]=3*shang[i-1]+xia[i-1]</p><p>向下的三角</p><p>xia[i]=3*xia[i-1]+shang[i-1];</p><hr><p>虽然观察出了本题的规律了<br><strong> 但是! 但是!! 但是!!! </strong><br>观察input 题目说<br><strong> n (0 ≤ n ≤ 10^18) </strong><br><strong> n (0 ≤ n ≤ 10^18) </strong><br><strong> n (0 ≤ n ≤ 10^18) </strong></p><p>10^18次幂 先不说超时 光是数组也开不出来啊</p><p>怎么办呢 ??<br>仔细想想 用两个二维数组相乘的话 一个表示要乘的参数 一个用来存数据就能开出来了<br>数组如下</p><pre><code>long long int a[2][2],c[2][2];</code></pre><p>其中a用来存储数据 ，c用来存储要乘的参数 即如下</p><pre><code>a[0][0]=1; a[0][1]=0;a[1][0]=0; a[1][1]=0;c[0][0]=3; c[0][1]=1;c[1][0]=1; c[1][1]=3;</code></pre><p>这样下来用矩阵的乘法就能求了</p><p>上述已经解决了 内存爆的情况 但是 时间上怎么优化呢<br>既然是矩阵 那自然可以用矩阵快速幂来优化 这样下来时间可是几何倍数的被优化</p><p>不懂矩阵快速幂的可以看这里 <a href="http://blog.csdn.net/qq_33184171/article/details/50888118" target="_blank" rel="noopener"> 矩阵快速幂</a></p><p>时间 空间的优化都结束了 就可以A题了 ~~</p><hr><p>附本题代码</p><pre><code>#include&lt;stdio.h&gt;int m=1000000007;void mul(long long int a[2][2], long long int b[2][2]){    long long int c[2][2];    int i, j, k;    for(i=0;i&lt;2;i++)    {        for(j=0;j&lt;2;j++)        {            c[i][j]=0;            for(k=0;k&lt;2;k++)            {                c[i][j]=(c[i][j]+a[i][k]*b[k][j])%m;            }        }    }    for(i=0;i&lt;2;i++)    {        for(j=0;j&lt;2;j++)        {            b[i][j]=c[i][j];        }    }}long long int a[2][2], e[2][2];void init(){    e[0][0]=3; e[0][1]=1;    e[1][0]=1; e[1][1]=3;    a[0][0]=1; a[0][1]=0;    a[1][0]=0; a[1][1]=0;}void solve(long long int n){    init();    //n=n-1;    while (n &gt; 0)    {        if (n%2==1)        {            mul(e, a);        }        mul(e, e);        n = n &gt;&gt; 1;    }    printf(&quot;%lld\n&quot;, a[0][0]);}int main(){    long long int n;    while(~scanf(&quot;%lld&quot;, &amp;n))    {        solve(n);    }    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>&lt;转&gt;#  矩阵快速幂</title>
      <link href="/2016/03/14/50888118/"/>
      <url>/2016/03/14/50888118/</url>
      
        <content type="html"><![CDATA[<h1 id="矩阵快速幂"><a href="#矩阵快速幂" class="headerlink" title="矩阵快速幂"></a>矩阵快速幂</h1><p>2016年03月14日 17:15:41  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：341<br>标签：  <a href="https://so.csdn.net/so/search/s.do?q=矩阵快速幂&amp;t=blog" target="_blank" rel="noopener"> 矩阵快速幂 </a> <a href="https://so.csdn.net/so/search/s.do?q=矩阵乘法快速优化&amp;t=blog" target="_blank" rel="noopener"> 矩阵乘法快速优化</a></p><hr><p> 博客爬取于<code>2019-04-18 17:21:05</code><br><strong><em>以下为正文</em></strong></p><p>矩阵 快速幂</p><p>super_boy原创文章，转载请注明出处 <a href="http://www.cnblogs.com/yan-boy/archive/2012/11/29/2795294.html" target="_blank" rel="noopener"> 这里链接 </a></p><p>矩阵的快速幂是用来高效地计算矩阵的高次方的。将朴素的o（n）的时间复杂度，降到log（n）。</p><p>这里先对原理（主要运用了矩阵乘法的结合律）做下简单形象的介绍：</p><p>一般一个矩阵的n次方，我们会通过连乘n-1次来得到它的n次幂。</p><p>但做下简单的改进就能减少连乘的次数，方法如下：</p><p>把n个矩阵进行两两分组，比如：A<em>A</em>A<em>A</em>A<em>A =&gt; (A</em>A) _ (A<em>A) _ (A</em>A)</p><p>这样变的好处是，你只需要计算一次A<em>A，然后将结果(A</em>A)连乘自己两次就能得到A^6，即(A*A)^3=A^6。算一下发现这次一共乘了3次，少于原来的5次<br>。</p><p>其实大家还可以取A^3作为一个基本单位。原理都一样：利用矩阵乘法的结合律，来减少重复计算的次数。</p><p>以上都是取一个具体的数来作为最小单位的长度，这样做虽然能够改进效率，但缺陷也是很明显的，取个极限的例子（可能有点不恰当，但基本能说明问题），当n无穷大的时候<br>，你现在所取的长度其实和1没什么区别。所以就需要我们找到一种与n增长速度”相适应“的”单位长度“，那这个长度到底怎么去取呢？？？这点是我们要思考的问题。</p><p>有了以上的知识，我们现在再来看看，到底怎么迅速地求得矩阵的N次幂。</p><p>既然要减少重复计算，那么就要充分利用现有的计算结果咯！~怎么充分利用计算结果呢？？？这里考虑二分的思想。。</p><p>大家首先要认识到这一点：任何一个整数N，都能用二进制来表示。。这点大家都应该知道，但其中的内涵真的很深很深（这点笔者感触很深，在文章的最后，我将谈谈我对的感<br>想）！！</p><p>计算机处理的是离散的信息，都是以0,1来作为信号的处理的。可想而知二进制在计算机上起着举足轻重的地位。它能将模拟信号转化成数字信号，将原来连续的实际模型，用<br>一个离散的算法模型来解决。 好了，扯得有点多了，不过相信这写对下面的讲解还是有用的。</p><p>回头看看矩阵的快速幂问题，我们是不是也能把它离散化呢？比如A^19 =&gt; （A^16） _ （A^2） _<br>（A^1），显然采取这样的方式计算时因子数将是log(n)级别的(原来的因子数是n)，不仅这样，因子间也是存在某种联系的，比如A^4能通过(A^2) _<br>(A^2)得到，A^8又能通过(A^4) _ (A^4)得到，这点也充分利用了现有的结果作为有利条件。下面举个例子进行说明：</p><p>现在要求A^156,而156(10)=10011100(2)</p><p>也就有A^156=&gt;(A^4) _ (A^8) _ (A^16)*(A^128)<br>考虑到因子间的联系，我们从二进制10011100中的最右端开始计算到最左端。细节就说到这，下面给核心代码：</p><pre><code> while(N)  {      if(N&amp;1)          res=res*A;      n&gt;&gt;=1;      A=A*A;  } </code></pre><p>里面的乘号，是矩阵乘的运算，res是结果矩阵。</p><p>第3行代码每进行一次，二进制数就少了最后面的一个1。二进制数有多少个1就第3行代码就执行多少次。</p><p>好吧，矩阵快速幂的讲解就到这里吧。在文章我最后给出我实现快速幂的具体代码（代码以3*3的矩阵为例）。</p><p>现在我就说下我对二进制的感想吧：</p><p>我们在做很多”连续“的问题的时候都会用到二进制将他们离散简化</p><p>1.多重背包问题</p><p>2.树状数组</p><p>3.状态压缩DP</p><p>……………还有很多。。。究其根本还是那句话：化连续为离散。。很多时候我们并不是为了解决一个问题而使用二进制，更多是时候是为了优化而使用它。所以如果你想让你的<br>程序更加能适应大数据的情况，那么学习学习二进制及其算法思想将会对你有很大帮助。</p><p>最后贴出一些代码供大家学习，主要起演示的效果：</p><pre><code>#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;iostream&gt; using namespace std;int N;struct matrix{       int a[3][3];}origin,res;matrix multiply(matrix x,matrix y){       matrix temp;       memset(temp.a,0,sizeof(temp.a));       for(int i=0;i&lt;3;i++)       {               for(int j=0;j&lt;3;j++)               {                       for(int k=0;k&lt;3;k++)                       {                               temp.a[i][j]+=x.a[i][k]*y.a[k][j];                       }               }       }       return temp;}void init(){     printf(&quot;随机数组如下:\n&quot;);     for(int i=0;i&lt;3;i++)     {             for(int j=0;j&lt;3;j++)             {                     origin.a[i][j]=rand()%10;                     printf(&quot;%8d&quot;,origin.a[i][j]);             }             printf(&quot;\n&quot;);     }     printf(&quot;\n&quot;);     memset(res.a,0,sizeof(res.a));     res.a[0][0]=res.a[1][1]=res.a[2][2]=1;                  //将res.a初始化为单位矩阵 }void calc(int n){     while(n)     {             if(n&amp;1)                    res=multiply(res,origin);             n&gt;&gt;=1;             origin=multiply(origin,origin);     }     printf(&quot;%d次幂结果如下：\n&quot;,n);     for(int i=0;i&lt;3;i++)     {             for(int j=0;j&lt;3;j++)                     printf(&quot;%8d&quot;,res.a[i][j]);             printf(&quot;\n&quot;);     }     printf(&quot;\n&quot;);}int main(){    while(cin&gt;&gt;N)    {            init();            calc(N);    }    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 矩阵快速幂 </tag>
            
            <tag> 矩阵乘法快速优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  HDU 5643 bestcoder Round</title>
      <link href="/2016/03/13/50878582/"/>
      <url>/2016/03/13/50878582/</url>
      
        <content type="html"><![CDATA[<h1 id="HDU-5643-bestcoder-Round-75-king’s-game-威瑟夫问题"><a href="#HDU-5643-bestcoder-Round-75-king’s-game-威瑟夫问题" class="headerlink" title="HDU 5643 bestcoder Round #75 king’s game [威瑟夫问题]"></a>HDU 5643 bestcoder Round #75 king’s game [威瑟夫问题]</h1><p>2016年03月13日 16:27:26  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：544<br>标签：  <a href="https://so.csdn.net/so/search/s.do?q=威瑟夫问题&amp;t=blog" target="_blank" rel="noopener"> 威瑟夫问题 </a> <a href="https://so.csdn.net/so/search/s.do?q=HDU-5643&amp;t=blog" target="_blank" rel="noopener"> HDU-5643</a> <a href="https://so.csdn.net/so/search/s.do?q=bestcoder&amp;t=blog" target="_blank" rel="noopener"> bestcoder</a> <a href="https://so.csdn.net/so/search/s.do?q=king-s-gam&amp;t=blog" target="_blank" rel="noopener"> king-s-gam</a></p><p>个人分类：  <a href="https://blog.csdn.net/qq_33184171/article/category/6117382" target="_blank" rel="noopener"> hdu </a> <a href="https://blog.csdn.net/qq_33184171/article/category/6132246" target="_blank" rel="noopener"><br>bestcoder </a></p><hr><p> 博客爬取于<code>2019-04-18 17:21:06</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/50878582" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/50878582</a></p><p>中文题意<br>题目链接 <a href="http://acm.hdu.edu.cn/showproblem.php?pid=5643" target="_blank" rel="noopener"> HDU 5643 </a></p><p>King’s Game Accepts: 249 Submissions: 671<br>Time Limit: 2000/1000 MS (Java/Others) Memory Limit: 65536/65536 K<br>(Java/Others)<br>问题描述<br>为了铭记历史，国王准备在阅兵的间隙玩约瑟夫游戏。它召来了 n(1\le n\le 5000)n(1≤n≤5000) 个士兵，逆时针围成一个圈，依次标号 1,<br>2, 3 … n1,2,3…n。</p><p>第一轮第一个人从 11 开始报数，报到 11 就停止且报到 11 的这个人出局。</p><p>第二轮从上一轮出局的人的下一个人开始从 11 报数，报到 22 就停止且报到 22 的这个人出局。</p><p>第三轮从上一轮出局的人的下一个人开始从 11 报数，报到 33 就停止且报到 33 的这个人出局。</p><p>第 n - 1n−1 轮从上一轮出局的人的下一个人开始从 11 报数，报到 n - 1n−1 就停止且报到 n - 1n−1 的这个人出局。</p><p>最后剩余的人是幸存者，请问这个人的标号是多少？<br>输入描述<br>第一行一个整数表示测试组数：T(0 &lt; T≤5000) 。</p><p>每组数据占一行，包含一个整数 nn，表示 nn 个人围成一圈。<br>输出描述<br>共 TT 行。对每组数据，输出幸存者的编号。<br>输入样例<br>2<br>2<br>3<br>输出样例<br>2<br>2<br>Hint<br>对于第一组数据，一开始报到 11 的人即标号为 11 的人退出，幸存者是 22 号。</p><p>对于第二组数据，一开始报到 11 的人即标号 11 的人退出。接着 22 号报 11，33 号报 22，报到 22 的人即 33 号退出。幸存者是 22<br>号。</p><hr><p><strong> 本题是一个威瑟夫问题的变种 </strong><br><strong> 跟题目讲述的一样 </strong><br><strong> 第几轮 报道第几个数的人 就出局 </strong><br><strong> 而且每一轮最先报数的是上一轮出局的人的下一个人 （昨天竟然 </strong> <strong> 看成的每轮从标号最小的人开始报数 </strong> <strong> 唉 模拟打表都打错了。。。） </strong><br><strong> 所以要找到剩下的最后一人可以只找出局的人 </strong> <strong> 最后一次出局的人的 </strong> <strong> 下一个人就是最后剩下的人 </strong><br><strong> 这样就很好想了 </strong><br><strong> 我做个表来模拟下 </strong> <strong> 0表示上一局出局了的人的位置 其他出局用X表示 </strong></p><p>第一轮  第二轮  第三轮  第四轮  第五轮  第六轮</p><p>人</p><p>1 2 3 4 5 6 7</p><p>0 2 3 4 5 6 7</p><p>X 2 0 4 5 6 7</p><p>X 2 X 4 5 0 7</p><p>X 2 X 4 0 X 7</p><p>X 0 X 4 X X 7</p><p>标号</p><p>1 2 3 4 5 6 7</p><p>0 1 2 3 4 5 6</p><p>X 5 0 1 2 3 4</p><p>X 2 X 3 4 0 1</p><p>X 2 X 3 X 0 1</p><p>X X 0 1 X X 2</p><p>结果</p><p>preson.1 out</p><p>person.3 out</p><p>person.6 out</p><p>person.5 out</p><p>person.2 out</p><p>person.7 out</p><p>No.1 out</p><p>No.2 out</p><p>No.3 out</p><p>No.4 out</p><p>No.2(5%3) out</p><p>No.2(6%2) out</p><p>person.4 is winer</p><hr><p><strong> 设 n为总人数 i为轮数 </strong><br><strong> 通过上面的表很容易看出 </strong><br><strong> 每一轮重新标号的规律 </strong><br><strong> 假设该轮有n个人，那么上一轮(n+1)人，编号为0的人上一轮编号 _ * _ </strong> 为k，也即编号为a[n]的人上一轮编号为(a[n]+k)%(n+1)。 *<br><strong> 我们知道最后剩下的人在最后一轮编号肯定为0，那么这样不断倒推就可以推出其在第一轮的编号，也即他本来的编号。 </strong></p><p>附本题代码</p><hr><pre><code>#include&lt;iostream&gt;using namespace std;int a[5005];int main (){    a[1] = 0;    int n;     cin&gt;&gt;n;    while(n--)    {        int k; cin&gt;&gt;k;        for(int i = 2; i &lt;= n; i++)        {            a[i] = (a[i - 1] + k)%i;        }    }    cout&lt;&lt;a[n] + 1&lt;&lt;endl;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hdu </tag>
            
            <tag> 威瑟夫问题 </tag>
            
            <tag> HDU-5643 </tag>
            
            <tag> bestcoder </tag>
            
            <tag> king-s-gam </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  HDU 5641 国王的手机 king&#39;s phone</title>
      <link href="/2016/03/12/50867690/"/>
      <url>/2016/03/12/50867690/</url>
      
        <content type="html"><![CDATA[<h1 id="HDU-5641-国王的手机-king’s-phone"><a href="#HDU-5641-国王的手机-king’s-phone" class="headerlink" title="HDU 5641 国王的手机 king’s phone"></a>HDU 5641 国王的手机 king’s phone</h1><p>2016年03月12日 21:22:58  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：620</p><hr><p> 博客爬取于<code>2019-04-18 17:21:08</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/50867690" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/50867690</a></p><p>King’s Phone Accepts: 629 Submissions: 2980<br>Time Limit: 2000/1000 MS (Java/Others) Memory Limit: 65536/65536 K<br>(Java/Others)<br>问题描述<br>阅兵式上，国王见到了很多新奇东西，包括一台安卓手机。他很快对手机的图形解锁产生了兴趣。</p><p>解锁界面是一个 3 \times 33×3 的正方形点阵，第一行的三个点标号 1, 2, 31,2,3，第二行的三个点标号 4, 5,<br>64,5,6，第三行的三个点标号 7, 8, 97,8,9。密码本身是一段序列，表示经过点的先后顺序，但遵循如下规则：</p><ol><li><p>密码至少经过四个点。 </p></li><li><p>不能重复经过同一个点。 </p></li><li><p>路径上的中间点不能跳过，除非已经被经过（34273427 是合法的，但 37243724 不合法）。 </p></li></ol><p>他想设置的密码的长度为正整数 k(1\le k\le 9)k(1≤k≤9)，密码序列为 s_1 s_2…s_k(0&lt;=s_i &lt; INT MAX)<br>s​1​​ s​2…s​k(0≤ s​ &lt; int_max)，</p><p>他想知道这个密码序列是否合法，这个问题交给了你。<br>输入描述<br>第一行一个整数表示测试组数：T (0 &lt; T ≤100000) 。</p><p>每组数据占一行，每行第一个数 kk，设置密码的长度；接着 kk 个正整数，之间用空格隔开，表示密码序列 s_1s_2…s_ks​1 s​2 …s​k<br>​​ 。<br>输出描述<br>共 TT 行。对每组数据，若合法输出 valid，否则输出 invalid。</p><p>输入样例</p><p>3<br>4 1 3 6 2<br>4 6 2 1 3<br>4 8 1 6 7</p><p>输出样例</p><p>invalid<br>valid<br>valid</p><p>Hint<br>对于第一组数据，11 到 33 跳过了路径上的点 22，所以不合法。</p><p>对于第二组数据，11 到 33 时点 22 已经被经过了，所以合法。</p><p>对于第三组数据，8-&gt; 1-&gt; 6 -&gt; 7<br>8→1→6→7 路径均没有中间点，所以合法。</p><hr><p>本题主要是对不可能成立的判断</p><p>比如说 1-&gt;3是不可以的 因为中间会经过2<br>这样的有共有16种<br>one 与other 是两头的数 mid是中间的数 one-&gt;other时 如果mid没有被经过就是错误的 用数组标记一下就能判断有没有背经过<br>当然 我这个是单向的 如果双向的话会省一半</p><p>one  other  mid</p><p>1</p><p>7</p><p>4</p><p>1</p><p>9</p><p>5</p><p>1</p><p>3</p><p>2</p><p>2</p><p>8</p><p>5</p><p>3</p><p>1</p><p>2</p><p>3</p><p>7</p><p>5</p><p>3</p><p>9</p><p>6</p><p>4</p><p>6</p><p>5</p><p>6</p><p>4</p><p>5</p><p>7</p><p>1</p><p>4</p><p>7</p><p>3</p><p>5</p><p>7</p><p>9</p><p>8</p><p>8</p><p>2</p><p>5</p><p>9</p><p>1</p><p>5</p><p>9</p><p>3</p><p>6</p><p>9</p><p>7</p><p>8</p><p>本题有个坑点吧<br>就是输入的数 要在1~9 上 否则就应是 invalid</p><hr><p>附本题代码</p><pre><code>#include &lt;string.h&gt;#include &lt;stdio.h&gt;#include &lt;iostream&gt;using namespace std;int main(){   // freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin);    //freopen(&quot;outt.txt&quot;, &quot;w&quot;, stdout);    int n,m,k;    int a[12];    int b[102];    scanf(&quot;%d&quot;,&amp;k);    while(k--)    {        scanf(&quot;%d&quot;,&amp;n);        memset(a,0,sizeof(a));        memset(b,0,sizeof(b));        for(int i=0; i&lt;n; i++)            scanf(&quot;%d&quot;,&amp;a[i]);        if(n&lt;4)        {            printf(&quot;invalid\n&quot;);            continue;        }        int f=1;        for(int i=0; i&lt;n-1; i++)        {            if(a[i]&gt;9||a[i]&lt;1)                {                f=0;                break;            }            if(b[a[i]]==1)            {                f=0;                break;            }            b[a[i]]=1;            if(a[i]==1)            {                if((a[i+1]==3&amp;&amp;b[2]==0)||(a[i+1]==7&amp;&amp;b[4]==0)||(a[i+1]==9&amp;&amp;b[5]==0))                    f=0;            }            if(a[i]==2)            {                if(a[i+1]==8&amp;&amp;b[5]==0)                    f=0;            }            if(a[i]==3)            {                if((a[i+1]==1&amp;&amp;b[2]==0)||(a[i+1]==7&amp;&amp;b[5]==0)||(a[i+1]==9&amp;&amp;b[6]==0))                    f=0;            }            if(a[i]==4)            {                if(a[i+1]==6&amp;&amp;b[5]==0)                    f=0;            }            if(a[i]==6)            {                if(a[i+1]==4&amp;&amp;b[5]==0)                    f=0;            }            if(a[i]==7)            {                if((a[i+1]==1&amp;&amp;b[4]==0)||(a[i+1]==3&amp;&amp;b[5]==0)||(a[i+1]==9&amp;&amp;b[8]==0))                    f=0;            }            if(a[i]==8)            {                if(a[i+1]==2&amp;&amp;b[5]==0)                    f=0;            }            if(a[i]==9)            {                if((a[i+1]==1&amp;&amp;b[5]==0)||(a[i+1]==3&amp;&amp;b[6]==0)||(a[i+1]==7&amp;&amp;b[8]==0))                    f=0;            }             // cout&lt;&lt;a[i]&lt;&lt;&quot; &quot;&lt;&lt;b[i]&lt;&lt;endl;        }        if(b[a[n-1]]==1||a[n-1]&gt;9||a[n-1]&lt;1)            f=0;        if(f==0)          printf(&quot;invalid\n&quot;);        else            printf(&quot;valid\n&quot;);    }    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  hrbusr 1214&amp;PID314 / [NOIP2000]方格取数 [多线程DP]</title>
      <link href="/2016/03/12/50865290/"/>
      <url>/2016/03/12/50865290/</url>
      
        <content type="html"><![CDATA[<h1 id="hrbusr-1214-amp-PID314-NOIP2000-方格取数-多线程DP"><a href="#hrbusr-1214-amp-PID314-NOIP2000-方格取数-多线程DP" class="headerlink" title="hrbusr 1214&amp;PID314 / [NOIP2000]方格取数 [多线程DP]"></a>hrbusr 1214&amp;PID314 / [NOIP2000]方格取数 [多线程DP]</h1><p>2016年03月12日 14:07:12  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：521</p><hr><p> 博客爬取于<code>2019-04-18 17:21:09</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/50865290" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/50865290</a></p><p>题目描述<br>设有N<em>N的方格图(N&lt;=10,我们将其中的某些方格中填入正整数,而其他的方格中则放入数字0。如下图所示（见样例）：<br>某人从图的左上角的A 点出发，可以向下行走，也可以向右走，直到到达右下角的B点。在走过的路上，他可以取走方格中的数（取走后的方格中将变为数字0）。<br>此人从A点到B 点共走两次，试找出2条这样的路径，使得取得的数之和为最大。<br>输入格式<br>输入的第一行为一个整数N（表示N</em>N的方格图），接下来的每行有三个整数，前两个表示位置，第三个数为该位置上所放的数。一行单独的0表示输入结束。<br>输出格式<br>只需输出一个整数，表示2条路径上取得的最大的和。</p><p>Sample Input<br>8<br>2 3 13<br>2 6 6<br>3 5 7<br>4 4 14<br>5 2 21<br>5 6 4<br>6 3 15<br>7 2 14<br>0 0 0<br>Sample Output<br>67</p><hr><p>本题是一个多线程DP<br>总体思路就是一个dp[x1][y1][x2][y2],来表示从x1,y1 到x2,y2最多能够拿到的数值 在这里已经是两条路径所能的和最大值了 依次向下规划<br>就得到最终的结果</p><hr><p>附本题代码</p><pre><code> #include&lt;iostream&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include&lt;algorithm&gt;using namespace std;const int MAXN=11;int g[MAXN][MAXN];int sum[MAXN][MAXN][MAXN][MAXN];int max(int a, int b){    if(a&gt;b) return a;    else return b;}int main(){    int n;    int x,y,z;    while(scanf(&quot;%d&quot;,&amp;n)!=EOF)    {        memset(sum, 0, sizeof(sum));        memset(g, 0,sizeof(g));        while(1)        {            scanf(&quot;%d %d %d&quot;, &amp;x, &amp;y, &amp;z);            if(x == 0 &amp;&amp; y == 0 &amp;&amp; z == 0)                break;            g[x][y] = z;        }        for(int i=1; i&lt;=n; i++)        {            for(int j=1; j&lt;=n; j++)            {                for(int k=1; k&lt;=n; k++)                {                    for(int e=1; e&lt;=n; e++)                    {                        sum[i][j][k][e] = max(max(sum[i-1][j][k-1][e], sum[i][j-1][k][e-1]), max(sum[i-1][j][k][e-1], sum[i][j-1][k-1][e]));                        sum[i][j][k][e] += g[i][j];                        if(i!=k || j!=e) sum[i][j][k][e] += g[k][e];                    }                }            }        }        printf(&quot;%d\n&quot;,sum[n][n][n][n]);    }    return 0;}</code></pre><p>以为题目规定了 只能向右向下走,所以 很多步是走不到的<br>完全可以在优化一维 用三维dp来解题<br>如果理解了题目 很容易就能写出<br>这里就不赘述了</p>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  HDU1829&amp;POJ 2492 a bug&#39;s life [并查集||二分图染色]</title>
      <link href="/2016/03/10/50848661/"/>
      <url>/2016/03/10/50848661/</url>
      
        <content type="html"><![CDATA[<h1 id="HDU1829-amp-POJ-2492-a-bug’s-life-并查集-二分图染色"><a href="#HDU1829-amp-POJ-2492-a-bug’s-life-并查集-二分图染色" class="headerlink" title="HDU1829&amp;POJ 2492 a bug’s life [并查集||二分图染色]"></a>HDU1829&amp;POJ 2492 a bug’s life [并查集||二分图染色]</h1><p>2016年03月10日 17:36:49  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：424</p><hr><p> 博客爬取于<code>2019-04-18 17:21:10</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/50848661" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/50848661</a></p><h2 id="POJ-2492-a-bug’s-life-并查集-二分图染色"><a href="#POJ-2492-a-bug’s-life-并查集-二分图染色" class="headerlink" title="POJ 2492 a bug’s life [并查集||二分图染色]"></a>POJ 2492 a bug’s life [并查集||二分图染色]</h2><p>题目链接: <a href="http://poj.org/problem?id=2492" target="_blank" rel="noopener"> POJ </a> &lt;-点此进入链接 <a href="http://acm.hdu.edu.cn/showproblem.php?pid=1829" target="_blank" rel="noopener"> HDU</a> &lt;-点此进入链接</p><p>A Bug’s Life<br>Time Limit: 10000MS Memory Limit: 65536K<br>Total Submissions: 32887 Accepted: 10772<br>Description</p><p>Background<br>Professor Hopper is researching the sexual behavior of a rare species of bugs.<br>He assumes that they feature two different genders and that they only interact<br>with bugs of the opposite gender. In his experiment, individual bugs and their<br>interactions were easy to identify, because numbers were printed on their<br>backs.<br>Problem<br>Given a list of bug interactions, decide whether the experiment supports his<br>assumption of two genders with no homosexual bugs or if it contains some bug<br>interactions that falsify it.<br>Input</p><p>The first line of the input contains the number of scenarios. Each scenario<br>starts with one line giving the number of bugs (at least one, and up to 2000)<br>and the number of interactions (up to 1000000) separated by a single space. In<br>the following lines, each interaction is given in the form of two distinct bug<br>numbers separated by a single space. Bugs are numbered consecutively starting<br>from one.<br>Output</p><p>The output for every scenario is a line containing “Scenario #i:”, where i is<br>the number of the scenario starting at 1, followed by one line saying either<br>“No suspicious bugs found!” if the experiment is consistent with his<br>assumption about the bugs’ sexual behavior, or “Suspicious bugs found!” if<br>Professor Hopper’s assumption is definitely wrong.<br>Sample Input</p><p>2<br>3 3<br>1 2<br>2 3<br>1 3<br>4 2<br>1 2<br>3 4<br>Sample Output</p><p>Scenario #1:<br>Suspicious bugs found!</p><p>Scenario #2:<br>No suspicious bugs found!<br>Hint</p><p>Huge input,scanf is recommended.</p><hr><p>题目大意 : <strong> 就是让虫子a与虫子b交配 不能同性交配 输入的数是两个虫子的序号 就是交配的两个虫子 如果性别相同了 就输出”Suspicious<br>bugs found!” 否则输出”No suspicious bugs found!”.. </strong></p><p>Ps: _ 这题目 污的不是一星半点.. _</p><hr><h3 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h3><p>先说一说并查集吧</p><p>就是说利用并查集的父子节点来表示不同的性别 ,</p><p>要注意的是 每颗树上 先确定父节点的性别 以此来判断子节点的性别就行 差一辈的就是异性 差两辈的就是同性<br>之后在建一个数组来存储性别 可以定义0是一个性别 1是另一个性别 在join函数中 如果处理的两个节点 在同一颗树上 且同性 就是”Suspicious<br>bugs found!” 其他情况 就是”No suspicious bugs found!”</p><pre><code>#include &lt;iostream&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;algorithm&gt;const int M= 1005;const int MAX= 100005;const long long int MOD=1000000007;using namespace std;int pre[MAX];int vis[MAX],n,m;int color[MAX];//0  一个性别  1另一个性别int ans=1,cnt,q,flag;void ff(int n){    for(int i=1; i&lt;=n; i++)    {        pre[i]=i;    }    memset(color,0,sizeof(color));    return ;}int findi(int x)    //理解，加强理解 {    int rt;    if(x!=pre[x])    {        rt=findi(pre[x]);        color[x]=color[x]^color[pre[x]];        return pre[x]=rt;    }    return pre[x];}void join(int x,int y){    int fx=findi(x),fy=findi(y);    if(fx==fy)    {        ans=color[x]^color[y];    }    else    {        pre[fx]=fy;        color[fx]=~(color[x]^color[y]);    }}int main(){    int t,f=0;    scanf(&quot;%d&quot;,&amp;t);    while(t--)    {        if(f==1)   printf(&quot;\n&quot;);        f=1,ans=1;        scanf(&quot;%d%d&quot;,&amp;n,&amp;m);        ff(n);        int a,b;        for(int i=0;i&lt;m;i++)        {            scanf(&quot;%d %d&quot;,&amp;a,&amp;b);            if(ans)            join(a,b);        }        printf(&quot;Scenario #%d:\n&quot;,++q);        if(!ans)            printf(&quot;Suspicious bugs found!\n&quot;);        else            printf(&quot;No suspicious bugs found!\n&quot;);    }    return 0;}</code></pre><hr><h3 id="二分图染色"><a href="#二分图染色" class="headerlink" title="二分图染色"></a>二分图染色</h3><p>二分图染色来自于 <a href="http://www.lai18.com/content/952667.html" target="_blank" rel="noopener"> 此 </a></p><p>稍后 就贴上</p><p>昨天一天就弄着一道题了。</p><p>一开始的时候想法是判断是否存在奇数圈。如果存在，肯定有同性恋存在。</p><p>后来看到了别人的想法。就是，判二分图。</p><p>后来在，上课翻离散书的时候看到一个定理：n阶无向图是一个二分图当且仅当图中没有无奇数圈。</p><p>这样，判奇数圈和判二分图就是一个意思了。</p><p>那么，怎么来判奇数圈或者二分图呢？？？</p><p>搜索了一下，看到一种染色法判断二分图。意思就是，将图中的节点染色，如果能够把所有的点染成不同的两个颜色，并且不产生矛盾（相连的节点颜色相同）；</p><p>如图所示：<br><img src="https://img-blog.csdn.net/20140227132907250?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY3JlYXQyMDEy/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"> <img src="https://img-blog.csdn.net/20140227132930281?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY3JlYXQyMDEy/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>可以用BFS或DFS实现：</p><p>BFS：</p><pre><code>#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;vector&gt;#include &lt;queue&gt;#define CLR(arr,val) memset(arr,val,sizeof(arr))using namespace std;const int N=2005;int color,n,m;bool vis;vector&lt;int&gt; map;bool bfs(int s){    queue&lt;int&gt; q;    q.push(s);color[s]=1;    while(!q.empty()){        int now=q.front();        q.pop();        for(int i=1;i&lt;=10000000;i++);        printf(&quot;now %d\n&quot;,now);        if(!vis[now]){        int len=map[now].size();        for(int i=0;i&lt;len;i++){            int des=map[now][i];            q.push(des);            if(color[des]==-1)            color[des]=color[now]==0?1:0;            else {                if(color[des]==color[now]) return false;                else continue;            }        }        vis[now]=true;        }    }    return true;}int main(){    freopen(&quot;1.txt&quot;,&quot;r&quot;,stdin);    int T,k=1;    scanf(&quot;%d&quot;,&amp;T);    while(T--){        CLR(color,-1);CLR(vis,0);        CLR(map,0);        scanf(&quot;%d%d&quot;,&amp;n,&amp;m);        for(int i=1;i&lt;=m;i++){            int a,b;            scanf(&quot;%d%d&quot;,&amp;a,&amp;b);            map[a].push_back(b);            map[b].push_back(a);        }        int i;        printf(&quot;Scenario #%d:\n&quot;,k++);        for(i=1;i&lt;=n;i++){            if(!vis[i]){                bool flag=bfs(i);                if(!flag){                    printf(&quot;Suspicious bugs found!\n\n&quot;);                    break;                }            }        }        if(i&gt;n) printf(&quot;No suspicious bugs found!\n\n&quot;);    }    return 0;}</code></pre><p>DFS：</p><pre><code>#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;vector&gt;#define CLR(arr,val) memset(arr,val,sizeof(arr))using namespace std;const int N=2003;int n,m,color;vector&lt;int&gt; map;bool vis;bool dfs(int s){    vis[s]=true;    int len=map[s].size();    for(int i=0;i&lt;len;i++){        int des=map[s][i];        if(color[des]==color[s]) return false;        if(color[des]==-1){            color[des]=color[s]==0?1:0;            if(!dfs(des)) return false;        }    }    return true;}int main(){    freopen(&quot;1.txt&quot;,&quot;r&quot;,stdin);    int T,k=1;    scanf(&quot;%d&quot;,&amp;T);    while(T--){        CLR(map,0);        CLR(vis,0);CLR(color,-1);        scanf(&quot;%d%d&quot;,&amp;n,&amp;m);        for(int i=1;i&lt;=m;i++){            int a,b;            scanf(&quot;%d%d&quot;,&amp;a,&amp;b);            map[a].push_back(b);            map[b].push_back(a);        }        printf(&quot;Scenario #%d:\n&quot;,k++);        bool flag=false;        for(int i=1;i&lt;=n;i++){            if(!vis[i]){                color[i]=1;                if(!dfs(i)){                    flag=true;                    break;                }            }        }        if(flag) printf(&quot;Suspicious bugs found!\n\n&quot;);        else printf(&quot;No suspicious bugs found!\n\n&quot;);    }    return 0;}</code></pre><p>无论BFS还是DFS，需要注意的是，所有的节点可能出现在不同的集合中。需要多次BFS或DFS。</p><p>二分图染色来自于 <a href="http://www.lai18.com/content/952667.html" target="_blank" rel="noopener"> 此 </a></p>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  HDU 1325&amp;POJ 1308 Is it A tree ? [并查集+树判定]</title>
      <link href="/2016/03/09/50838736/"/>
      <url>/2016/03/09/50838736/</url>
      
        <content type="html"><![CDATA[<h1 id="HDU-1325-amp-POJ-1308-Is-it-A-tree-并查集-树判定"><a href="#HDU-1325-amp-POJ-1308-Is-it-A-tree-并查集-树判定" class="headerlink" title="HDU 1325&amp;POJ 1308 Is it A tree ? [并查集+树判定]"></a>HDU 1325&amp;POJ 1308 Is it A tree ? [并查集+树判定]</h1><p>2016年03月09日 21:06:53  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：451</p><hr><p> 博客爬取于<code>2019-04-18 17:21:11</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/50838736" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/50838736</a></p><p>题目链接 <a href="http://poj.org/problem?id=1308" target="_blank" rel="noopener"> poj </a> <a href="http://acm.hdu.edu.cn/showproblem.php?pid=1325" target="_blank" rel="noopener"> hdu</a></p><p>Is It A Tree?</p><p>Time Limit: 2000/1000 MS (Java/Others) Memory Limit: 65536/32768 K<br>(Java/Others)</p><p>Total Submission(s): 421 Accepted Submission(s): 157</p><p>Problem Description</p><p>A tree is a well-known data structure that is either empty (null, void,<br>nothing) or is a set of one or more nodes connected by directed edges between<br>nodes satisfying the following properties.<br>There is exactly one node, called the root, to which no directed edges point.</p><p>Every node except the root has exactly one edge pointing to it.</p><p>There is a unique sequence of directed edges from the root to each node.</p><p>For example, consider the illustrations below, in which nodes are represented<br>by circles and edges are represented by lines with arrowheads. The first two<br>of these are trees, but the last is not.</p><p><img src="http://acm.hdu.edu.cn/data/images/1325-1.gif" alt="这里写图片描述"><br><img src="http://acm.hdu.edu.cn/data/images/1325-2.gif" alt="这里写图片描述"><br><img src="http://acm.hdu.edu.cn/data/images/1325-3.gif" alt="这里写图片描述"></p><p>In this problem you will be given several descriptions of collections of nodes<br>connected by directed edges. For each of these you are to determine if the<br>collection satisfies the definition of a tree or not.</p><p>Input</p><p>The input will consist of a sequence of descriptions (test cases) followed by<br>a pair of negative integers. Each test case will consist of a sequence of edge<br>descriptions followed by a pair of zeroes Each edge description will consist<br>of a pair of integers; the first integer identifies the node from which the<br>edge begins, and the second integer identifies the node to which the edge is<br>directed. Node numbers will always be greater than zero.</p><p>Output<br>For each test case display the line <code>Case k is a tree.\\\\\\\\\\\\\&quot; or theline</code> Case k is not a tree.\\\\”, where k corresponds to the test case<br>number (they are sequentially numbered starting with 1).</p><p>Sample Input</p><p>6 8 5 3 5 2 6 4<br>5 6 0 0</p><p>8 1 7 3 6 2 8 9 7 5<br>7 4 7 8 7 6 0 0</p><p>3 8 6 8 6 4<br>5 3 5 6 5 2 0 0</p><p>-1 -1 </p><p>Sample Output</p><p>Case 1 is a tree.<br>Case 2 is a tree.<br>Case 3 is not a tree.</p><hr><p>程序分析（转载）：</p><p>这道题跟 <a href="http://blog.csdn.net/qq_33184171/article/details/50838424" target="_blank" rel="noopener"> 小希的迷宫 </a><br>有很大的相似吧，只是一个是无向图一个是有向图。也是给你那些结点之间的信息，然后让你判断是不是一颗树罢了，用树的定义来 判断吧，无环，n个结点最多有n-<br>1条边，不然就会有环。只有一个入度为0的结点，不存在入度大于1的结点。这些也足以判断是否为一棵树了吧。不过要注意 一些特殊数据的情况，空树也是树。比如输入0<br>0。</p><p>解决方法：</p><p>其实也可以不用并查集，这样就可以直接按照上面的条件来统计，就可以判断是不是一颗树了。</p><p>自我感言：额，这道题目关键就是判断树的那几个标准，1，无环；2，除了根，所有的入度为1，根入度为0；3，这个结构只有一个根，不然是森林了。</p><p>这是三个标准拿捏好，再注意这里空树也是树。基本上就ok了。。</p><p>坑爹的是下边的代码可以在hdu上通过，而不能在poj上通过。。。。。看了discuss才知道 1 1 0 0 不能是树。</p><p><strong> 下面几种情况要注意了。。。。 </strong><br>1: 0 0 空树是一棵树<br>2: 1 1 0 0 不是树 不能自己指向自己<br>3: 1 2 1 2 0 0 不是树….自己开始一直在这么WA 好郁闷 重复都不行呀~~5555<br>4: 1 2 2 3 4 5 不是树 森林不算是树(主要是注意自己)<br>5: 1 2 2 3 3 4 4 5 5 6 6 7 7 8 8 9 9 1 注意 一个节点在指向自己的父亲或祖先 都是错误的 即 9–&gt;1 错<br>6: 1 2 2 1 0 0 也是错误的这样基本上就可以在poj上通过了，poj(1308) 题这是hdu上通过的代码：</p><pre><code>#include &lt;stdio.h&gt;const int max_num = 100000+10;typedef struct{    int num,root,conn;//数据、根、入度}Node;Node node[max_num];void init(){    for(int i = 0; i &lt; max_num; i++)    {        node[i].conn = 0;//入度初始化为0        node[i].root= i;//根记录为自身        node[i].num=0;//标记数字是否被使用过，0:没有被使用过，1:使用过了    }}int find_root(int a){    if(node[a].root!=a)        return node[a].root = find_root(node[a].root);    return node[a].root;}void union_set(int a,int b){    a = find_root(a);    b = find_root(b);    if(a==b)//同一个根，说明是在同一个树下    return;    node[b].root=a;//把b的根赋为a的根，此时a已经是根，num==root}int main(){    int n,m;    int i = 1;    bool flag=true;//true：是个树，false:不是树    init();    while(scanf(&quot;%d%d&quot;,&amp;n,&amp;m)!=EOF&amp;&amp;n&gt;=0&amp;&amp;m&gt;=0)    {        if(!flag&amp;&amp;n!=0&amp;&amp;n!=0)continue;//已经确定不是树了，就继续循环        if(n==0&amp;&amp;m==0)        {            int root_num=0;            for(int j = 1; j &lt; max_num;j++)            {                //判断是否为森林，如果，root_num用来记录根的数目                if(node[j].num &amp;&amp; find_root(j)==j)                root_num++;                if(node[j].conn&gt;1)//如果出现某个节点的入度超过1，不是树                {                    flag = false;                    break;                }            }            if(root_num&gt;1)//连通分支大于1，是森林不是树                flag=false;            if(flag)            printf(&quot;Case %d is a tree.\n&quot;,i++);            else printf(&quot;Case %d is not a tree.\n&quot;,i++);            flag = true;            init();            continue;        }        if(m!=n&amp;&amp;find_root(n)==find_root(m))        flag = false;        else        {            //将m,n，记录为节点            node[m].num = 1;            node[n].num = 1;            node[m].conn++;//入度增加一            union_set(n,m);        }    }    return 0;} </code></pre><p>中间只是稍作修改，把if(m!=n&amp;&amp;find_root(n)==find_root(m))改成了if((m!=n&amp;&amp;find_root(n)==find_<br>root(m))||m==n）就在poj上通过了</p><pre><code>#include &lt;stdio.h&gt;const int max_num = 100000+10;typedef struct{    int num,root,conn;//数据、根、入度}Node;Node node[max_num];void init(){    for(int i = 0; i &lt; max_num; i++)    {        node[i].conn = 0;//入度初始化为0        node[i].root= i;//根记录为自身        node[i].num=0;//标记数字是否被使用过，0:没有被使用过，1:使用过了    }}int find_root(int a){    if(node[a].root!=a)        return node[a].root = find_root(node[a].root);    return node[a].root;}void union_set(int a,int b){    a = find_root(a);    b = find_root(b);    if(a==b)//同一个根，说明是在同一个树下    return;    node[b].root=a;//把b的根赋为a的根，此时a已经是根，num==root}int main(){    int n,m;    int i = 1;    bool flag=true;//true：是个树，false:不是树    init();    while(scanf(&quot;%d%d&quot;,&amp;n,&amp;m)!=EOF&amp;&amp;n&gt;=0&amp;&amp;m&gt;=0)    {        if(!flag&amp;&amp;n!=0&amp;&amp;n!=0)continue;//已经确定不是树了，就继续循环        if(n==0&amp;&amp;m==0)        {            int root_num=0;            for(int j = 1; j &lt; max_num;j++)            {                //判断是否为森林，如果，root_num用来记录根的数目                if(node[j].num &amp;&amp; find_root(j)==j)                root_num++;                if(node[j].conn&gt;1)//如果出现某个节点的入度超过1，不是树                {                    flag = false;                    break;                }            }            if(root_num&gt;1)//连通分支大于1，是森林不是树                flag=false;            if(flag)            printf(&quot;Case %d is a tree.\n&quot;,i++);            else printf(&quot;Case %d is not a tree.\n&quot;,i++);            flag = true;            init();            continue;        }        if((m!=n&amp;&amp;find_root(n)==find_root(m))||m==n)        flag = false;        else        {            //将m,n，记录为节点            node[m].num = 1;            node[n].num = 1;            node[m].conn++;//入度增加一            union_set(n,m);        }    }    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  HDU 1272 小希的迷宫 [并查集+回路判定]</title>
      <link href="/2016/03/09/50838424/"/>
      <url>/2016/03/09/50838424/</url>
      
        <content type="html"><![CDATA[<h1 id="HDU-1272-小希的迷宫-并查集-回路判定"><a href="#HDU-1272-小希的迷宫-并查集-回路判定" class="headerlink" title="HDU 1272 小希的迷宫 [并查集+回路判定]"></a>HDU 1272 小希的迷宫 [并查集+回路判定]</h1><p>2016年03月09日 20:29:54  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：251</p><hr><p> 博客爬取于<code>2019-04-18 17:21:12</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/50838424" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/50838424</a></p><h2 id="题目链接-lt-点此进入链接"><a href="#题目链接-lt-点此进入链接" class="headerlink" title=" 题目链接  &lt;-点此进入链接"></a><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1272" target="_blank" rel="noopener"> 题目链接 </a> &lt;-点此进入链接</h2><p>小希的迷宫</p><p>Time Limit: 2000/1000 MS (Java/Others) Memory Limit: 65536/32768 K<br>(Java/Others)<br>Total Submission(s): 39392 Accepted Submission(s): 12092</p><p>Problem Description<br>上次Gardon的迷宫城堡小希玩了很久（见Problem B），现在她也想设计一个迷宫让Gardon来走。但是她设计迷宫的思路不一样，首先她认为所有的通道都<br>应该是双向连通的，就是说如果有一个通道连通了房间A和B，那么既可以通过它从房间A走到房间B，也可以通过它从房间B走到房间A，为了提高难度，小希希望任意两个房<br>间有且仅有一条路径可以相通（除非走了回头路）。小希现在把她的设计图给你，让你帮忙判断她的设计图是否符合她的设计思路。比如下面的例子，前两个是符合条件的，但是<br>最后一个却有两种方法从5到达8。</p><p>Input<br>输入包含多组数据，每组数据是一个以0<br>0结尾的整数对列表，表示了一条通道连接的两个房间的编号。房间的编号至少为1，且不超过100000。每两组数据之间有一个空行。<br>整个文件以两个-1结尾。</p><p>Output<br>对于输入的每一组数据，输出仅包括一行。如果该迷宫符合小希的思路，那么输出”Yes”，否则输出”No”。</p><p>Sample Input<br>6 8 5 3 5 2 6 4<br>5 6 0 0</p><p>8 1 7 3 6 2 8 9 7 5<br>7 4 7 8 7 6 0 0</p><p>3 8 6 8 6 4<br>5 3 5 6 5 2 0 0</p><p>-1 -1 </p><p>Sample Output<br>Yes<br>Yes<br>No</p><hr><p>本题就是一个简单的用并查集判断回路有无的问题</p><p>1.在连接两个点的时候 如果这两个点的父节点相同 那 再进行连接这两个点的操作 就会产生回路.</p><p>2.连通图中 他的父节点只有一个 如果多于一个 就是存在 没有联通的点.</p><h2 id="附本题代码"><a href="#附本题代码" class="headerlink" title="附本题代码"></a>附本题代码</h2><hr><pre><code>#include &lt;iostream&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;algorithm&gt;const int M= 1005;const int MAX= 100005;const long long int MOD=1000000007;using namespace std;int pre[MAX];int vis[MAX];int ans,cnt;void ff(int n){    for(int i=0; i&lt;MAX; i++)    {        pre[i]=i;        vis[i]=0;    }    return ;}int findi(int x){    int r=x;    while(r!=pre[r])        r=pre[r];    int i=x,j;  //路径压缩    while(i!=j)    {        j=pre[i];        pre[i]=r;        i=j;    }    return r;}int join(int x,int y){    int fx=findi(x),fy=findi(y);    if(fx!=fy)        pre[fx]=fy;    else ans=0; //.在连接两个点的时候 如果这两个点的父节点相同 那 再进行连接这两个点的操作 就会产生回路.}int main(){    int f=0;    while(true)    {        int i,mini=0x1f1f1f,maxi=-0x1f1f1f,a,b;        memset(vis,0,sizeof(vis));        ff(i);        ans=1,cnt=0;        for(i=0; i&lt;MAX; i++)        {            scanf(&quot;%d%d&quot;,&amp;a,&amp;b);            if(a==0&amp;&amp;b==0)break;            if(a==-1&amp;&amp;b==-1)            {                f=1;                break;            }            mini=min(mini,min(a,b));            maxi=max(maxi,max(a,b));            join(a,b);            vis[a]=vis[b]=1;        }        if(f==1)            break;        if(ans)        for(i=mini; i&lt;=maxi; i++)   //看图是否连通        {            if(pre[i]==i &amp;&amp; vis[i])                cnt++;            if(cnt&gt;1)       //连通图中只有根节点的父节点是自身，cnt应该是1            {                ans=0;                break;            }        }        if(ans) printf(&quot;Yes\n&quot;);        else printf(&quot;No\n&quot;);    }    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  POJ 1611 The Suspects 【并查集】</title>
      <link href="/2016/03/09/50834496/"/>
      <url>/2016/03/09/50834496/</url>
      
        <content type="html"><![CDATA[<h1 id="POJ-1611-The-Suspects-【并查集】"><a href="#POJ-1611-The-Suspects-【并查集】" class="headerlink" title="POJ 1611 The Suspects 【并查集】"></a>POJ 1611 The Suspects 【并查集】</h1><p>2016年03月09日 13:08:53  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：260<br>标签：  <a href="https://so.csdn.net/so/search/s.do?q=poj&amp;t=blog" target="_blank" rel="noopener"> poj </a> <a href="https://so.csdn.net/so/search/s.do?q=并查集&amp;t=blog" target="_blank" rel="noopener"> 并查集</a></p><p>个人分类：  <a href="https://blog.csdn.net/qq_33184171/article/category/6114215" target="_blank" rel="noopener"> POJ </a></p><hr><p> 博客爬取于<code>2019-04-18 17:21:13</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/50834496" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/50834496</a></p><p>The Suspects<br>Time Limit:1000MS Memory Limit:20000KB 64bit IO Format:%I64d &amp; %I64u<br>Submit</p><p>Status<br>Description<br>严重急性呼吸系统综合症( SARS), 一种原因不明的非典型性肺炎,从2003年3月中旬开始被认为是全球威胁。为了减少传播给别人的机会,<br>最好的策略是隔离可能的患者。<br>在Not-Spreading-Your-Sickness大学( NSYSU), 有许多学生团体。同一组的学生经常彼此相通,一个学生可以同时加入几个小组。为了<br>防止非典的传播,NSYSU收集了所有学生团体的成员名单。他们的标准操作程序(SOP)如下：<br>一旦一组中有一个可能的患者, 组内的所有成员就都是可能的患者。<br>然而,他们发现当一个学生被确认为可能的患者后不容易识别所有可能的患者。你的工作是编写一个程序, 发现所有可能的患者。</p><p>Input<br>输入文件包含多组数据。<br>对于每组测试数据：<br>第一行为两个整数n和m, 其中n是学生的数量, m是团体的数量。0 &lt; n &lt;= 30000，0 &lt;= m &lt;= 500。<br>每个学生编号是一个0到n-1之间的整数，一开始只有0号学生被视为可能的患者。<br>紧随其后的是团体的成员列表，每组一行。<br>每一行有一个整数k，代表成员数量。之后,有k个整数代表这个群体的学生。一行中的所有整数由至少一个空格隔开。<br>n = m = 0表示输入结束，不需要处理。<br>Output<br>对于每组测试数据, 输出一行可能的患者。<br>Sample Input<br>100 4<br>2 1 2<br>5 10 13 11 12 14<br>2 0 1<br>2 99 2<br>200 2<br>1 5<br>5 1 2 3 4 5<br>1 0<br>0 0<br>Sample Output<br>4<br>1<br>1</p><p>并查集基础<br>不解释</p><pre><code>#include &lt;iostream&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;using namespace std;int pre[30005];int a[30005];void ff(int n){    for(int i=0;i&lt;n;i++)        pre[i]=i;    return ;}int findi(int x){    int r=x;    while(r!=pre[r])        r=pre[r];    int i=x,j;  //一定要路径压缩 否则超时    while(i!=j)    {        j=pre[i];        pre[i]=r;        i=j;    }    return r;}int join(int x,int y){    int fx=findi(x),fy=findi(y);    if(fx!=fy)        pre[fy]=fx;}int main(){    int n,m;    while(scanf(&quot;%d%d&quot;,&amp;n,&amp;m)!=EOF)    {        if(n==0&amp;&amp;m==0) break;        ff(n);        while(m--)        {            int t,tt;            scanf(&quot;%d&quot;,&amp;t);            for(int i=0;i&lt;t;i++)            {                scanf(&quot;%d&quot;,&amp;a[i]);                if(i&gt;0)                join(a[i],a[0]);            }        }        int sum=0;        for(int i=0;i&lt;n;i++)        {            if(findi(i)==findi(0))//一定要findi                 sum++;        }        printf(&quot;%d\n&quot;,sum);    }    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并查集 </tag>
            
            <tag> poj </tag>
            
            <tag> POJ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  POJ 3768 Repeater 较复杂 分形 题目</title>
      <link href="/2016/03/08/50826765/"/>
      <url>/2016/03/08/50826765/</url>
      
        <content type="html"><![CDATA[<h1 id="POJ-3768-Repeater-较复杂-分形-题目"><a href="#POJ-3768-Repeater-较复杂-分形-题目" class="headerlink" title="POJ 3768 Repeater 较复杂 分形 题目"></a>POJ 3768 Repeater 较复杂 分形 题目</h1><p>2016年03月08日 14:06:30  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：927</p><hr><p> 博客爬取于<code>2019-04-18 17:21:14</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/50826765" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/50826765</a></p><p><a href="http://poj.org/problem?id=3768" target="_blank" rel="noopener"> 本题网址 </a> &lt;-点此进入链接</p><p>Repeater<br>Time Limit: 1000MS<br>Memory Limit: 65536K<br>Total Submissions: 4187<br>Accepted: 1114<br>Description<br>Harmony is indispensible in our daily lifeand no one can live without it—-may<br>be Facer is the only exception. One dayit is rumored that repeat painting will<br>create harmony and then hundreds ofpeople started their endless drawing. Their<br>paintings were based on a smalltemplate and a simple method of duplicating.<br>Though Facer can easily imaginethe style of the whole picture, but he cannot<br>find the essential harmony. Nowyou need to help Facer by showing the picture<br>on computer.<br>You will be given a template containingonly one kind of character and spaces,<br>and the template shows how the endlesspicture is created—-use the characters<br>as basic elements and put them in theright position to form a bigger template,<br>and then repeat and repeat doingthat. Here is an example.</p><pre><code># # #     &lt;-template# #So the Level 1 picture will be# # ## #Level 2 picture will be# #   # # #     ## #   # #   # #       #       # #   # #   # # #     # # #   # #InputThe input contains multiple test cases.Thefirst line of each case is an integer N, representing the size of the template is N*N (N could only be 3, 4 or 5).Next Nlines describe the template.Thefollowing line contains an integer Q, which is the Scale Level of the picture.Inputis ended with a case of N=0.It isguaranteed that the size of one picture will not exceed 3000*3000.OutputFor each test case, just print the Level Q picture by using the given template.Sample Input3# # ## #13# # ## #34 OOO  OO  O OO20Sample Output# # ## ## #   # #        # #   # # #    #           #     ## #   # #        # #   # #   # #               # #      #                 #      # #               # #  # #   # #        # #   # # #    #           #     ## #   # #        # #   # #         # #  # #                  #    #                  # #  # #                    # #                        #                        # #                    # #   # #                  #    #                  # #  # #        # #   # #        # #   # # #    #           #     ## #   # #        # #   # #   # #               # #      #                 #      # #               # #  # #   # #        # #   # # #    #           #     ## #   # #        # #   # #     OO OO        O OO  O       O OO  O        OO OO     OO         OOO  O       O  OO  O       O  O OO         OO OO         OOO  O       O  OO  O       O  O OO         OO     OO OO        O OO  O       O OO  O        OO OO    </code></pre><p>本题就是一个基础的分形问题 ，只不过是在一个自己定义的图形中，再进行分形处理 。<br>所以我们一定要把最先定义的图形遍历一遍 找到他的基础结构。用一个二维的数组标记出他的最基础构型 ，就可以开始分型了。<br>稍有不同的是在分形打印的函数中的递归函数需要双层的for循环来遍历标记数组，<br>其实在遍历标记数组的时候发现比把每个都写出来要容易操作的多（但时间复杂度会变高），当然本题必须采用遍历的操作才可以，因为自己定义的图形，在没有定义的时候，他<br>的结构就是未知的，所以必须遍历。</p><p>接下来就是简单的分型操作了相信你在做这道题的时候已经掌握分形的操作了 这里就不在赘述了</p><p>PS：如果真的不了解分形的话，可以看看这篇博客。<br><a href="http://blog.csdn.net/qq_33184171/article/details/50390031" target="_blank" rel="noopener"> 2014年蓝桥杯第五题 分型问题 判断递归起点稍有不同</a> &lt;-点此进入链接<br><a href="http://blog.csdn.net/qq_33184171/article/details/50274193" target="_blank" rel="noopener"> 哈理工OJ 题目格式较本题稍复杂</a> &lt;-点此进入链接</p><p>另附解题代码</p><pre><code>#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;math.h&gt;char a[3002][3002];//图形char asdf;//分形图形中的字符char b[6];//输入用的int num,n;int flag[6][6];//本组数据是标记用的void dayin(int cur,int x,int y){    if(cur==1)    {       a[x][y]=asdf;       return ;    }   int s=pow(n,cur-2);   for(int i=0; i&lt;n; i++)//这就是遍历标记数组    {       for(int j=0; j&lt;n; j++)       {           if(flag[i][j]==1)//如果没有运行就不采取操作                dayin(cur-1,x+i*s,y+j*s);       }    }}int main(){   while(~scanf(&quot;%d&quot;,&amp;n))    {       getchar();       if(n==0) break;       memset(a,&#39; &#39;,sizeof(a));       memset(flag,0,sizeof(flag));       for(int i=0; i&lt;n; i++)       {           gets(b);           for(int j=0; j&lt;n; j++)//遍历图形 并标记           {                if(b[j]!=&#39; &#39;)                {                    asdf=b[j];                    flag[i][j]=1; //标记                }           }       }       int m;       scanf(&quot;%d&quot;,&amp;m);       int s=pow(n,m);       dayin(m+1,1,1);       for(inti=1; i&lt;=s; i++)//这步主要是控制格式       {           a[i][s+1]=&#39;\0&#39;;           puts(a[i]+1);//切记一定要用puts 并且交G++  否则无限TLE 其实对比输入优化算法 发现对字符串处理函数的耗时是最短了        }    }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>&lt;转&gt;#  位运算及其应用详解</title>
      <link href="/2016/03/06/50813606/"/>
      <url>/2016/03/06/50813606/</url>
      
        <content type="html"><![CDATA[<h1 id="位运算及其应用详解"><a href="#位运算及其应用详解" class="headerlink" title="位运算及其应用详解"></a>位运算及其应用详解</h1><p>置顶  2016年03月06日 15:30:37  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：674</p><hr><p> 博客爬取于<code>2019-04-18 17:15:19</code><br><strong><em>以下为正文</em></strong></p><h2 id="本博客引用于此"><a href="#本博客引用于此" class="headerlink" title=" 本博客引用于此 "></a><a href="http://blog.chinaunix.net/uid-21411227-id-1826986.html" target="_blank" rel="noopener"> 本博客引用于此 </a></h2><h2 id="还有一个帖子不错-总结的不错-戳我"><a href="#还有一个帖子不错-总结的不错-戳我" class="headerlink" title="还有一个帖子不错 总结的不错  戳我 "></a>还有一个帖子不错 总结的不错 <a href="http://www.xuebuyuan.com/1960396.html" target="_blank" rel="noopener"> 戳我 </a></h2><h2 id="对于位运算的深入运用请看-2014国家集训队论文《回归本源——位运算及其应用》"><a href="#对于位运算的深入运用请看-2014国家集训队论文《回归本源——位运算及其应用》" class="headerlink" title="对于位运算的深入运用请看 [ 2014国家集训队论文《回归本源——位运算及其应用》"></a>对于位运算的深入运用请看 [ 2014国家集训队论文《回归本源——位运算及其应用》</h2><p>](<a href="http://download.csdn.net/album/detail/657" target="_blank" rel="noopener">http://download.csdn.net/album/detail/657</a>)</p><p>一．逻辑运算符<br>1.&amp; 位与运算<br>1) 运算规则<br>位与运算的实质是将参与运算的两个数据，按对应的二进制数逐位进行逻辑与运算。例如：int型常量4和7进行位与运算的运算过程如下：<br>4=0000 0000 0000 0100 &amp;7 =0000 0000 0000 0111= 0000 0000 0000 0100<br>对于负数，按其补码进行运算。例如：例如：int型常量-4和7进行位与运算的运算过程如下： －4=1111 1111 1111 1100 &amp;7 =0000<br>0000 0000 0111= 0000 0000 0000 0100<br>2) 典型应用<br>(1) 清零<br>清零：快速对某一段数据单元的数据清零，即将其全部的二进制位为0。例如整型数a=321对其全部数据清零的操作为a=a&amp;0x0。 321=0000 0001<br>0100 0001 &amp;0=0000 0000 0000 0000<br>= 0000 0000 0000 0000<br>(2) 获取一个数据的指定位<br>获取一个数据的指定位。例如获得整型数a=的低八位数据的操作为a=a&amp;0xFF。321=<br>0000 0001 0100 0001 &amp; 0xFF =0000 0000 1111 11111<br>= 0000 0000 0100 0001<br>获得整型数a=的高八位数据的操作为a=a&amp;0xFF00。==a&amp;0XFF00==<br>321=0000 0001 0100 0001 &amp; 0XFF00=1111 1111 0000 0000<br>= 0000 0001 0000 0000<br>(3)保留数据区的特定位<br>保留数据区的特定位。例如获得整型数a=的第7-8位（从0开始）位的数据操作为： 110000000<br>321=0000 0001 0100 0001 &amp; 384=0000 0001 1000 0000<br>=0000 0001 0000 0000<br>2. | 位或运算<br>1) 运算规则<br>位或运算的实质是将参与运算的两个数据，按对应的二进制数逐位进行逻辑或运算。例如：int型常量5和7进行位或运算的表达式为5|7，结果如下：5= 0000<br>0000 0000 0101<br>| 7= 0000 0000 0000 0111=0000 0000 0000 0111<br>2) 主要用途<br>(1) 设定一个数据的指定位。例如整型数a=321，将其低八位数据置为1的操作为a=a|0XFF。321= 0000 0001 0100 0001 |<br>0000 0000 1111 1111=0000 0000 1111 1111<br>逻辑运算符||与位或运算符|的区别<br>条件“或”运算符 (||) 执行 bool 操作数的逻辑“或”运算，但仅在必要时才计算第二个操作数。 x || y , x | y 不同的是，如果 x 为<br>true，则不计算 y（因为不论 y 为何值，“或”操作的结果都为 true）。这被称作为“短路”计算。<br>3. ^ 位异或<br>1) 运算规则<br>位异或运算的实质是将参与运算的两个数据，按对应的二进制数逐位进行逻辑异或运算。只有当对应位的二进制数互斥的时候，对应位的结果才为真。例如：int型常量5和7<br>进行位异或运算的表达式为5^7，结果如下：5=0000 0000 0000 0101^7=0000 0000 0000 0111<br>= 0000 0000 0000 0010<br>2) 典型应用<br>(1)定位翻转<br>定位翻转：设定一个数据的指定位，将1换为0，0换为1。例如整型数a=321,，将其低八位数据进行翻位的操作为a=a^0XFF;<br>(2)数值交换<br>数值交换。例如a=3,b=4。在例11-1中，无须引入第三个变量，利用位运算即可实现数据交换。以下的操作可以实现a,b两个数据的交换：<br>a=a^b;<br>b=b^a;<br>a=a^b;<br>4．~ 位非<br>位非运算的实质是将参与运算的两个数据，按对应的二进制数逐位进行逻辑非运算。</p><p>二．位移运算符<br>1．位左移<br>左移运算的实质是将对应的数据的二进制值逐位左移若干位，并在空出的位置上填0，最高位溢出并舍弃。例如int a,b;<br>a=5;<br>b=a&lt;&lt;2;<br>则b=20，分析过程如下：<br>(a)10=(5)10=(0000 0000 0000 0101)2<br>b=a&lt;&lt;2;<br>b=(0000 0000 0001 0100)2=(20)10<br>从上例可以看出位运算可以实现二倍乘运算。由于位移操作的运算速度比乘法的运算速度高很多。因此在处理数据的乘法运算的时，采用位移运算可以获得较快的速度。<br>提示 将所有对2的乘法运算转换为位移运算，可提高程序的运行效率<br>2．位右移<br>位右移运算的实质是将对应的数据的二进制值逐位右移若干位，并舍弃出界的数字。如果当前的数为无符号数，高位补零。例如：<br>int (a)10=(5)10=(0000 0000 0000 0101)2<br>b=a&gt;&gt;2;<br>b=(0000 0000 0000 0001)2=(1)10<br>如果当前的数据为有符号数，在进行右移的时候，根据符号位决定左边补0还是补1。如果符号位为0，则左边补0；但是如果符号位为1，则根据不同的计算机系统，可能有不<br>同的处理方式。可以看出位右移运算，可以实现对除数为2的整除运算。<br>提示 将所有对2的整除运算转换为位移运算，可提高程序的运行效率<br>3．复合的位运算符<br>在C语言中还提供复合的位运算符，如下：<br>&amp;=、!=、&gt;&gt;=、&lt;&lt;=和^=<br>例如：a&amp;=0x11等价于 a= a&amp;0x11，其他运算符以此类推。<br>不同类型的整数数据在进行混合类型的位运算时，按右端对齐原则进行处理，按数据长度大的数据进行处理，将数据长度小的数据左端补0或1。例如char a与int<br>b进行位运算的时候，按int 进行处理，char a转化为整型数据，并在左端补0。<br>补位原则如下：<br>1) 对于有符号数据：如果a为正整数，则左端补0，如果a 为负数，则左端补1。<br>2) 对于无符号数据：在左端补0。<br>4．例子<br>例11-2　获得一个无符号数据从第p位开始的n位二进制数据。假设数据右端对齐，第0位二进制数在数据的最右端，获得的结果要求右对齐。</p><pre><code>#include &lt;stdio.h&gt;/*getbits:获得从第p位开始的n位二进制数 */unsigned int getbits(unsigned int x, unsigned int p, unsigned n){unsigned int a;unsigned int b;a=x&gt;&gt;(p+1);b=~(~0&lt;&lt;n);return a&amp;b;}</code></pre><p>提示 在某一平台进行程序开发时，首先要求了解此系统的基本数据类型的有效范围， 对涉及的位运算进行评估，特别是要对边界数据进行检测，确保计算正确。</p>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  hdu 1847 Nim博弈</title>
      <link href="/2016/03/06/50813592/"/>
      <url>/2016/03/06/50813592/</url>
      
        <content type="html"><![CDATA[<h1 id="hdu-1847-Nim博弈"><a href="#hdu-1847-Nim博弈" class="headerlink" title="hdu 1847 Nim博弈"></a>hdu 1847 Nim博弈</h1><p>2016年03月06日 15:28:21  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：396</p><hr><p> 博客爬取于<code>2019-04-18 17:21:15</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/50813592" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/50813592</a></p><h1 id="博弈问题"><a href="#博弈问题" class="headerlink" title="博弈问题"></a>博弈问题</h1><h3 id="巴士博弈"><a href="#巴士博弈" class="headerlink" title="巴士博弈"></a>巴士博弈</h3><p><a href="http://blog.csdn.net/qq_33184171/article/details/50790076" target="_blank" rel="noopener"> HDU1846 </a><br>&lt;-点击此处进入链接</p><h3 id="威尔夫博弈"><a href="#威尔夫博弈" class="headerlink" title="威尔夫博弈"></a>威尔夫博弈</h3><p><a href="http://blog.csdn.net/qq_33184171/article/details/50790140" target="_blank" rel="noopener"> HDU1527 </a><br>&lt;-点击此处进入链接</p><h3 id="斐波那契博弈"><a href="#斐波那契博弈" class="headerlink" title="斐波那契博弈"></a>斐波那契博弈</h3><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=2516" target="_blank" rel="noopener"> HDU2516 </a> &lt;-点击此处进入链接</p><h3 id="尼姆博弈"><a href="#尼姆博弈" class="headerlink" title="尼姆博弈"></a>尼姆博弈</h3><p><a href="http://blog.csdn.net/qq_33184171/article/details/50813592" target="_blank" rel="noopener"> HDUXXX </a><br>&lt;-点击此处进入链接</p><hr><p>题目链接： <a href="http://poj.org/problem?id=2975" target="_blank" rel="noopener"> poj </a> <a href="http://acm.zju.edu.cn/onlinejudge/showProblem.do?problemCode=3067" target="_blank" rel="noopener"> zoj</a><br>题意：有 N 堆石子，两人轮流从任一堆中取任意个石子（至少一个），最后一个取石子的人为胜利者。若先取者胜利，则输出第一次拿走石头的方法一共可以有多少种。<br>分析：<br>求出一个必胜局面有多少种方式可以导出必败局面.<br>也就是求由S态到T态有多少种路径.<br>一个S态要转化成为T态,<br>令C = k1^k2^k3…^kn.<br>C的二进制表示最高位为1.<br>假设ki的二进制表示最高位与C的二进制表示最高位相同,那么可以通过将ki的某些二进制位上的0置为1,1置为0来使得C’ = 0,也就是使S态转化为T态.<br>所以问题就是寻找有多少个ki,其最高位和C的最高位相同.</p><hr><p>看本题前后 可以做一下斐波那契博弈 在思维上有些相关性<br><strong> <a href="http://blog.csdn.net/qq_33184171/article/details/50813093" target="_blank" rel="noopener"> 斐波那契博弈 </a> </strong> &lt;-点击这里进入链接 </p><hr><p><strong> 先声明一下 每一个数 都可以用2的N次幂的数的集合里元素加起来表示 （联想2进制数把每位的数换成他所等价的10进制的值） </strong><br><strong> 标准的Nim博弈是要求可以取任意个石子 因为这个任意的数能够用2的N次幂的数的集合里元素加起来表示 所以只取2^n(n=0,1,2.3……)个数的石子就可以了 </strong><br><strong> 而且相对后面判断奇异局势，比较好理解 </strong></p><p><strong> 还是和所有博弈一样 找到它的必败态也就是奇异局势 </strong><br><strong> 假设n堆为3堆 </strong><br><strong> 1.(0,0,0)是理所当然的奇异局势 </strong><br><strong> 2.(0,n,n)也是奇异局势,只要先手拿多少,后手在另一堆里拿相同个数的石子 就总保持(0,n,n)等先手最后一次拿光的时候,后手就可以把最后一堆剩下的全部拿光了 </strong><br><strong> 3.(a,b,c)满足奇异局势的时候,和(2)的情况一样先手拿多少后手就拿多少,这个时候假定每一次先手拿的石子个数是a[i],那么只要保证在(a,b,c)中保证a[i]均成对即可 这样对方拿出来多少你就拿多少 就能保证赢 </strong><br><strong> 举个例子(4,9,13) </strong><br><img src="https://img-blog.csdn.net/20160306144936313" alt="\(4,9,13的分解\)"><br>如果先手拿8,4,1 后手也这样拿 那么先手一定输<br>当然 先手也可能拿2 不管拿那个数里的2 都可分解出来 成对的<br>如果说拿的是4里的2 可以拿13中的2 可以拿13中的2 保证接下来的是成对的<br>可以划成这样 <img src="https://img-blog.csdn.net/20160306145853098" alt="这里写图片描述"><br>如果说拿的是9里的2 也可以拿13中的2 保证接下来的是成对的<br>可以划成这样 <img src="https://img-blog.csdn.net/20160306150038208" alt="这里写图片描述"><br>如果说拿的是13里的2 也可以拿9或13中的2 保证接下来的是成对的<br>划分之后的和上两个图片是一样了<br><strong> 知道了上述这些 那么无论是3堆还是多少堆 都是这样凑成对就好了 </strong></p><hr><p><strong> 刚刚解释的就是Nim博弈的过程了 那么怎么用代码实现的呢 </strong><br><strong> 其实自习观察上几张图片 会发现点什么 先想一想再看下文 </strong><br><strong> 如果把出了0的数均换成1 并按照顺序呢列出 就会发现这就是一个二进制数 </strong><br><strong> 想到了而进制数 那就应该想到位运算 </strong><br><strong> <a href="http://blog.csdn.net/qq_33184171/article/details/50813606" target="_blank" rel="noopener"> Ps: 如果想多了解一下位运算 </a> &lt;-点击此处进入链接 </strong><br><strong> 那么只要用“^”异或运算就可以判断局势是不是奇异局势了 </strong></p><p><strong> 对于三堆的满足a^b^c=0就是奇异局势 </strong><br><strong> N堆的话就是 </strong></p><hr><p>付一下本题代码</p><pre><code>#include &lt;iostream&gt;  #include &lt;cstdio&gt;  using namespace std;  int main()  {      int n;      while (scanf(&quot;%d&quot;, &amp;n), n)      {          int stone[1001], ans = 0, i;          for (i=0; i&lt;n; i++)          {              scanf(&quot;%d&quot;, &amp;stone[i]);              ans ^= stone[i];          }          int total = 0;          for (i=0; i&lt;n; i++)          {              if (stone[i] &gt; (stone[i]^ans))                  total ++;          }          printf(&quot;%d\n&quot;, total);      }      return 0;  }  </code></pre>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  HDU 2516 取石子游戏 [斐波那契博弈]</title>
      <link href="/2016/03/06/50813093/"/>
      <url>/2016/03/06/50813093/</url>
      
        <content type="html"><![CDATA[<h1 id="HDU-2516-取石子游戏-斐波那契博弈"><a href="#HDU-2516-取石子游戏-斐波那契博弈" class="headerlink" title="HDU 2516 取石子游戏 [斐波那契博弈]"></a>HDU 2516 取石子游戏 [斐波那契博弈]</h1><p>2016年03月06日 13:57:58  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：607</p><hr><p> 博客爬取于<code>2019-04-18 17:21:16</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/50813093" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/50813093</a></p><h1 id="博弈问题"><a href="#博弈问题" class="headerlink" title="博弈问题"></a>博弈问题</h1><h3 id="巴士博弈"><a href="#巴士博弈" class="headerlink" title="巴士博弈"></a>巴士博弈</h3><p><a href="http://blog.csdn.net/qq_33184171/article/details/50790076" target="_blank" rel="noopener"> HDU1846 </a><br>&lt;-点击此处进入链接</p><h3 id="威尔夫博弈"><a href="#威尔夫博弈" class="headerlink" title="威尔夫博弈"></a>威尔夫博弈</h3><p><a href="http://blog.csdn.net/qq_33184171/article/details/50790140" target="_blank" rel="noopener"> HDU1527 </a><br>&lt;-点击此处进入链接</p><h3 id="斐波那契博弈"><a href="#斐波那契博弈" class="headerlink" title="斐波那契博弈"></a>斐波那契博弈</h3><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=2516" target="_blank" rel="noopener"> HDU2516 </a> &lt;-点击此处进入链接</p><h3 id="尼姆博弈"><a href="#尼姆博弈" class="headerlink" title="尼姆博弈"></a>尼姆博弈</h3><p><a href="http://blog.csdn.net/qq_33184171/article/details/50813592" target="_blank" rel="noopener"> HDUXXX </a><br>&lt;-点击此处进入链接</p><h3 id="公平组合博弈"><a href="#公平组合博弈" class="headerlink" title="公平组合博弈"></a>公平组合博弈</h3><p><a href="asdfasd"> HDUxxxx </a> &lt;-点击此处进入链接</p><hr><p>取石子游戏</p><p>Time Limit: 2000/1000 MS (Java/Others) Memory Limit: 32768/32768 K<br>(Java/Others)<br>Total Submission(s): 3862 Accepted Submission(s): 2307</p><p>Problem Description<br>1堆石子有n个,两人轮流取.先取者第1次可以取任意多个，但不能全部取完.以后每次取的石子数不能超过上次取子数的2倍。取完者胜.先取者负输出”Second<br>win”.先取者胜输出”First win”.</p><p>Input<br>输入有多组.每组第1行是2&lt;=n&lt;2^31. n=0退出.</p><p>Output<br>先取者负输出”Second win”. 先取者胜输出”First win”.<br>参看Sample Output.</p><p>Sample Input<br>2<br>13<br>10000<br>0</p><p>Sample Output<br>Second win<br>Second win<br>First win</p><hr><p>斐波那契博弈这里需要借助“Zeckendorf定理”（齐肯多夫定理）：任何正整数可以表示为若干个不连续的Fibonacci数之和。</p><p>先看看斐波那契数列的必败证明：</p><p>1、当i=2时，先手只能取1颗，显然必败，结论成立。</p><p>2、假设当i&lt;=k时，结论成立。</p><p>则当i=k+1时，f[i] = f[k]+f[k-1]。</p><p>则我们可以把这一堆石子看成两堆，简称k堆和k-1堆。</p><p>（一定可以看成两堆，因为假如先手第一次取的石子数大于或等于f[k-1]，则后手可以直接取完f[k]，因为f[k] &lt; 2*f[k-1]）</p><p>对于k-1堆，由假设可知，不论先手怎样取，后手总能取到最后一颗。下面我们分析一下后手最后取的石子数x的情况。</p><p>如果先手第一次取的石子数y&gt;=f[k-1]/3，则这小堆所剩的石子数小于2y，即后手可以直接取完，此时x=f[k-1]-y，则x&lt;=2/3*f[k-1]。</p><p>我们来比较一下2/3<em>f[k-1]与1/2</em>f[k]的大小。即4<em>f[k-1]与3</em>f[k]的大小，由数学归纳法不难得出，后者大。</p><p>所以我们得到，x&lt;1/2*f[k]。</p><p>即后手取完k-1堆后，先手不能一下取完k堆，所以游戏规则没有改变，则由假设可知，对于k堆，后手仍能取到最后一颗，所以后手必胜。</p><p>即i=k+1时，结论依然成立。</p><p>对于不是FIB数，首先进行分解。</p><p>分解的时候，要取尽量大的Fibonacci数。</p><p>比如分解85：85在55和89之间，于是可以写成85=55+30，然后继续分解30,30在21和34之间，所以可以写成30=21+9，</p><p>依此类推，最后分解成85=55+21+8+1。</p><p>则我们可以把n写成 n = f[a1]+f[a2]+……+f[ap]。（a1&gt;a2&gt;……&gt;ap）</p><p>我们令先手先取完f[ap]，即最小的这一堆。由于各个f之间不连续，则a(p-1) &gt; ap + 1，则有f[a(p-1)] &gt;<br>2*f[ap]。即后手只能取f[a(p-1)]这一堆，且不能一次取完。</p><p>此时后手相当于面临这个子游戏（只有f[a(p-1)]这一堆石子，且后手先取）的必败态，即先手一定可以取到这一堆的最后一颗石子。</p><p>同理可知，对于以后的每一堆，先手都可以取到这一堆的最后一颗石子，从而获得游戏的胜利。</p><h2 id="齐肯拉夫定理代码实现"><a href="#齐肯拉夫定理代码实现" class="headerlink" title="齐肯拉夫定理代码实现"></a>齐肯拉夫定理代码实现</h2><pre><code>//齐肯多夫定理 代码 实现int largestFib(int n){    if(n==0||n==1)        return n;    int a=0;    int b=1;    int c=1;    while(c&lt;=n)    {        a=b;        b=c;        c=a+b;    }    return b;}int main(){    int n;    cin&gt;&gt;n;    while(n&gt;0)    {        int tempn=largestFib(n);        cout&lt;&lt;tempn&lt;&lt;&quot; &quot;;        n=n-tempn;    }}</code></pre><hr><p>附本题AC代码</p><pre><code>#include &lt;iostream&gt;using namespace std;int main(){   int a[50];   __int64 i;   long long int n;   while(1)   {       cin&gt;&gt;n;       if(n==1)       continue;       if(n==0)        break;       a[0]=1;       a[1]=1;       for(i=2;i&lt;46;i++)       {           a[i]=a[i-1]+a[i-2];       }           for(i=0;i&lt;46;i++)                if(a[i]==n)           {               cout&lt;&lt;&quot;Second win&quot;&lt;&lt;endl;                 break;           }           if(i==46)            cout&lt;&lt;&quot;First win&quot;&lt;&lt;endl;   }    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  HDU 5635 LCP array</title>
      <link href="/2016/03/05/50811273/"/>
      <url>/2016/03/05/50811273/</url>
      
        <content type="html"><![CDATA[<h1 id="HDU-5635-LCP-array"><a href="#HDU-5635-LCP-array" class="headerlink" title="HDU 5635 LCP array"></a>HDU 5635 LCP array</h1><p>2016年03月05日 22:57:14  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：541</p><hr><p> 博客爬取于<code>2019-04-18 17:21:17</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/50811273" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/50811273</a></p><p>LCP Array</p><p>Time Limit: 4000/2000 MS (Java/Others) Memory Limit: 131072/131072 K<br>(Java/Others)<br>Total Submission(s): 307 Accepted Submission(s): 86</p><p>Problem Description<br>Peter has a string s=s1s2…sn, let suffi=sisi+1…sn be the suffix start with<br>i-th character of s. Peter knows the lcp (longest common prefix) of each two<br>adjacent suffixes which denotes as ai=lcp(suffi,suffi+1)(1≤i<em>&lt;</em>n).</p><p>Given the lcp array, Peter wants to know how many strings containing lowercase<br>English letters only will satisfy the lcp array. The answer may be too large,<br>just print it modulo 109+7.</p><p>Input<br>There are multiple test cases. The first line of input contains an integer T<br>indicating the number of test cases. For each test case:</p><p>The first line contains an integer n (2≤n≤105) – the length of the string. The<br>second line contains n−1 integers: a1,a2,…,an−1 (0≤ai≤n).</p><p>The sum of values of n in all test cases doesn’t exceed 106.</p><p>Output<br>For each test case output one integer denoting the answer. The answer must be<br>printed modulo 109+7.</p><p>Sample Input<br>3<br>3<br>0 0<br>4<br>3 2 1<br>3<br>1 2</p><p>Sample Output<br>16250<br>26<br>0</p><hr><p><strong> 题目就是说给你输入的a[i]后 第i个字符与后面a[i]个字符都是相同的 问你有多少个符合输入的种类 </strong><br><strong> 本题有主要有三个点 </strong><br><strong> 1.a[i]小于n-i </strong><br><strong> 2.a[i]是每一段递减的 而且必须是依次减1 减到0后可以接着再有一段递减的 但最后都要到1 否则不符合1 </strong><br><strong> 3.每一段递减段的字符必须是相同的 </strong><br><strong> 可以把每一段规程一块 且相邻的两块不相同 </strong></p><p><strong> _ Ps：取鱼之后的输出也超了int 要用long long int _ </strong><br><strong> 博主在这里错了无数发才想到这个问题 </strong><br>最后正常写就好了</p><hr><pre><code>#include &lt;stdio.h&gt;const int MOD=1000000007;int a[100005];int main(){    int t;    scanf(&quot;%d&quot;,&amp;t);    while(t--)    {        int n;        scanf(&quot;%d&quot;,&amp;n);        long long int sum=26,mm=0;        for(int i=1; i&lt;n; i++)        {            scanf(&quot;%d&quot;,&amp;a[i]);        }        for(int i=1; i&lt;n; i++)        {            if(a[i]&gt;n-i||a[i-1]!=0&amp;&amp;a[i]!=a[i-1]-1)            {                sum=0;                break;            }            if(a[i]==0)            {                sum*=25;                sum%=MOD;            }        }        printf(&quot;%I64d\n&quot;,sum%MOD);    }    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  HDU 1527 取石子游戏 威尔夫博弈</title>
      <link href="/2016/03/03/50790140/"/>
      <url>/2016/03/03/50790140/</url>
      
        <content type="html"><![CDATA[<h1 id="HDU-1527-取石子游戏-威尔夫博弈"><a href="#HDU-1527-取石子游戏-威尔夫博弈" class="headerlink" title="HDU 1527 取石子游戏 威尔夫博弈"></a>HDU 1527 取石子游戏 威尔夫博弈</h1><p>2016年03月03日 17:21:04  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：705</p><hr><p> 博客爬取于<code>2019-04-18 17:21:18</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/50790140" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/50790140</a></p><h1 id="博弈问题"><a href="#博弈问题" class="headerlink" title="博弈问题"></a>博弈问题</h1><h3 id="巴士博弈"><a href="#巴士博弈" class="headerlink" title="巴士博弈"></a>巴士博弈</h3><p><a href="http://blog.csdn.net/qq_33184171/article/details/50790076" target="_blank" rel="noopener"> HDU1846 </a><br>&lt;-点击此处进入链接</p><h3 id="威尔夫博弈"><a href="#威尔夫博弈" class="headerlink" title="威尔夫博弈"></a>威尔夫博弈</h3><p><a href="http://blog.csdn.net/qq_33184171/article/details/50790140" target="_blank" rel="noopener"> HDU1527 </a><br>&lt;-点击此处进入链接</p><h3 id="斐波那契博弈"><a href="#斐波那契博弈" class="headerlink" title="斐波那契博弈"></a>斐波那契博弈</h3><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=2516" target="_blank" rel="noopener"> HDU2516 </a> &lt;-点击此处进入链接</p><h3 id="尼姆博弈"><a href="#尼姆博弈" class="headerlink" title="尼姆博弈"></a>尼姆博弈</h3><p><a href="http://blog.csdn.net/qq_33184171/article/details/50813592" target="_blank" rel="noopener"> HDUXXX </a><br>&lt;-点击此处进入链接</p><h3 id="公平组合博弈"><a href="#公平组合博弈" class="headerlink" title="公平组合博弈"></a>公平组合博弈</h3><p><a href="asdfasd"> HDUxxxx </a> &lt;-点击此处进入链接</p><hr><p>取石子游戏</p><p>Time Limit: 2000/1000 MS (Java/Others) Memory Limit: 65536/32768 K<br>(Java/Others)<br>Total Submission(s): 5425 Accepted Submission(s): 2833</p><p>Problem Description<br>有两堆石子，数量任意，可以不同。游戏开始由两个人轮流取石子。游戏规定，每次有两种不同的取法，一是可以在任意的一堆中取走任意多的石子；二是可以在两堆中同时取走<br>相同数量的石子。最后把石子全部取完者为胜者。现在给出初始的两堆石子的数目，如果轮到你先取，假设双方都采取最好的策略，问最后你是胜者还是败者。</p><p>Input<br>输入包含若干行，表示若干种石子的初始情况，其中每一行包含两个非负整数a和b，表示两堆石子的数目，a和b都不大于1,000,000,000。</p><p>Output<br>输出对应也有若干行，每行包含一个数字1或0，如果最后你是胜者，则为1，反之，则为0。</p><p>Sample Input<br>2 1<br>8 4<br>4 7</p><p>Sample Output<br>0<br>1<br>0</p><hr><p><strong> 如果做本题之前没有做过巴士博弈的题目，建议先做一下巴士博弈 </strong><br><strong> 巴士博弈 </strong><br><a href="http://blog.csdn.net/qq_33184171/article/details/50790076" target="_blank" rel="noopener"> HDU1846 </a><br>&lt;-点击此处进入链接<br><strong> 如果做本题之前没有做过巴士博弈的题目，建议先做一下巴士博弈 </strong><br><strong> 如果做本题之前没有做过巴士博弈的题目，建议先做一下巴士博弈 </strong><br><strong> 如果做本题之前没有做过巴士博弈的题目，建议先做一下巴士博弈 </strong></p><hr><p>用(n,m) 表示当前的局势，n与m表示剩下的石子个数<br>先引出奇异局势的概念<br>奇异局势就是指当轮到甲取石子的时候局势(n,m)能确保甲无论怎么取石子都会输的局势</p><p><strong> 本题就要详细解释下奇异局势的性质 </strong><br><strong> 1.任何自然数都包含在一个且仅有一个奇异局势中。 </strong><br><strong> 2.任意操作都可将奇异局势变为非奇异局势。 </strong><br><strong> 3.采用适当的方法，可以将非奇异局势变为奇异局势。 </strong></p><hr><p><strong> 其实做这类题只要找到奇异局势就好了 </strong></p><p>那么任给一个局势（a，b），怎样判断它是不是奇异局势呢？我们有如下公式： ak =[k（1+√5）/2]，bk= ak + k （k=0，1，2，…,n<br>方括号表示取整函数) 奇妙的是其中出现了黄金分割数（1+√5）/2 =<br>1。618…,因此,由ak，bk组成的矩形近似为黄金矩形，由于2/（1+√5）=（√5-1）/2，可以先求出j=[a（√5-1）/2]，若a=[<br>j（1+√5）/2]，那么a = aj，bj = aj + j，若不等于，那么a = aj+1，bj+1 = aj+1 + j +<br>1，若都不是，那么就不是奇异局势。然后再按照上述法则进行，一定会遇到奇异局势。</p><p><strong> _ <a href="http://blog.csdn.net/smcwwh/article/details/5051239" target="_blank" rel="noopener"> 上述奇异局势的判断来自这里 </a> _ </strong> &lt;-点击此处进入链接 </p><hr><p>附本题代码</p><pre><code>#include &lt;iostream&gt;#include &lt;stdio.h&gt;#include &lt;math.h&gt;using namespace std;//威尔夫博弈int main(){    int n,m;    while(~scanf(&quot;%d%d&quot;,&amp;n,&amp;m))    {        if(n&lt;m)        {            n=n^m;            m=m^n;            n=n^m;        }        int k=n-m;        n=(int)(k*(1+sqrt(5))/2.0);        if(n==m)        {            printf(&quot;0\n&quot;);        }        else printf(&quot;1\n&quot;);    }    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  HDU 1846 Brave Game 巴士博弈</title>
      <link href="/2016/03/03/50790076/"/>
      <url>/2016/03/03/50790076/</url>
      
        <content type="html"><![CDATA[<h1 id="HDU-1846-Brave-Game-巴士博弈"><a href="#HDU-1846-Brave-Game-巴士博弈" class="headerlink" title="HDU 1846 Brave Game 巴士博弈"></a>HDU 1846 Brave Game 巴士博弈</h1><p>2016年03月03日 17:15:26  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：1358<br>标签：  <a href="https://so.csdn.net/so/search/s.do?q=游戏&amp;t=blog" target="_blank" rel="noopener"> 游戏 </a> <a href="https://so.csdn.net/so/search/s.do?q=博弈&amp;t=blog" target="_blank" rel="noopener"> 博弈</a> <a href="https://so.csdn.net/so/search/s.do?q=巴士博弈&amp;t=blog" target="_blank" rel="noopener"> 巴士博弈</a> <a href="https://so.csdn.net/so/search/s.do?q=HDU&amp;t=blog" target="_blank" rel="noopener"> HDU</a> <a href="https://so.csdn.net/so/search/s.do?q=HDU-1846&amp;t=blog" target="_blank" rel="noopener"> HDU-1846</a></p><p>个人分类：  <a href="https://blog.csdn.net/qq_33184171/article/category/6117381" target="_blank" rel="noopener"> ===== 博弈 =====</a> <a href="https://blog.csdn.net/qq_33184171/article/category/6117382" target="_blank" rel="noopener"> hdu</a></p><hr><p> 博客爬取于<code>2019-04-18 17:21:20</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/50790076" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/50790076</a></p><h1 id="博弈问题"><a href="#博弈问题" class="headerlink" title="博弈问题"></a>博弈问题</h1><h3 id="巴士博弈"><a href="#巴士博弈" class="headerlink" title="巴士博弈"></a>巴士博弈</h3><p><a href="http://blog.csdn.net/qq_33184171/article/details/50790076" target="_blank" rel="noopener"> HDU1846 </a><br>&lt;-点击此处进入链接</p><h3 id="威尔夫博弈"><a href="#威尔夫博弈" class="headerlink" title="威尔夫博弈"></a>威尔夫博弈</h3><p><a href="http://blog.csdn.net/qq_33184171/article/details/50790140" target="_blank" rel="noopener"> HDU1527 </a><br>&lt;-点击此处进入链接</p><h3 id="斐波那契博弈"><a href="#斐波那契博弈" class="headerlink" title="斐波那契博弈"></a>斐波那契博弈</h3><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=2516" target="_blank" rel="noopener"> HDU2516 </a> &lt;-点击此处进入链接</p><h3 id="尼姆博弈"><a href="#尼姆博弈" class="headerlink" title="尼姆博弈"></a>尼姆博弈</h3><p><a href="http://blog.csdn.net/qq_33184171/article/details/50813592" target="_blank" rel="noopener"> HDUXXX </a><br>&lt;-点击此处进入链接</p><h3 id="公平组合博弈"><a href="#公平组合博弈" class="headerlink" title="公平组合博弈"></a>公平组合博弈</h3><p><a href="asdfasd"> HDUxxxx </a> &lt;-点击此处进入链接</p><hr><p>Brave Game</p><p>Time Limit: 1000/1000 MS (Java/Others) Memory Limit: 32768/32768 K<br>(Java/Others)<br>Total Submission(s): 9376 Accepted Submission(s): 6228</p><p>Problem Description<br>十年前读大学的时候，中国每年都要从国外引进一些电影大片，其中有一部电影就叫《勇敢者的游戏》（英文名称：Zathura），一直到现在，我依然对于电影中的部分电<br>脑特技印象深刻。<br>今天，大家选择上机考试，就是一种勇敢（brave）的选择；这个短学期，我们讲的是博弈（game）专题；所以，大家现在玩的也是“勇敢者的游戏”，这也是我命名这<br>个题目的原因。<br>当然，除了“勇敢”，我还希望看到“诚信”，无论考试成绩如何，希望看到的都是一个真实的结果，我也相信大家一定能做到的~</p><p>各位勇敢者要玩的第一个游戏是什么呢？很简单，它是这样定义的：<br>1、 本游戏是一个二人游戏;<br>2、 有一堆石子一共有n个；<br>3、 两人轮流进行;<br>4、 每走一步可以取走1…m个石子；<br>5、 最先取光石子的一方为胜；</p><p>如果游戏的双方使用的都是最优策略，请输出哪个人能赢。</p><p>Input<br>输入数据首先包含一个正整数C(C&lt;=100)，表示有C组测试数据。<br>每组测试数据占一行，包含两个整数n和m（1&lt;=n,m&lt;=1000），n和m的含义见题目描述。</p><p>Output<br>如果先走的人能赢，请输出“first”，否则请输出“second”，每个实例的输出占一行。</p><p>Sample Input<br>2<br>23 2<br>4 3</p><p>Sample Output<br>first<br>second</p><hr><p>本题是巴士博弈<br><strong> _ 此处应为题目描述 请见上文 _ </strong><br>用 <strong> (n,m) </strong> 表示当前的局势,n表示剩下的石子个数,m为每次最多能够取的石子个数<br>先引出 <strong> _ 奇异局势 _ </strong> 的概念<br>奇异局势就是指当轮到 <strong> 甲 </strong> 取石子的时候局势(n,m)能确保甲无论怎么取石子都会输的局势<br><strong> _ 简单一句话 奇异局势就是谁碰谁输的局势(无论你怎样取石子) _ </strong><br>要想赢就要想办法让最后 <strong> 剩在自己面前的石子&lt;=m </strong><br>而想要保证上一点，就必须 <strong> 保证输家最后一次拿石子的时候剩余m+1个 </strong> 这样无论输家怎么拿，都能确保 <strong> 剩在自己面前的石子&lt;=m </strong><br>且输家不可能一次拿光石子<br>现在我们还可以知道这样的等式<strong>n=(m+1)*r+s</strong>r为任意自然数，s为小于m的自然数<br>我们只要先将s个数的石子取走 等到对方取了 <strong> k </strong> 个石子过后在取 <strong> m+1-k </strong> 个石子就能保证最后剩到对方的就是 <strong> m+1 </strong><br>个石子 来确保赢</p><p><strong> _ 综上所述 _ </strong> <strong> 我们可以知道只要面对(m+1)*r个石子就必输无疑 </strong><br><strong> 所以我们就能得到奇异局势就是剩余的石子个数是(m+1)*r的情况 </strong><br><strong> 所以只要判断当前是不是奇异局势就能判断出最好谁是赢家 </strong></p><hr><p><strong> 附一下本题代码 </strong></p><pre><code>#include &lt;stdio.h&gt;using namespace std;//巴士博弈int main(){    int t;    scanf(&quot;%d&quot;,&amp;t);    while(t--)    {        int n,m;        scanf(&quot;%d %d&quot;,&amp;n,&amp;m);        if(n%(m+1)==0) //判断是奇异局势 所以先手一定输            printf(&quot;second\n&quot;);        else            printf(&quot;first\n&quot;);    }    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hdu </tag>
            
            <tag> 游戏 </tag>
            
            <tag> 博弈 </tag>
            
            <tag> 巴士博弈 </tag>
            
            <tag> HDU </tag>
            
            <tag> HDU-1846 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  HRBUST 1564 螺旋矩阵 DFS</title>
      <link href="/2016/03/03/50787788/"/>
      <url>/2016/03/03/50787788/</url>
      
        <content type="html"><![CDATA[<h1 id="HRBUST-1564-螺旋矩阵-DFS"><a href="#HRBUST-1564-螺旋矩阵-DFS" class="headerlink" title="HRBUST 1564 螺旋矩阵 DFS"></a>HRBUST 1564 螺旋矩阵 DFS</h1><p>2016年03月03日 13:19:37  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：496</p><hr><p> 博客爬取于<code>2019-04-18 17:21:21</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/50787788" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/50787788</a></p><hr><h2 id="HRBUST-1564-螺旋矩阵-DFS-1"><a href="#HRBUST-1564-螺旋矩阵-DFS-1" class="headerlink" title="HRBUST 1564 螺旋矩阵 DFS"></a>HRBUST 1564 螺旋矩阵 DFS</h2><h2 id="点击此处一大神的本题题解"><a href="#点击此处一大神的本题题解" class="headerlink" title="[ 点击此处一大神的本题题解"></a>[ 点击此处一大神的本题题解</h2><p>](<a href="http://blog.csdn.net/mengxiang000000/article/details/50787638" target="_blank" rel="noopener">http://blog.csdn.net/mengxiang000000/article/details/50787638</a>)</p><p>螺旋矩阵<br>Time Limit: 1000 MS Memory Limit: 10240 K<br>Total Submit: 282(78 users) Total Accepted: 81(72 users) Rating: Special<br>Judge: No<br>Description<br>对于给定的一个数n，要你打印n*n的螺旋矩阵。</p><p>比如n=3时，输出：</p><p>1 2 3<br>8 9 4<br>7 6 5</p><p>Input<br>多组测试数据，每个测试数据包含一个整数n（1&lt;=n&lt;=32）<br>Output<br>对于每组测试数据，输出一个n*n的螺旋矩阵，定义在题目描述里。</p><p>在一组测试数据中，每个数占的字符宽度是该组数据中最大的数位数加1，比如3*3的螺旋矩阵，最大值是9，那么每个数就要占2个字符宽度。</p><p>两组测试数据之间用一个空行隔开。</p><p>Sample Input<br>1<br>2<br>3<br>Sample Output<br>1</p><p>1 2<br>4 3</p><p>1 2 3<br>8 9 4<br>7 6 5</p><hr><p><strong> 本题我用的是搜索 </strong><br><strong> 关键点在于搜索的方向控制 </strong><br><strong> 方向控制很简单 就是用fx[4]与fy[4]控制方向 </strong><br><strong> “→”“↓”“←”“↑”这四个方向的循环 </strong><br><strong> 如果上一次搜索是那个搜索那个方向的 如果搜索的图已经到头了 </strong><br><strong> 就从下一个方向开始搜索 </strong><br><strong> 如下就是搜索的代码 </strong></p><pre><code>void dfs(int x,int y,int ii){    int xx,yy;    for(int i=ii;i&lt;4+ii;i++)    {        xx=x+fx[i%4];        yy=y+fy[i%4];        if(xx&gt;0&amp;&amp;yy&gt;0&amp;&amp;xx&lt;=n&amp;&amp;yy&lt;=n&amp;&amp;a[xx][yy]==0)        {            a[xx][yy]=num++;           // printf(&quot;%d %d  -%d\n&quot;,xx,yy,a[xx][yy]);            dfs(xx,yy,i%4);            num--;        }    }}</code></pre><p><strong> _ 本题非常容易PE 主要由以下两点 _ </strong><br><strong> 1.两组数据中间的空格。（这个很容易 但是要读题啊 博主就因为没看到而PE多次） </strong><br><strong> 2.图内最大的数有几位 图内的所有数都占几+1位（这样想就没有空格的干扰了） </strong><br><strong> 关于控制数据占位的个数可以这样表示 </strong></p><pre><code>printf(&quot;%*d&quot;,length+1,a[i][j]); //其中*号是位数 对应length是对应位数的数据 +1是数值之前的空格占一位#include &lt;iostream&gt;#include &lt;stdio.h&gt;#include &lt;vector&gt;#include &lt;stdio.h&gt;#include &lt;queue&gt;#include &lt;string.h&gt;#include &lt;algorithm&gt;using namespace std;int n,num;int a[34][34];int fx[4]={0,1,0,-1};int fy[4]={1,0,-1,0};void dfs(int x,int y,int ii){    int xx,yy;    for(int i=ii;i&lt;4+ii;i++)    {        xx=x+fx[i%4];        yy=y+fy[i%4];        if(xx&gt;0&amp;&amp;yy&gt;0&amp;&amp;xx&lt;=n&amp;&amp;yy&lt;=n&amp;&amp;a[xx][yy]==0)        {            a[xx][yy]=num++;           // printf(&quot;%d %d  -%d\n&quot;,xx,yy,a[xx][yy]);            dfs(xx,yy,i%4);            num--;        }    }}int main(){    int flag=0;    while(~scanf(&quot;%d&quot;,&amp;n))    {        if(flag==1) {printf(&quot;\n&quot;);}        memset(a,0,sizeof(a));        num=2;        int length=1,m=n*n;        while(m&gt;=10)        {            length++;            m/=10;        }        for(int i=0;i&lt;=n+1;i++)        {            a[0][i]=999;            a[i][0]=999;            a[i][n+1]=999;            a[n+1][i]=999;        }        a[1][1]=1;        dfs(1,1,0);        for(int i=1;i&lt;=n;i++)        {            for(int j=1;j&lt;=n;j++)            {                printf(&quot;%*d&quot;,length+1,a[i][j]);            }            printf(&quot;\n&quot;);        }        flag=1;    }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  2015年蓝桥杯省赛B组C/C++（试题+答案）前几题</title>
      <link href="/2016/03/01/50775612/"/>
      <url>/2016/03/01/50775612/</url>
      
        <content type="html"><![CDATA[<h1 id="2015年蓝桥杯省赛B组C-C-（试题-答案）前几题"><a href="#2015年蓝桥杯省赛B组C-C-（试题-答案）前几题" class="headerlink" title="2015年蓝桥杯省赛B组C/C++（试题+答案）前几题"></a>2015年蓝桥杯省赛B组C/C++（试题+答案）前几题</h1><p>2016年03月01日 20:57:20  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：3280</p><hr><p> 博客爬取于<code>2019-04-18 17:21:21</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/50775612" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/50775612</a></p><p>一、奖券数目</p><p>有些人很迷信数字，比如带“4”的数字，认为和“死”谐音，就觉得不吉利。<br>虽然这些说法纯属无稽之谈，但有时还要迎合大众的需求。某抽奖活动的奖券号码是5位数（10000-99999），要求其中不要出现带“4”的号码，主办单位请你计算<br>一下，如果任何两张奖券不重号，最多可发出奖券多少张。</p><p>请提交该数字（一个整数），不要写任何多余的内容或说明性文字。</p><p><strong> 简单数学问题 </strong><br><strong> 排列组合一下 </strong><br>8<em>9</em>9<em>9</em>9=52488</p><p><strong> 暴力搜索 </strong></p><pre><code>#include &lt;stdio.h&gt;int sum;void dfs(int n){    if(n&gt;6) return ;    if(n==6)        sum++;    for(int i=0;i&lt;10;i++)    {        if(n==1&amp;&amp;i==0) continue;        if(i==4) continue;        dfs(n+1);    }}int main(){     dfs(1);     printf(&quot;\n%d\n&quot;,sum);}</code></pre><hr><p>二、</p><p>星系炸弹</p><p>在X星系的广袤空间中漂浮着许多X星人造“炸弹”，用来作为宇宙中的路标。<br>每个炸弹都可以设定多少天之后爆炸。<br>比如：阿尔法炸弹2015年1月1日放置，定时为15天，则它在2015年1月16日爆炸。<br>有一个贝塔炸弹，2014年11月9日放置，定时为1000天，请你计算它爆炸的准确日期。</p><p>请填写该日期，格式为 yyyy-mm-dd 即4位年份2位月份2位日期。比如：2015-02-19<br>请严格按照格式书写。不能出现其它文字或符号。</p><p><strong> _ 本题最好还是用Excel _ </strong><br><strong> 一来题目不难就是麻烦点 </strong><br><strong> 二来比赛时间有限啊 </strong><br><strong> 答案是 </strong> 2017-08-05<br><strong> _ 要注意格式 _ </strong></p><hr><p>三、三羊献瑞</p><p>观察下面的加法算式：</p><ul><li><img src="https://img-blog.csdn.net/20160301180449804" alt="这里写图片描述"></li></ul><p>其中，相同的汉字代表相同的数字，不同的汉字代表不同的数字。</p><p>请你填写“三羊献瑞”所代表的4位数字（答案唯一），不要填写任何多余内容。</p><p><strong> 这就是个数学题 </strong><br><strong> 先按数学题的方法解一下 </strong><br><strong> _ 语言表述的话很长 但思考的时候是很快的 如果没兴趣可以跳过 _ </strong><br><strong> 1，因为是加法算式三是进位出来的 所以是三是1 </strong><br><strong> 2，因为三是1且三加祥能进位，只有1+9能进位，所以祥是9 </strong><br><strong> 但是考虑可能有进位的情况祥可能为8或9 * </strong><br><strong> ⑴，当祥为8时8+1+1（进位的1）=10 这时羊只能为0 而0+任何1~9数均&lt;10 不可能进位 ——不成立 </strong><br><strong> ⑵，当祥为9时9+1+1（进位的1）=1，羊为1 因为三为1 所以羊不为1 ——不成立 </strong><br><strong> 综上得到三为1 祥为9 所以羊为0 </strong><br><strong> 3，瑞+0=生只能是后面进位了，得到瑞+1等于生。 </strong><br><strong> 又有生+献=瑞 即 瑞+1+献=瑞 即 1+献=0 </strong><br><strong> _ （到这可能有些不明白，解释下，这又是因为后位进1导致1+献=0 应为 1+献+1（进位的1）=0 即献=8） _ </strong><br><strong> 此时设瑞=x，辉=y，气=z。 </strong><br><strong> 这时所有的数的关系如下 </strong><br><img src="https://img-blog.csdn.net/20160301205622509" alt="这里写图片描述"><br><strong> 这时从x开始试数，1,0已经有了 从2开始试数 </strong><br><strong> x=2时 x+y&gt;=10，y&gt;=8 而8,9已经存在—— 不成立 </strong><br><strong> x=3时 x+y&gt;=10，y&gt;=7 8,9已经存在 也只能为7，但 x+y=3+7+10 z应为0 因0已经存在—— 不成立 </strong><br><strong> x=4时 x+y&gt;=10，y&gt;=6 8,9已经存在 y可为6,7 当为6时z=0—— 不成立 当为7时 z=1 不成立 </strong><br><strong> x=5时 x+y&gt;=10，y&gt;=5 8,9已经存在 y为7时 z为2 此时总式成立 </strong></p><p><strong> 所以得出结果为 </strong> <strong> _ 9567+1085=10652 _ </strong></p><p><strong> 得出三样献瑞 为1085 </strong><br><strong> _ 此题目用推理的方式做出来 上述只是他的证明过程 所以文字多 篇幅长 但是这都是思考出来的 在实际操作中很快就会得出结果 比写暴力的代码要省时的多 毕竟代码那么多的for语句 还有那么多数字加在一起 很容易出错了 虽然不用代码 有点违背蓝桥杯是C++比赛的事实 但是做出题来得分 取得名次 才是王道 _ </strong></p><p><strong> 下面是常规暴力做法 </strong></p><pre><code>#include &lt;iostream&gt;#include &lt;cstdio&gt;using namespace std;int main(){    int a, b, c, d, e, f, g;    for(a = 1; a &lt;= 9; a++)    {        for(b = 0; b &lt;= 9; b++)        {            for(c = 0; c &lt;= 9; c++)            {                for(d = 0; d &lt;= 9; d++)                {                        for(e = 0; e &lt;= 9; e++)                        {                            for(f = 0; f &lt;= 9; f++)                            {                                for(g = 0; g &lt;= 9; g++)                                {                                        if((a * 1000 + b * 100 + c * 10 + d) + (1000 + e * 100 + f * 10 + b) == (10000 + e * 1000 + c * 100 + b * 10 + g))                                        {                                            if(a != 1 &amp;&amp; b != 1 &amp;&amp; c != 1 &amp;&amp; d != 1 &amp;&amp; e != 1 &amp;&amp; f != 1)                                            {                                                    if(a != b &amp;&amp; a != c &amp;&amp; a != d &amp;&amp; a !=e &amp;&amp; a != f &amp;&amp; a != g &amp;&amp; b != c &amp;&amp; b != d &amp;&amp; b != e &amp;&amp; b != f &amp;&amp; b != g &amp;&amp; c != d &amp;&amp; c != e &amp;&amp; c != f &amp;&amp; c != g &amp;&amp; d != e &amp;&amp; d != f &amp;&amp; d != g &amp;&amp; e != f &amp;&amp; e != g &amp;&amp; f != g)                                                    {                                                            cout&lt;&lt;1 * 1000 + e * 100 + f * 10 + b&lt;&lt;endl;                                                    }                                            }                                        }                                }                            }                        }                }            }        }    }    return 0;}</code></pre><p>_ 这么繁杂的代码 写起来也很影响心情啊 _<br>———————————Update—————————–<br>其实C++ 库中有一种函数是next_permutation()<br>它能够将序列的全排列全部计算出来,这样的话,这道题目的代码量就会减少太多了.<br>以下代码已经确认 <strong> ‘三’=1 </strong> , <strong> ‘祥’=9 </strong></p><pre><code>bool check(int *a){    return ((9*1000+a[0]*100+a[1]*10+a[2])+(1000+a[3]*100+a[4]*10+a[0])==(10000+a[3]*1000+a[1]*100+a[0]*10+a[5]));}int main(){    int a[]={0,2,3,4,5,6,7,8};    int tem = 8*7*6*5*4*3*2*1;    while(tem--){        if(check(a)){            printf(&quot;%d\n&quot;,(1000+a[3]*100+a[4]*10+a[0]));        }        next_permutation(a,a+8);    }    return 0;}</code></pre><hr><p>第6题：加号改乘号</p><p>题目大意</p><p>把1+2+3+…+48+49中的两个加号改成乘号（修改位置不能相邻），使得式子的结果由1225变为2015。</p><p>解题分析：</p><p>用双循环暴力两个乘号的位置，计算在数字i、j后的加号改为乘号，式子数值的变化即可，注意j的起始位置为i+2。</p><p>简化一下能得到是判断式为 <strong> 792=i<em>(i-1)+j</em>(j-1) </strong></p><p>代码：</p><pre><code>#include &lt;iostream&gt;#include &lt;cstdio&gt;using namespace std;int main(){    for(int i = 1; i &lt;= 48; i++)    {        for(int j = i + 2; j &lt;= 48; j++)        {            if(792==i*(i-1)+j*(j-1))                cout&lt;&lt;i&lt;&lt;j&lt;&lt;endl;        }    }    return 0;}</code></pre><hr><p>7题：牌型种数</p><p>题目大意</p><p>原题：</p><p>小明被劫持到X赌城，被迫与其他3人玩牌。<br>一副扑克牌（去掉大小王牌，共52张），均匀发给4个人，每个人13张。<br>这时，小明脑子里突然冒出一个问题：<br>如果不考虑花色，只考虑点数，也不考虑自己得到的牌的先后顺序，自己手里能拿到的初始牌型组合一共有多少种呢？</p><p>请填写该整数，不要填写任何多余的内容或说明文字。</p><p>解题分析：<br>这里也是两种方法， 暴力搜索。</p><p><strong> 题目很容易 记住剪枝 能快不少 </strong></p><pre><code>#include &lt;iostream&gt;#include &lt;stdio.h&gt;using namespace std;__int64 sum=0;void dfs(int x,int num){    if(num&gt;13) return;    if(x==0)    {        if(num==13)            sum++;        return;    }    for(int i=0; i&lt;5; i++)    {        dfs(x-1,num+i);    }}int main(){    dfs(13,0);    printf(&quot;%I64d\n&quot;,sum);    return 0;}</code></pre><hr><p>就这么多吧</p>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  POJ 1611 The Suspects [简单并查集应用]</title>
      <link href="/2016/03/01/50774422/"/>
      <url>/2016/03/01/50774422/</url>
      
        <content type="html"><![CDATA[<h1 id="POJ-1611-The-Suspects-简单并查集应用"><a href="#POJ-1611-The-Suspects-简单并查集应用" class="headerlink" title="POJ 1611 The Suspects [简单并查集应用]"></a>POJ 1611 The Suspects [简单并查集应用]</h1><p>2016年03月01日 17:48:23  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：532</p><hr><p> 博客爬取于<code>2019-04-18 17:21:22</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/50774422" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/50774422</a></p><p><strong> _ 中文版的题目很人性化 有木有 _ </strong><br>B - The Suspects<br>Time Limit:1000MS Memory Limit:20000KB 64bit IO Format:%I64d &amp; %I64u<br>Submit</p><p>Status<br>Description<br>严重急性呼吸系统综合症( SARS), 一种原因不明的非典型性肺炎,从2003年3月中旬开始被认为是全球威胁。为了减少传播给别人的机会,<br>最好的策略是隔离可能的患者。<br>在Not-Spreading-Your-Sickness大学( NSYSU), 有许多学生团体。同一组的学生经常彼此相通,一个学生可以同时加入几个小组。为了<br>防止非典的传播,NSYSU收集了所有学生团体的成员名单。他们的标准操作程序(SOP)如下：<br>一旦一组中有一个可能的患者, 组内的所有成员就都是可能的患者。<br>然而,他们发现当一个学生被确认为可能的患者后不容易识别所有可能的患者。你的工作是编写一个程序, 发现所有可能的患者。</p><p>Input<br>输入文件包含多组数据。<br>对于每组测试数据：<br>第一行为两个整数n和m, 其中n是学生的数量, m是团体的数量。0 &lt; n &lt;= 30000，0 &lt;= m &lt;= 500。<br>每个学生编号是一个0到n-1之间的整数，一开始只有0号学生被视为可能的患者。<br>紧随其后的是团体的成员列表，每组一行。<br>每一行有一个整数k，代表成员数量。之后,有k个整数代表这个群体的学生。一行中的所有整数由至少一个空格隔开。<br>n = m = 0表示输入结束，不需要处理。<br>Output<br>对于每组测试数据, 输出一行可能的患者。<br>Sample Input<br>100 4<br>2 1 2<br>5 10 13 11 12 14<br>2 0 1<br>2 99 2<br>200 2<br>1 5<br>5 1 2 3 4 5<br>1 0<br>0 0<br>Sample Output<br>4<br>1<br>1</p><hr><p>本题思路：就是并查集的基本使用 把与病人接触的和间接接触的放在一堆即可 然后遍历一下 记录一下有多少就行</p><p><strong> _ 一定要注意 _ </strong> ：本题后台数据量较大 一定要使用路径压缩 否则在遍历的时候 时间复杂度远大于O(n) 造成TLE </p><p><a href="http://acm.hrbust.edu.cn/index.php?m=ProblemSet&amp;a=showProblem&amp;problem_id=1073" target="_blank" rel="noopener"> <strong> 附一道简单的类似题 </strong> </a></p><p><strong> 有人嫌上述的并查集代码比较麻烦所以用递归的并查集代码，但是并不能对路径进行压缩，对于那些不许路径压缩的题目很好 但是对于本类必须进行路径压缩的就不行了 </strong><br><strong> _ 当然递归的代码可能有路径压缩，但是我不会&gt;_&lt; _ </strong></p><pre><code>#include&lt;stdio.h&gt;  #include&lt;string.h&gt;  using namespace std;  int f[3000000];  int a[3000000];  int j[3000000];  int find(int a)  {      int r=a;      while(f[r]!=r)      r=f[r];      int i=a;      int j;      while(i!=r)    {          j=f[i];          f[i]=r;          i=j;      }      return r;  }  void merge(int a,int b)  {      int A,B;      A=find(a);      B=find(b);      if(A!=B)      {           f[B]=A;           j[A]+=j[B];      }  }  int main()  {      int n,m;      while(~scanf(&quot;%d%d&quot;,&amp;n,&amp;m))      {          if(n==0&amp;&amp;m==0)break;          for(int i=0;i&lt;n;i++)          {              f[i]=i;              j[i]=1;          }          for(int i=0;i&lt;m;i++)          {              int k;              scanf(&quot;%d&quot;,&amp;k);              for(int j=0;j&lt;k;j++)              {                  scanf(&quot;%d&quot;,&amp;a[j]);                  for(int l=0;l&lt;j;l++)                  {                      merge(a[j],a[l]);                  }              }          }          printf(&quot;%d\n&quot;,j[find(0)]);      }      return 0;}  </code></pre>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  2014第五届蓝桥杯C++B组第七题</title>
      <link href="/2016/03/01/50773461/"/>
      <url>/2016/03/01/50773461/</url>
      
        <content type="html"><![CDATA[<h1 id="2014第五届蓝桥杯C-B组第七题"><a href="#2014第五届蓝桥杯C-B组第七题" class="headerlink" title="2014第五届蓝桥杯C++B组第七题"></a>2014第五届蓝桥杯C++B组第七题</h1><p>2016年03月01日 16:12:00  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：366</p><hr><p> 博客爬取于<code>2019-04-18 17:21:23</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/50773461" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/50773461</a></p><p>第7题：六角填数（12’）  </p><p>如图所示六角形中，填入1~12的数字。<br>使得每条直线上的数字之和都相同。<br>图中，已经替你填好了3个数字，请你计算星号位置所代表的数字是多少？  </p><p>请通过浏览器提交答案，不要填写多余的内容。  </p><p><img src="https://img-blog.csdn.net/20140325202603937?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGpkNDMwNQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt>  </p><p>思路就是暴力解决  蓝桥杯还没有时间限制</p><p>之间运用了STL的一个函数 next_permutation（）;</p><p>next_permutation（）;是一个用来来寻找一组序列的下一个排列的函数   使用时与sort类似</p><p>解释一下什么是一个序列的下一个排列：</p><p>比如有一个序列 1 2 3  他的下一个排列就是1 3 2</p><p>这是所有1 2 3的所有排列</p><p>1 3 2</p><p>1 3 2<br>2 1 3<br>2 3 1<br>3 1 2<br>3 2 1  </p><p>当本次排列已经是最后一个排列的时候 他的下一个排列就是第一个排列</p><p>附道题吧<br><a href="http://acm.hrbust.edu.cn/index.php?m=ProblemSet&amp;a=showProblem&amp;problem_id=2005" target="_blank" rel="noopener">http://acm.hrbust.edu.cn/index.php?m=ProblemSet&amp;a=showProblem&amp;problem_id=2005</a></p><p>这道题仅用这个函数就能做出来 题目对本函数的描述也是很详细的</p><pre><code>#include &lt;iostream&gt;#include &lt;stdio.h&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;algorithm&gt;using namespace std;//int a[4][10];int sum[10];int a[15]={0,2,4,5,6,7,9,10,11,12};int main(){    for(int i=1;i&gt;0;i++)    {        next_permutation(a+1,a+10);          sum[1]=1+a[1]+a[4]+a[6];        sum[2]=1+a[2]+a[5]+a[9];        sum[3]=a[6]+a[7]+a[8]+a[9];        sum[4]=8+a[2]+a[1]+a[3];        sum[5]=8+a[4]+a[7]+3;        sum[6]=3+a[8]+a[5]+a[3];        if(sum[1]==sum[2]&amp;&amp;sum[1]==sum[3]&amp;&amp;sum[1]==sum[4]&amp;&amp;sum[1]==sum[5]&amp;&amp;sum[1]==sum[6])            break;    }    for(int i=1;i&lt;10;i++)    printf(&quot;%d-%d\n&quot;,i,a[i]);    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  HDU 2571 命运 DP 动态规划</title>
      <link href="/2016/03/01/50772761/"/>
      <url>/2016/03/01/50772761/</url>
      
        <content type="html"><![CDATA[<h1 id="HDU-2571-命运-DP-动态规划"><a href="#HDU-2571-命运-DP-动态规划" class="headerlink" title="HDU 2571 命运 DP 动态规划"></a>HDU 2571 命运 DP 动态规划</h1><p>2016年03月01日 15:19:50  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：505</p><hr><p> 博客爬取于<code>2019-04-18 17:21:25</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/50772761" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/50772761</a></p><h1 id="命运"><a href="#命运" class="headerlink" title="命运"></a>命运</h1><p><strong> Time Limit: 2000/1000 MS (Java/Others)    Memory Limit: 32768/32768 K (Java/Others)<br>Total Submission(s): 14372    Accepted Submission(s): 5068  </strong>   </p><p>Problem Description</p><p>穿过幽谷意味着离大魔王lemon已经无限接近了！<br>可谁能想到，yifenfei在斩杀了一些虾兵蟹将后，却再次面临命运大迷宫的考验，这是魔王lemon设下的又一个机关。要知道，不论何人，若在迷宫中被困1小时以<br>上，则必死无疑！<br>可怜的yifenfei为了去救MM，义无返顾地跳进了迷宫。让我们一起帮帮执着的他吧！<br>命运大迷宫可以看成是一个两维的方格阵列，如下图所示：<br><img src="http://acm.hdu.edu.cn/data/images/C164-1005-1.jpg" alt><br>yifenfei一开始在左上角，目的当然是到达右下角的大魔王所在地。迷宫的每一个格子都受到幸运女神眷恋或者痛苦魔王的诅咒，所以每个格子都对应一个值，走到那里<br>便自动得到了对应的值。<br>现在规定yifenfei只能向右或者向下走，向下一次只能走一格。但是如果向右走，则每次可以走一格或者走到该行的列数是当前所在列数倍数的格子，即：如果当前格子<br>是（x,y），下一步可以是（x+1,y），(x,y+1)或者(x,y*k) 其中k&gt;1。<br>为了能够最大把握的消灭魔王lemon，yifenfei希望能够在这个命运大迷宫中得到最大的幸运值。<br><img src="http://acm.hdu.edu.cn/data/images/C164-1005-2.jpg" alt>  </p><p>Input</p><p>输入数据首先是一个整数C，表示测试数据的组数。<br>每组测试数据的第一行是两个整数n,m，分别表示行数和列数(1&lt;=n&lt;=20,10&lt;=m&lt;=1000)；<br>接着是n行数据，每行包含m个整数，表示n行m列的格子对应的幸运值K ( |k|&lt;100 )。  </p><p>Output</p><p>请对应每组测试数据输出一个整数，表示yifenfei可以得到的最大幸运值。</p><p>Sample Input</p><p>1 3 8 9 10 10 10 10 -10 10 10 10 -11 -1 0 2 11 10 -20 -11 -11 10 11 2 10 -10<br>-10</p><p>Sample Output</p><p>52</p><p>Author</p><p>yifenfei</p><p>本题就是简单的DP   难点就在于几个细的点没有想到</p><p>1、如果全是负数的时候  。</p><p>2、向右跳的时候k值的界限 k&lt;=m</p><p>直接上代码</p><p>AC代码</p><p>#include &lt;stdio.h&gt;  </p><p>#include <algorithm>  </algorithm></p><p>#include <iostream>  </iostream></p><p>#include &lt;math.h&gt;  </p><p>#include &lt;string.h&gt;  </p><p>#include <queue>  </queue></p><p>#include <stack>  </stack></p><p>#include <map><br>using namespace std;<br>int a[22][1005];<br>int dp[22][1005];<br>int main()<br>{<br>int t;<br>scanf(“%d”,&amp;t);<br>while(t–)<br>{<br>memset(a,0,sizeof(a));<br>memset(dp,-0x1f1f1f,sizeof(dp));<br>int n,m;<br>scanf(“%d%d”,&amp;n,&amp;m);<br>for(int i=1; i&lt;=n; i++)<br>{<br>for(int j=1; j&lt;=m; j++)<br>{<br>scanf(“%d”,&amp;a[i][j]);<br>}<br>}<br>//int maxi=-0X1f1f1f1f;<br>dp[1][1]=a[1][1];<br>dp[1][0]=dp[0][1]=0;<br>/*<br>for(int j=2; j&lt;=n; j++)<br>{<br>dp[j][1]=dp[j-1][1]+a[j][1];<br>}<br>for(int i=2; i&lt;=m; i++)<br>{  </map></p><p>dp[1][i]=dp[1][i-1];<br>dp[1][i]+=a[1][i];<br>for(int k=2; k&lt;i; k++)<br>{<br>if(i%k==0)<br>dp[1][i]=max(dp[1][i],a[1][i]+dp[1][i/k]);<br>}<br>}<br>for(int j=2; j&lt;=n; j++)<br>{<br>dp[j][1]=dp[j-1][1]+a[j][1];<br>}<em>/<br>/</em>                //测试用<br>printf(“++++++++++++\n”);  </p><p>for(int i=0; i&lt;=n; i++)<br>{<br>for(int j=0; j&lt;=m; j++)<br>printf(“%3d “,a[i][j]);<br>printf(“\n”);<br>}<br>printf(“++++++++++++\n”);<br>for(int i=0; i&lt;=n; i++)<br>{<br>for(int j=0; j&lt;=m; j++)<br>printf(“%3d “,dp[i][j]);<br>printf(“\n”);<br>}*/<br>for(int i=1; i&lt;=n; i++)<br>{<br>for(int j=1; j&lt;=m; j++)<br>{  </p><p>dp[i][j]=max(dp[i][j-1],dp[i-1][j]);<br>for(int k=2; k&lt;=m; k++)<br>{<br>if(j%k==0)<br>dp[i][j]=max(dp[i][j],dp[i][j/k]);<br>}  </p><p>dp[i][j]+=a[i][j];<br>}<br>}<br>/*                            //测试用<br>printf(“++++++++++++\n”);  </p><p>for(int i=0; i&lt;=n; i++)<br>{<br>for(int j=0; j&lt;=m; j++)<br>printf(“%3d “,dp[i][j]);<br>printf(“\n”);<br>}<br>printf(“++++++++++++\n”);<br>*/<br>printf(“%d\n”,dp[n][m]);<br>}<br>return 0;<br>}  </p><p>错误代码  差别就是k值取得是k&lt;j    一开始想的是在每个点的时候 选取到这个点时的最大值 没有考虑那么多  </p><p>#include &lt;stdio.h&gt;  </p><p>#include <algorithm>  </algorithm></p><p>#include <iostream>  </iostream></p><p>#include &lt;math.h&gt;  </p><p>#include &lt;string.h&gt;  </p><p>#include <queue>  </queue></p><p>#include <stack>  </stack></p><p>#include <map><br>using namespace std;<br>int a[22][1005];<br>int dp[22][1005];<br>int main()<br>{<br>int t;<br>scanf(“%d”,&amp;t);<br>while(t–)<br>{<br>memset(a,0,sizeof(a));<br>memset(dp,-0x1f1f1f,sizeof(dp));<br>int n,m;<br>scanf(“%d%d”,&amp;n,&amp;m);<br>for(int i=1; i&lt;=n; i++)<br>{<br>for(int j=1; j&lt;=m; j++)<br>{<br>scanf(“%d”,&amp;a[i][j]);<br>}<br>}<br>//int maxi=-0X1f1f1f1f;<br>dp[1][1]=a[1][1];<br>dp[1][0]=dp[0][1]=0;<br>/*<br>for(int j=2; j&lt;=n; j++)<br>{<br>dp[j][1]=dp[j-1][1]+a[j][1];<br>}<br>for(int i=2; i&lt;=m; i++)<br>{  </map></p><p>dp[1][i]=dp[1][i-1];<br>dp[1][i]+=a[1][i];<br>for(int k=2; k&lt;i; k++)<br>{<br>if(i%k==0)<br>dp[1][i]=max(dp[1][i],a[1][i]+dp[1][i/k]);<br>}<br>}<br>for(int j=2; j&lt;=n; j++)<br>{<br>dp[j][1]=dp[j-1][1]+a[j][1];<br>}<em>/<br>/</em>                //测试用<br>printf(“++++++++++++\n”);  </p><p>for(int i=0; i&lt;=n; i++)<br>{<br>for(int j=0; j&lt;=m; j++)<br>printf(“%3d “,a[i][j]);<br>printf(“\n”);<br>}<br>printf(“++++++++++++\n”);<br>for(int i=0; i&lt;=n; i++)<br>{<br>for(int j=0; j&lt;=m; j++)<br>printf(“%3d “,dp[i][j]);<br>printf(“\n”);<br>}<em>/<br>for(int i=1; i&lt;=n; i++)<br>{<br>for(int j=1; j&lt;=m; j++)<br>{<br>if(a[i][j]+dp[i][j-1]&gt;a[i][j]+dp[i-1][j])<br>{<br>dp[i][j]=a[i][j]+dp[i][j-1];<br>for(int k=2; k&lt;=m; k++)<br>{<br>if(j%k==0)<br>dp[i][j]=max(dp[i][j],a[i][j]+dp[i][j/k]);<br>}<br>}<br>else dp[i][j]= a[i][j]+dp[i-1][j];<br>}<br>}<br>/</em>                            //测试用<br>printf(“++++++++++++\n”);  </p><p>for(int i=0; i&lt;=n; i++)<br>{<br>for(int j=0; j&lt;j; j++)<br>printf(“%3d “,dp[i][j]);<br>printf(“\n”);<br>}<br>printf(“++++++++++++\n”);<br>*/<br>printf(“%d\n”,dp[n][m]);<br>}<br>return 0;<br>}  </p><p>精简版代码</p><p>#include &lt;stdio.h&gt;  </p><p>#include <algorithm>  </algorithm></p><p>#include <iostream>  </iostream></p><p>#include &lt;math.h&gt;  </p><p>#include &lt;string.h&gt;  </p><p>#include <queue>  </queue></p><p>#include <stack>  </stack></p><p>#include <map><br>using namespace std;<br>int a[22][1005];<br>int dp[22][1005];<br>int main()<br>{<br>int t;<br>scanf(“%d”,&amp;t);<br>while(t–)<br>{<br>memset(a,0,sizeof(a));<br>memset(dp,-0x1f1f1f,sizeof(dp));<br>int n,m;<br>scanf(“%d%d”,&amp;n,&amp;m);<br>for(int i=1; i&lt;=n; i++)<br>{<br>for(int j=1; j&lt;=m; j++)<br>{<br>scanf(“%d”,&amp;a[i][j]);<br>}<br>}<br>dp[1][1]=a[1][1];<br>dp[1][0]=dp[0][1]=0;<br>for(int i=1; i&lt;=n; i++)<br>{<br>for(int j=1; j&lt;=m; j++)<br>{  </map></p><p>dp[i][j]=max(dp[i][j-1],dp[i-1][j]);<br>for(int k=2; k&lt;=m; k++)<br>{<br>if(j%k==0)<br>dp[i][j]=max(dp[i][j],dp[i][j/k]);<br>}  </p><p>dp[i][j]+=a[i][j];<br>}<br>}<br>printf(“%d\n”,dp[n][m]);<br>}<br>return 0;<br>}  </p>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  HDU 5326 work 【并查集】</title>
      <link href="/2016/02/29/50768959/"/>
      <url>/2016/02/29/50768959/</url>
      
        <content type="html"><![CDATA[<h1 id="HDU-5326-work-【并查集】"><a href="#HDU-5326-work-【并查集】" class="headerlink" title="HDU 5326 work 【并查集】"></a>HDU 5326 work 【并查集】</h1><p>2016年02月29日 22:44:31  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：287</p><hr><p> 博客爬取于<code>2019-04-18 17:21:26</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/50768959" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/50768959</a></p><h1 id="Work"><a href="#Work" class="headerlink" title="Work"></a>Work</h1><p><strong> Time Limit: 2000/1000 MS (Java/Others)    Memory Limit: 32768/32768 K (Java/Others)<br>Total Submission(s): 1353    Accepted Submission(s): 813  </strong>   </p><p>Problem Description</p><p><img src="http://acm.hdu.edu.cn/data/images/5326-1.jpg" alt>  </p><p>It’s an interesting experience to move from ICPC to work, end my college life<br>and start a brand new journey in company.<br>As is known to all, every stuff in a company has a title, everyone except the<br>boss has a direct leader, and all the relationship forms a tree. If A’s title<br>is higher than B(A is the direct or indirect leader of B), we call it A<br>manages B.<br>Now, give you the relation of a company, can you calculate how many people<br>manage k people.  </p><p>Input</p><p>There are multiple test cases.<br>Each test case begins with two integers n and k, n indicates the number of<br>stuff of the company.<br>Each of the following n-1 lines has two integers A and B, means A is the<br>direct leader of B.  </p><p>1 &lt;= n &lt;= 100 , 0 &lt;= k &lt; n<br>1 &lt;= A, B &lt;= n  </p><p>Output</p><p>For each test case, output the answer as described above.</p><p>Sample Input</p><p>7 2 1 2 1 3 2 4 2 5 3 6 3 7</p><p>Sample Output</p><p>2</p><p>Author</p><p>题目大意就是求子集节点数是K的有几个</p><p>然后做着做着就出来了</p><p>/*</p><p>#include <iostream></iostream></p><p>#include &lt;stdio.h&gt;</p><p>#include &lt;string.h&gt;</p><p>#include <algorithm></algorithm></p><p>using namespace std;</p><p>int has[2][105][105];</p><p>int son[105];</p><p>int n,m,sum;</p><p>int fin(int x)</p><p>{</p><p>int num=0;</p><p>for(int j=1; j&lt;=n; j++)</p><p>{</p><p>if(has[1][x][j]==1&amp;&amp;has[0][x][j]==0)</p><p>{</p><p>num++;</p><p>has[0][x][j]=1;</p><p>son[x]+=fin(j);</p><p>}</p><p>}</p><p>return son[x];</p><p>}</p><p>int main ()</p><p>{</p><p>while(~scanf(“%d%d”,&amp;n,&amp;m))</p><p>{</p><p>memset(has,0,sizeof(has));</p><p>memset(son,0,sizeof(son));</p><p>int a,aa;</p><p>sum=0;</p><p>for(int i=1; i&lt;n; i++)</p><p>{</p><p>scanf(“%d%d”,&amp;a,&amp;aa);</p><p>has[1][a][aa]=1;</p><p>son[a]++;</p><p>}</p><p>for(int i=1; i&lt;=n; i++)</p><p>{</p><p>for(int j=1; j&lt;=n; j++)</p><p>{</p><p>if(has[1][i][j]==1&amp;&amp;has[0][i][j]==0)</p><p>{</p><p>has[0][i][j]=1;</p><p>son[i]+=fin(j);</p><p>}</p><p>}</p><p>}</p><p>/* for(int i=1; i&lt;=n; i++)</p><p>{</p><p>printf(“**%d\n”,son[i]);</p><p>}</p><p>for(int i=1; i&lt;=n; i++)</p><p>{</p><p>if(m==son[i])</p><p>sum++;</p><p>}</p><p>printf(“%d\n”,sum);</p><p>}</p><p>}*/</p><p>#include&lt;stdio.h&gt;</p><p>#include&lt;string.h&gt;</p><p>using namespace std;</p><p>int f[105];</p><p>int jihe[105];</p><p>void find2(int a)</p><p>{</p><p>int r=a;</p><p>while(f[r]!=r)</p><p>{</p><p>r=f[r];//r是一个上司。</p><p>jihe[r]++;//这个上司有一个员工。</p><p>}</p><p>}</p><p>int main()</p><p>{</p><p>int n,m;</p><p>while(~scanf(“%d%d”,&amp;n,&amp;m))</p><p>{</p><p>for(int i=1;i&lt;=n;i++)</p><p>{</p><p>f[i]=i;</p><p>jihe[i]=0;</p><p>}</p><p>for(int i=0;i&lt;n-1;i++)</p><p>{</p><p>int x,y;</p><p>scanf(“%d%d”,&amp;x,&amp;y);</p><p>f[y]=x;//让并查集数组指向上司</p><p>}</p><p>int output=0;</p><p>for(int i=1;i&lt;=n;i++)</p><p>{</p><p>find2(i);//枚举每一个人，让他找他的上司</p><p>}</p><p>for(int i=1;i&lt;=n;i++)</p><p>{</p><p>if(jihe[i]==m)</p><p>output++;//符合条件的输出</p><p>}</p><p>printf(“%d\n”,output);</p><p>}</p><p>}</p><p>//附几组数据</p><p>/*</p><p>7 6</p><p>1 2</p><p>1 3</p><p>2 4</p><p>2 5</p><p>3 6</p><p>3 7</p><p>7 2</p><p>1 2</p><p>1 3</p><p>2 4</p><p>2 5</p><p>3 6</p><p>3 7</p><p>7 2</p><p>7 6</p><p>7 5</p><p>6 4</p><p>6 3</p><p>5 2</p><p>5 1</p><p>7 1</p><p>1 2</p><p>2 3</p><p>3 4</p><p>4 5</p><p>5 6</p><p>6 7</p><p>*/ </p><p>Author</p>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>&lt;转&gt;#  HDU 2709 总结 DP/递推</title>
      <link href="/2016/02/28/50761497/"/>
      <url>/2016/02/28/50761497/</url>
      
        <content type="html"><![CDATA[<h1 id="HDU-2709-总结-DP-递推"><a href="#HDU-2709-总结-DP-递推" class="headerlink" title="HDU 2709 总结 DP/递推"></a>HDU 2709 总结 DP/递推</h1><p>2016年02月28日 20:28:28  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：300<br>标签：  <a href="https://so.csdn.net/so/search/s.do?q=hdu&amp;t=blog" target="_blank" rel="noopener"> hdu </a> <a href="https://so.csdn.net/so/search/s.do?q=OJ&amp;t=blog" target="_blank" rel="noopener"> OJ</a> <a href="https://so.csdn.net/so/search/s.do?q=杭电&amp;t=blog" target="_blank" rel="noopener"> 杭电</a></p><hr><p> 博客爬取于<code>2019-04-18 17:21:27</code><br><strong><em>以下为正文</em></strong></p><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=2709" target="_blank" rel="noopener">http://acm.hdu.edu.cn/showproblem.php?pid=2709</a></p><h1 id="Sumsets"><a href="#Sumsets" class="headerlink" title="Sumsets"></a>Sumsets</h1><p><strong> Time Limit: 6000/2000 MS (Java/Others)    Memory Limit: 32768/32768 K (Java/Others)<br>Total Submission(s): 2052    Accepted Submission(s): 813  </strong>   </p><p>Problem Description</p><p>Farmer John commanded his cows to search for different sets of numbers that<br>sum to a given number. The cows use only numbers that are an integer power of</p><ol start="2"><li>Here are the possible sets of numbers that sum to 7:  </li></ol><p>1) 1+1+1+1+1+1+1<br>2) 1+1+1+1+1+2<br>3) 1+1+1+2+2<br>4) 1+1+1+4<br>5) 1+2+2+2<br>6) 1+2+4  </p><p>Help FJ count all possible representations for a given integer N (1 &lt;= N &lt;=<br>1,000,000).</p><p>Input</p><p>A single line with a single integer, N.</p><p>Output</p><p>The number of ways to represent N as the indicated sum. Due to the potential<br>huge size of this number, print only last 9 digits (in base 10<br>representation).</p><p>Sample Input</p><p>7</p><p>Sample Output</p><p>6</p><p>一、 DP解法（这应该是标准解法了 本人第一次 碰到这类题 也是用DP）</p><p>思路：</p><p>1.如果n为奇数，那么所求的分解结果中必含有1，因此，直接将n-1的分拆结果中添加一个1即可 为s[n-1]</p><p>2.如果n为偶数，那么n的分解结果分两种情况：<br>a) 含有1：这种情况可以直接在n-1的分解结果中添加一个1即可 s[n-1]<br>b) 不含1：那么，分解因子的都是偶数，将每个分解的因子都除以2，刚好是n/2的分解结果，并且可以与之一一对应，这种情况有 s[n/2]</p><p>所以，状态转移方程为<br>如果i为奇数 s[i] = s[i-1]<br>如果i为偶数 s[i] = s[i-1] + s[i/2]</p><pre><code>#include &lt;iostream&gt;using namespace std;int n, s[1000001], i = 3;void init(){    s[1] = 1;    s[2] = 2;    for( ;i &lt;= 1000000; i += 2 )    {        s[i] = s[i-1];        s[i+1] = (s[i] + s[(i+1)/2]) % 1000000000;    }}int main(){    init();    while( cin&gt;&gt;n )        cout&lt;&lt;s[n]&lt;&lt;endl;    return 0;}</code></pre><p>二、这是递推的方法   （很简洁  偶然看到这个代码  只想说牛X）</p><pre><code>如果所求的n为奇数，那么所求的分解结果中必含有1，因此，直接将n-1的分拆结果中添加一个1即可 为s[n-1]如果所求的n为偶数，那么n的分解结果分两种情况1.含有1 这种情况可以直接在n-1的分解结果中添加一个1即可 s[n-1]2.不含有1 那么，分解因子的都是偶数，将每个分解的因子都除以2，刚好是n/2的分解结果，并且可以与之一一对应，这种情况有 s[n/2]所以，状态转移方程为如果i为奇数, s[i] = s[i-1]如果i为偶数  s[i] = s[i-1] + s[i/2]</code></pre><p>#include &lt;stdio.h&gt;<br>int n,s[1000001], i = 3;<br>int main()<br>{<br>s[1] = 1;<br>s[2] = 2;<br>while (i &lt;= 1000000)<br>{<br>s[i++] = s[i-1];<br>s[i++] = (s[i-2] + s[i &gt;&gt; 1]) % 1000000000;//  &gt;&gt;是位运算 的左移运算  自行百度吧<br>}<br>while(scanf(“%d”,&amp;n) != EOF)<br>printf(“%d\n”, s[n]);<br>return 0;<br>}  </p>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OJ </tag>
            
            <tag> hdu </tag>
            
            <tag> 杭电 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  HDU 5326 多维数组接法 【并查集】</title>
      <link href="/2016/01/23/50570897/"/>
      <url>/2016/01/23/50570897/</url>
      
        <content type="html"><![CDATA[<h1 id="HDU-5326-多维数组接法-【并查集】"><a href="#HDU-5326-多维数组接法-【并查集】" class="headerlink" title="HDU 5326 多维数组接法 【并查集】"></a>HDU 5326 多维数组接法 【并查集】</h1><p>2016年01月23日 18:40:20  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：268</p><hr><p> 博客爬取于<code>2019-04-18 17:21:28</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/50570897" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/50570897</a></p><p>A -  Work</p><p>Time Limit:  1000  MS  Memory Limit:  32768  KB  64bit IO Format:  %I64d &amp;<br>%I64u</p><p>Description</p><p><img src="http://7xjob4.com1.z0.glb.clouddn.com/ee0a87cafbceb5dd46a39468cbb10195" alt></p><p><strong>   </strong></p><p>It’s an interesting experience to move from ICPC to work, end my college life<br>and start a brand new journey in company.</p><p>As is known to all, every stuff in a company has a title, everyone except the<br>boss has a direct leader, and all the relationship forms a tree. If A’s title<br>is higher than B(A is the direct or indirect leader of B), we call it A<br>manages B.</p><p>Now, give you the relation of a company, can you calculate how many people<br>manage k people.</p><p>Input</p><p>There are multiple test cases.</p><p>Each test case begins with two integers n and k, n indicates the number of<br>stuff of the company.</p><p>Each of the following n-1 lines has two integers A and B, means A is the<br>direct leader of B.</p><p><strong>   </strong></p><p>1 &lt;= n &lt;= 100 , 0 &lt;= k &lt; n</p><p>1 &lt;= A, B &lt;= n</p><p>Output</p><p>For each test case, output the answer as described above.</p><p>Sample Input</p><p>7 2</p><p>1 2</p><p>2 4</p><p>1 3 2 5</p><p>3 7</p><p>3 6</p><p>Sample Output</p><p>2</p><p>题目就是给了一堆数，分别对应一个人，然后吧就是A领导B，最后让你求出有K个手下的人的个数。（开始翻译成了求K的手下有几个。。英语不好真苦逼啊）。。。</p><p>本题其实是一道并查集的题目，但是并查集并没有写明白，所以用了苦逼的多维数组。。。</p><p>详情请看代码。。。</p><p>然后开始贴代码</p><p>#include <iostream>//本人AC代码  </iostream></p><p>#include &lt;stdio.h&gt;  </p><p>#include &lt;string.h&gt;  </p><p>#include <algorithm><br>using namespace std;<br>int has[2][105][105];  //表示领导关系的成立与否 成立为1 不成立默认是0<br>int son[105];               //表示第几个人的手下<br>int n,m,sum;<br>int  fin(int x)              //核心代码<br>{<br>int num=0;<br>for(int j=1; j&lt;=n; j++)<br>{<br>if(has[1][x][j]==1&amp;&amp;has[0][x][j]==0)<br>{<br>num++;<br>has[0][x][j]=1;<br>son[x]+=fin(j);<br>}<br>}<br>return son[x];<br>}<br>int main ()<br>{<br>while(~scanf(“%d%d”,&amp;n,&amp;m))<br>{<br>memset(has,0,sizeof(has));//数组清0<br>memset(son,0,sizeof(son));<br>int a,aa;<br>sum=0;<br>for(int i=1; i&lt;n; i++)<br>{<br>scanf(“%d%d”,&amp;a,&amp;aa);<br>has[1][a][aa]=1;      //表示领导关系<br>son[a]++;                 //这里把a的直接手下记录<br>}<br>for(int i=1; i&lt;=n; i++)   // 这里来计算每个人的间接手下<br>{<br>for(int j=1; j&lt;=n; j++)<br>{<br>if(has[1][i][j]==1&amp;&amp;has[0][i][j]==0)   //后面的那个用来标记遍没遍历，不知道到底有没有用 但是这样比较保险<br>{<br>has[0][i][j]=1;<br>son[i]+=fin(j);<br>}<br>}<br>}<br>//测试的代码<br>/<em><br>for(int i=1; i&lt;=n; i++)<br>{<br>printf(“**%d\n”,son[i]);<br>}  </em>/<br>for(int i=1; i&lt;=n; i++)<br>{<br>if(m==son[i])<br>sum++;<br>}<br>printf(“%d\n”,sum);<br>}<br>}  </algorithm></p><p>另附几组测试数据</p><p>7 6  //1<br>1 2<br>1 3<br>2 4<br>2 5<br>3 6<br>3 7  </p><p>7 2  //2<br>1 2<br>1 3<br>2 4<br>2 5<br>3 6<br>3 7  </p><p>7 2 // 2<br>7 6<br>7 5<br>6 4<br>6 3<br>5 2<br>5 1  </p><p>7 1  //1<br>1 2<br>2 3<br>3 4<br>4 5<br>5 6<br>6 7  </p>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  HRBUST2189 并查集入门 节点的连接</title>
      <link href="/2015/12/28/50420268/"/>
      <url>/2015/12/28/50420268/</url>
      
        <content type="html"><![CDATA[<h1 id="HRBUST2189-并查集入门-节点的连接"><a href="#HRBUST2189-并查集入门-节点的连接" class="headerlink" title="HRBUST2189 并查集入门 节点的连接"></a>HRBUST2189 并查集入门 节点的连接</h1><p>2015年12月28日 17:22:57  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：360<br>标签：  <a href="https://so.csdn.net/so/search/s.do?q=OJ&amp;t=blog" target="_blank" rel="noopener"> OJ </a> <a href="https://so.csdn.net/so/search/s.do?q=并查集&amp;t=blog" target="_blank" rel="noopener"> 并查集</a></p><hr><p> 博客爬取于<code>2019-04-18 17:21:29</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/50420268" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/50420268</a></p><p><strong> 节点的连接  </strong></p><p>Time Limit: 1000 MS</p><p>Memory Limit: 32768 K</p><p>Total Submit: 80  (43 users)</p><p>Total Accepted: 45  (41 users)</p><p>Rating:</p><p>Special Judge:  No</p><p><strong> Description  </strong></p><p>有N个节点，一开始任意两个节点都没有相连，之后有两种操作：</p><p>1: 将 A 节点和 B 节点连接起来。</p><p>2: 问从A节点出发可以直接或间接到达的节点数量。</p><p>如果 A 节点和 B 节点被连接起来了，那么从A可以到达B，同时从B也可以到达A。</p><p><strong> Input  </strong></p><p>第一行是一个整数T，表示有T组测试数据。</p><p>对于每组测试数据，第一行是一个整数 n (n&lt;=1000) 代表节点数，一个整数 m (m&lt;=1000)代表操作数，之后有m行，每行代表一种操作。</p><p>第一种操作是:  0 A B  (1&lt;=A,B&lt;=n)，表示将A,B节点连接起来；</p><p>第二种操作是:  1 A    (1&lt;=A&lt;=n)，表示询问从A节点出发可以直接或间接到达的节点的数量。</p><p><strong> Output  </strong></p><p>对于每组测试数据，如果是第二种操作，输出一个整数表示答案，每组输出占一行。</p><p><strong> Sample Input  </strong></p><p>1</p><p>4 5</p><p>0 1</p><p>1 1 2</p><p>0 1</p><p>1 1 3</p><p>0 3</p><p><strong> Sample Output  </strong></p><p>1</p><p>2</p><p>3</p><p>本题是一道简单的并查集问题</p><p>并查集主要就是有找到自己的上级 然后使两伙人合并到一伙</p><p>其中路径压缩是为使两伙归终于一个老大 而下级之间并不存在关心</p><p>本题没什么难的看看 代码注释就能理解</p><p>#include &lt;stdio.h&gt;</p><p>#include <algorithm></algorithm></p><p>#include &lt;string.h&gt;</p><p>#include <iostream></iostream></p><p>using namespace std;</p><p>int pre[1050];</p><p>void nimabi(int x)   //这个算初始化（自己是自己的老大）</p><p>{</p><p>for(int i=1;i&lt;=x;i++)</p><p>{</p><p>pre[i]=i;</p><p>}</p><p>}</p><p>int find (int x)  //找老大</p><p>{</p><p>int r=x;</p><p>while(r!=pre[r])</p><p>{</p><p>r=pre[r];</p><p>}</p><p>int i=x,j;    //每个人（除了老大）都只有一个老大（老大不会再有老大）</p><p>while(i!=r)</p><p>{</p><p>j=pre[i];</p><p>pre[i]=r;</p><p>i=j;</p><p>}</p><p>return r;</p><p>}</p><p>void join(int x,int y)//这个算是两个集体合伙了（但是老大只能有一个）</p><p>{</p><p>int fx=find(x),fy=find(y);</p><p>if(fx!=fy)</p><p>pre[fx]=fy;</p><p>}</p><p>int main()</p><p>{</p><p>int t;</p><p>scanf(“%d”,&amp;t);</p><p>while(t–)</p><p>{</p><p>int n,m;</p><p>scanf(“%d%d”,&amp;n,&amp;m);</p><p>nimabi(n);</p><p>/* for(int i=1;i&lt;=n;i++)     //就是测试用来找老大的  便于理解</p><p>printf(“%d  “,find(i));</p><p>printf(“======\n”);*/</p><p>for(int i=0;i&lt;m;i++)</p><p>{</p><p>int a;</p><p>scanf(“%d”,&amp;a);</p><p>if(a==1)</p><p>{</p><p>int b,c;</p><p>scanf(“%d%d”,&amp;b,&amp;c);</p><p>join(b,c);</p><p>/*for(int i=1;i&lt;=n;i++)   //跟上面那个一个样</p><p>printf(“%d  “, find(i));</p><p>printf(“===========\n”);*/</p><p>}</p><p>else</p><p>{</p><p>int d,sum=0;</p><p>scanf(“%d”,&amp;d);</p><p>for(int j=1;j&lt;=n;j++)</p><p>{</p><p>if(find(d)==find(j)) sum++;</p><p>}</p><p>printf(“%d\n”,sum);</p><p>}</p><p>}</p><p>}</p><p>}</p>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OJ </tag>
            
            <tag> 并查集 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  POJ3768 较复杂分形题目</title>
      <link href="/2015/12/28/50420183/"/>
      <url>/2015/12/28/50420183/</url>
      
        <content type="html"><![CDATA[<h1 id="POJ3768-较复杂分形题目"><a href="#POJ3768-较复杂分形题目" class="headerlink" title="POJ3768 较复杂分形题目"></a>POJ3768 较复杂分形题目</h1><p>2015年12月28日 17:14:17  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：431</p><hr><p> 博客爬取于<code>2019-04-18 17:21:30</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/50420183" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/50420183</a></p><p>本题就是一个基础的分形问题 ，只不过是在一个自己定义的图形中，再进行分形处理  。</p><p>所以我们一定要把最先定义的图形遍历一遍 找到他的基础结构。用一个二维的数组标记出他的最基础构型 ，就可以开始分型了。</p><p>稍有不同的是在分形打印的函数中的递归函数需要双层的for循环来遍历标记数组，</p><p>其实在遍历标记数组的时候发现比把每个都写出来要容易操作的多（但时间复杂度会变高），当然本题必须采用遍历的操作才可以，因为自己定义的图形，在没有定义的时候，他<br>的结构就是未知的，所以必须遍历。</p><p>接下来就是简单的分型操作了相信你在做这道题的时候已经掌握分形的操作了  这里就不在赘述了</p><p>PS：如果真的不了解分形的话，可以看看这篇博客。</p><p>2014年蓝桥杯第五题 分型问题  判断递归起点稍有不同</p><p><a href="http://blog.csdn.net/qq_33184171/article/details/50390031" target="_blank" rel="noopener"> http://blog.csdn.net/qq_33184171/article/details/50390031</a></p><p>哈理工OJ 题目格式较本题稍复杂</p><p><a href="http://blog.csdn.net/qq_33184171/article/details/50274193" target="_blank" rel="noopener"> http://blog.csdn.net/qq_33184171/article/details/50274193</a></p><p>本题网址： <a href="http://poj.org/problem?id=3768" target="_blank" rel="noopener"> http://poj.org/problem?id=3768 </a></p><p>方便读者  题目放到了本文最后</p><p>另附解题代码</p><p>#include &lt;stdio.h&gt;</p><p>#include &lt;string.h&gt;</p><p>#include &lt;math.h&gt;</p><p>char a[3002][3002];//图形</p><p>char asdf;//分形图形中的字符</p><p>char b[6];//输入用的</p><p>int num,n;</p><p>int flag[6][6];//本组数据是标记用的</p><p>void dayin(int cur,int x,int y)</p><p>{</p><p>if(cur==1)</p><p>{</p><p>a[x][y]=asdf;</p><p>return ;</p><p>}</p><p>int s=pow(n,cur-2);</p><p>for(int i=0; i&lt;n; i++)//这就是遍历标记数组</p><p>{</p><p>for(int j=0; j&lt;n; j++)</p><p>{</p><p>if(flag[i][j]==1)//如果没有运行就不采取操作</p><p>dayin(cur-1,x+i<em>s,y+j</em>s);</p><p>}</p><p>}</p><p>}</p><p>int main()</p><p>{</p><p>while(~scanf(“%d”,&amp;n))</p><p>{</p><p>getchar();</p><p>if(n==0) break;</p><p>memset(a,’ ‘,sizeof(a));</p><p>memset(flag,0,sizeof(flag));</p><p>for(int i=0; i&lt;n; i++)</p><p>{</p><p>gets(b);</p><p>for(int j=0; j&lt;n; j++)//遍历图形 并标记</p><p>{</p><p>if(b[j]!=’ ‘)</p><p>{</p><p>asdf=b[j];</p><p>flag[i][j]=1; //标记</p><p>}</p><p>}</p><p>}</p><p>int m;</p><p>scanf(“%d”,&amp;m);</p><p>int s=pow(n,m);</p><p>dayin(m+1,1,1);</p><p>for(inti=1; i&lt;=s; i++)//这步主要是控制格式</p><p>{</p><p>a[i][s+1]=’\0’;</p><p>puts(a[i]+1);//切记一定要用puts 并且交G++  否则无限TLE 至于为什么 我也不知道</p><p>}</p><p>}</p><p>}</p><p><strong> Repeater  </strong></p><p><strong> Time Limit: </strong> 1000MS </p><p><strong> Memory Limit: </strong> 65536K </p><p><strong> Total Submissions: </strong> 4187 </p><p><strong> Accepted: </strong> 1114 </p><p><strong> Description  </strong></p><p>Harmony is indispensible in our daily lifeand no one can live without it—-<br>may be Facer is the only exception. One dayit is rumored that repeat painting<br>will create harmony and then hundreds ofpeople started their endless drawing.<br>Their paintings were based on a smalltemplate and a simple method of<br>duplicating. Though Facer can easily imaginethe style of the whole picture,<br>but he cannot find the essential harmony. Nowyou need to help Facer by showing<br>the picture on computer.</p><p>You will be given a template containingonly one kind of character and spaces,<br>and the template shows how the endlesspicture is created—-use the characters<br>as basic elements and put them in theright position to form a bigger template,<br>and then repeat and repeat doingthat. Here is an example.</p><h1 id><a href="#" class="headerlink" title="#"></a>#</h1><h1 id="lt-template"><a href="#lt-template" class="headerlink" title="&lt;-template"></a>&lt;-template</h1><h1 id="-1"><a href="#-1" class="headerlink" title="#"></a>#</h1><p>So the Level 1 picture will be</p><h1 id="-2"><a href="#-2" class="headerlink" title="#"></a>#</h1><h1 id="-3"><a href="#-3" class="headerlink" title=" "></a> </h1><h1 id="-4"><a href="#-4" class="headerlink" title="#"></a>#</h1><p>Level 2 picture will be</p><h2 id="-5"><a href="#-5" class="headerlink" title="#"></a>#</h2><h1 id="-6"><a href="#-6" class="headerlink" title="#"></a>#</h1><h2 id="-7"><a href="#-7" class="headerlink" title="#"></a>#</h2><h1 id="-8"><a href="#-8" class="headerlink" title="#"></a>#</h1><h1 id="-9"><a href="#-9" class="headerlink" title=" "></a> </h1><h1 id="-10"><a href="#-10" class="headerlink" title="#"></a>#</h1><h2 id="-11"><a href="#-11" class="headerlink" title="#"></a>#</h2><h1 id="-12"><a href="#-12" class="headerlink" title="#"></a>#</h1><h2 id="-13"><a href="#-13" class="headerlink" title="#"></a>#</h2><p><strong> Input  </strong></p><p>The input contains multiple test cases.<br>Thefirst line of each case is an integer _ N _ , representing the size of the<br>template is _ N _ <em> _ N _ ( _ N _ could only be 3, 4 or 5).<br>Next Nlines describe the template.<br>Thefollowing line contains an integer _ Q _ , which is the Scale Level of the<br>picture.<br>Inputis ended with a case of _ N _ =0.<br>It isguaranteed that the size of one picture will not exceed 3000</em>3000.</p><p><strong> Output  </strong></p><p>For each test case, just print the Level _ Q _ picture by using the given<br>template.</p><p><strong> Sample Input  </strong></p><p>3</p><h1 id="-14"><a href="#-14" class="headerlink" title="#"></a>#</h1><p>#</p><h1 id="-15"><a href="#-15" class="headerlink" title="#"></a>#</h1><p>1</p><p>3</p><h1 id="-16"><a href="#-16" class="headerlink" title="#"></a>#</h1><p>#</p><h1 id="-17"><a href="#-17" class="headerlink" title="#"></a>#</h1><p>3</p><p>4</p><p>OO</p><p>O  O</p><p>O  O</p><p>OO</p><p>2</p><p>0</p><p><strong> Sample Output  </strong></p><h1 id="-18"><a href="#-18" class="headerlink" title="#"></a>#</h1><p>#</p><h1 id="-19"><a href="#-19" class="headerlink" title="#"></a>#</h1><h1 id="-20"><a href="#-20" class="headerlink" title="#   # #        # #   #"></a>#   # #        # #   #</h1><h1 id="-21"><a href="#-21" class="headerlink" title="#           #"></a>#           #</h1><h1 id="-22"><a href="#-22" class="headerlink" title="#   # #        # #   #"></a>#   # #        # #   #</h1><h1 id="-23"><a href="#-23" class="headerlink" title="#               #"></a>#               #</h1><h1 id="-24"><a href="#-24" class="headerlink" title="#"></a>#</h1><h1 id="-25"><a href="#-25" class="headerlink" title="#               #"></a>#               #</h1><h1 id="-26"><a href="#-26" class="headerlink" title="#   # #        # #   #"></a>#   # #        # #   #</h1><h1 id="-27"><a href="#-27" class="headerlink" title="#           #"></a>#           #</h1><h1 id="-28"><a href="#-28" class="headerlink" title="#   # #        # #   #"></a>#   # #        # #   #</h1><h1 id="-29"><a href="#-29" class="headerlink" title="#  #"></a>#  #</h1><h1 id="-30"><a href="#-30" class="headerlink" title="#"></a>#</h1><h1 id="-31"><a href="#-31" class="headerlink" title="#  #"></a>#  #</h1><h1 id="-32"><a href="#-32" class="headerlink" title="#"></a>#</h1><p>#</p><h1 id="-33"><a href="#-33" class="headerlink" title="#"></a>#</h1><h1 id="-34"><a href="#-34" class="headerlink" title="#   #"></a>#   #</h1><h1 id="-35"><a href="#-35" class="headerlink" title="#"></a>#</h1><h1 id="-36"><a href="#-36" class="headerlink" title="#  #"></a>#  #</h1><h1 id="-37"><a href="#-37" class="headerlink" title="#   # #        # #   #"></a>#   # #        # #   #</h1><h1 id="-38"><a href="#-38" class="headerlink" title="#           #"></a>#           #</h1><h1 id="-39"><a href="#-39" class="headerlink" title="#   # #        # #   #"></a>#   # #        # #   #</h1><h1 id="-40"><a href="#-40" class="headerlink" title="#               #"></a>#               #</h1><h1 id="-41"><a href="#-41" class="headerlink" title="#"></a>#</h1><h1 id="-42"><a href="#-42" class="headerlink" title="#               #"></a>#               #</h1><h1 id="-43"><a href="#-43" class="headerlink" title="#   # #        # #   #"></a>#   # #        # #   #</h1><h1 id="-44"><a href="#-44" class="headerlink" title="#           #"></a>#           #</h1><h1 id="-45"><a href="#-45" class="headerlink" title="#   # #        # #   #"></a>#   # #        # #   #</h1><p>OO OO</p><p>O OO  O</p><p>O OO  O</p><p>OO OO</p><p>OO         OO</p><p>O  O       O  O</p><p>O  O       O  O</p><p>OO         OO</p><p>OO         OO</p><p>O  O       O  O</p><p>O  O       O  O</p><p>OO         OO</p><p>OO OO</p><p>O OO  O</p><p>O OO  O</p><p>OO OO</p><p><strong> Source  </strong></p>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  蓝桥杯 2014 第五题</title>
      <link href="/2015/12/23/50390031/"/>
      <url>/2015/12/23/50390031/</url>
      
        <content type="html"><![CDATA[<h1 id="蓝桥杯-2014-第五题"><a href="#蓝桥杯-2014-第五题" class="headerlink" title="蓝桥杯 2014 第五题"></a>蓝桥杯 2014 第五题</h1><p>2015年12月23日 21:59:18  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：601</p><hr><p> 博客爬取于<code>2019-04-18 17:21:31</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/50390031" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/50390031</a></p><p>蓝桥杯2014第五题</p><p>打印图形：</p><p>小明在X星球的城堡了发现了如下图形和文字：</p><p>Rank=3</p><p><img src="https://img-blog.csdn.net/20151228172916859?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt>  </p><p>Rank=4</p><p><img src="https://img-blog.csdn.net/20151228172935235?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt>  </p><p>Rank=5</p><p><img src="https://img-blog.csdn.net/20151228172948657?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt>  </p><p>题目是填空题 但是代码是自己写的</p><p>分形问题最主要的是找到图形的最基本的点</p><p>如POJ  2083 的那个X  基本构成 就是在九个方格里 左上，左下，中间，右上，右下，这5个位置 都有X  而数字没加一个<br>就把每一个X替换成这个基本的构成</p><p>POJ ： <a href="http://poj.org/problem?id=2083" target="_blank" rel="noopener"> http://poj.org/problem?id=2083 </a></p><p>这道题个基本构成就不是这么简单  不是每个三角形上的每个点 而是三角形上的三个顶点  其实了解过分形的 看到这句就能解决了  之后就一遍又一遍的递归就好了<br>但千万注意  你递归的只是三角形的三个顶点 在打印图形的时候 要把 8个点 都打印上</p><p>详情请看代码注释  很详细的哦</p><p>#include&lt;stdio.h&gt;</p><p>#include&lt;string.h&gt;</p><p>#include<algorithm></algorithm></p><p>#include&lt;math.h&gt;</p><p>using namespacestd;</p><p>chara[1000][1000];</p><p>void  dayin(int car,int x,int y)  //核心算法 递归打印</p><p>{</p><p>if(car==1)  //因为递归的只是三角形的定点 所以得把剩下所有的点 都给附上图形</p><p>{</p><p>a[x][y]=’*’;</p><p>a[x+1][y+1]=’*’;</p><p>a[x+1][y-1]=’*’;</p><p>a[x+2][y+2]=’*’;</p><p>a[x+2][y-2]=’*’;</p><p>a[x+3][y+1]=’*’;</p><p>a[x+3][y-1]=’*’;</p><p>a[x+3][y+3]=’*’;</p><p>a[x+3][y-3]=’*’;</p><p>return ;</p><p>}</p><p>int s=pow(2,car-2);    //这也是高</p><p>int e=pow(2,car-2);    //这也是宽度</p><p>dayin(car-1,x,y);</p><p>// dayin(car-1,x+s,y+e);       //因为图形是根据三个定点进行分形的  所以 只打印三个定点就好了 剩下的都不需要递归</p><p>// dayin(car-1,x+s,y-e);</p><p>// dayin(car-1,x+s<em>2,y+e</em>2);</p><p>// dayin(car-1,x+s<em>2,y-e</em>2);</p><p>dayin(car-1,x+s<em>4,y+e</em>4);</p><p>dayin(car-1,x+s<em>4,y-e</em>4);</p><p>// dayin(car-1,x+s*3,y+e);</p><p>// dayin(car-1,x+s*3,y-e);</p><p>}</p><p>int main()</p><p>{</p><p>int t;</p><p>scanf(“%d”,&amp;t);</p><p>while(t–)</p><p>{</p><p>memset(a,’ ‘,sizeof(a));</p><p>int n;</p><p>scanf(“%d”,&amp;n);</p><p>int s=pow(2,n-1);  //这是高</p><p>int e=pow(2,n);    //这是宽度</p><p>dayin(n,1,e/2);   //打印</p><p>for(int i=1;i&lt;=s;i++)  //把图形之外的都去掉</p><p>a[i][e]=’\0’;</p><p>for(int i=1;i&lt;=s;i++)</p><p>printf(“%s\n”,a[i]+1);</p><p>}</p><p>}</p>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  哈理工hrbust OJ 2225 解题报告 【递推】</title>
      <link href="/2015/12/22/50378327/"/>
      <url>/2015/12/22/50378327/</url>
      
        <content type="html"><![CDATA[<h1 id="哈理工hrbust-OJ-2225-解题报告-【递推】"><a href="#哈理工hrbust-OJ-2225-解题报告-【递推】" class="headerlink" title="哈理工hrbust OJ 2225 解题报告 【递推】"></a>哈理工hrbust OJ 2225 解题报告 【递推】</h1><p>2015年12月22日 10:43:46  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：734</p><hr><p> 博客爬取于<code>2019-04-18 17:21:32</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/50378327" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/50378327</a></p><p>粉刷栅栏</p><p>Time Limit: 500 MS</p><p>Memory Limit: 32768 K</p><p>Total Submit: 58  (19 users)</p><p>Total Accepted: 14  (10 users)</p><p>Rating: <img src="http://acm.hrbust.edu.cn/Public/images/star-solid.png" alt><br><img src="http://acm.hrbust.edu.cn/Public/images/star-solid.png" alt><br><img src="http://acm.hrbust.edu.cn/Public/images/star-solid.png" alt><br><img src="http://acm.hrbust.edu.cn/Public/images/star-half2.png" alt></p><p>Special Judge:  No</p><p>Description</p><p>给定一组长度为  n  的栅栏，从左到右高度依次是  h[i]  。</p><p>你需要对这个栅栏粉刷油漆，每次你可以粉刷一行或者一列。</p><p>问最少粉刷几次，可以给所有栅栏上漆。（不能多刷）</p><p>Input</p><p>第一行包含一个整数，表示栅栏的长度。</p><p>接下来的一行，包含  n  个数（  n &lt;= 5000  ），依次表示  h<a href="0 &lt;= h[i] &lt;= 10">i</a>  。</p><p>Output</p><p>输出一行表示对应的答案。</p><p>Sample Input</p><p>5</p><p>2 2 1 2 1</p><p>Sample Output</p><p>3</p><p>Hint</p><p><img src="http://acm.hrbust.edu.cn/contests/attached/image/20141231/20141231155623_91685.jpg" alt></p><p>其实本题很好想  做不出来 还是想的太多  就一层一层的刷  刷完这层下层分开了 那就当成新的两个栅栏刷就好了  之后接着再刷<br>看到这里你可能会想到会用到递归  没错！！  本题就是一个递归的思想解决</p><p>如果你每次都分出新的栅栏  就会发现每一层其实只有横着和竖着刷两种刷法  两种刷法的话就很好了  只要计算出横着刷用多少下就好了<br>当然要和竖着刷的次数比较一下  选择小的记录   竖着刷就是有机列就刷几下么</p><p>本题复杂的操作就是判断新的多个栅栏的时候   如何更新</p><p>首先把每一个栅栏都有的几层都刷上  然后减去  因为刷完了 就相当于没有这几行  之后在遍历一下 看一看那一段还有栅栏需要刷  在重复之前的操作就好了</p><p>用递归 ！！</p><p>//===================================附代码</p><p>#include <iostream>//-递归思想  把每一层分块的部分块的都刷上  </iostream></p><p>#include <cstdio>  </cstdio></p><p>#include <algorithm>  </algorithm></p><p>#include <cstring>  </cstring></p><p>#define inf 0x3f3f3f3f<br>using namespace std;<br>long long s[5030];<br>long long solve(long long l,long long r)//刷的时候没有竖着的 都是横着刷的<br>{<br>long long minn=inf,maxn=-1,tem=0;<br>for (long long i=l; i&lt;r; i++)  //把每行最底下都有的几行给 刷了<br>if(minn&gt;s[i]) minn=s[i];<br>for (long long i=l; i&lt;r; i++)<br>s[i]-=minn;   //刷完的剪去<br>tem+=minn;<br>for (long long i=l; i&lt;r; i++)<br>{<br>if (s[i]&gt;0)<br>{<br>for (long long j=i; j&lt;r; j++)//把每行断开的给刷了 并且 记录刷的次数<br>{<br>if(s[j]==0||j==r-1&amp;&amp;s[j]!=0) //判断刷的边界<br>{<br>if (j==r-1 &amp;&amp; s[j]!=0)   //此情况下 要处理的话应该使左右大一个<br>j++;<br>long long now=solve(i,j);  //横着刷上部分的<br>tem+=min(now,j-i); //比较一下横着刷有多少下 竖着刷有多少下  哪个小  就加上哪个<br>i=j;<br>break;<br>}<br>}<br>}<br>}<br>return tem;<br>}<br>int main()<br>{<br>long long n;<br>while (scanf(“%lld”,&amp;n)!=EOF)<br>{<br>for (long long i=0; i&lt;n; i++)<br>scanf(“%lld”,&amp;s[i]);<br>long long res=solve(0,n);<br>res=min(res,n);   //比较一下横着刷有多少下 竖着刷有多少下  哪个小  就输出哪个<br>printf(“%lld\n”,res);<br>}<br>}</p>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  POJ 3190 解题报告</title>
      <link href="/2015/12/18/50354268/"/>
      <url>/2015/12/18/50354268/</url>
      
        <content type="html"><![CDATA[<h1 id="POJ-3190-解题报告"><a href="#POJ-3190-解题报告" class="headerlink" title="POJ 3190 解题报告"></a>POJ 3190 解题报告</h1><p>2015年12月18日 21:16:40  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：359</p><hr><p> 博客爬取于<code>2019-04-18 17:21:33</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/50354268" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/50354268</a></p><p><a href="http://poj.org/problem?id=3190" target="_blank" rel="noopener">http://poj.org/problem?id=3190</a></p><p>题目大意： 每一只奶牛都要在区间[a,b]的时段内独自享受一个牛栏 如果两只牛的时间岔开了<br>那很好 它们两个用一个牛栏就好了  如果不能岔开  那么只好分别用一个牛栏了  </p><p>这题主要是贪心的思想  寻找最优解  但是单单贪心是不够的  你需要记录每只牛在第几只牛栏<br>而且你要判断这些牛那些能在一起而那些不能在一起   所以本题  用到了优先队列  优先级就为最小的结束时间<br>然后进行比较  这里就看代码的注释就好了<br>其实思路还是比较好像 但是操作起来着实不宜  再加上博主平时就不怎么用队列 更不用说优先队列的  所以本题迟迟不能写出来啊 所以粘了大神的代码  </p><p>大神的代码 虽然看懂了 但是自己写的话很多地方都不能很好的处理   还是技术不行啊</p><pre><code>#include&lt;queue&gt;#include&lt;math.h&gt;#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;algorithm&gt;using namespace std;struct node{    int x,y;    int no;    int ss;    friend bool operator&lt; (node n1, node n2)//定义优先级    {        return n1.y &gt; n2.y;    }} p[50050];bool cmp1 (node a,node b)//排序 贪心用的{    if (a.x==a.y) return a.y&lt;b.y;    else return a.x&lt;b.x;}bool cmp2 (node a,node b)//排序 为输出格式准备的  按次序输出牛在第几栏{    return a.ss&lt;b.ss;}int main(){    int n,i,tag=0,co=0;    scanf (&quot;%d&quot;,&amp;n);    for (i=0; i&lt;n; i++)    {        scanf (&quot;%d%d&quot;,&amp;p[i].x,&amp;p[i].y);        p[i].ss=i;//标记次序    }    sort (p,p+n,cmp1);    tag=p[0].x;//表示最小的右边界    priority_queue &lt;node&gt; que;//优先队列 优先级为右值//  for (i=0;i&lt;n;i++)         //测试用 就是看下排序//      printf (&quot;%d:%d %d\n&quot;,i,p[i].x,p[i].y);    for (i=0; i&lt;n; i++)//核心代码了     {        if (tag&gt;=p[i].x)  //如果不能与之前的牛放到同一栏        {            co++;    //那就单独放一栏里               p[i].no=co;//表示第几只牛在第几个栏            que.push(p[i]);            tag=que.top().y;  //更新右边界  队头是优先队列里右边界做小的        }        else        {            p[i].no=que.top().no;  //可以与之前的牛放到一起  所以栏数相同            que.pop();            que.push(p[i]);            tag=que.top().y;        }    }//    while (!que.empty())//    {//        printf (&quot;%d &quot;,que.top().y);//        que.pop();//    }    printf (&quot;%d\n&quot;,co);  //总栏数    sort (p,p+n,cmp2);    //排序二排序  未达成输出顺序    for (i=0; i&lt;n; i++)          printf(&quot;%d\n&quot;,p[i].no);    return 0;}#include&lt;queue&gt;#include&lt;math.h&gt;#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;algorithm&gt;using namespace std;struct node {    int l,r;    int no;    int id;    friend bool operator&lt;(node a,node b){        return a.r&gt;b.r;    }}a[50050];bool cmp1(node a,node b){    if(a.l==a.r) return a.r&lt;b.r;    return a.l&lt;b.l;}bool cmp2(node a,node b){    return a.id&lt;b.id;}int main(){    int n,tag,cnt= 0;;    scanf(&quot;%d&quot;,&amp;n);    for(int i=0;i&lt;n;i++){        scanf(&quot;%d%d&quot;,&amp;a[i].l,&amp;a[i].r);        a[i].id=i;    }    sort(a,a+n,cmp1);    tag=a[0].l;    priority_queue&lt;node &gt;que;    for(int i=0;i&lt;n;i++){        if(tag&gt;=a[i].l){            a[i].no=++cnt;            que.push(a[i]);        }        else {            a[i].no=que.top().no;            que.pop();            que.push(a[i]);        }        tag=que.top().r;    }    printf(&quot;%d\n&quot;,cnt);    sort(a,a+n,cmp2);    for(int i=0;i&lt;n;i++){        printf(&quot;%d\n&quot;,a[i].no);    }    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  杭电HDU 4550 字符串处理</title>
      <link href="/2015/12/13/50287091/"/>
      <url>/2015/12/13/50287091/</url>
      
        <content type="html"><![CDATA[<h1 id="杭电HDU-4550-字符串处理"><a href="#杭电HDU-4550-字符串处理" class="headerlink" title="杭电HDU 4550 字符串处理"></a>杭电HDU 4550 字符串处理</h1><p>2015年12月13日 21:57:53  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：288</p><hr><p> 博客爬取于<code>2019-04-18 17:21:34</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/50287091" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/50287091</a></p><p><strong> 卡片游戏  </strong></p><p><strong> Time Limit: 3000/1000 MS(Java/Others)    Memory Limit: 65535/32768 K (Java/Others)<br>Total Submission(s): 1675    Accepted Submission(s): 488  </strong>   </p><p><strong> Problem Description  </strong></p><p>小明最近宅在家里无聊，于是他发明了一种有趣的游戏，游戏道具是N张叠在一起的卡片，每张卡片上都有一个数字，数字的范围是0~9，游戏规则如下：<br>首先取最上方的卡片放到桌子上，然后每次取最上方的卡片，放到桌子上已有卡片序列的最右边或者最左边。当N张卡片全部都放到桌子上后，桌子上的N张卡片构成了一个数。<br>这个数不能有前导0，也就是说最左边的卡片上的数字不能是0。游戏的目标是使这个数最小。<br>现在你的任务是帮小明写段程序，求出这个最小数。</p><p><strong> Input  </strong></p><p>第一行是一个数T，表示有T组测试数据；<br>然后下面有T行， 每行是一个只含有0~9的字符串，表示N张叠在一起的卡片，最左边的数字表示最上方的卡片。  </p><p>[Technical Specification]<br>T&lt;=1000<br>1 &lt;= N &lt;= 100</p><p><strong> Output  </strong></p><p>对于每组测试数据，请在一行内输出能得到的最小数。</p><p><strong> Sample Input  </strong></p><p>3</p><p>565</p><p>9876543210</p><p>9876105432</p><p><strong> Sample Output  </strong></p><p>556</p><p>1234567890</p><p>1678905432</p><p>主要思想就是模拟排一下序，把第一个数最为输出的第一个数（暂时的），然后进行比较，</p><p>看代码注释比较好  但一定注意含0的情况   坑点就是这个0.</p><p>有0的话第一个数就应该非0最小值，且排序的话之排序非0最小值之前的，之后的只能按输入的顺序放在后面（注释解释的更加详细）。</p><p>//=================================本人AC代码</p><p>#include&lt;stdio.h&gt;</p><p>#include&lt;string.h&gt;</p><p>#include&lt;math.h&gt;</p><p>#include<algorithm></algorithm></p><p>using namespace std;</p><p>char a[102];</p><p>char b[300];//排列用</p><p>int main ()</p><p>{</p><p>int  t;</p><p>scanf(“%d”,&amp;t);</p><p>getchar();</p><p>while(t–)</p><p>{</p><p>memset(a,’\0’,sizeof(a));</p><p>memset(b,’\0’,sizeof(b));</p><p>gets(a);</p><p>int la =strlen(a);</p><p>int tou=150,wei=150;</p><p>int f=0,tt=0;</p><p>char mini;</p><p>for(int i=0;i&lt;la;i++)  //标记最小值用的  切记提议来说0是不可以的</p><p>{</p><p>if(a[i]!=’0’) {mini=a[i];break; }</p><p>}</p><p>for(int i=0; i&lt;la; i++)</p><p>{</p><p>if(a[i]==’0’)</p><p>f++;</p><p>if(a[i]&lt;=mini&amp;&amp;a[i]!=’0’) {mini=a[i];tt=i;} //非0最小值</p><p>}</p><p>if(f==0)</p><p>{</p><p>b[tou]=a[0];</p><p>for(int i=1; i&lt;la; i++)  //其实就是左边和右边  如果这个数字比头数字大就放</p><p>//后面  其他的发前面</p><p>{</p><p>if(b[tou]&gt;=a[i])</p><p>{</p><p>tou–;</p><p>b[tou]=a[i];</p><p>}</p><p>else</p><p>{</p><p>wei++;</p><p>b[wei]=a[i];</p><p>}</p><p>}</p><p>for(int i=tou; i&lt;=wei; i++)</p><p>printf(“%c”,b[i]);</p><p>printf(“\n”);</p><p>}</p><p>else if(tt!=0)</p><p>{</p><p>b[tou]=a[0];  //0不在首位那就以a[0]为标准来比较判断a[i]应该放在前面还//是后面</p><p>printf(“%c”,a[tt]);</p><p>for(int i=1; i&lt;tt; i++)</p><p>{</p><p>if(b[tou]&gt;=a[i])</p><p>{</p><p>tou–;</p><p>b[tou]=a[i];</p><p>}</p><p>else</p><p>{</p><p>wei++;</p><p>b[wei]=a[i];</p><p>}</p><p>}</p><p>for(int i=tou; i&lt;=wei; i++)</p><p>{</p><p>if(i==tt) continue;</p><p>printf(“%c”,b[i]);</p><p>}</p><p>for(int i=tt+1;i&lt;la;i++)</p><p>printf(“%c”, a[i]);</p><p>printf(“\n”);</p><p>}</p><p>else</p><p>{</p><p>for(int i=0;i&lt;la;i++)   //如果存在0 且最小值在 首位  那么就不用排序了  //直接输出就可以了  为保证树最小那么一定要报<br>非零的最小值放在最前面 而根据题意 //数字就只能放到后面了 一个一个的 所以相当于没排序</p><p>printf(“%c”, a[i]);</p><p>printf(“\n”);</p><p>}</p><p>}</p><p>}</p>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>&lt;原&gt;#  分形问题 递归打印解决 另附hrbust 2291 题目</title>
      <link href="/2015/12/12/50274193/"/>
      <url>/2015/12/12/50274193/</url>
      
        <content type="html"><![CDATA[<h1 id="分形问题-递归打印解决-另附hrbust-2291-题目"><a href="#分形问题-递归打印解决-另附hrbust-2291-题目" class="headerlink" title="分形问题 递归打印解决 另附hrbust 2291 题目"></a>分形问题 递归打印解决 另附hrbust 2291 题目</h1><p>2015年12月12日 13:06:01  <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="noopener"> Tabris_ </a> 阅读数：741</p><hr><p> 博客爬取于<code>2019-04-18 17:21:36</code><br><strong><em>以下为正文</em></strong></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/50274193" target="_blank" rel="noopener">https://blog.csdn.net/qq_33184171/article/details/50274193</a></p><p>本博客为博主处女贴    如有问题欢迎指出</p><h2 id="—————————————————————————"><a href="#—————————————————————————" class="headerlink" title="-—————————————————————————-"></a>-—————————————————————————-</h2><p>虽然不太可能 但是如有转载 请注明出处</p><p><strong> Help C5  </strong></p><p>Time Limit: 1000 MS</p><p>Memory Limit: 65535 K</p><p>Total Submit: 51  (9 users)</p><p>Total Accepted: 12  (8 users)</p><p>Rating:</p><p>Special Judge:  No</p><p><strong> Description  </strong></p><p>Hello, I’m Sea5, and you can call me C5 instead. I want a program which can<br>sign my name automatically. And my brothers, C0, C1, C2, C3, C4, C6, C7, C8,<br>each of them wants one as well. Can you help us?</p><p><strong> Input  </strong></p><p>First line is the number of test cases T(T&lt;=8).</p><p>T lines follow, each line includes an integer N(N&lt;=7), and you should help<br>C(N) to sign his name.</p><p><strong> Output  </strong></p><p>C0’s signature is ‘C’.</p><p>When you draw C(N)’s name, you should print the name using C(N-1)’s name as<br>its element, and using the following format to draw it.</p><p>*XX </p><p>X**</p><p>*XX </p><p>(X is the element, * is blank space)</p><p>And please don’t print extra spaces at the end of line.</p><p>For example, C1’s name should be</p><p><em>CC                    </em>CC </p><p>C                      C**</p><p><em>CC     But not    </em>CC </p><p>(I use * to show you where are spaces.)</p><p><strong> Sample Input  </strong></p><p>3<br>0<br>1<br>2</p><p><strong> Sample Output  </strong></p><p>C<br>CC<br>C<br>CC<br>CC CC<br>C  C<br>CC CC<br>CC<br>C<br>CC<br>CC CC<br>C  C<br>CC CC</p><p>本类型题其实就是模版体  比赛的时候有模版还是很好做的  （其实没有模版也不难）</p><p>最主要的是格式  对输出图形空格的格式   以及没两组输出后又没有空格等</p><p>对不同的图行 只要找到相应的位置不断的递归就可以了</p><p>其实也可以先把所有的图形都打印下来 然后在选取部分输出就好了</p><p>附本题代码</p><p>#include<cstdio>   //分形问题递归打印解决</cstdio></p><p>#include<cstring></cstring></p><p>#include<iostream></iostream></p><p>using namespace std;</p><p>char a[3000][3000];  //注意数组的大小   不然存不下图形  会RE</p><p>int mypow(int d)</p><p>{</p><p>int ans=1;</p><p>for(int i=1;i&lt;=d;i++)</p><p>ans*=3;</p><p>return ans;</p><p>}</p><p>void dfs(int cur,int x,int y)</p><p>{</p><p>if(cur==1)</p><p>{</p><p>a[x][y]=’C’;</p><p>return ;</p><p>}</p><p>int s=mypow(cur-2);</p><p>dfs(cur-1,x+s,y);//这些按照格式来就好</p><p>dfs(cur-1,x,y+2*s);</p><p>dfs(cur-1,x,y+s);</p><p>dfs(cur-1,x+2*s,y+s);</p><p>dfs(cur-1,x+2<em>s,y+2</em>s);</p><p>}</p><p>int main(void)</p><p>{</p><p>int t;</p><p>scanf(“%d”,&amp;t);</p><p>while(t–)</p><p>{</p><p>int n;</p><p>scanf(“%d”,&amp;n);</p><p>n++;</p><p>memset(a,’ ‘,sizeof(a));</p><p>dfs(n,1,1);</p><p>int s=mypow(n-1);</p><p>for(int i=0;i&lt;=s;i++)  //先把最大的边界找到</p><p>a[i][s+1]=’\0’;</p><p>for(int i=0;i&lt;=s;i++)//其实格式可以每行从后往前来把每个编程\0遇到不是空格就停止</p><p>{</p><p>for(int j=s+1;j&gt;=0;j–)</p><p>{</p><p>if(a[i][j]==’C’){a[i][j+1]=’\0’;break;}</p><p>}</p><p>}</p><p>for(int i=1;i&lt;=s;i++)</p><p>printf(“%s\n”,a[i]+1);//a[i]+1 就是从a[1]开始输出</p><p>}</p><p>return 0;</p><p>}</p>]]></content>
      
      
      <categories>
          
          <category> OJ算法题 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
