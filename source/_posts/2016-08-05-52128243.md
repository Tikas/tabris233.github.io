---
title: "[原创]这是一篇被放弃的博客。。不要看了。。（新手千万不要手撸模板）"
date: 2016-08-05 13:33:21
description:
toc: true
author: tabris
# 图片推荐使用图床(腾讯云、七牛云、又拍云等)来做图片的路径.如:http://xxx.com/xxx.jpg
img:
# 如果top值为true，则会是首页推荐文章
top: false
# 如果要对文章设置阅读验证密码的话，就可以在设置password的值，该值必须是用SHA256加密后的密码，防止被他人识破
password:
# 本文章是否开启mathjax，且需要在主题的_config.yml文件中也需要开启才行
mathjax: true
summary: ""
categories: [CSDN,智障]
tags: [CSDN,数据结构,namespace]
key: key451cba88-2442-4d5b-8e47-98e6f74d1f22
---

今天解除了一下线段树  据自己理解手撸了发建树与查询的操作  的模板
```Segment tree
# include <iostream>
# include <string>
# include <string.h>
# include <algorithm>
# include <math.h>
# include <stdio.h>
# include <vector>
# include <time.h>

using namespace std;

# define  LL  long long int

int a[1010101];

struct node
{
    int value ;
    int right , left;

}tree[4040404];


int firstbuild(int o,int l,int r)//从第O个节点 开始建树  不断递归 知道最后到叶子节点
{
    tree[o].left  = l;
	tree[o].right = r;
	tree[o].value = 0;

    if(l==r)
    {
    	tree[o].value = a[l];
        return tree[o].value ;
    }
    int mid = (l+r) >> 1;

    tree[o].value=firstbuild(o * 2,l,mid)+firstbuild(o*2+1,mid+1,r);
	return tree[o].value;
}

int query(int o,int &l,int &r)
{
	//printf("%d--->%d %d\n",o,tree[o].left,tree[o].right);

    int sum=0;
    //首先判断是不是属于所要查询的区间
    if(l<=tree[o].left&&tree[o].right<=r)      //如果该区间属于要查询的区间内  就加上  而且不向下递归了  最终的加和一定是这些区间的和 而且不会重复 不会
        sum += tree[o].value;
    else if(tree[o].right<l||r<tree[o].left) ;
    //如果区间有重合部分但又不包含 就要继续递归子节点 寻找区间。。
 	else if(tree[o].left<l||r<tree[o].right)  //区间过大了  就递归缩小区间
        sum += query(o*2,l,r) + query(o*2+1,l,r);
    else  ; //区间完全不重合 就没有在向下查询的必要了

    return sum;
}

int main()
{
	int n;
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>a[i];
	}


	firstbuild(1,1,n);
	for(int i=1;i<=n*2-1;i++)
		printf("%d %d\n",tree[i].left,tree[i].right);
	puts("");
	int nu=0,un=1;
    for(int i=1;i<=n*2-1;i++)
    {
        if(nu>=un)
        {
            nu=0,un*=2;
            puts("");
        }
        nu++;
        printf("%d ",tree[i].value);
    }
    puts("");
    while(true)
	{
		int l,r;
		cin>>l>>r;
		if(l==0||r==0) break;
		printf("%d\n",query(1,l,r));
	}
	return 0;
}
```