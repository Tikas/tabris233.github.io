---
title: "[原创]codeforces 710D Two Arithmetic Progressions   [同余方程]【数论】"
date: 2016-08-24 17:32:54
description:
toc: true
author: tabris
# 图片推荐使用图床(腾讯云、七牛云、又拍云等)来做图片的路径.如:http://xxx.com/xxx.jpg
img:
# 如果top值为true，则会是首页推荐文章
top: false
# 如果要对文章设置阅读验证密码的话，就可以在设置password的值，该值必须是用SHA256加密后的密码，防止被他人识破
password:
# 本文章是否开启mathjax，且需要在主题的_config.yml文件中也需要开启才行
mathjax: true
summary: ""
categories: [CSDN,codeforces, 数论 ]
tags: [CSDN,codeforces]
key: key2e88a7fc-ca22-41a2-b93e-a7b9bda962d6
---

题目链接：http://codeforces.com/problemset/problem/710/D
--------------------------.
D. Two Arithmetic Progressions
time limit per test1 second
memory limit per test256 megabytes
inputstandard input
outputstandard output
You are given two arithmetic progressions: a1k + b1 and a2l + b2. Find the number of integers x such that L ≤ x ≤ R and x = a1k' + b1 = a2l' + b2, for some integers k', l' ≥ 0.

Input
The only line contains six integers a1, b1, a2, b2, L, R (0 < a1, a2 ≤ 2·109,  - 2·109 ≤ b1, b2, L, R ≤ 2·109, L ≤ R).

Output
Print the desired number of integers x.

Examples
input
2 0 3 3 5 21
output
3
input
2 4 3 0 6 17
output
2
-----------------------------.
题目大意 ：
		就是给你a1, b1, a2, b2, L, R   在区间L~R找一个x 使得a1k' + b1 = a2l' + b2  问能找到的x的个数

解题思路 ：
		根据题意 很明显的同余方程
		x= b1 (mod a1)；
	    x= b2 (mod a2)；
		然后解得x的最小正整数解之后 每次加上 lcm(a1,a2)  一直从l到r  这部分直接计算就能够得出
		值得注意的是l与 b1,b2 的大小有关   在计算的时候l应取三者最大值;
		Ps:题目很坑的是有负数的情况  也是赛后看了题解才知道。。


附本题代码
-----------------------------------.
```
# include <bits/stdc++.h>
using namespace std;

typedef long long LL;
typedef long long ll;
const int mod = 1000000007;
const int maxn = 200010;

LL exgcd(LL a,LL b,LL &x,LL &y)
{
    if(!b)
    {
        x=1,y=0;
        return a;
    }
    else
    {
        LL r = exgcd(b,a%b,x,y);
        LL t = x;
        x = y;
        y = t - (a/b) * y;
        return r;
    }
}
LL labs(LL a)
{
    if(a<0) return -a;
    else    return a;
}
int main()
{
    ios::sync_with_stdio(false);
    LL a1,a2,b1,b2,l,r;
    while(cin>>a1>>b1>>a2>>b2>>l>>r)
    {
        LL x,y;
        LL d = exgcd(a1,a2,x,y);
        if((b2-b1)%d)
        {
            puts("0");
            continue;
        }
        x*=(b2-b1)/d;
        x=(x%labs(a2/d)+labs(a2/d))%labs(a2/d);

       LL cnt = x*a1+b1;
       LL tmp = labs(a1*a2/d);
       LL ans = 0;
       l = max(l,max(b1,b2));
       if(l>r)
       {
           puts("0");
           continue;
       }
       if(cnt<=r) ans+=(r-cnt)/tmp+1;
       if(cnt<l)  ans-=(l-1-cnt)/tmp+1;
       printf("%I64d\n",ans);
    }
    return 0;
}

```